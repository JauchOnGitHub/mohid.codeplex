!------------------------------------------------------------------------------
!        IST/MARETEC, Water Modelling Group, Mohid modelling system
!------------------------------------------------------------------------------
!
! TITLE         : Mohid Hydrodynamic
! PROJECT       : Mohid Water
! MODULE        : ModuleHydrodynamic
! URL           : http://www.mohid.com
! AFFILIATION   : IST/MARETEC, Marine Modelling Group
! DATE          : Fev 2010
! REVISION      : Paulo Leitão - v4.0
! DESCRIPTION   : Module responsbile for computing non-turbulent hydrodynamic processes
!
!------------------------------------------------------------------------------
!
!This program is free software; you can redistribute it and/or
!modify it under the terms of the GNU General Public License 
!version 2, as published by the Free Software Foundation.
!
!This program is distributed in the hope that it will be useful,
!but WITHOUT ANY WARRANTY; without even the implied warranty of
!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!GNU General Public License for more details.
!
!You should have received a copy of the GNU General Public License
!along with this program; if not, write to the Free Software
!Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
!
!------------------------------------------------------------------------------
!
! Use this for the occasional introduction to a long file.
!

!-------------------------------------------------------------------------
!        IST/MARETEC, Marine Modelling Group, Mohid2000 modelling system
!-------------------------------------------------------------------------
!BOI
! !TITLE: Mohid2000 hydrodynamic model 
! !AUTHORS: Paulo Chambel
! !AFFILIATION: IST/MARETEC, Marine Modelling Group
! !DATE: 15Nov2000
! !INTRODUCTION: General description of the hydrodynamic model
!  The hydrodynamic class solves the three-dimensional primitive 
!  equations in Cartesian coordinates for incompressible flows. 
!  Hydrostatic equilibrium is assumed as well as Boussinesq Objroximation.  
!  The mass and momentum evolution equations solve by the model are:
!  $$
!   \frac{\partial \int dV}{\partial t}=\oint 
!   \overrightarrow{F}_{Water}\cdot d\overrightarrow{n}
!  $$
!  $$
!   \frac{\partial \int \overrightarrow{\text{v}}dV}
!   {\partial t}= \oint 
!   \overrightarrow{\text{v}}\left( \overrightarrow
!   {\text{v}}+v\nabla \cdot 
!   \overrightarrow{\text{v}}\right) \cdot 
!   d\overrightarrow{n}-\nabla \eta \int
!   dV-\frac 1\rho \stackunder{\eta +z}
!   {\nabla \cdot \stackrel{\eta }{\int }\rho
!   dz}\cdot \int dV
!  $$
!  $$
!  \nabla =\left( \frac \partial {\partial x},\frac 
!  \partial {\partial y}\right) 
!  $$
!
!EOI
!-------------------------------------------------------------------------


Module ModuleHydrodynamic
!-------------------------------------------------------------------------
!        IST/MARETEC, Marine Modelling Group, Mohid2000 modelling system
!-------------------------------------------------------------------------

!BOP
!
! !MODULE: ModuleHydrodynamic

!    !DESCRIPTION: 
!     This model is responsible for all hydrodynamic properties:
!     Water level, velocites, water fluxes
 
! !REVISION HISTORY: 
!   1Jan2000   Paulo Chambel       First experimental version.
!  16Nov2000   Paulo Chambel       Comments are introduce in the Protex format 
!                                  to produce a manual
!  21Dec2000   Frank Braunschweig  Writes Velocity Modulus to HDF file
!
! !FILES USED:   
!  'nomfich.dat' file is where the name files are given .
!  The keywords relevant for the hydrodynamic model are:
!    IN_DAD3D : input file  
!    OUT_DESF : output file 
!    IN_CNDI  : restart file  
!    OUT_FIN  : final output use to restart the model
!              
!
! !SEE ALSO:    
!  http://194.65.82.103/manuais/default.htm     
!

! !USES:
    use ModuleGlobalData
    use ModuleFunctions         
    use ModuleTime              
    use ModuleEnterData           
    use ModuleGridData,         only : GetGridData, UngetGridData 
    use ModuleProfile,          only : StartProfile, WriteProfile, KillProfile
    use ModuleDischarges,       only : Construct_Discharges, GetDischargesNumber,        &
                                       GetDischargesGridLocalization, GetDischargeON,    &
                                       GetDischargeWaterFlow, GetDischargeFlowVelocity,  &
                                       GetByPassON, GetDischargesIDName,                 &
                                       CorrectsCellsDischarges, SetLocationCellsZ,       &
                                       GetDischargeSpatialEmission, SetLayer,            &
                                       TryIgnoreDischarge,                               &
                                       GetDischargeFlowDistribuiton, UnGetDischarges,    &
                                       Kill_Discharges
    use ModuleTimeSerie,        only : StartTimeSerie, StartTimeSerieInput,              &
                                       GetTimeSerieLocation, CorrectsCellsTimeSerie,     &
                                       GetNumberOfTimeSeries, TryIgnoreTimeSerie,        &
                                       GetTimeSerieValue, WriteTimeSerie,                &
                                       GetTimeSerieName, WriteTimeSerieLine, KillTimeSerie         
    use ModuleHorizontalMap,    only : GetWaterPoints2D, GetBoundaries, GetBoundaryFaces,&
                                       GetExteriorBoundaryFaces, UnGetHorizontalMap
    use ModuleHorizontalGrid,   only : WriteHorizontalGrid, GetComputeZUV,               &
                                       GetCoriolisFrequency, GetHorizontalGrid,          &
                                       InterpolRegularGrid, UnGetHorizontalGrid,         &
                                       GetGridCoordType, GetCoordTypeList, GetGridOrigin,&
                                       GetGridLatitudeLongitude, GetHorizontalGridSize,  &
                                       GetCheckDistortion, GetGridRotation, GetGridAngle,&
                                       RotateVectorFieldToGrid, GetXYCellZ,              &
                                       GetCellZInterceptByPolygon, GetCellZInterceptByLine
    use ModuleGeometry,         only : GetGeometrySize, GetGeometryWaterColumn,          &
                                       GetGeometryDistances, GetGeometryKFloor,          &
                                       GetGeometryMinWaterColumn, UnGetGeometry,         &
                                       ReadGeometry, ComputeInitialGeometry,             &
                                       ComputeVerticalGeometry, WriteGeometry,           &
                                       GetGeometryVolumes, GetGeometryAreas, GetLayer4Level
    use ModuleMap,              only : GetWaterPoints3D, GetOpenPoints3D,                &
                                       GetComputeFaces3D, GetImposedTangentialFaces,     &
                                       GetImposedNormalFaces, UnGetMap,                  &
                                       UpdateComputeFaces3D, SetComputesFaces3D,         &
                                       GetLandBoundaryFaces3D, GetWetFaces         
    use ModuleBoxDif,           only : StartBoxDif, GetBoxes, BoxDif, UngetBoxDif,       &
                                       KillBoxDif
    use ModuleOpenBoundary,     only : ConstructOpenBoundary, Modify_OpenBoundary,       &
                                       GetAverageImposedElevation, GetImposedElevation,  &
                                       UnGetOpenBoundary, GetOldImposedElevation,        &
                                       GetOpenBoundParameter, GetImposedVelocity,        &
                                       GetBoundaryReferenceLevel, KillOpenBoundary,      &
                                       Modify_AllDomain
    use ModuleTurbulence,       only : GetContinuousGOTM, GetMLD_Surf, UnGetTurbulence,  &
                                       GetHorizontalViscosity, GetVerticalViscosity   
    use ModuleHydrodynamicFile, only : StartHydrodynamicFile, GetHydrodynamicFileIOState,&
                                       ModifyHydrodynamicFile, GetFileWaterLevel,        &
                                       GetFileFluxes, GetFileMapping,                    &
                                       UnGetHydrodynamicFile, KillHydrodynamicFile

    use ModuleAssimilation,     only : StartAssimilation, GetAssimilationField,          &
                                       GetAssimilationCoef, UnGetAssimilation,           &
                                       KillAssimilation, GetAssimilationAltimetry,       &
                                       GetAssimilationAltimetryDT, GetAltimetryDecayTime,&
                                       GetAltimSigmaDensAnalyzed
    use ModuleStopWatch,        only : StartWatch, StopWatch         
    use ModuleStatistic,        only : ConstructStatistic, GetStatisticMethod,           &
                                       GetStatisticParameters, GetStatisticLayersNumber, &
                                       GetStatisticLayerDef, ModifyStatistic,            &
                                       AddStatisticLayers, KillStatistic         
    use ModuleHDF5       
#ifndef _WAVES_
    use ModuleWaves,            only : GetWavesStress, SetGeneric4DValues, UnGetWaves       
#endif
    use ModuleFillMatrix,       only : ConstructFillMatrix, ModifyFillMatrix, KillFillMatrix
    use ModuleDrawing
    !$ use omp_lib
    
#if _USE_MPI
    use mpi
#endif    

#ifdef _ENABLE_CUDA
    use ModuleCuda
#endif _ENABLE_CUDA

    implicit none 

    private

!   !PUBLIC SUBROUTINES

    !Constructor
        !  StartHydrodynamic
    !Modifier
        !  Modify_Hydrodynamic
    !Selector 
        !  GetWaterFluxes
        !  GetHorizontalVelocity
        !  GetOldHorizontalVelocity
        !  GetVerticalVelocity
        !  GetWaterLevel
        !  GetChezy
        !  GetDirection
        !  GetHydrodynamicSource
        !  GetDischargesFluxes
        !  GetPointDischargesState
        !  UngetHydrodynamic
    !Destructor
        !  KillHydrodynamic

    !PUBLIC TYPES: 
        !  T_Hydrodynamic

 !EOP

    !subroutines tree---------------------------------------------------------------



    !Should be transfer for a Bottom boundary module 
    private :: Bottom_Boundary
    private :: Modify_ChezyZ
    private :: Modify_ChezyVelUV


    !Constructor
    public  :: StartHydrodynamic
    private ::      Construct_Hydrodynamic
    private ::          Construct_HydrodynamicTime
    private ::          Read_Hydrodynamic_Files_Name
    private ::          Construct_Numerical_Options
    private ::          Verify_Numerical_Options
    private ::          Actualize_HydrodynamicTimeStep
    private ::          InitialHydrodynamicField
    private ::          StartOutputBoxFluxes
    private ::          AllocateVariables
    private ::          Construct_Sub_Modules
    private ::          Construct_OutPutTime
    private ::          Construct_Time_Serie
    private ::          ConstructMatrixesOutput
    private ::          ConstructHydrodynamicProperties
    private ::              Read_Final_Hydrodynamic_File
    private ::          ReadInitialImposedSolution
    private ::          Initial_Geometry

    private ::          InitialReferenceWaterFluxes
    private ::          Open_HDF5_OutPut_File
    private ::          Open_Surface_HDF5_OutPut_File
    private ::          ConstructEnergy
    private ::          ConstructTidePotential

    private ::          ConstructRelaxation
    private ::          ConstructHydroStatistic

    private ::      CourantGH
    private ::          F_Courant                   !Function
    private ::          OutputCourant

#ifdef OVERLAP
    private  :: ConstructHydroOverlap
#endif OVERLAP

#ifdef _USE_SEQASSIMILATION
    !Subroutine to point to memory space of hydrodynamic properties
    public  :: PointToHydroState
#endif _USE_SEQASSIMILATION
 
    !Modifier
    public  :: Modify_Hydrodynamic
    private ::      Actualises_Hydrodynamic
    private ::      CalcNewDT

    private ::      One_Iteration
    private ::      MomentumMassConservation
    private ::          ReadImposedSolution            
    private ::          Abbott_Scheme
    private ::          Leendertse_Scheme
    private ::              ChangeDirection
    private ::                  AssociateDirectionX
    private ::                  AssociateDirectionY
    private ::              Explicit_Forces
    private ::                  Modify_Horizontal_Transport
    private ::                      Modify_Advection_UX_VY
    private ::                      Modify_Advection_UY_VX
    private ::                      Modify_Advection_Bound
    private ::                          Modify_UX_VY_Boundary
    private ::                          Modify_UY_VX_Boundary
    private ::                          Modify_UX_VY_SubModel
    private ::                          Modify_UY_VX_SubModel
    private ::                      Modify_Diffusion_UX_VY
    private ::                      Modify_Diffusion_UY_VX
    private ::                      ModifyDiffSub_UX_VY
    private ::                      ModifyDiffSub_UY_VX
    private ::                      ModifyVolumeVariation
    private ::                      ModifyMomentumDischarge
    private ::                  ModifyRelaxHorizAdv
    private ::                  Modify_InertiaForces
    private ::                  Modify_ROX3
    private ::                  ModifyTidePotential
    private ::                  ModifyRelaxAceleration
    private ::                  ModifyAltimAceleration
    private ::              VerticalMomentum
    private ::              NonHydroStaticCorrection
    private ::                  NonHydroOpenBoundary
    private ::                  NonHydroWallBoundary    

    private ::          ReadHydrodynamicFile
    !private ::          ModifyBackgroundVelocity

    private ::              Compute_Velocity
    private ::                  Velocity_ExplicitForces
    private ::                  Velocity_VerticalAdvection
    private ::                  Velocity_VerticalDiffusion
    private ::                  VelVerticalDiffusionBoundaries
    private ::                  Velocity_OpenBoundary
    private ::                      Compute_BaroclinicHorVelocity
    private ::                      VelTangentialOpenBoundary
    private ::                      VelNormalOpenBoundary
    private ::                      VelSubModelNormalOB 
    private ::                      VelSubModelTangentialOB 
    private ::                      CyclicBoundVectTangential
    private ::                      CyclicBoundVectNormal
    private ::                      CyclicBoundVertical

    private ::              Compute_WaterLevel
    private ::                  WaterLevel_BarotropicPressure
    private ::                  WaterLevel_BottomFriction
    private ::                  WaterLevel_ExplicitForces
    private ::                  WaterLevel_WaterFluxes
    private ::                  WaterLevel_OpenBoundary
    private ::                      WaterLevel_ImposedWave
    private ::                      WaterLevel_FlatherWindWave
    private ::                      WaterLevel_FlatherLocalSolution
    private ::                      WaterLevel_BlumbergKantha
    private ::                  WaterLevelDischarges
    private ::                  WaterLevelRelaxation
    private ::                  WaterLevelRelaxationAltimetry
    private ::                  WaterLevelCorrection
    private ::                  WaterLevelMaxMin

    private ::                  Waterlevel_CyclicBoundary
    private ::                      CyclicCoef2D

    private ::              Modify_HorizontalWaterFlow

    private ::          New_Geometry
    private ::          New_VerticalHydrodynamic
    private ::              Modify_VerticalWaterFlow
    private ::              Filter_3D_Fluxes
    private ::              Compute_VerticalVelocity
    private ::              ComputeCartesianVertVelocity  
    private ::              ComputeCartesianNH
    private ::              Boundary_VerticalFlow
    private ::                  ComputeBaroclinicVertVelocity  
    private ::                  Compute_BoundaryVertFlux

    private ::          ModifyWaterDischarges

    private ::      ComputeResidualFlowProperties
    private ::      ComputeSystemEnergy
    private ::          WriteEnergyDataFile
    private ::      Hydrodynamic_OutPut
    private ::          Write_HDF5_Format
    private ::          Write_Surface_HDF5_Format
    private ::              CenterVelocity
    private ::              Statistics_OutPut
    private ::          OutPut_TimeSeries
    private ::          ModifyMatrixesOutput

#ifdef _USE_SEQASSIMILATION
    !Copy subroutines usable in sequential data assimilation to change variables' value
    public  :: CopyWaterLevel
    public  :: CopyHorizontalVelocity
    public  :: CopyVerticalVelocity
    public  :: CopyWaterFluxes
    public  :: CopySubModelFluxes
    public  :: CopyChezyVelUV
#endif _USE_SEQASSIMILATION

    !private ::         ASCII_Format
    
    !Selector 
    public  :: GetWaterFluxes
    public  :: GetHorizontalVelocity
    public  :: GetOldHorizontalVelocity
    public  :: GetVerticalVelocity
    public  :: GetWaterLevel
    public  :: GetChezy
    public  :: GetHydrodynamicAirOptions
    public  :: GetDirection
    public  :: GetHydrodynamicSource
    public  :: GetDischargesFluxes
    public  :: GetPointDischargesState
    public  :: GetHydroNeedsFather 
    public  :: GetWavesStressON
    public  :: GetHydroAltimAssim
    public  :: GetVertical1D
    public  :: GetXZFlow
    public  :: GetVelocityModulus


#ifdef _USE_SEQASSIMILATION
    public  :: GetHydroSeqAssimilation
    public  :: GetCyclicBoundary
    public  :: GetSubModelFluxes
    public  :: GetChezyVelUV
#endif _USE_SEQASSIMILATION

#ifdef OVERLAP
    public  :: GetHydroOverlap
    public  :: SetModelOverlapHydro
#endif OVERLAP

    
    public  :: SetHydroFather
    private ::      ConstructTimeInterpolation
    private ::      TestSubModelOptionsConsistence
    private ::      ReadNextOrInitialField
    private ::          ReadLockFather
    private ::          ReadUnLockFather
    private ::      ActualizeSubModelValues
    private ::      ActualizeSon3DWithFather2D
    private ::          RemoveLowerSpikes
    private ::          ReadLockSon
    private ::          ReadUnLockSon
    private ::      ActualizeSon3DWithFather3D
    public  :: SetHydrodynamicManning
    public  :: SetHydrodynamicChezy
    public  :: SetHydrodynamicRugosityMatrix
    public  :: SetSurfaceWaterFlux
    public  :: SetBottomWaterFlux
    public  :: SetWindStress
    public  :: SetAtmosphericPressure
    public  :: SetWaveChezyVel

#ifdef _USE_SEQASSIMILATION
    !Set subroutines usable to point variables to external variables/memory space
    public  :: SetWaterLevel
    public  :: SetHorizontalVelocity
    public  :: SetVerticalVelocity
    public  :: SetWaterFluxes
    public  :: SetSubModelFluxes
    public  :: SetChezyVelUV

    !Set subroutine to manage a virtual run of the model for EOF propagation
    public  :: SetHydroVirtualRun

    !Reset subroutine usable to reestablish variables to internal memory space
    public  :: ReSetHydrodynamicProperties
#endif _USE_SEQASSIMILATION

    public  :: UngetHydrodynamic


    !Destructor
    public  :: KillHydrodynamic
    private ::      KillHydroStatistics
    private ::      Write_Final_Hydrodynamic_File
    private ::      Deassociate_External_Modules               
    private ::      Kill_Sub_Modules
    private ::          KillEnergy
    private ::          KillTidePotential
    private ::          KillSubModel
    private ::      DeallocateVariables 
    private ::          KillMatrixesOutput

#ifdef _USE_SEQASSIMILATION
    !Subroutine to point to memory space of hydrodynamic properties
    public  :: NullifyHydroStatePointer
#endif _USE_SEQASSIMILATION

    !Management
    private :: ReadLock_External_Modules
    private ::      ReadLock_ModuleHorizontalGrid 
    private ::      ReadLock_ModuleHorizontalMap 
    private ::      ReadLock_ModuleGeometry 
    private ::      ReadLock_ModuleMap 
    private :: ReadLock_ModuleTurbulence
#ifndef _WAVES_
    private :: ReadLock_ModuleWaves
#endif
    private ::          Read_Lock

    private :: ReadUnLock_External_Modules
    private ::      ReadUnLock_ModuleHorizontalGrid 
    private ::      ReadUnLock_ModuleHorizontalMap 
    private ::      ReadUnLock_ModuleGeometry 
    private ::      ReadUnLock_ModuleMap 
    private :: ReadUnLock_ModuleTurbulence
#ifndef _WAVES_
    private :: ReadUnLock_ModuleWaves
#endif
    private ::          Read_UnLock

    !Functions
    private :: TangentialVelInterpolation
    private :: spythag
    private :: dpythag
    private :: Locate_Layer
    private :: Face_Interpolation
    private :: FrictionCoefficient
    private :: Face_Velocity_Modulus


    !Interfaces----------------------------------------------------------------

    private :: UngetHydrodynamic2Dreal4
    private :: UngetHydrodynamic2Dreal8
    private :: UngetHydrodynamic3Dreal4
    private :: UngetHydrodynamic3Dreal8
    interface  UngetHydrodynamic
        module procedure UngetHydrodynamic2Dreal4
        module procedure UngetHydrodynamic2Dreal8
        module procedure UngetHydrodynamic3Dreal4
        module procedure UngetHydrodynamic3Dreal8
    end interface UngetHydrodynamic

    private :: pythag
    interface  pythag
        module procedure spythag
        module procedure dpythag
    end interface pythag

    private :: HydroPropAssimilation3D
    private :: HydroPropAssimilation2D

    private HydroPropAssimilation
    interface  HydroPropAssimilation
        module procedure HydroPropAssimilation3D
        module procedure HydroPropAssimilation2D
    end interface HydroPropAssimilation

#ifdef _USE_MPI
    public  :: SendHydrodynamicMPI
    public  :: RecvHydrodynamicMPI
    public  :: UpdateHydroMPI
    !include  "mpif.f90"
#endif _USE_MPI

    !ModuleHydrodynamic parameters---------------------------------------------------------------------------


    !Direction
    integer, parameter :: DirectionX_      = 1
    integer, parameter :: DirectionY_      = 2
    integer, parameter :: DirectionXY_     = 3
    integer, parameter :: WestSouth        = 1
    integer, parameter :: EastNorth        = 2

    !Numeric Options
    integer, parameter :: UpWind_Scheme   = 1
    integer, parameter :: Quick_Scheme    = 2

    !Parameters
    character(LEN = StringLength), parameter :: Char_Upwind_Scheme          = trim(adjustl('Upwind'               ))
    character(LEN = StringLength), parameter :: Char_Quick_Scheme           = trim(adjustl('Quick'                ))


    real,    parameter :: Abbott          = 1.
    real,    parameter :: Leendertse      = 2.

    integer, parameter :: CurrentVelocity           = 0
    integer, parameter :: ResidualVelocity          = 1
    integer, parameter :: ResidualFlux              = 2
    integer, parameter :: ResidualFluxVel           = 3
    integer, parameter :: BaroclinicVelocity        = 4
    integer, parameter :: AltimGeostrophicVelocity  = 5
    integer, parameter :: BaroclinicForce           = 6

    integer, parameter :: Solve_Equations_       = 1
    integer, parameter :: Read_File_             = 2
    integer, parameter :: No_hydrodynamic_       = 3
    integer, parameter :: Residual_hydrodynamic_ = 4
    integer, parameter :: Run_Off_               = 5
    integer, parameter :: ImposedSolution_       = 6
    !Guillaume
    integer, parameter :: Vertical1D_            = 7
    integer, parameter :: Harmonics_             = 8

    !Parameters
    character(LEN = StringLength), parameter :: Char_Solve_Equations        = trim(adjustl('Solve_Equations'      ))
    character(LEN = StringLength), parameter :: Char_Read_File              = trim(adjustl('Read_File'            ))
    character(LEN = StringLength), parameter :: Char_No_hydrodynamic        = trim(adjustl('No_hydrodynamic'      ))
    character(LEN = StringLength), parameter :: Char_Residual_hydrodynamic  = trim(adjustl('Residual_hydrodynamic'))
    character(LEN = StringLength), parameter :: Char_Run_Off                = trim(adjustl('Run_Off'              ))
    character(LEN = StringLength), parameter :: Char_ImposedSolution        = trim(adjustl('Imposed Solution'     ))
    character(LEN = StringLength), parameter :: Char_Vertical1D             = trim(adjustl('Vertical1D'           ))
    character(LEN = StringLength), parameter :: Char_Harmonics              = trim(adjustl('Harmonics'            ))



    integer, parameter :: NULL_VALUE           = 1
    integer, parameter :: NULL_GRADIENT        = 2

    !Input / Output
    integer, parameter :: FileOpen = 1, FileClose = 0
    integer, parameter :: EnergyBufferSize        = 1000

    !Geometry
    integer, parameter :: Fix         = 1
    integer, parameter :: Variable    = 2



    !Boxes
    real,    parameter :: Boxes_MinDepth = 0.0

    !Water
    character(5), parameter :: Char_Water = 'water'

    !Internal Waves Celerity 
    integer, parameter :: Orlanski_    = 0
    integer, parameter :: Constant_    = 1
    integer, parameter :: OeyAndChen_  = 2

    !Maximum internal wave velocity allowed is 10 m/s.
    real,    parameter :: MaxInternalCelerity = 10. 

    !Internal waves radiation
    integer, parameter :: NoRadiation_ = 0
    integer, parameter :: Horizontal_  = 1
    integer, parameter :: Vertical_    = 2


    !Barotropic boundary radiation conditions
    integer, parameter :: FlatherWindWave_      = 1
    integer, parameter :: FlatherLocalSolution_ = 2
    integer, parameter :: BlumbergKantha_       = 3

    !Local solution type
    integer, parameter :: NoLocalSolution_      = 1
    integer, parameter :: Submodel_             = 2
    integer, parameter :: AssimilationField_    = 3
    integer, parameter :: Gauge_                = 4
    integer, parameter :: AssimilaPlusSubModel_ = 5
    integer, parameter :: GaugePlusSubModel_    = 6
    integer, parameter :: AssimilaGaugeSubModel_= 7

    !Baroclinic open boundary conditio discretization options
    integer, parameter :: Explicit_  = 1
    integer, parameter :: Implicit_  = 2
    integer, parameter :: StoreWave_ = 3


    ! Velocity use in the process of relaxation 
    integer, parameter :: TotalVel_    = 1
    integer, parameter :: BarotrVel_   = 2
    integer, parameter :: BaroclVel_   = 3

    ! Wind forcing type
    integer, parameter :: NoWind_           = 0
    integer, parameter :: WithWind_         = 1
    integer, parameter :: InitialSmoothWind_= 2

    !Tidal components use to compute the tide potential effect
    integer, parameter     :: M2=1, S2=2, K2=3, N2=4, K1=5, O1=6, P1=7, Q1=8, Ssa = 9,   &
                              Mm =10, Mf = 11 

    !Ways of computing the tide potential phase of each constituint using the doodson numbers
    integer, parameter     :: Kantha = 1, Lefevre=2


    !Types---------------------------------------------------------------------

    private :: T_State
    type       T_State
        logical :: BOXFLUXES  = OFF         !Calculates fluxes among boxes, concentracions, etc.
        logical :: SURFACE    = OFF 
        logical :: Initial    = OFF         
    end type T_State


    private :: T_Direction
    type       T_Direction
        integer  :: XY = null_int !initialization: jauch
        integer  :: YX = null_int !initialization: jauch
        integer  :: di = null_int !initialization: jauch
        integer  :: dj = null_int !initialization: jauch
    end type       T_Direction

    private :: T_Files
    type       T_Files
         character(len=PathLength) :: InitialHydrodynamic = null_str !initialization: jauch
         character(len=PathLength) :: FinalHydrodynamic   = null_str !initialization: jauch
         character(len=PathLength) :: OutPutFields        = null_str !initialization: jauch
         character(len=PathLength) :: ConstructData       = null_str !initialization: jauch
         character(len=PathLength) :: BoxFluxesFileName   = null_str !initialization: jauch
         character(len=PathLength) :: Energy              = null_str !initialization: jauch
    end type T_Files
    
    private :: T_DomainDecomposition
    type       T_DomainDecomposition        
        logical                                 :: ON       = .false. 
        logical                                 :: Master   = .false. !initialization: jauch
        integer                                 :: Master_MPI_ID    = null_int !initialization: jauch
        integer                                 :: Nslaves          = 0 !initialization: jauch
        integer, dimension(:), pointer          :: Slaves_MPI_ID    => null()
        type (T_Size2D), dimension(:), pointer  :: Slaves_Size      => null()
        type (T_Size2D), dimension(:), pointer  :: Slaves_Inner     => null()
        type (T_Size2D), dimension(:), pointer  :: Slaves_Mapping   => null()
        type (T_Size2D), dimension(:), pointer  :: Slaves_HaloMap   => null()
        integer                                 :: MPI_ID = null_int !initialization: jauch
        type (T_Size2D)                         :: Global
        type (T_Size2D)                         :: Mapping
        type (T_Size2D)                         :: Inner
        type (T_Size2D)                         :: HaloMap
        real(8), pointer, dimension(:)          :: VECG           => null() 
        real(8), pointer, dimension(:)          :: VECW           => null()
        real,    pointer, dimension(:,:)        :: WaterLevel_New => null()
        type(T_Coef_2D ), pointer               :: Coef           => null()
        integer                                 :: NeighbourSouth = null_int !initialization: jauch
        integer                                 :: NeighbourWest  = null_int !initialization: jauch
        integer                                 :: NeighbourEast  = null_int !initialization: jauch
        integer                                 :: NeighbourNorth = null_int !initialization: jauch
        integer                                 :: Halo_Points    = null_int !initialization: jauch
    end type T_DomainDecomposition

    !Generic 4D
    private :: T_Generic4D
    type T_Generic4D
        logical                            :: ON              = .false.   !initialization: jauch
        integer                            :: ObjTimeSerie    = null_int  !initialization: jauch
        integer                            :: TimeSerieColumn = null_int  !initialization: jauch
        real                               :: CurrentValue    = null_real !initialization: jauch
    end type T_Generic4D

    !NonHydrostatic
    private :: T_NonHydrostatic
    type T_NonHydrostatic
        real, dimension (:, :, :), pointer :: PressureCorrect => null()
        real, dimension (:, :, :), pointer :: PrevisionalQ    => null()
        real, dimension (:, :, :), pointer :: CCoef           => null()
        real, dimension (:, :, :), pointer :: GCoef           => null()
        logical                            :: ON = .false.
        real                               :: ThetaUV  = null_real !initialization: jauch
        real                               :: Residual = 1.e-6
        logical                            :: NormalizedResidual = .false.
        real                               :: alphaLU = 0.5
        integer                            :: MaxIt = 500
    end type T_NonHydrostatic

    private :: T_WaterLevel
    type T_WaterLevel
        type(T_PropertyID)              :: ID
        real, dimension (:, :), pointer :: New           => null()
        real, dimension (:, :), pointer :: Old           => null()
        real, dimension (:, :), pointer :: VolumeCreated => null()
        real, dimension (:, :), pointer :: Maxi          => null()
        real, dimension (:, :), pointer :: Mini          => null()
        real                            :: DT      = null_real !initialization: jauch
        real                            :: Default = null_real !initialization: jauch
        logical                         :: InitalizedByFile = .false.
    end type T_WaterLevel

    private :: T_Vel_UV
    type T_Vel_UV    
        type(T_PropertyID)                 :: ID
        real, dimension (:, :, :), pointer :: New => null()
        real, dimension (:, :, :), pointer :: Old => null()
#ifdef _USE_PAGELOCKED
        type(C_PTR)                        :: OldPtr
        type(C_PTR)                        :: NewPtr
#endif _USE_PAGELOCKED
        real                               :: Default   = null_real !initialization: jauch
        integer                            :: InTypeZUV = null_int  !initialization: jauch
    end type T_Vel_UV 

    private :: T_Horizontal
    type T_Horizontal
        type(T_Vel_UV)   ::   U
        type(T_Vel_UV)   ::   V
        type(T_Vel_UV)   ::   UV
        type(T_Vel_UV)   ::   VU
    end type T_Horizontal

    private :: T_Vertical
    type T_Vertical
        real, dimension (:, :, :), pointer :: Cartesian    => null()
        real, dimension (:, :, :), pointer :: CartesianOld => null()
        real, dimension (:, :, :), pointer :: Across       => null()
#ifdef _USE_PAGELOCKED
        type(C_PTR)                        :: CartesianPtr
#endif
    end type T_Vertical

    private :: T_Velocity
    type T_Velocity
        type (T_Horizontal)  :: Horizontal
        type (T_Vertical)    :: Vertical
        real                 :: DT = null_real !initialization: jauch
    end type T_Velocity

    private :: T_WaterFluxes
    type T_WaterFluxes
        real(8), dimension(:,:,:), pointer     :: X               => null()
        real(8), dimension(:,:,:), pointer     :: Y               => null()
        real(8), dimension(:,:,:), pointer     :: Z               => null()
        real(8), dimension(:,:,:), pointer     :: XY              => null()
        real(8), dimension(:,:,:), pointer     :: YX              => null()
        real(8), dimension(:,:,:), pointer     :: Discharges      => null()
        real(8), dimension(:,:,:), pointer     :: DischargesVelU  => null()
        real(8), dimension(:,:,:), pointer     :: DischargesVelV  => null()
        real(8), dimension(:,:,:), pointer     :: DischargesVelUV => null()
        real                                   :: New_Old = null_real !initialization: jauch
    end type T_WaterFluxes

    private :: T_Residual
    type T_Residual
        real                                :: ResidualTime      = null_real !initialization: jauch
        real, dimension(:,:),   pointer     :: WaterLevel        => null()
        real, dimension(:,:,:), pointer     :: Velocity_U        => null()
        real, dimension(:,:,:), pointer     :: Velocity_V        => null()
        real, dimension(:,:,:), pointer     :: Vertical_Velocity => null()
        real, dimension(:,:,:), pointer     :: DWZ               => null()
        real(8), dimension(:,:,:), pointer  :: WaterFlux_X       => null()
        real(8), dimension(:,:,:), pointer  :: WaterFlux_Y       => null()
    end type T_Residual

    private :: T_Geostroph
    type T_Geostroph
        real,    dimension (:, :, :), pointer :: PressGrad    => null()
        real,    dimension (:, :, :), pointer :: U            => null()
        real,    dimension (:, :, :), pointer :: V            => null()
        real,    dimension (:, :, :), pointer :: UV           => null()
        real,    dimension (:, :, :), pointer :: VU           => null()
        real,    dimension (:, :, :), pointer :: AuxDesCentre => null()
        real,    dimension (:, :), pointer    :: U_barotropic => null()
        real,    dimension (:, :), pointer    :: V_barotropic => null()
        real,    dimension (:, :), pointer    :: Reference_U_barotropic => null()
        real,    dimension (:, :), pointer    :: Reference_V_barotropic => null()
        real,    dimension (:, :), pointer    :: Coef_U_barotropic => null()
        real,    dimension (:, :), pointer    :: Coef_V_barotropic => null()
        logical                               :: ON = .false. !initialization: jauch
    end type T_Geostroph

    private :: T_Forces
    type T_Forces
        real,    dimension (:, :, :), pointer :: Rox3XY => null() ! Baroclinic
        real,    dimension (:, :, :), pointer :: Rox3X  => null() ! Baroclinic
        real,    dimension (:, :, :), pointer :: Rox3Y  => null() ! Baroclinic
        real(8), dimension (:, :, :), pointer :: Horizontal_Transport => null()
        real,    dimension (:, :, :), pointer :: Inertial_Aceleration => null()
        real,    dimension (:, :, :), pointer :: Relax_Aceleration => null()
        real,    dimension (:, :, :), pointer :: ObstacleDrag_Aceleration => null()
        real,    dimension (:, :, :), pointer :: Altim_Relax_Aceleration => null()
        real,    dimension (:,:),     pointer :: TidePotentialLevel => null()
        real,    dimension (:, :, :), pointer :: Scraper_Aceleration => null()
        real,    dimension (:, :, :), pointer :: ThinWalls_Dissipation => null()
    end type T_Forces

    private :: T_HorAdvection
    type T_HorAdvection

        real :: Coef1_Up = null_real !initialization: jauch
        real :: Coef2_Up = null_real !initialization: jauch
        real :: Coef3_Up = null_real !initialization: jauch

    end type T_HorAdvection

    private :: T_Coef_1D
    type T_Coef_1D
        real,    dimension (:), pointer :: a   => null(), &
                                           c   => null(), &
                                           r   => null(), &
                                           x   => null(), &
                                           u   => null(), &
                                           z   => null()
        real(8), dimension (:), pointer :: b   => null(), &
                                           bb  => null(), &
                                           gam => null()
    end type T_Coef_1D


    private :: T_Coef_2D
    type T_Coef_2D
        real,    dimension (:, :), pointer :: D     => null(), & 
                                              F     => null(), &
                                              Ti    => null(), &
                                              Tiaux => null(), &
                                              Rad   => null(), &
                                              TiRad => null()
        real(8), dimension (:, :), pointer :: E     => null(), &
                                              Eaux  => null()
    end type T_Coef_2D


    private :: T_Coef_3D
    type T_Coef_3D
#ifdef _ENABLE_CUDA
        real(C_DOUBLE), dimension (:, :, :), pointer    :: D  => null(), &
                                                           F  => null(), &
                                                           Ti => null(), &
                                                           E   => null()    !initialization: jauch - was real... Mabe should be real(8)? 
#else
        real,    dimension (:, :, :), pointer :: D  => null(), &
                                                 F  => null(), & 
                                                 Ti => null()
        real(8), dimension (:, :, :), pointer :: E  => null()
#endif _ENABLE_CUDA
#ifdef _USE_PAGELOCKED
        type(C_PTR)                                     :: DPtr, &
                                                           EPtr, &
                                                           FPtr, &
                                                           TiPtr
#endif _USE_PAGELOCKED
    end type T_Coef_3D

    private :: T_Coef_Baroc
    type T_Coef_Baroc

        Integer, dimension( : ), pointer   :: Kleft  => null(), &
                                              Kright => null()

        Real(8), dimension( : ), pointer   :: Depth_integ => null(), & 
                                              Hcenter     => null(), &
                                              Hleft       => null(), &
                                              Hright      => null(), &
                                              HroLeft     => null(), &
                                              HroRight    => null(), &
                                              DensRight   => null(), &
                                              DensLeft    => null()
    end type T_Coef_Baroc

    private :: T_InstantBound
    type T_InstantBound

        type (T_Time)                  :: TimeB  
        real                           :: BaroclVel = null_real !initialization: jauch
        type (T_InstantBound), pointer :: Next => null(), &
                                          Prev => null()

    end type T_InstantBound


    private :: T_Imposed
    type T_Imposed

        integer                        :: Number     = null_int  !initialization: jauch
        real                           :: DTInterval = null_real !initialization: jauch
        type (T_InstantBound), pointer :: FirstInstant => null(), &
                                          LastInstant  => null()

    end type T_Imposed

    private :: T_VelBaroclinic
    type T_VelBaroclinic

        type(T_Vel_UV)   ::   U
        type(T_Vel_UV)   ::   V
        type(T_Vel_UV)   ::   UV
        type(T_Vel_UV)   ::   VU
        !This velocity is compute for the cartesian referential
        real, dimension (:, :, :), pointer :: W_New => null(), &
                                              W_Old => null()

        real, dimension (:, :   ), pointer :: U2D  => null(), &
                                              V2D  => null(), & 
                                              UV2D => null()

        type (T_Imposed), dimension(:), pointer :: ImposedNormX  => null(), &
                                                   ImposedNormY  => null(), & 
                                                   ImposedNormXY => null(), &
                                                   ImposedTangX  => null(), &
                                                   ImposedTangY  => null(), & 
                                                   ImposedTangXY => null()

        integer :: CelerityType              = null_int     !initialization: jauch
        real    :: InternalCelerity          = null_real    !initialization: jauch
        real    :: TRelaxOut                 = null_real, & !initialization: jauch
                   TRelaxIn                  = null_real    !initialization: jauch
        real    :: MinLeavingBaroclincVel    = null_real    !initialization: jauch
        logical :: BaroclinicNormalRadiation = .false.      !initialization: jauch
        integer :: BaroclinicOBCDiscret      = null_int     !initialization: jauch
        logical :: StoreBaroclinicWave       = .false.      !initialization: jauch

        real    :: DTWave = null_real

    end type T_VelBaroclinic

#ifdef _USE_SEQASSIMILATION
    private :: T_StatePointer
    type T_StatePointer
        real, dimension (:, :),    pointer :: WaterLevelNew        => null()
        real, dimension (:, :, :), pointer :: VelocityUNew         => null(), &
                                              VelocityVNew         => null(), &
                                              VelocityUOld         => null(), &
                                              VelocityVOld         => null(), &
                                              VelVerticalCartesian => null(), &
                                              VelVerticalAcross    => null()
        real(8), dimension(:,:,:), pointer :: WaterFluxX           => null(), &
                                              WaterFluxY           => null(), &
                                              WaterFluxZ           => null(), &
                                              SubModelqX           => null(), &
                                              SubModelqY           => null()
        real, dimension(:,:),      pointer :: ChezyVelUV           => null()
    end type T_StatePointer
#endif _USE_SEQASSIMILATION

    private :: T_Coefficients
    type T_Coefficients
        type(T_Coef_1D)                    :: D1
        type(T_Coef_2D)                    :: D2
        type(T_Coef_3D)                    :: D3
        !griflet
        type(T_Coef_Baroc), dimension(:), pointer   :: Baroc => null()
    end type T_Coefficients


    private :: T_External
    type T_External
        !Horizontal Mapping

        !Boundary faces : boundary point in one side and a interior point in another
        integer, dimension(:,:),   pointer :: BoundaryFacesUV => null(), &
                                              BoundaryFacesVU => null(), & 
                                              BoundaryFacesU  => null(), &
                                              BoundaryFacesV  => null(), & 
                                              BoundaryPoints  => null(), &
                                              WaterPoints2D   => null()

        !3D Mapping

        !Compute faces. Faces where is possible to compute a velocity
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_U  => null(), & 
                                              ComputeFaces3D_V  => null(), &
                                              ComputeFaces3D_UV => null(), &
                                              ComputeFaces3D_VU => null(), &
                                              WaterPoints3D     => null(), &
                                              ComputeFaces3D_W  => null(), &
                                              OpenPoints3D      => null()

        !Land Water faces. Faces that have a land point in one side and a interior point in another
        integer, dimension(:,:,:), pointer :: LandBoundaryFacesUV => null(), &
                                              LandBoundaryFacesVU => null(), & 
                                              LandBoundaryFacesU  => null(), &
                                              LandBoundaryFacesV  => null()


        !Imposed faces  : faces where the model do not compute velocites 
        !                 but need to imposed values to define the 
        !                 the velocities boundary condition
        integer, dimension(:,:,:),   pointer :: ImposedNormalFacesUV     => null(), &
                                                ImposedNormalFacesU      => null(), &
                                                ImposedNormalFacesV      => null(), &
                                                ImposedTangentialFacesU  => null(), &
                                                ImposedTangentialFacesV  => null(), &
                                                ImposedTangentialFacesUV => null(), &
                                                ImposedTangentialFacesVU => null()



        !Horizontal Grid
        !DUX - distance between the West face and the East face of a cell along the center cell
        !DVY - distance between the South face and the North face of a cell along the center cell
        !DZX - distance between the cell center and the center of the West cell (X direction)
        !DZY - distance between the cell center and the center of the South cell (Y direction)
        !DYY - width of the West face of a cell 
        !DXX - width of the South face of a cell 
        real,    dimension(:,:  ), pointer :: DUX => null(), &
                                              DVY => null(), &
                                              DZX => null(), &
                                              DZY => null(), &
                                              DYY => null(), &
                                              DXX => null()
        !Auxiliar pointers
        real,    dimension(:,:  ), pointer :: DUX_VY => null(), &
                                              DZX_ZY => null(), &
                                              DZY_ZX => null(), &
                                              DYY_XX => null(), &
                                              DXX_YY => null(), &
                                              DVY_UX => null()

        real,    dimension(:, :),  pointer :: Coriolis_Freq => null(), &
                                              RotationX     => null(), &
                                              RotationY     => null()
                                              
        logical                            :: Distortion   = .false.     !initialization: jauch
        real                               :: GridRotation = null_real   !initialization: jauch

        !3D Geometry 

        !Volume_Z_New - Last compute control volume of the water level compute point, 
        !               basically is the volume of our grid
        !Volume_Z_Old - Previous compute control volume of the water level compute point
        !Volume_U     - Last compute control volume of the velocity U compute point
        !Volume_V     - Last compute control volume of the velocity V compute point
        !Volume_W     - Last compute control volume of the velocity W compute point
        !Area_U       - Area of the grid cell West face
        !Area_V       - Area of the grid cell South face
        !DWZ          - Thickness of the cell grid
        real(8), dimension(:,:,:), pointer :: Volume_Z_Old => null(), &
                                              Volume_Z_New => null(), &
                                              Volume_U     => null(), &
                                              Volume_V     => null(), &
                                              Volume_W     => null()
                                              
        real,    dimension(:,:,:), pointer :: Area_U        => null(), &
                                              Area_V        => null(), &
                                              DWZ           => null(), &
                                              SZZ           => null(), &
                                              DUZ           => null(), &
                                              DVZ           => null(), &
                                              DUZ_VZ        => null(), &
                                              DZZ           => null()
                                              
        real,    dimension(:,:  ), pointer :: WaterColumn   => null(), &
                                              WaterColumnU  => null(), &
                                              WaterColumnV  => null(), &
                                              WaterColumnUV => null(), &
                                              WaterColumnVU => null()

        !Auxiliar
        real(8), dimension(:,:,:), pointer :: Volume_UV => null()
        
        real,    dimension(:,:,:), pointer :: Area_UV   => null(), &
                                              Area_VU   => null()

        !KFloor variables (matrix that stores the first layer of the water column)
        integer, dimension(:,:),   pointer :: KFloor_Z => null(), &
                                              KFloor_U => null(), & 
                                              KFloor_V => null()

        !Auxiliar
        integer, dimension(:,:),   pointer :: KFloor_UV => null(), &
                                              KFloor_VU => null()

        !Turbulence
        !Visc_H_Corner - Turbulent horizontal viscosity in the cell SW corner
        !Visc_H_Corner - Turbulent horizontal viscosity in the cell center
        !Visc_H_Corner - Turbulent vertical   viscosity 
        real,    dimension(:,:,:), pointer :: Visc_H_Corner         => null(), &
                                              Visc_H_Center         => null(), &
                                              Vertical_Viscosity    => null()

        !Water Properties
        real,    dimension(:,:,:), pointer :: Density   => null(), &
                                              SigmaDens => null()

        !Bottom
        real,    dimension(:,:),   pointer :: ChezyZ            => null(), &
                                              ChezyVelUV        => null(), &
                                              WaveChezyVel      => null(), &
                                              RugosityMatrix    => null()
        
        real                               :: Hmin_Chezy    = null_real, &
                                              Vmin_Chezy    = null_real, &
                                              ChezyCoef     = null_real
                                              
        logical                            :: Manning = .false., &
                                              Chezy   = .false.


        !Surface
        real,    dimension(:,:),   pointer :: TauWindU      => null(), &
                                              TauWindV      => null(), &
                                              TauWind_UV    => null()
        
        real(8), dimension(:,:  ), pointer :: BottomWaterFlux   => null()
        
        real,    dimension(:,:  ), pointer :: SurfaceWaterFlux      => null(), &
                                              WindStress_X          => null(), &
                                              WindStress_Y          => null(), &
                                              AtmosphericPressure   => null()

        !Waves 
        real,    dimension(:,:),   pointer :: TauWavesU     => null(), & 
                                              TauWavesV     => null(), &
                                              TauWaves_UV   => null()

        !Altimetry Assimilation
        real,    dimension(:,:  ), pointer :: AltimWaterLevelAnalyzed   => null()
        
        real                               :: AltimDecayTime    = null_real, & !initialization: Jauch
                                              AltimAssimDT      = null_real    !initialization: Jauch
        
        real,    dimension(:,:,:), pointer :: AltimSigmaDensAnalyzed    => null()
        
        logical                            :: Backtracking  = .false.                

    end type T_External

    type T_Drag
        type(T_PropertyID)              :: ID
        real, dimension(:,:,:), pointer :: Coef => null()
    end type T_Drag

    type T_Scraper
        type(T_PropertyID)                  :: ID_U, ID_V, ID_W
         
        real,    dimension(:,:,:), pointer  :: VelU => null(), &
                                               VelV => null(), &
                                               VelW => null()
                                               
        integer, dimension(:,:,:), pointer  :: Position => null()
        
        logical                             :: UOn  = .false., & !initialization: Jauch  
                                               VOn  = .false., & !initialization: Jauch  
                                               WOn  = .false.    !initialization: Jauch
        
        real                                :: VelLimit     = -1e8
        real                                :: TimeScale    = null_real !initialization: Jauch
    end type T_Scraper

    type T_ThinWalls
        integer, dimension(:),     pointer  :: FaceU_I  => null(), &
                                               FaceU_J  => null(), &
                                               FaceU_K  => null(), &
                                               FaceV_I  => null(), &
                                               FaceV_J  => null(), &
                                               FaceV_K  => null(), &
                                               FaceW_I  => null(), &
                                               FaceW_J  => null(), &
                                               FaceW_K  => null()
                                               
        logical                             :: UOn  = .false., & !initialization: Jauch
                                               VOn  = .false., & !initialization: Jauch
                                               WOn  = .false., & !initialization: Jauch
                                               ON   = .false.    !initialization: Jauch
                                               
        integer                             :: Nu   = null_int, & !initialization: Jauch
                                               Nv   = null_int, & !initialization: Jauch
                                               Nw   = null_int    !initialization: Jauch
                                               
        integer                             :: ObjTimeSerie     = null_int, & !initialization: Jauch
                                               CloseFlagColumn  = null_int    !initialization: Jauch
                                               
        logical                             :: VariableInTime   = .false. !initialization: Jauch
        
        real                                :: GradWL_Limit = null_real !initialization: Jauch
        
                                               !CloseFlag = 1 close, CloseFlag = 0 open
        integer                             :: CloseFlag    = null_int !initialization: Jauch
    end type T_ThinWalls

    type       T_HydroCoupling                  
         type(T_Time)                           :: NextCompute
         real                                   :: DT_Compute   = FillValueReal
         logical                                :: Yes          = .false.
         logical                                :: flag         = .false.
    end type T_HydroCoupling  

    private :: T_HydroOptions
    type       T_HydroOptions
        real(8)                         :: EnteringWaveDirection    = null_real !initialization: Jauch
        
        real, dimension(:,:,:), pointer :: BiHarmonicUX_VY  => null(), &
                                           BiHarmonicUY_VX  => null()
                                           
        real, dimension(:,:),   pointer :: Tlag => null()

        real                            :: BiHarmonicCoef           = null_real, & !initialization: Jauch
                                           BottomViscCoef           = null_real, & !initialization: Jauch
                                           UpStream_CenterDif       = null_real, & !initialization: Jauch
                                           ImplicitVertAdvection    = null_real, & !initialization: Jauch
                                           ImplicitVertDiffusion    = null_real, & !initialization: Jauch
                                           Num_Discretization       = null_real, & !initialization: Jauch
                                           MinLeavingVelocity       = null_real, & !initialization: Jauch
                                           MinLeavingComponent      = null_real, & !initialization: Jauch
                                           InertialPeriods          = null_real, & !initialization: Jauch
                                           RampPeriod               = null_real, & !initialization: Jauch
                                           TideSlowStartCoef        = null_real, & !initialization: Jauch
                                           Hmin_Advection           = null_real, & !initialization: Jauch
                                           !AtmosphereCoef: This is the coefficient bounded by [0 1] to multiply the atmospheric forces with.
                                           AtmosphereCoef           = null_real, & !initialization: Jauch
                                           !AtmospherePeriod: This period will substitute the SmoothInitial period                                                    
                                           AtmospherePeriod         = null_real    !initialization: Jauch                                           

        integer                         :: UpStream                 = null_int, & !initialization: Jauch
                                           Evolution                = null_int, & !initialization: Jauch
                                           VelTangentialBoundary    = null_int, & !initialization: Jauch
                                           VelNormalBoundary        = null_int, & !initialization: Jauch
                                           BaroclinicMethod         = null_int    !initialization: Jauch

        logical                         :: Baroclinic           = .false., & !initialization: Jauch
                                           BoundaryBaroclinic   = .false., & !initialization: Jauch                                           
                                           Coriolis             = .false., & !initialization: Jauch
                                           Continuous           = .false., & !initialization: Jauch
                                           Compute_Tide         = .false., & !initialization: Jauch
                                           Imposed_BoundaryWave = .false., & !initialization: Jauch
                                           WaterDischarges      = .false., & !initialization: Jauch
                                           Residual             = .false., & !initialization: Jauch
                                           ComputeEnteringWave  = .false., & !initialization: Jauch
                                           Energy               = .false., & !initialization: Jauch
                                           VolumeVariation      = .false., & !initialization: Jauch
                                           HorizontalDiffusion  = .false., & !initialization: Jauch
                                           HorizontalAdvection  = .false., & !initialization: Jauch
                                           VerticalDiffusion    = .false., & !initialization: Jauch
                                           VerticalAdvection    = .false., & !initialization: Jauch
                                           BaroclinicRAMP       = .false., & !initialization: Jauch
                                           NullBoundaryHorAdv   = .false., & !initialization: Jauch
                                           !AtmosphereRAMP: This logical value makes obsolete the wind
                                           AtmosphereRAMP       = .false., & !initialization: Jauch
                                           InvertBarometer      = .false., & !initialization: Jauch
                                           InvertBaromSomeBound = .false.    !initialization: Jauch
                                           
        real, pointer, dimension(:,:)   :: InvertBarometerCells => null()
                                                      
        integer                         :: Wind                 = null_int  !initialization: Jauch
        real                            :: SmoothInitialPeriod  = null_real !initialization: Jauch
        
        logical                         :: AtmPressure      = .false.  !initialization: Jauch
        integer                         :: AtmPressureType  = null_int !initialization: JAuch
                                            ! 0 - don't use atmospheric pressure
                                            ! 1 - Use atmospheric pressure
                                            ! 2 - Use Mean Sea Level Pressure (MSLP)
                                        
        logical                         :: SurfaceWaterFlux     = .false., & !initialization: Jauch
                                           BottomWaterFlux      = .false., & !initialization: Jauch
                                           Relaxation           = .false., & !initialization: Jauch
                                           Geost_Initialization = .false., & !initialization: Jauch
                                           Level_Bottom_Anomaly = .false.    !initialization: Jauch
        
        type(T_HydroCoupling)           :: AltimetryAssimilation
        
        logical                         :: CoriolisBoundary     = .false., & !initialization: Jauch
                                           Recording            = .false., & !initialization: Jauch
                                           MomentumDischarge    = .false., & !initialization: Jauch
                                           LocalDensity         = .false., & !initialization: Jauch
                                           BlumbergKantha       = .false., & !initialization: Jauch
                                           InitialElevation     = .false., & !initialization: Jauch
                                           ConservativeHorDif   = .false., & !initialization: Jauch
                                           BiHarmonic           = .false., & !initialization: Jauch
                                           BottomVisc_LIM       = .false., & !initialization: Jauch  !MRV
                                           WaterLevelMaxMin     = .false.    !initialization: Jauch

#ifdef OVERLAP
        logical                         :: Overlap  = .false. !initialization: Jauch
#endif OVERLAP

        integer                         :: BarotropicRadia  = null_int, &  !initialization: Jauch
                                           BaroclinicRadia  = null_int, &  !initialization: Jauch
                                           LocalSolution    = null_int     !initialization: Jauch

        logical                         :: CorrectWaterLevel    = .false.       !initialization: Jauch
        real                            :: WaterLevelMin        = null_real, &  !initialization: Jauch
                                           WaterColumn2D        = null_real     !initialization: Jauch

        logical                         :: SlippingCondition    = .false., &  !initialization: Jauch
                                           WaveStress           = .false., &  !initialization: Jauch
                                           Obstacle             = .false., &  !initialization: Jauch
                                           Scraper              = .false. 

        type (T_Time)                   :: RAMP_BeginTime

        logical                         :: CentrifugalForce = .false., &  !initialization: Jauch
                                           InertiaForces    = .false.     !initialization: Jauch

        integer                         :: AdvectionMethodH = null_int, &  !initialization: Jauch
                                           TVD_LimH         = null_int, &  !initialization: Jauch
                                           AdvectionMethodV = null_int, &  !initialization: Jauch
                                           TVD_LimV         = null_int     !initialization: Jauch
                   
        logical                         :: Upwind2H = .false., &  !initialization: Jauch
                                           Upwind2V = .false.     !initialization: Jauch
                   
        real                            :: VolumeRelMax = null_real !initialization: Jauch

        integer                         :: BaroclinicPoliDegree         = null_int, &  !initialization: Jauch
                                           Vertical_AxiSymmetric_Model  = null_int     !initialization: Jauch

        real                            :: FlatherColdPeriod    = null_real, & !initialization: Jauch
                                           FlatherColdSeaLevel  = null_real    !initialization: Jauch
        
        !PCL
        logical                         :: XZFlow   = .false.
        
        logical                         :: ExternalBarotropicVel2D  = .true. 

    end type T_HydroOptions

    type       T_OutPut
         type (T_Time), dimension(:), pointer     :: OutTime, &
                                                     RestartOutTime, &
                                                     SurfaceOutTime
                                                     
         integer                                  :: NextOutPut             = null_int, & !initialization: Jauch
                                                     Number                 = null_int, & !initialization: Jauch
                                                     NextRestartOutput      = null_int, & !initialization: Jauch
                                                     NextSurfaceOutput      = null_int, & !initialization: Jauch
                                                     NumberSurfaceOutputs   = null_int    !initialization: Jauch
                                                     
         logical                                  :: HDF5ON             = .false., & !initialization: Jauch
                                                     HDF5_Surface_ON    = .false., & !initialization: Jauch
                                                     Run_End            = .false., & !initialization: Jauch
                                                     WriteRestartFile   = .false., & !initialization: Jauch
                                                     TimeSerieON        = .false., & !initialization: Jauch
                                                     ProfileON          = .false.    !initialization: Jauch
                                                     
         real,          dimension(:,:,:), pointer :: ModulusH       => null(), &
                                                     CenterU        => null(), &
                                                     CenterV        => null(), &
                                                     CenterW        => null(), &
                                                     DirectionH     => null(), &
                                                     Vorticity3D    => null(), &
                                                     CenterUaux     => null(), &
                                                     CenterVaux     => null(), &
                                                     ModulusUVaux   => null(), &
                                                     CenterWaux     => null()
                                                     
         real,          dimension(:,:),   pointer :: Aux2D          => null(), &
                                                     WaterLevelMax  => null(), &
                                                     WaterLevelMin  => null()
                                                     
         logical                                  :: RestartOverwrite   = .false., & !initialization: Jauch
                                                     Faces              = .false.    !initialization: Jauch
                                                     
         real                                     :: WaterLevelUnits    = null_real !initialization: Jauch
         logical                                  :: TimeSerieDischON   = .false. 
         
         integer                                  :: DischargesNumber   = null_int !initialization: Jauch
         
         integer, dimension(:),   pointer         :: TimeSerieDischID   => null()     
         real,    dimension(:,:), pointer         :: TimeSerieDischProp => null()
    end type T_OutPut

    type      T_OutW
        type(T_OutPutTime), dimension(:), pointer :: OutPutWindows      => null()
        logical                                   :: OutPutWindowsON    = .false. !initialization: Jauch        
        integer                                   :: WindowsNumber      = 0       !initialization: Jauch
        integer,            dimension(:), pointer :: ObjHDF5            => null()
        logical                                   :: Simple             = .false. !initialization: Jauch
    end type  T_OutW
    
    type T_Energy
        integer                         :: FileID       = null_int !initialization: Jauch
        integer                         :: BufferCount  = null_int !initialization: Jauch
        real(8)                         :: PotentialEnergyReference = null_real !initialization: Jauch
        logical                         :: FirstTime                = .true.
        real, dimension(:), pointer     :: YearBuffer               => null(), &
                                           MonthBuffer              => null(), &
                                           DayBuffer                => null(), &
                                           HourBuffer               => null(), &
                                           MinuteBuffer             => null(), &
                                           SecondBuffer             => null(), &
                                           RelativeKEBuffer         => null(), &
                                           RelativePEBuffer         => null(), &
                                           KineticBuffer            => null(), &
                                           PotentialBuffer          => null(), &
                                           VorticityBuffer          => null(), &
                                           MassBuffer               => null(), &
                                           VolumeBuffer             => null(), &
                                           OpenVolumeBuffer         => null(), &
                                           WaterLevelBuffer         => null(), &
                                           BarotropicKEBuffer       => null(), &
                                           BaroclinicKEBuffer       => null(), &
                                           VelMaxBaroclinicBuffer   => null(), & 
                                           VelMaxBuffer             => null()

        real, dimension(:,:,:), pointer :: CenterU  => null(), &
                                           CenterV  => null(), &
                                           CenterW  => null()
                                           
        real, dimension(:,:  ), pointer :: BarotropicU  => null(), &
                                           BarotropicV  => null()

        type (T_Size3D)                 :: Window
        type (T_Time)                   :: NextOutPut
        
        real                            :: DtOut = null_real !initialization: Jauch
    end type T_Energy

    
    private :: T_Astro
    type       T_Astro
        logical                           :: Compute    = .false. !initialization: Jauch
        
        integer                           :: ComponentsNumber = 11
        
        real,    pointer, dimension (:  ) :: Beta       => null(), &
                                             Amplitude  => null(), &
                                             Frequency  => null(), &
                                             Arguments  => null(), &
                                             L          => null()
                                             
        integer, pointer, dimension (:  ) :: m  => null()
        
        type (T_Time)                     :: TimeRef        
        real                              :: Alpha      = null_real !initialization: Jauch
        integer                           :: Algorithm  = null_int  !initialization: Jauch
    end type T_Astro
     
    private :: T_Relaxation
    type       T_Relaxation
        logical                             :: Rox3                 = .false.
        logical                             :: HorizAdv             = .false.
        logical                             :: Coriolis             = .false.
        logical                             :: Velocity             = .false.       
        logical                             :: WaterLevel           = .false.
        logical                             :: RefBoundWaterLevel   = .false.
        logical                             :: Force                = .false.
        logical                             :: Geometry             = .false.
        integer                             :: ReferenceVelocity    = TotalVel_
        real,   dimension(:,:,:), pointer   :: DecayTimeGeo => null()       
    endtype      

    private :: T_SubModel
    type       T_SubModel
        logical                              :: ON              = .false., & !initialization: Jauch
                                                Set             = .false., & !initialization: Jauch
                                                InterPolTime    = .false., & !initialization: Jauch
                                                DeadZone        = .false., & !initialization: Jauch
                                                MissingNull     = .false., & !initialization: Jauch
                                                FatherHotStart  = .false.    !initialization: Jauch
                                                
        character (Len = PathLength)         :: DeadZoneFile    = null_str !initialization: Jauch
        integer                              :: VertComunic     = null_int !initialization: Jauch

        logical                              :: Extrapolate     = .false., & !initialization: Jauch
                                                HotStartData    = .false.

        logical, dimension(:,:,:), pointer   :: DeadZonePoint   => null()

        real,    dimension(:,:  ), pointer   :: Z   => null()
        
        real,    dimension(:,:,:), pointer   :: U_New       => null(), &
                                                V_New       => null(), &
                                                UV_New      => null(), &
                                                VU_New      => null(), &
                                                U_Old       => null(), &
                                                V_Old       => null(), &
                                                UV_Old      => null(), &
                                                DUZ_Old     => null(), &
                                                DVZ_Old     => null(), &
                                                DUVZ_Old    => null(), &
                                                DUZ_New     => null(), &
                                                DVZ_New     => null()
                                                
        real(8), dimension(:,:,:), pointer   :: qX  => null(), &
                                                qY  => null(), &
                                                qXY => null(), &
                                                qYX => null()

        !Time Interpolation
        type(T_Time)                         :: NextTime, PreviousTime
        
        real,    dimension(:,:  ), pointer   :: Z_Previous  => null(), &
                                                Z_Next      => null()
                                                
        real,    dimension(:,:,:), pointer   :: U_Previous      => null(), & 
                                                V_Previous      => null(), &
                                                U_Next          => null(), &
                                                V_Next          => null(), &
                                                DUZ_Previous    => null(), &
                                                DUZ_Next        => null(), &
                                                DVZ_Previous    => null(), &
                                                DVZ_Next        => null()

        ! Ang: new implementation father-son 3D
        !Father3D-Son3D connection auxiliary
        real(8), dimension(:,:,:), pointer   :: Aux_qX  => null(), &
                                                Aux_qY  => null()
                                                
        real,    dimension(:,:,:), pointer   :: Aux_DUZ => null(), &
                                                Aux_DVZ => null(), &
                                                Aux_U   => null(), &
                                                Aux_V   => null()
                                                
        logical                              :: MomentConserv   = .false.
        
        integer                              :: FatherKLB   = null_int, & !initialization: Jauch
                                                FatherKUB   = null_int    !initialization: Jauch
                                                
        type(T_Time)                         :: GetFatherTime 

        integer                              :: ObjBoxDif = 0

    endtype   

    type T_HydroStatistic           
        logical                              :: ON      = .false. !initialization: Jauch
        character(len=StringLength)          :: File    = null_str !initialization: Jauch
        integer                              :: NProp   = 4
        
        integer, dimension(:), allocatable   :: PropList, &
                                                ID 
    end type T_HydroStatistic

    type T_CyclicBoundary
        logical                              :: ON          = .false.  !initialization: Jauch
        integer                              :: Direction   = null_int !initialization: Jauch
    end type T_CyclicBoundary
       
    private :: T_Hydrodynamic
    type       T_Hydrodynamic
        private
        type(T_Direction     ) :: Direction 
        type(T_State         ) :: State
        integer                :: InstanceID    = null_int !initialization: Jauch
        character(PathLength)  :: ModelName     = null_str !initialization: Jauch
        type(T_Size2D        ) :: Size2D
        type(T_Size2D        ) :: WorkSize2D
        type(T_Size3D        ) :: Size
        type(T_Size3D        ) :: WorkSize
        type(T_Files         ) :: Files
        type(T_Time          ) :: BeginTime  
        type(T_Time          ) :: CurrentTime  
        type(T_Time          ) :: EndTime
        type(T_Time          ) :: LastIteration 
        type(T_WaterLevel    ) :: Waterlevel
        type(T_Velocity      ) :: Velocity
        type(T_Geostroph     ) :: Geostroph
        type(T_WaterFluxes   ) :: WaterFluxes
        type(T_Residual      ) :: Residual
        type(T_Forces        ) :: Forces
        type(T_HorAdvection  ) :: HorAdvection
        type(T_Coefficients  ) :: Coef
        type(T_External      ) :: External_Var
        type(T_HydroOptions  ) :: ComputeOptions
        type(T_OutPut        ) :: OutPut
        type(T_OutW          ) :: OutW        
        type(T_Energy        ) :: Energy
        type(T_Astro         ) :: TidePotential
        type(T_Relaxation    ) :: Relaxation
        type(T_SubModel      ) :: SubModel
        type(T_VelBaroclinic ) :: VelBaroclinic
        type(T_HydroStatistic) :: Statistics
        type(T_HydroStatistic) :: Statistics2d
        type(T_CyclicBoundary) :: CyclicBoundary 
        type(T_NonHydrostatic) :: NonHydrostatic
        type(T_Generic4D     ) :: Generic4D
        type(T_Drag          ) :: Drag
        type(T_Scraper       ) :: Scraper
        type(T_Thinwalls     ) :: Thinwalls
        
        type(T_DomainDecomposition) :: DomainDecomposition
                
        logical                :: FirstIteration = .true.
#ifdef _USE_SEQASSIMILATION
        !This variable is used to retain location of original memory space for variables
        !changed in sequential data assimilation (some external memory is used ocasionally)
        type(T_StatePointer  ) :: AuxPointer
        logical                :: RunSeqAssimilation    = .false.
        logical                :: VirtualRun            = .false.
#endif _USE_SEQASSIMILATION         

        !Auxiliar thomas arrays
        real(8), pointer, dimension(:) :: VECG_3D   => null(), &
                                          VECW_3D   => null(), &
                                          VECG_2D   => null(), &
                                          VECW_2D   => null()
        
        !Auxiliar flux properties
        real(8), pointer, dimension(:,:,:) :: Aux3DFlux => null()    

        !Instance of ModuleGridData
        integer :: ObjGridData              = 0
      
        !Instance of ModuleHorizontalGrid
        integer :: ObjHorizontalGrid        = 0

        !Instance of ModuleTime
        integer :: ObjTime                  = 0

        !Instance of ModuleGeometry
        integer :: ObjGeometry              = 0

        !Instance of ModuleHorizontalMap
        integer :: ObjHorizontalMap         = 0

        !Instance of ModuleMap
        integer :: ObjMap                   = 0

        !Modules construct INSIDE the hydrodynamic module

        !Instance of Module HDF5
        integer :: ObjHDF5                  = 0

        !Instance of Module HDF5 for surface outputs
        integer :: ObjSurfaceHDF5           = 0

        !Instance of Module_EnterData
        integer :: ObjEnterData             = 0
       
        !Instance of Module_EnterData
        integer :: ObjEnterData1            = 0
        
        !Instance of ModuleOpenBoundary
        integer :: ObjOpenBoundary          = 0

        !Instance of ModuleTurbulence
        integer :: ObjTurbulence            = 0

        !Instance of ModuleSurface
        integer :: ObjDischarges            = 0

        !Instance of ModuleBoxDif
        integer :: ObjBoxDif                = 0           

        !Instance of ModuleTimeSerie
        integer :: ObjTimeSerie             = 0

        !!Instance of ModuleProfile
        integer :: ObjProfile               = 0

        !Instance of ModuleHydrodynamicFile (Input)
        integer :: ObjHydrodynamicFileIn    = 0

        !Instance of ModuleHydrodynamicFile (Output)
        integer :: ObjHydrodynamicFileOut   = 0

        !Instance of ModuleAssimilation      
        integer :: ObjAssimilation          = 0

        !Instance of Waves      
        integer :: ObjWaves                 = 0
        
#ifdef _ENABLE_CUDA
        !Instance of CUDA
        integer :: ObjCuda                  = 0
#endif _ENABLE_CUDA

        !griflet
        integer                         :: MaxThreads   = null_int !initialization: Jauch
        type(T_THOMAS), pointer         :: THOMAS   => null()
        type(T_THOMAS2D), pointer       :: THOMAS2D => null()

        type (T_Hydrodynamic), pointer :: Next

    end type T_Hydrodynamic

    !Global Module Variables
    type (T_Hydrodynamic), pointer                  :: FirstHydrodynamic    => null()
    type (T_Hydrodynamic), pointer                  :: Me                   => null()

    contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CO

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!-------------------------------------------------------------------------
!        IST/MARETEC, Marine Modelling Group, Mohid2000 modelling system
!-------------------------------------------------------------------------


!BOP
!
! !ROUTINE: StartHydrodynamic

! !DESCRIPTION: 
!     This routine is responsible for the initialization of the 
!     hydrodynamic model: numerical options, hydrodynamic initial values, etc.
 
! !REVISION HISTORY: 
!  1Jan2000    Paulo Chambel  First experimental version.
!  16Nov2000   Paulo Chambel  Comments are introduce in the Protex format 
!                             to produce a manual
!            

! !INTERFACE:

    subroutine StartHydrodynamic (ModelName,                                            &
                                  HydrodynamicID,                                       &
                                  GridDataID,                                           &
                                  HorizontalGridID,                                     & 
                                  GeometryID,                                           &
                                  HorizontalMapID,                                      &
                                  MapID,                                                &
                                  AssimilationID,                                       &
                                  TimeID,                                               &
                                  TurbulenceID,                                         &
                                  DischargesID,                                         &
                                  WavesID,                                              &
#ifdef _ENABLE_CUDA
                                  CudaID,                                               &
#endif _ENABLE_CUDA
                                  MPI_ID,                                               &
                                  STAT)

!
! !INPUT PARAMETERS:

        !Arguments-------------------------------------------------------------
        character(Len=*)              :: ModelName
        integer, intent (INOUT)       :: HydrodynamicID 
        integer, intent (IN)          :: GridDataID     
        integer, intent (IN)          :: HorizontalGridID
        integer, intent (IN)          :: GeometryID     
        integer, intent (IN)          :: HorizontalMapID
        integer, intent (IN)          :: MapID          
        integer                       :: AssimilationID 
        integer, intent (IN)          :: TimeID         
        integer, intent (IN)          :: TurbulenceID
        integer, intent (IN)          :: WavesID
        integer                       :: DischargesID
#ifdef _ENABLE_CUDA
        integer                       :: CudaID
#endif _ENABLE_CUDA
        integer, intent (IN)          :: MPI_ID
! !OUTPUT PARAMETERS:                                          
        
        integer, optional, intent(OUT):: STAT                          


!EOP

        !Local-----------------------------------------------------------------

        integer :: ready_
        integer :: STAT_       
        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        !Assures nullification of the global variable
        if (.not. ModuleIsRegistered(mHydrodynamic_)) then
            nullify (FirstHydrodynamic)
            call RegisterModule (mHydrodynamic_) 
        endif


        call Ready(HydrodynamicID, ready_)    

cd0 :   if (ready_ .EQ. OFF_ERR_) then

            call AllocateInstance 

            Me%ModelName = ModelName

            !Associates External Instances
            Me%ObjTime           = AssociateInstance (mTIME_,           TimeID          )
            Me%ObjGridData       = AssociateInstance (mGRIDDATA_,       GridDataID      ) 
            Me%ObjHorizontalGrid = AssociateInstance (mHORIZONTALGRID_, HorizontalGridID)
            Me%ObjHorizontalMap  = AssociateInstance (mHORIZONTALMAP_,  HorizontalMapID )
            Me%ObjGeometry       = AssociateInstance (mGEOMETRY_,       GeometryID      )
            Me%ObjMap            = AssociateInstance (mMAP_,            MapID           )
            Me%ObjTurbulence     = AssociateInstance (mTURBULENCE_,     TurbulenceID    )

            if(WavesID /= 0)then
                Me%ObjWaves      = AssociateInstance (mWAVES_,          WavesID)
            end if
            
#ifdef _ENABLE_CUDA
            Me%ObjCuda          = AssociateInstance (mCUDA_,             CudaID)
#endif _ENABLE_CUDA

            Me%DomainDecomposition%MPI_ID = MPI_ID

            call Construct_Hydrodynamic (DischargesID,  AssimilationID)

            if (Me%ComputeOptions%Evolution == Solve_Equations_)                        &
                call CourantGH()

            call null_time   (Me%LastIteration)
            call null_time   (Me%CurrentTime)

            !Returns ID 
            HydrodynamicID = Me%InstanceID

            STAT_ = SUCCESS_

        else cd0

            STAT_ = UNKNOWN_

        end if cd0

        if (present(STAT)) STAT = STAT_

    !----------------------------------------------------------------------

    end subroutine StartHydrodynamic

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine AllocateInstance

        !Local-----------------------------------------------------------------
        type (T_Hydrodynamic), pointer              :: NewHydrodynamic
        type (T_Hydrodynamic), pointer              :: PreviousHydrodynamic

        !Allocates new instance
        allocate (NewHydrodynamic)
        nullify  (NewHydrodynamic%Next)

        !Insert New Instance into list and makes Current point to it
        if (.not. associated(FirstHydrodynamic)) then
            FirstHydrodynamic         => NewHydrodynamic
            Me                        => NewHydrodynamic
        else
            PreviousHydrodynamic      => FirstHydrodynamic
            Me                        => FirstHydrodynamic%Next
            do while (associated(Me))
                PreviousHydrodynamic  => Me
                Me                    => Me%Next
            enddo
            Me                        => NewHydrodynamic
            PreviousHydrodynamic%Next => NewHydrodynamic
        endif

        Me%InstanceID = RegisterNewInstance (mHYDRODYNAMIC_)


    end subroutine AllocateInstance


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Construct_Hydrodynamic(DischargesID,  AssimilationID)

        !Arguments------------------------------------------------------------- 
        integer             :: DischargesID
        integer             :: AssimilationID
        !Local----------------------------------------------------------------- 
        integer             :: STAT_CALL, iW

        !----------------------------------------------------------------------

        Me%State%Initial = ON
       
        Me%FirstIteration = .true.
       
        call GetHorizontalGridSize(Me%ObjHorizontalGrid,                                &
                                   Size     = Me%Size2D,                                &
                                   WorkSize = Me%WorkSize2D,                            &
                                   STAT     = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Construct_Hydrodynamic - ModuleHydrodynamic - ERR00'


        call GetGeometrySize(Me%ObjGeometry,                                            &
                             Size = Me%Size, WorkSize = Me%WorkSize,                    &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Construct_Hydrodynamic - ModuleHydrodynamic - ERR01'


        call Construct_HydrodynamicTime(  )

    
        call Read_Hydrodynamic_Files_Name(  )

       
        !Construct enter data 
        call ConstructEnterData(Me%ObjEnterData, Me%Files%ConstructData,                &
                                STAT = STAT_CALL) 

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine Construct_Hydrodynamic; Module ModuleHydrodynamic. ERR02.'

        call Construct_Numerical_Options

        call Verify_Numerical_Options   

        call Construct_OutPutTime

        !Opens the HDF 5 file
        if (Me%OutPut%hdf5ON)          call Open_HDF5_OutPut_File

        if (Me%OutW%OutPutWindowsON)  then
            do iW = 1, Me%OutW%WindowsNumber
                call Open_HDF5_OutPut_File(iW)
            enddo
        endif

        !Opens the HDF 5 file for surface outputs
        if (Me%OutPut%HDF5_Surface_ON) call Open_Surface_HDF5_OutPut_File

        call Actualize_HydrodynamicTimeStep

        call InitialHydrodynamicField (DischargesID, AssimilationID) 

        call StartOutputBoxFluxes     

#ifdef OVERLAP
        call ConstructHydroOverlap
#endif OVERLAP

        !Construct the Time Serie Obj
        if (Me%OutPut%TimeSerieON) call Construct_Time_Serie

        if (Me%OutPut%TimeSerieON .or. Me%OutPut%hdf5ON .or. Me%OutPut%ProfileON)       &
            call ConstructMatrixesOutput

        if (Me%OutPut%ProfileON) call Construct_Output_Profile
        
        if (Me%ThinWalls%ON) then
            call ConstructThinWalls
        endif
        

        !call External Modules
        call ReadLock_External_Modules

        !Do the first output
        call Hydrodynamic_OutPut
        
        call ConstructDomainDecomposition

        !call External Modules
        call ReadUnLock_External_Modules

        call KillEnterData(Me%ObjEnterData, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine Construct_Hydrodynamic; Module ModuleHydrodynamic. ERR03.'

        !To let the model take access to the Mapping and geometry variables
        call ReadLock_External_Modules  

        !Call this subroutine to actualize the variabel DUZ_VY 
        !Only this way the subroutine ModifyChezyVelUV nows the 
        !face direction where the chezy coeficient must be compute. 
        !
        call MaintainDirection

        !Initialize bottom boundary (Chezy coefficient is computed for the first time)
!        call Bottom_Boundary            

        !Unget the Mapping and geometry variables
        call ReadUnLock_External_Modules

        Me%State%Initial = OFF


    End Subroutine Construct_Hydrodynamic

    !End----------------------------------------------------------------

    subroutine ConstructDomainDecomposition

#ifdef _USE_MPI

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                             :: GILB, GIUB, GJLB, GJUB, JImin, JImax, STAT_CALL
        integer                             :: AuxHalo
        type (T_Size2D)                     :: Mapping
        !----------------------------------------------------------------------

        write(*,*) 'Construct DD ', Me%DomainDecomposition%MPI_ID

        Me%DomainDecomposition%ON = .true.
        
        !Master_MPI_ID by default is assumed to be MPI_ID = 0
        Me%DomainDecomposition%Master_MPI_ID = 0        

        if (Me%DomainDecomposition%MPI_ID == 0) then
            Me%DomainDecomposition%Master = .true.
        else            
            Me%DomainDecomposition%Master = .false.
        endif
        
        Me%DomainDecomposition%Halo_Points = 2        

        Me%DomainDecomposition%Global%ILB = 1
        Me%DomainDecomposition%Global%IUB = 290
        Me%DomainDecomposition%Global%JLB = 1
        Me%DomainDecomposition%Global%JUB = 241
        
        GILB = Me%DomainDecomposition%Global%ILB - 1
        GIUB = Me%DomainDecomposition%Global%IUB + 1       
        GJLB = Me%DomainDecomposition%Global%JLB - 1
        GJUB = Me%DomainDecomposition%Global%JUB + 1               

        if (Me%DomainDecomposition%Master) then
        
            write(*,*) 'Allocate DD ', Me%DomainDecomposition%MPI_ID        
        
            JImin = min (GILB, GJLB)
            JImax = max (GIUB, GJUB)
            
            write(*,*) 'Allocate DD a', Me%DomainDecomposition%MPI_ID

            allocate (Me%DomainDecomposition%VECG(JImin : JImax), STAT = STAT_CALL)
            allocate (Me%DomainDecomposition%VECW(JImin : JImax), STAT = STAT_CALL)
            
             write(*,*) 'Allocate DD aa', Me%DomainDecomposition%MPI_ID

            Me%DomainDecomposition%VECG(:) = 0
            Me%DomainDecomposition%VECW(:) = 0
            
            write(*,*) 'Allocate DD b', Me%DomainDecomposition%MPI_ID
            
            allocate(Me%DomainDecomposition%Coef)

            allocate (Me%DomainDecomposition%Coef%D    (GILB:GIUB, GJLB:GJUB)) 
            allocate (Me%DomainDecomposition%Coef%E    (GILB:GIUB, GJLB:GJUB)) 
            allocate (Me%DomainDecomposition%Coef%Eaux (GILB:GIUB, GJLB:GJUB))         
            allocate (Me%DomainDecomposition%Coef%F    (GILB:GIUB, GJLB:GJUB)) 
            allocate (Me%DomainDecomposition%Coef%Ti   (GILB:GIUB, GJLB:GJUB)) 
            allocate (Me%DomainDecomposition%Coef%TiAux(GILB:GIUB, GJLB:GJUB)) 
            
            write(*,*) 'Allocate DD c', Me%DomainDecomposition%MPI_ID
            
            Me%DomainDecomposition%Coef%D    (:,:)= 0
            Me%DomainDecomposition%Coef%E    (:,:)= 1
            Me%DomainDecomposition%Coef%Eaux (:,:)= 1
            Me%DomainDecomposition%Coef%F    (:,:)= 0
            Me%DomainDecomposition%Coef%Ti   (:,:)= 0
            Me%DomainDecomposition%Coef%TiAux(:,:)= 0
            
            write(*,*) 'Allocate DD 2', Me%DomainDecomposition%MPI_ID  
            
            allocate (Me%DomainDecomposition%WaterLevel_New(GILB:GIUB, GJLB:GJUB)) 
            
            Me%DomainDecomposition%WaterLevel_New(:,:) = 0.
            
            write(*,*) 'Allocate DD 3', Me%DomainDecomposition%MPI_ID        
        endif
        
        write(*,*) 'Allocate DD 4', Me%DomainDecomposition%MPI_ID  
        
        if      (Me%DomainDecomposition%MPI_ID == 0) then
            Mapping%ILB = 1
            Mapping%IUB = 145
            Mapping%JLB = 1
            Mapping%JUB = 120

            Me%DomainDecomposition%NeighbourSouth = FillValueInt
            Me%DomainDecomposition%NeighbourWest  = FillValueInt
            Me%DomainDecomposition%NeighbourEast  = 1
            Me%DomainDecomposition%NeighbourNorth = 2 
            
        else if (Me%DomainDecomposition%MPI_ID == 1) then
        
            Mapping%ILB = 1 
            Mapping%IUB = 145
            Mapping%JLB = 121
            Mapping%JUB = 241

            Me%DomainDecomposition%NeighbourSouth = FillValueInt
            Me%DomainDecomposition%NeighbourWest  = 0
            Me%DomainDecomposition%NeighbourEast  = FillValueInt
            Me%DomainDecomposition%NeighbourNorth = 3 
        
        else if (Me%DomainDecomposition%MPI_ID == 2) then
        
            Mapping%ILB = 146 
            Mapping%IUB = 290
            Mapping%JLB = 1
            Mapping%JUB = 120

            Me%DomainDecomposition%NeighbourSouth = 0
            Me%DomainDecomposition%NeighbourWest  = FillValueInt
            Me%DomainDecomposition%NeighbourEast  = 3
            Me%DomainDecomposition%NeighbourNorth = FillValueInt

        else if (Me%DomainDecomposition%MPI_ID == 3) then
        
            Mapping%ILB = 146 
            Mapping%IUB = 290
            Mapping%JLB = 121
            Mapping%JUB = 241

            Me%DomainDecomposition%NeighbourSouth = 1
            Me%DomainDecomposition%NeighbourWest  = 2
            Me%DomainDecomposition%NeighbourEast  = FillValueInt
            Me%DomainDecomposition%NeighbourNorth = FillValueInt
        
        endif
        
        write(*,*) 'Allocate DD 5', Me%DomainDecomposition%MPI_ID        
        
        Me%DomainDecomposition%Mapping = Mapping
        
        if (Me%DomainDecomposition%NeighbourSouth /= FillValueInt) then         
            AuxHalo = Me%DomainDecomposition%Halo_Points
        else
            AuxHalo = 0.
        endif
        
        Me%DomainDecomposition%Inner%ILB    = Me%WorkSize%ILB                    + AuxHalo
        Me%DomainDecomposition%HaloMap%ILB  = Me%DomainDecomposition%Mapping%ILB - AuxHalo
        
        write(*,*) 'Allocate DD 6', Me%DomainDecomposition%MPI_ID          
                
        if (Me%DomainDecomposition%NeighbourNorth /= FillValueInt) then         
            AuxHalo = Me%DomainDecomposition%Halo_Points
        else
            AuxHalo = 0.
        endif
        
        Me%DomainDecomposition%Inner%IUB    = Me%WorkSize%IUB                    - AuxHalo
        Me%DomainDecomposition%HaloMap%IUB  = Me%DomainDecomposition%Mapping%IUB + AuxHalo
        
        if (Me%DomainDecomposition%HaloMap%IUB - Me%DomainDecomposition%HaloMap%ILB /=  &
            Me%WorkSize%IUB                    - Me%WorkSize%ILB) then
            
            write(*,*) "Decomposition domains is inconsistent with the grid data input - Lines "
            write(*,*) 'WorkSize ILB,IUB, =',Me%WorkSize%ILB,Me%WorkSize%IUB
            write(*,*) 'HaloMap  ILB,IUB, =',Me%DomainDecomposition%HaloMap%ILB,Me%DomainDecomposition%HaloMap%IUB
            stop "ConstructDomainDecomposition - ModuleHydrodynamic - ERR10"

        endif          
        
        write(*,*) 'Allocate DD 7', Me%DomainDecomposition%MPI_ID  
        
        if (Me%DomainDecomposition%NeighbourWest /= FillValueInt) then         
            AuxHalo = Me%DomainDecomposition%Halo_Points
        else
            AuxHalo = 0.
        endif
        
        Me%DomainDecomposition%Inner%JLB    = Me%WorkSize%JLB                    + AuxHalo
        Me%DomainDecomposition%HaloMap%JLB  = Me%DomainDecomposition%Mapping%JLB - AuxHalo
        
        write(*,*) 'Allocate DD 8', Me%DomainDecomposition%MPI_ID  
                
        if (Me%DomainDecomposition%NeighbourEast /= FillValueInt) then         
            AuxHalo = Me%DomainDecomposition%Halo_Points
        else
            AuxHalo = 0.
        endif
        
        write(*,*) 'Allocate DD 9', Me%DomainDecomposition%MPI_ID          
    
        Me%DomainDecomposition%Inner%JUB   = Me%WorkSize%JUB                     - AuxHalo
        Me%DomainDecomposition%HaloMap%JUB = Me%DomainDecomposition%Mapping%JUB  + AuxHalo
        
        if (Me%DomainDecomposition%HaloMap%JUB - Me%DomainDecomposition%HaloMap%JLB /=  &
            Me%WorkSize%JUB                    - Me%WorkSize%JLB) then
            
            write(*,*) "Decomposition domains is inconsistent with the grid data input - Columns "
            write(*,*) 'WorkSize JLB,JUB, =',Me%WorkSize%JLB,Me%WorkSize%JUB
            write(*,*) 'HaloMap  JLB,JUB, =',Me%DomainDecomposition%HaloMap%JLB,Me%DomainDecomposition%HaloMap%JUB
            stop "ConstructDomainDecomposition - ModuleHydrodynamic - ERR20"

        endif            
        
        
        write(*,*) 'Domains DD ', Me%DomainDecomposition%HaloMap%IUB, &
                    Me%DomainDecomposition%HaloMap%JUB, Me%DomainDecomposition%MPI_ID        

        
        if (Me%DomainDecomposition%Master) then
        
            Me%DomainDecomposition%Nslaves = 3
            
            allocate(Me%DomainDecomposition%Slaves_MPI_ID (Me%DomainDecomposition%Nslaves))
            allocate(Me%DomainDecomposition%Slaves_Inner  (Me%DomainDecomposition%Nslaves))
            allocate(Me%DomainDecomposition%Slaves_Size   (Me%DomainDecomposition%Nslaves))
            allocate(Me%DomainDecomposition%Slaves_Mapping(Me%DomainDecomposition%Nslaves))
            allocate(Me%DomainDecomposition%Slaves_HaloMap(Me%DomainDecomposition%Nslaves))
        
            Me%DomainDecomposition%Slaves_MPI_ID(1) = 1
            Me%DomainDecomposition%Slaves_MPI_ID(2) = 2
            Me%DomainDecomposition%Slaves_MPI_ID(3) = 3
        
        endif
        
        write(*,*) 'End construct DD ', Me%DomainDecomposition%MPI_ID        

#endif _USE_MPI        

    end subroutine ConstructDomainDecomposition

    !End----------------------------------------------------------------


    Subroutine InitialHydrodynamicField(DischargesID, AssimilationID)

        !Arguments-------------------------------------------------------------
        
        integer             :: DischargesID
        integer             :: AssimilationID

        !Local-----------------------------------------------------------------

        integer :: OutputStateEx, STAT_CALL

        !----------------------------------------------------------------------

        if (Me%ComputeOptions%BaroclinicRadia /= NoRadiation_)              &
            call Construct_RadiaBaroclinic

        
        call AllocateVariables


        !This must be called before initial_geometry. Elevation is needed.
        call ConstructHydrodynamicProperties

        if (.not. Me%ComputeOptions%Continuous) call ReadInitialImposedSolution 

        !Guillaume
        if (Me%ComputeOptions%Evolution == Vertical1D_) then
            Me%WaterFluxes%X (:,:,:) = 0.
            Me%WaterFluxes%Y (:,:,:) = 0.
            Me%WaterFluxes%Z (:,:,:) = 0.
            Me%Waterlevel%New(:,:  ) = 0.
        endif

        call Generic4thDimension
    

        call Initial_Geometry


        call Construct_Sub_Modules (DischargesID, AssimilationID) 


        call ReadLock_ModuleMap
        
        call ReadLock_ModuleGeometry
        call ModifyWaterDischarges 
        call ReadUnLock_ModuleGeometry

        !The subroutine StartHydrodynamicFile in RECORDING mode must be called
        !after the Initial_Geometry where the Mapping update is done because 
        !to record the intial field is necessary to have have the Mapping of 
        !the compute points
cd11:   if (Me%ComputeOptions%Recording) then

            call GetHydrodynamicFileIOState(OutputStateEx = OutputStateEx)
            call StartHydrodynamicFile (Me%ObjHydrodynamicFileOut,          &
                                        Me%ObjGridData,                     &
                                        Me%ObjHorizontalGrid,               &
                                        Me%ObjGeometry,                     &
                                        Me%ObjMap,                          &
                                        Me%ObjHorizontalMap,                &
                                        Me%ObjTime,                         &
                                        OutputStateEx,                      &
                                        InitialWaterLevel      =            &
                                        Me%WaterLevel%New,                  &
                                        InitialWaterFluxX      =            &
                                        Me%WaterFluxes%X,                   &
                                        InitialWaterFluxY      =            &
                                        Me%WaterFluxes%Y,                   &
                                        InitialDischarges      =            &
                                        Me%WaterFluxes%Discharges,          &
                                        InitialComputeFacesU3D =            &
                                        Me%External_Var%ComputeFaces3D_U,   &
                                        InitialComputeFacesV3D =            &
                                        Me%External_Var%ComputeFaces3D_V,   &
                                        STAT = STAT_CALL)            

            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine InitialHydrodynamicField; Module ModuleHydrodynamic. ERR01' 

        endif cd11

        call ReadUnLock_ModuleMap

        !PCL - This initial field is only constructed 
        !if the run is new and the user wants to imposed 
        !a flow relaxation scheme OR hydrodynamic field is equal to the residual one (Evolution == Residual_hydrodynamic_)
        call InitialReferenceWaterFluxes

        !PCL - This initial field is only constructed 
        !if the transisent hydrodynamic is read from a file
        call InitialHydrodynamicFileVel

        if (.not. Me%ComputeOptions%Continuous)                             &
            call NewEqualsOld



    End Subroutine InitialHydrodynamicField

    !End----------------------------------------------------------------



   !----------------------------------------------------------------------------

    subroutine Generic4thDimension

        !Arguments-------------------------------------------------------------
        

        !Local-----------------------------------------------------------------
        character(len = StringLength)      :: BeginBlock, EndBlock, Filename
        integer                            :: STAT_CALL, ClientNumber, iflag
        logical                            :: BlockFound

        !----------------------------------------------------------------------


        BeginBlock = "<begin_generic4D>"
        EndBlock   = "<end_generic4D>"

        !Searches for water level 
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                     &
                                     BeginBlock, EndBlock,                              &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Generic4thDimension  - ModuleHydrodynamic - ERR10'

        if (BlockFound) then
            
            Me%Generic4D%ON = .true.

            call GetData(Filename, Me%ObjEnterData, iflag,                              &
                         keyword        = 'FILENAME',                                   &  
                         SearchType     = FromBlock,                                    &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         default        = "******.***",                                 &
                         STAT           = STAT_CALL)            
            if (STAT_CALL /= SUCCESS_) stop 'Generic4thDimension  - ModuleHydrodynamic - ERR20'
            if (iflag == 0) stop 'Generic4thDimension  - ModuleHydrodynamic - ERR30'

            call GetData(Me%Generic4D%TimeSerieColumn, Me%ObjEnterData, iflag,          &
                         keyword        = 'TIME_SERIE_COLUMN',                          &  
                         SearchType     = FromBlock,                                    &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         default        = 2,                                            &
                         STAT           = STAT_CALL)            
            if (STAT_CALL /= SUCCESS_) stop 'Generic4thDimension  - ModuleHydrodynamic - ERR40'

            !Starts Time Serie
            call StartTimeSerieInput(Me%Generic4D%ObjTimeSerie,                         &
                                     FileName,                                          &
                                     Me%ObjTime,                                        &
                                     STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Generic4thDimension - ModuleFillMatrix - ERR50'


#ifndef _WAVES_

            Me%Generic4D%CurrentValue = TimeSerieValue(Me%Generic4D%ObjTimeSerie,       &
                                                       Me%CurrentTime,                  &
                                                       Me%Generic4D%TimeSerieColumn) 

            call SetGeneric4DValues(Me%ObjWaves, Me%Generic4D%CurrentValue, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                      &
                stop 'Generic4thDimension - ModuleHydrodynamic - ERR60'
#endif 

        else 

            Me%Generic4D%ON = .false.

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Generic4thDimension  - ModuleHydrodynamic - ERR70'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'Generic4thDimension  - ModuleHydrodynamic - ERR80'


     end subroutine Generic4thDimension
   !----------------------------------------------------------------------------

    subroutine ReadInitialImposedSolution 

        !Arguments-------------------------------------------------------------
        

        !Local-----------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Matrix3D
        integer, dimension(:,:,:), pointer :: PointsToFill3D
        character(len = StringLength)      :: BeginBlock, EndBlock, Char_TypeZUV
        integer                            :: STAT_CALL, ClientNumber, i, j, k, iflag 
        logical                            :: BlockFound
        real                               :: MinWaterColumn
        real,    dimension(:,:),   pointer :: Bathymetry
        
        !----------------------------------------------------------------------


        BeginBlock = "<begin_waterlevel>"
        EndBlock   = "<end_waterlevel>"

        !Searches for water level 
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                     &
                                     BeginBlock, EndBlock,                              &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR10'

        Me%WaterLevel%InitalizedByFile = BlockFound

        if (BlockFound) then

            !Gets WaterPoints2D
            call GetWaterPoints2D(Me%ObjHorizontalMap,                                  &
                                  Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR20'

            call ConstructPropertyID  (Me%WaterLevel%ID, Me%ObjEnterData, FromBlock)

            call ConstructFillMatrix  (PropertyID           = Me%WaterLevel%ID,             &
                                       EnterDataID          = Me%ObjEnterData,              &
                                       TimeID               = Me%ObjTime,                   &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,         &
                                       ExtractType          = FromBlock,                    &
                                       PointsToFill2D       = Me%External_Var%WaterPoints2D,&
                                       Matrix2D             = Me%WaterLevel%New,            &
                                       TypeZUV              = TypeZ_,                       &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR30'
            
            Me%WaterLevel%New (:,:) = Me%WaterLevel%New (:,:) / Me%OutPut%WaterLevelUnits            

            if(.not. Me%WaterLevel%ID%SolutionFromFile)then
            
                call GetGeometryMinWaterColumn(Me%ObjGeometry, MinWaterColumn, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR40'
                
                call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR41'

                do  j=Me%WorkSize%JLB, Me%WorkSize%JUB
                do  i=Me%WorkSize%ILB, Me%WorkSize%IUB
                        
                    if (Me%External_Var%WaterPoints2D(i, j) == WaterPoint) then
                    
                        if (Me%WaterLevel%New(i,j) < (- Bathymetry(i, j) + 0.999 * MinWaterColumn)) then
                            Me%WaterLevel%New(i,j) =  - Bathymetry(i, j) + 0.999 * MinWaterColumn
                        endif 

                        Me%WaterLevel%Old(i, j) = Me%WaterLevel%New(i, j)

                    endif

                enddo
                enddo
                
                call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR41'

                call KillFillMatrix(Me%WaterLevel%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR50'
                
            end if
            
            !UnGets WaterPoints2D
            call UnGetHorizontalMap(Me%ObjHorizontalMap,                                &                      
                                    Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR61'


        else 
            if (Me%ComputeOptions%Evolution == ImposedSolution_) then
                write(*,*) 'Block not found'
                write(*,*) 'Begin = ',trim(BeginBlock)
                write(*,*) 'End   = ',trim(EndBlock)
                stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR60'
            endif

        endif
        


        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR70'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR80'

        call Initial_Geometry


        !Module - ModuleMap
        !3D Mapping Properties
        call GetComputeFaces3D(Me%ObjMap,                                               &
                               ComputeFacesU3D = Me%External_Var%ComputeFaces3D_U,      &
                               ComputeFacesV3D = Me%External_Var%ComputeFaces3D_V,      &
                               STAT            = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR90'

        call GetOpenPoints3D(Me%ObjMap, Me%External_Var%OpenPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR100'

        BeginBlock = "<begin_velocity_u>"
        EndBlock   = "<end_velocity_u>"

        !Searches for velocity u
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                     &
                                     BeginBlock, EndBlock,                              &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR110'

        if (BlockFound) then

            call ConstructPropertyID  (Me%Velocity%Horizontal%U%ID, Me%ObjEnterData, FromBlock)

            call GetData(Char_TypeZUV, Me%ObjEnterData, iflag,                          &
                         keyword        = 'TYPE_ZUV',                                   &  
                         SearchType     = FromBlock,                                    &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         default        = "Z",                                          &
                         STAT           = STAT_CALL)            
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR120'

            Me%Velocity%Horizontal%U%InTypeZUV = TranslateTypeZUV(Char_TypeZUV)

            if      (Me%Velocity%Horizontal%U%InTypeZUV == TypeU_) then
            
                PointsToFill3D => Me%External_Var%ComputeFaces3D_U
                Matrix3D       => Me%Velocity%Horizontal%U%New

            else if (Me%Velocity%Horizontal%U%InTypeZUV == TypeZ_) then

                PointsToFill3D => Me%External_Var%OpenPoints3D
                
                allocate (Matrix3D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB,Me%Size%KLB:Me%Size%KUB))
                Matrix3D(:,:,:) = FillValueReal

            else if (Me%Velocity%Horizontal%U%InTypeZUV == TypeV_) then

                stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR130'

            else

                stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR140'

            endif

            !Uncovered cells are set to zero
            call ConstructFillMatrix  (PropertyID           = Me%Velocity%Horizontal%U%ID,      &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       GeometryID           = Me%ObjGeometry,                   &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill3D       = PointsToFill3D,                   &
                                       Matrix3D             = Matrix3D,                         &
                                       TypeZUV              = Me%Velocity%Horizontal%U%InTypeZUV,&
                                       FillMatrix           = 0.,                               &             
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR150'

            if (Me%Velocity%Horizontal%U%InTypeZUV == TypeZ_) then

                Me%Velocity%Horizontal%U%New(:,:,:) = 0.

                do k = Me%WorkSize%KLB,Me%WorkSize%KUB
                do j = Me%WorkSize%JLB,Me%WorkSize%JUB
                do i = Me%WorkSize%ILB,Me%WorkSize%IUB
                    
                    if (PointsToFill3D(i,j-1,k) == OpenPoint .and.                      &
                        PointsToFill3D(i,j  ,k) == OpenPoint) then
                        Me%Velocity%Horizontal%U%New(i,j,k) = (Matrix3D(i,j-1,k) + Matrix3D(i,j,k)) / 2.
                    endif

                enddo
                enddo
                enddo

                deallocate(Matrix3D)

            endif

            nullify   (PointsToFill3D)
            nullify   (Matrix3D)

            if(.not. Me%Velocity%Horizontal%U%ID%SolutionFromFile)then
                
                call KillFillMatrix(Me%Velocity%Horizontal%U%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR160'
            end if

        else

            if (Me%ComputeOptions%Evolution == ImposedSolution_) then
                write(*,*) 'Block not found'
                write(*,*) 'Begin = ',trim(BeginBlock)
                write(*,*) 'End   = ',trim(EndBlock)
                stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR170'
            endif

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR180'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR190'



        BeginBlock = "<begin_velocity_v>"
        EndBlock   = "<end_velocity_v>"

        !Searches for velocity v
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR200'

        if (BlockFound) then

            call ConstructPropertyID  (Me%Velocity%Horizontal%V%ID, Me%ObjEnterData, FromBlock)

            call GetData(Char_TypeZUV, Me%ObjEnterData, iflag,                          &
                         keyword        = 'TYPE_ZUV',                                   &  
                         SearchType     = FromBlock,                                    &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         default        = "Z",                                          &
                         STAT           = STAT_CALL)            
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR210'

            Me%Velocity%Horizontal%V%InTypeZUV = TranslateTypeZUV(Char_TypeZUV)

            if      (Me%Velocity%Horizontal%V%InTypeZUV == TypeV_) then
            
                PointsToFill3D => Me%External_Var%ComputeFaces3D_V
                Matrix3D       => Me%Velocity%Horizontal%V%New

            else if (Me%Velocity%Horizontal%V%InTypeZUV == TypeZ_) then

                PointsToFill3D => Me%External_Var%OpenPoints3D
                
                allocate (Matrix3D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB,Me%Size%KLB:Me%Size%KUB))
                Matrix3D(:,:,:) = FillValueReal

            else if (Me%Velocity%Horizontal%V%InTypeZUV == TypeU_) then

                stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR220'

            else

                stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR230'

            endif


            !Uncovered cells are set to zero
            call ConstructFillMatrix  (PropertyID           = Me%Velocity%Horizontal%V%ID,      &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       GeometryID           = Me%ObjGeometry,                   &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill3D       = PointsToFill3D,                   &
                                       Matrix3D             = Matrix3D,                         &
                                       TypeZUV              = Me%Velocity%Horizontal%V%InTypeZUV,&
                                       FillMatrix           = 0.,                               &             
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR240'

            if (Me%Velocity%Horizontal%V%InTypeZUV == TypeZ_) then

                Me%Velocity%Horizontal%V%New(:,:,:) = 0.

                do k = Me%WorkSize%KLB,Me%WorkSize%KUB
                do j = Me%WorkSize%JLB,Me%WorkSize%JUB
                do i = Me%WorkSize%ILB,Me%WorkSize%IUB
                    
                    if (PointsToFill3D(i-1,j,k) == OpenPoint .and.                       &
                        PointsToFill3D(i  ,j,k) == OpenPoint) then
                        Me%Velocity%Horizontal%V%New(i,j,k) = (Matrix3D(i-1,j,k) + Matrix3D(i,j,k)) / 2.
                    endif

                enddo
                enddo
                enddo

                deallocate(Matrix3D)

            endif

            nullify   (PointsToFill3D)
            nullify   (Matrix3D)

            if(.not. Me%Velocity%Horizontal%V%ID%SolutionFromFile)then
                
                call KillFillMatrix(Me%Velocity%Horizontal%V%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR250'
            end if

        else

            if (Me%ComputeOptions%Evolution == ImposedSolution_) then

                write(*,*) 'Block not found'
                write(*,*) 'Begin = ',trim(BeginBlock)
                write(*,*) 'End   = ',trim(EndBlock)
                stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR260'

            endif

        endif


        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR270'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR280'
        

        call GetGeometryAreas(Me%ObjGeometry,                 &
                              AreaU = Me%External_Var%Area_U, &
                              AreaV = Me%External_Var%Area_V, &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR290'
        
dok1:   do k = Me%WorkSize%KLB,Me%WorkSize%KUB        
doj1:   do j = Me%WorkSize%JLB,Me%WorkSize%JUB
doi1:   do i = Me%WorkSize%ILB,Me%WorkSize%IUB

Cov1:       if (Me%External_Var%ComputeFaces3D_U(I, J, K) == Covered) then

                    Me%WaterFluxes%X(i, j, k) = dble(Me%Velocity%Horizontal%U%New(i,j,k)) * &
                                                dble(Me%External_Var%Area_U      (i,j,k))
            endif Cov1
            
        enddo doi1
        enddo doj1        
        enddo dok1


dok2:   do k = Me%WorkSize%KLB,Me%WorkSize%KUB        
doj2:   do j = Me%WorkSize%JLB,Me%WorkSize%JUB
doi2:   do i = Me%WorkSize%ILB,Me%WorkSize%IUB

Cov2:       if ( Me%External_Var%ComputeFaces3D_V(I, J, K) == Covered) then

                    Me%WaterFluxes%Y(i, j, k) = dble(Me%Velocity%Horizontal%V%New(i,j,k)) * &
                                                dble(Me%External_Var%Area_V      (i,j,k))
            endif Cov2
            
        enddo doi2
        enddo doj2        
        enddo dok2        
        
        !Module - ModuleMap
        !3D Mapping Properties
        call UnGetMap(Me%ObjMap, Me%External_Var%ComputeFaces3D_U,                       &
                      STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR300'

        call UnGetMap(Me%ObjMap, Me%External_Var%ComputeFaces3D_V,                       &
                      STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR310'

        call UnGetMap(Me%ObjMap, Me%External_Var%OpenPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR320'

        call UnGetGeometry(Me%ObjGeometry, Me%External_Var%Area_U, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR330'

        call UnGetGeometry(Me%ObjGeometry, Me%External_Var%Area_V, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'ReadInitialImposedSolution  - ModuleHydrodynamic - ERR340'


    end subroutine ReadInitialImposedSolution 


    subroutine ConstructDragCoefficients

        !Local-----------------------------------------------------------------
        character(len = StringLength)           :: BeginBlock, EndBlock
        integer                                 :: STAT_CALL, ClientNumber
        logical                                 :: BlockFound

        !----------------------------------------------------------------------
 
        call GetWaterPoints3D(Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) stop 'StartOutputBoxFluxes - ModuleHydrodynamic - ERR01'

        BeginBlock = "<begin_dragcoef>"
        EndBlock   = "<end_dragcoef>"

        !Searches for drag coefficients block
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR01'

        if (BlockFound) then

            call ConstructPropertyID  (Me%Drag%ID, Me%ObjEnterData, FromBlock)

            !Uncovered cells are set to zero
            call ConstructFillMatrix  (PropertyID           = Me%Drag%ID,                       &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       GeometryID           = Me%ObjGeometry,                   &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill3D       = Me%External_Var%WaterPoints3D,    &
                                       Matrix3D             = Me%Drag%Coef,                     &
                                       TypeZUV              = TypeZ_,                           &
                                       FillMatrix           = 0.,                               &             
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR08'

            if(.not. Me%Drag%ID%SolutionFromFile)then
                
                call KillFillMatrix(Me%Drag%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR10'
            end if

        else

            write(*,*) 'Block not found'
            write(*,*) 'Begin = ',trim(BeginBlock)
            write(*,*) 'End   = ',trim(EndBlock)
            stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR11'

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR12'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR13'
        
        call UnGetMap (Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR14'


    end subroutine ConstructDragCoefficients

    !-----------------------------------------------------------------------------------

    subroutine ConstructScraper

        !Local-----------------------------------------------------------------
        character(len = StringLength)           :: BeginBlock, EndBlock
        integer                                 :: STAT_CALL, ClientNumber
        logical                                 :: BlockFound

        !----------------------------------------------------------------------
        
        
        Me%Scraper%UOn            = .false.
        Me%Scraper%VOn            = .false.
        Me%Scraper%WOn            = .false.
        
        !call GetData

        call GetWaterPoints3D(Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR10'

        BeginBlock = "<begin_scraper_u>"
        EndBlock   = "<end_scraper_u>"
        
        allocate(Me%Scraper%Position(Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB, Me%Size%KLB:Me%Size%KUB))
        
        Me%Scraper%Position(:,:,:) = Me%External_Var%WaterPoints3D(:,:,:)

        !Searches for drag coefficients block
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR20'

        if (BlockFound) then
        
            Me%Scraper%UOn            = .true.

            call ConstructPropertyID  (Me%Scraper%ID_U, Me%ObjEnterData, FromBlock)
            
            allocate(Me%Scraper%VelU(Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB, Me%Size%KLB:Me%Size%KUB))

            !Uncovered cells are set to zero
            call ConstructFillMatrix  (PropertyID           = Me%Scraper%ID_U,                  &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       GeometryID           = Me%ObjGeometry,                   &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill3D       = Me%External_Var%WaterPoints3D,    &
                                       Matrix3D             = Me%Scraper%VelU,                  &
                                       TypeZUV              = TypeU_,                           &
                                       FillMatrix           = FillValueReal,                    &             
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR30'

            if(.not. Me%Scraper%ID_U%SolutionFromFile)then
                
                call KillFillMatrix(Me%Scraper%ID_U%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR40'
            end if

        else

            write(*,*) 'Block not found'
            write(*,*) 'Begin = ',trim(BeginBlock)
            write(*,*) 'End   = ',trim(EndBlock)
            stop 'ConstructScraper - ModuleHydrodynamic - ERR50'

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR60'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR70'
        
        
        BeginBlock = "<begin_scraper_v>"
        EndBlock   = "<end_scraper_v>"

        !Searches for drag coefficients block
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR80'

        if (BlockFound) then
        
            Me%Scraper%VOn            = .true.            

            call ConstructPropertyID  (Me%Scraper%ID_V, Me%ObjEnterData, FromBlock)
            
            allocate(Me%Scraper%VelV(Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB, Me%Size%KLB:Me%Size%KUB))            

            !Uncovered cells are set to zero
            call ConstructFillMatrix  (PropertyID           = Me%Scraper%ID_V,                  &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       GeometryID           = Me%ObjGeometry,                   &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill3D       = Me%External_Var%WaterPoints3D,    &
                                       Matrix3D             = Me%Scraper%VelV,                  &
                                       TypeZUV              = TypeV_,                           &
                                       FillMatrix           = FillValueReal,                    &             
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR90'

            if(.not. Me%Scraper%ID_V%SolutionFromFile)then
                
                call KillFillMatrix(Me%Scraper%ID_V%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR100'
            end if

        else

            write(*,*) 'Block not found'
            write(*,*) 'Begin = ',trim(BeginBlock)
            write(*,*) 'End   = ',trim(EndBlock)
            stop 'ConstructScraper - ModuleHydrodynamic - ERR110'

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR120'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR130'
        
        call UnGetMap (Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR140'


    end subroutine ConstructScraper

    !-----------------------------------------------------------------------------------

    subroutine ConstructThinWalls

        !Local-----------------------------------------------------------------
        integer, dimension(3)                   :: Cell
        character(len = PathLength  )           :: TimeSerieFile
        character(len = StringLength)           :: BeginBlock, EndBlock
        integer                                 :: STAT_CALL, ClientNumber
        integer                                 :: FirstLine, LastLine, n, l, iflag
        logical                                 :: BlockFound
        type(T_Time)                            :: Time1, Time2
        real                                    :: Value1, Value2
        logical                                 :: TimeCycle        

        !----------------------------------------------------------------------
        
        Me%ThinWalls%UOn = .false.
        Me%ThinWalls%Nu  = FillValueInt

        Me%ThinWalls%VOn = .false.
        Me%ThinWalls%Nv  = FillValueInt

        Me%ThinWalls%WOn = .false.
        Me%ThinWalls%Nw  = FillValueInt

        BeginBlock = "<begin_thinwalls_u>"
        EndBlock   = "<end_thinwalls_u>"
        
        !Searches for drag coefficients block
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, FirstLine, LastLine, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR10'
        
        if (BlockFound) then
        
            Me%ThinWalls%UOn = .true.
            
            Me%ThinWalls%Nu  = LastLine - FirstLine - 1
            
            allocate(Me%ThinWalls%FaceU_I(Me%ThinWalls%Nu))
            allocate(Me%ThinWalls%FaceU_J(Me%ThinWalls%Nu))
            allocate(Me%ThinWalls%FaceU_K(Me%ThinWalls%Nu))
            
d1:         do l = FirstLine+1, LastLine-1

                call GetData(Cell, Me%ObjEnterData, iflag, Buffer_Line  = l, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) then
                    stop 'ConstructThinWalls - ModuleHydrodynamic - ERR20'
                endif                    
                    
                if (iflag /= 3) then                    
                    stop 'ConstructThinWalls - ModuleHydrodynamic - ERR30'
                endif
                
                n = l - FirstLine

                Me%ThinWalls%FaceU_I(n) = cell(1)
                Me%ThinWalls%FaceU_J(n) = cell(2)
                Me%ThinWalls%FaceU_K(n) = cell(3)
                
            enddo d1
                            
        else

            write(*,*) 'Block not found'
            write(*,*) 'Begin = ',trim(BeginBlock)
            write(*,*) 'End   = ',trim(EndBlock)

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR40'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR50'


        BeginBlock = "<begin_thinwalls_v>"
        EndBlock   = "<end_thinwalls_v>"
        
        !Searches for drag coefficients block
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, FirstLine, LastLine, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR60'
        
        if (BlockFound) then
        
            Me%ThinWalls%VOn = .true.
            
            Me%ThinWalls%Nv  = LastLine - FirstLine - 1
            
            allocate(Me%ThinWalls%FaceV_I(Me%ThinWalls%Nv))
            allocate(Me%ThinWalls%FaceV_J(Me%ThinWalls%Nv))
            allocate(Me%ThinWalls%FaceV_K(Me%ThinWalls%Nv))
            
d2:         do l = FirstLine+1, LastLine-1

                call GetData(Cell, Me%ObjEnterData, iflag, Buffer_Line  = l, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) then
                    stop 'ConstructThinWalls - ModuleHydrodynamic - ERR70'
                endif                    
                    
                if (iflag /= 3) then                    
                    stop 'ConstructThinWalls - ModuleHydrodynamic - ERR80'
                endif
                
                n = l - FirstLine

                Me%ThinWalls%FaceV_I(n) = cell(1)
                Me%ThinWalls%FaceV_J(n) = cell(2)
                Me%ThinWalls%FaceV_K(n) = cell(3)
                
            enddo d2
                            
        else

            write(*,*) 'Block not found'
            write(*,*) 'Begin = ',trim(BeginBlock)
            write(*,*) 'End   = ',trim(EndBlock)

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR90'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR100'


        BeginBlock = "<begin_thinwalls_w>"
        EndBlock   = "<end_thinwalls_w>"
        
        !Searches for drag coefficients block
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, FirstLine, LastLine, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR110'
        
        if (BlockFound) then
        
            Me%ThinWalls%WOn = .true.
            
            Me%ThinWalls%Nw  = LastLine - FirstLine - 1
            
            allocate(Me%ThinWalls%FaceW_I(Me%ThinWalls%Nw))
            allocate(Me%ThinWalls%FaceW_J(Me%ThinWalls%Nw))
            allocate(Me%ThinWalls%FaceW_K(Me%ThinWalls%Nw))
            
d3:         do l = FirstLine+1, LastLine-1

                call GetData(Cell, Me%ObjEnterData, iflag, Buffer_Line  = l, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) then
                    stop 'ConstructThinWalls - ModuleHydrodynamic - ERR120'
                endif                    
                    
                if (iflag /= 3) then                    
                    stop 'ConstructThinWalls - ModuleHydrodynamic - ERR130'
                endif
                
                n = l - FirstLine

                Me%ThinWalls%FaceW_I(n) = cell(1)
                Me%ThinWalls%FaceW_J(n) = cell(2)
                Me%ThinWalls%FaceW_K(n) = cell(3)
                
            enddo d3
                            
        else

            write(*,*) 'Block not found'
            write(*,*) 'Begin = ',trim(BeginBlock)
            write(*,*) 'End   = ',trim(EndBlock)

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR140'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR150'
        
        call GetData(Me%ThinWalls%VariableInTime,                                       & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'THIN_WALLS_VARIABLE',                                &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR160'

        if (Me%ThinWalls%VariableInTime) then

            call GetData(TimeSerieFile,                                                 & 
                         Me%ObjEnterData, iflag,                                        & 
                         Keyword    = 'THIN_WALLS_TIME_SERIE',                          &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)          
            if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR170'
            

            !Starts Time Serie
            call StartTimeSerieInput(Me%ThinWalls%ObjTimeSerie,                         &
                                     TimeSerieFile,                                     &
                                     Me%ObjTime,                                        &
                                     STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR180'

            call GetData(Me%ThinWalls%GradWL_Limit,                                     & 
                         Me%ObjEnterData, iflag,                                        & 
                         Keyword    = 'WATER_LEVEL_GRAD_LIMIT',                         &
                         !units = water level gradient [m/m]
                         Default    = 0.001,                                            &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)       
            if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR190'
            

            allocate(Me%Forces%ThinWalls_Dissipation(Me%Size%ILB:Me%Size%IUB,           &
                                          Me%Size%JLB:Me%Size%JUB,                      &
                                          Me%Size%KLB:Me%Size%KUB))
                    
            Me%Forces%ThinWalls_Dissipation(:,:,:) = 0.                             

            call GetData(Me%ThinWalls%CloseFlagColumn,                                  & 
                         Me%ObjEnterData, iflag,                                        & 
                         Keyword    = 'TIME_FLAG_COLUMN',                               &
                         Default    = 2,                                                &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)       
            if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR200'


            !Gets Value for current Time
            call GetTimeSerieValue (Me%ThinWalls%ObjTimeSerie, Me%CurrentTime,          &
                                    Me%ThinWalls%CloseFlagColumn,                       &
                                    Time1, Value1, Time2, Value2, TimeCycle,            &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR210'       

            if (Value1 == 1. .and. Value2 == 1) then                
                Me%ThinWalls%CloseFlag = 1
            else
                Me%ThinWalls%CloseFlag = 0
            endif
            
        else
        
            Me%ThinWalls%CloseFlag = 1
            
        endif   
        
                          


    end subroutine ConstructThinWalls



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : ASCII data                                                                   !
    ! OutPut: Time                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Construct_HydrodynamicTime 
                      
        !Arguments-----------------------------------------------------------------
           

        !Local---------------------------------------------------------------------
        type (T_Time)   :: CurrentTime, EndTime, BeginTime
        integer         :: STAT_CALL

        !Begin---------------------------------------------------------------------

        call GetComputeCurrentTime(Me%ObjTime, CurrentTime, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) &
            stop 'Sub. Construct_HydrodynamicTime - ModuleHydrodynamic - ERR10'


        call GetComputeTimeLimits(Me%ObjTime, BeginTime = BeginTime, &
                                  EndTime = EndTime, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) &
            stop 'Sub. Construct_HydrodynamicTime - ModuleHydrodynamic - ERR20'


        Me%BeginTime   = BeginTime

        Me%CurrentTime = CurrentTime

        Me%EndTime     = EndTime
        

        ! Check if the simulation goes backward in time or forward in time (default mode)
        call GetBackTracking(Me%ObjTime, Me%External_Var%BackTracking, STAT = STAT_CALL)                    
        if (STAT_CALL /= SUCCESS_) &
            stop 'Sub. Construct_HydrodynamicTime - ModuleHydrodynamic - ERR20'


    End Subroutine Construct_HydrodynamicTime

    !End-----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : ASCII data                                                                   !
    ! OutPut: Time                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Actualize_HydrodynamicTimeStep 
                      
        !Arguments-----------------------------------------------------------------
           
        


        !Local---------------------------------------------------------------------
        real            :: DT_Model
        integer         :: Num_Discretization, STAT_CALL, Evolution
        real            :: TimePeriod, DT_RunPeriod

        !Begin---------------------------------------------------------------------
        call GetComputeTimeStep(Me%ObjTime, DT_Model, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) &
            stop 'Sub. Actualize_HydrodynamicTime - ModuleHydrodynamic - Error01'

        Evolution = Me%ComputeOptions%Evolution

cd1:    if (Evolution == Solve_Equations_) then 

            ! Calculate the Atmospheric RAMP coef
            ! Coef(x) = ( Tanh ( ( 2 x / T - 1 ) * Pi ) + 1 ) / 2
            ! A funcao Coef(x) no intervalo [0 infinity[ vale Coef(0) = 0, Coef(T) = 1 
            ! e Coef ( infinity ) = 1. E uma funcao tangente hiperbolica re-escalada.
            !
            if (Me%ComputeOptions%AtmosphereRAMP) then
                
                TimePeriod = Me%ComputeOptions%AtmospherePeriod

                DT_RunPeriod = Me%CurrentTime - Me%BeginTime

                TimePeriod = 2 * DT_RunPeriod / TimePeriod - 1

                TimePeriod = TimePeriod * Pi

                Me%ComputeOptions%AtmosphereCoef = 0.5 * ( tanh( TimePeriod ) + 1 ) 

            endif

            Num_Discretization      = Me%ComputeOptions%Num_Discretization
        
            if (Num_Discretization == Leendertse) then 

                Me%Velocity%DT = DT_Model ! 6 equations - velocities compute every DT

            else if (Num_Discretization == Abbott) then 

                Me%Velocity%DT = 2 * DT_Model    ! 4 equations - velocities compute every 2 * DT

            endif

            Me%WaterLevel%DT = DT_Model          ! In both numerical discretizations elevations are compute every DT

        else

            Me%WaterLevel%DT = DT_Model

            Me%Velocity%DT   = DT_Model

        endif cd1

    End Subroutine Actualize_HydrodynamicTimeStep

    !End-----------------------------------------------------------------------

    !--------------------------------------------------------------------------
    !Read the name of the files need to construct and modify
    ! the hydrodynamic properties 

    subroutine Read_Hydrodynamic_Files_Name

        !Arguments-------------------------------------------------------------




        !External--------------------------------------------------------------

        integer :: STAT_CALL 

        character(len = StringLength) :: Message
        character(len = PathLength)   :: RootPath

        logical :: exist

        !----------------------------------------------------------------------


        ! ---> ASCII file used to construct a new hydrodynamic
        Message   ='ASCII file used to construct a new hydrodynamic.'
        Message   = trim(Message)

        call ReadFileName('IN_DAD3D', Me%Files%ConstructData, &
                           Message = Message, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine Read_Hydrodynamic_Files_Name; Module ModuleHydrodynamic. ERR02.' 


        inquire(FILE   = Me%Files%ConstructData,                   &
                EXIST  = exist,                                                 &
                IOSTAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                            &
            stop 'Subroutine Read_Hydrodynamic_Files_Name; Module ModuleHydrodynamic. ERR02a.' 
        if (.NOT. exist)                                                        &
            stop 'Subroutine Read_Hydrodynamic_Files_Name; Module ModuleHydrodynamic. ERR02b.' 



        ! ---> File in HDF format where is written instant fields of hydrodynamic properties
        Message   ='Instant fields of hydrodynamic properties in HDF format.'
        Message   = trim(Message)

        call ReadFileName('OUT_DESF', Me%Files%OutPutFields,          &
                           Message = Message, TIME_END = Me%EndTime, &
                           Extension = 'hyt', STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                  &
            stop 'Subroutine Read_Hydrodynamic_Files_Name; Module ModuleHydrodynamic. ERR03.' 



        ! ---> hydrodynamic properties final values in HDF format
        Message   ='Hydrodynamic properties final values in HDF format.'
        Message   = trim(Message)

        call ReadFileName('OUT_FIN', Me%Files%FinalHydrodynamic,     &
                           Message = Message, TIME_END = Me%EndTime, &
                           Extension = 'hyf', STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                &
            stop 'Subroutine Read_Hydrodynamic_Files_Name; Module ModuleHydrodynamic. ERR04.' 



        ! ---> Hydrodynamic properties initial values in HDF format
        Message   ='Water properties initial values in HDF format.'
        Message   = trim(Message)

        call ReadFileName('IN_CNDI', Me%Files%InitialHydrodynamic,          &
                           Message = Message, TIME_END = Me%BeginTime,      &
                           STAT = STAT_CALL)
cd1 :   if      (STAT_CALL .EQ. FILE_NOT_FOUND_ERR_   ) then

            stop 'Subroutine Read_Hydrodynamic_Files_Name; Module ModuleHydrodynamic. ERR06'

        else if (STAT_CALL .EQ. KEYWORD_NOT_FOUND_ERR_) then


!This message just confuses the user. 
!
!            write(*,*)  
!            write(*,*) 'Keyword for the inicial file not found in nomfich.dat. '
!            write(*,*) 'Subroutine Read_Hydrodynamic_Files_Name; Module ModuleHydrodynamic. WRN01'
!            write(*,*) 
 
            call SetError(WARNING_, KEYWORD_, 'Keyword IN_CNDI not found - ModuleHydrodynamic', &
                          Screen = .false.)

        else if (STAT_CALL .EQ. SUCCESS_              ) then

            continue

        else

            write(*,*) 
            write(*,*) 'Error calling ReadFileName. '
            stop       'Subroutine Read_Hydrodynamic_Files_Name; Module ModuleHydrodynamic. ERR05.' 
        end if cd1  
                                                                             
        ! ---> File where to store the energy evolution of the system
        Message   ='System Energy result file'
        Message   = trim(Message)



        call ReadFileName("ROOT_SRT", RootPath, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            call ReadFileName("ROOT", RootPath, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                call ReadFileName("RAIZ", RootPath, STAT = STAT_CALL)
                stop 'Subroutine Read_Hydrodynamic_Files_Name; Module ModuleHydrodynamic. ERR06.' 
            endif
        endif

        Me%Files%Energy = trim(adjustl(RootPath))//"TotalEnergy.dat"


        !----------------------------------------------------------------------

    end subroutine Read_Hydrodynamic_Files_Name

    !End--------------------------------------------------------------------------

    Subroutine Construct_Numerical_Options

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type(T_PropertyID) :: GenericID

        integer :: FromFile
        integer :: STAT_CALL, iflag, BarotropicRadia, SIMPLE_GEOG, GEOG, ICOORD_TIP

        logical :: Baroclinic, Continuous_Compute, Compute_Tide,                         &
                   WaterDischarges, Residual,                                            &
                   Coriolis,                                                             &
                   BoundaryBaroclinic, Energy, VolumeVariation,                          &
                   HorizontalAdvection, HorizontalDiffusion,                             &
                   BaroclinicRamp, VerticalAdvection,                                    &
                   VerticalDiffusion, NullBoundaryHorAdv,                                &
                   ComputeTidePotential,                                                 &
                   ComputeAtmPressure, ComputeSurfaceWaterFlux,                          &
                   Relaxation, Geost_Initialization,                                     &
                   InitialElevation, AtmosphereRAMP, Level_Bottom_Anomaly,               &
                   DefaultAux
        integer :: ComputeAtmPressureType

        real    :: UpStream_CenterDif
        real    :: ImplicitVertAdvection
        real    :: ImplicitVertDiffusion
        real    :: Num_Discretization
        real    :: MinLeavingVelocity, MinLeavingComponent
        real    :: InitialElevationValue, InitialVelocityU, InitialVelocityV
        real(8) :: EnteringWaveDirection

        real    :: Hmin_Chezy, Vmin_Chezy, Hmin_Advection

        real    :: InertialPeriods, AtmospherePeriod

        real    :: TideSlowStartCoef, SmoothInitialPeriod, DT_Model
        
        integer :: VelTangentialBoundary, VelNormalBoundary, ComputeWind

        integer :: ClientNumber, WorkKUB, AuxInt

        character(LEN = StringLength)  :: BeginBlock, EndBlock, String
        
        logical :: BlockFound

        !Begin-----------------------------------------------------------------
        
       
        call GetExtractType(FromFile = FromFile)

        WorkKUB = Me%WorkSize%KUB

        !<BeginKeyword>
            !Keyword          : BAROCLINIC
            !<BeginDescription>       
               ! 
               ! Checks if the user pretends to compute the baroclinic pressure
               ! 
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Baroclinic,                                                        &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'BAROCLINIC',                                         &
                     Default    = .false.,                                              &                                           
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR10') 


        Me%ComputeOptions%Baroclinic = Baroclinic

        !<BeginKeyword>
            !Keyword          : CONTINUOUS
            !<BeginDescription>       
               ! 
               ! Checks if the user pretends to continue a old run 
               ! 
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>



        call GetData(Continuous_Compute,                                                &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'CONTINUOUS',                                         &
                     Default    = .false.,                                              &                                           
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR20.')

        Me%ComputeOptions%Continuous = Continuous_Compute


        !<BeginKeyword>
            !Keyword          : TIDE
            !<BeginDescription>       
               ! 
               ! Checks if the user pretends to impose a wave tide in the open boundary 
               ! 
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>
        call GetData(Compute_Tide,                                                      &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'TIDE',                                               & 
                     default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR30.')


        Me%ComputeOptions%Compute_Tide = Compute_Tide


        !<BeginKeyword>
            !Keyword          : ENTERING_WAVE
            !<BeginDescription>       
               ! 
               ! Checks if the wave imposed in the boundary is entering in the domain or leaving it 
               ! 
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>
        call GetData(Me%ComputeOptions%ComputeEnteringWave,                             &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'ENTERING_WAVE',                                      & 
                     default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR40.')


        if (Compute_tide) Me%ComputeOptions%ComputeEnteringWave = .true.

        !<BeginKeyword>
            !Keyword          : RADIATION
            !<BeginDescription>       
               ! 
               ! Checks if the user wants to imposed the Flather 1974 radiation boundary condition
               ! 
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>


        call GetData(BarotropicRadia,                                                   &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'RADIATION',                                          & 
                     default    = NoRadiation_,                                         &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR50.')


        Me%ComputeOptions%BarotropicRadia = BarotropicRadia

        


        if (BarotropicRadia == NoRadiation_) then

            Me%ComputeOptions%Imposed_BoundaryWave = .true.

        else
        
            Me%ComputeOptions%Imposed_BoundaryWave = .false.

        endif

ifRadia: if (BarotropicRadia == FlatherWindWave_) then
        
            !<BeginKeyword>
                !Keyword          : WAVE_DIRECTION
                !<BeginDescription>       
                   ! 
                   ! The user with this keyword give a direction to a wave entering the domain
                   ! 
                !<EndDescription>
                !Type             : Real 
                !Units            : Degrees 
                !Default          : 0.
                !File keyword     : IN_DAD3D
                !Multiple Options : Do Not Have
                !Search Type      : From File
            !<EndKeyword>
            call GetData(EnteringWaveDirection,                                         &
                         Me%ObjEnterData, iflag,                                        &
                         keyword    = 'WAVE_DIRECTION',                                 & 
                         default    = dble(0.),                                         & 
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)            
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR60.')


            Me%ComputeOptions%EnteringWaveDirection = EnteringWaveDirection * Pi / 180.


        endif IfRadia

ifFla: if (BarotropicRadia == FlatherWindWave_ .or. BarotropicRadia == FlatherLocalSolution_) then


            !<BeginKeyword>
                !Keyword          : MIN_VELOCITY
                !<BeginDescription>       
                   ! 
                   ! The minimum velocity in the open boundary below which the radiation is canceled 
                   ! 
                !<EndDescription>
                !Type             : Real 
                !Units            : m/s 
                !Default          : 1e-6
                !File keyword     : IN_DAD3D
                !Multiple Options : Do Not Have
                !Search Type      : From File
            !<EndKeyword>
            call GetData(MinLeavingVelocity,                                            &
                         Me%ObjEnterData, iflag,                                        &
                         keyword    = 'MIN_VELOCITY',                                   & 
                         default    = 1e-6,                                             &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)            
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR70.' )





            Me%ComputeOptions%MinLeavingVelocity = MinLeavingVelocity


            !<BeginKeyword>
                !Keyword          : MIN_COMPONENT
                !<BeginDescription>       
                   ! 
                   ! The minimum component of the radiative wave below which 
                   ! the radiation process is canceled
                   ! 
                !<EndDescription>
                !Type             : Real 
                !Units            : m/m 
                !Default          : 1e-3
                !File keyword     : IN_DAD3D
                !Multiple Options : Do Not Have
                !Search Type      : From File
            !<EndKeyword>
            call GetData(MinLeavingComponent,                                           &
                         Me%ObjEnterData, iflag,                                        &
                         keyword    = 'MIN_COMPONENT',                                  & 
                         default    = 1e-3,                                             &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)            
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR80.')

            Me%ComputeOptions%MinLeavingComponent = MinLeavingComponent


        endif ifFla

        !<BeginKeyword>
            !Keyword          : WATER_DISCHARGES
            !<BeginDescription>       
               ! 
               ! Check if the user want to water discharges 
               ! 
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (false), 1 (true)
            !Search Type      : From File
        !<EndKeyword>
        call GetData(WaterDischarges,                                                   &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'WATER_DISCHARGES',                                   & 
                     default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic -ERR90.') 

        Me%ComputeOptions%WaterDischarges = WaterDischarges
        
        !<BeginKeyword>
            !Keyword          : TIME_SERIE_DISCHARGE
            !<BeginDescription>       
               ! 
               !Checks out if the user pretends to write a time serie with the discharge flows
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. , .false.
            !Search Type      : From File
        !<EndKeyword>
        
        if (Me%ComputeOptions%WaterDischarges) then

            call GetData(Me%Output%TimeSerieDischON,                              &
                         Me%ObjEnterData, iflag,                                  &
                         keyword    = 'TIME_SERIE_DISCHARGES',                    &
                         Default    = .false.,                                    &
                         SearchType = FromFile,                                   &
                         ClientModule ='ModuleHydrodynamic',                      &
                         STAT       = STAT_CALL)            
            if (STAT_CALL /= SUCCESS_)                                            &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR92.')

        endif        


        !<BeginKeyword>
            !Keyword          : RESIDUAL
            !<BeginDescription>       
               ! 
               ! Check if the user want to compute the residual flow 
               ! 
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (false), 1 (true)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Residual,                                                          &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'RESIDUAL',                                            & 
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR96.')

        Me%ComputeOptions%Residual = Residual

        !<BeginKeyword>
            !Keyword          : ENERGY
            !<BeginDescription>       
               ! 
               ! Check if the user want to compute the potential and kinetic energy of the entire domain 
               ! 
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (false), 1 (true)
            !Search Type      : From File
        !<EndKeyword>
        call GetData(Energy,                                                             &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'ENERGY',                                              &
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR100.') 

        Me%ComputeOptions%Energy = Energy



        !<BeginKeyword>
            !Keyword          : UP_CENTER
            !<BeginDescription>       
               ! 
               ! Check if the horizontal advection discretization 
               ! is upstream or center differences 
               ! By default advection is computed using a Upstream scheme
               ! 
            !<EndDescription>
            !Type             : Real (0,1) 
            !Default          : 1
            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (Center Difference), 1 (Upstream), >0 and <1 (hybrid)
            !Search Type      : From File
        !<EndKeyword>

        call GetData( UpStream_CenterDif,                                                &
                      Me%ObjEnterData, iflag,                               &
                      keyword    = 'UP_CENTER',                                          &           
                      default    =  1.,                                                  &
                      SearchType =  FromFile,                                            &
                      ClientModule ='ModuleHydrodynamic',                                 &
                      STAT       =  STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic -ERR16.' )


        Me%ComputeOptions%UpStream_CenterDif = UpStream_CenterDif


        !<BeginKeyword>
            !Keyword          : IMPLICIT_VERTADVECTION
            !<BeginDescription>       
               ! 
               ! Check if the vertical advection is implicit
               ! 
            !<EndDescription>
            !Type             : Real (0,1) 
            !Default          : 1
            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (explicit), 1 (implicit), >0 and <1 (hybrid)
            !Search Type      : From File
        !<EndKeyword>
        call GetData(ImplicitVertAdvection,                                              &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'IMPLICIT_VERTADVECTION',                              &
                    !By default vertical advection is implicit
                     default    = 1.,                                                    &  
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR110.')

        ! If the new keyword is not find the model tries to read the old one.
        if (iflag == 0) then

            call GetData(ImplicitVertAdvection,                                          &
                         Me%ObjEnterData, iflag,                            &
                         keyword    = 'IMPLICIT_VERTCONVECTION',                         &
                        !By default vertical advection is implicit
                         default    = 1.,                                                &  
                         SearchType = FromFile,                                          &
                         ClientModule ='ModuleHydrodynamic',                             &
                         STAT       = STAT_CALL)            
            if (STAT_CALL /= SUCCESS_)                                                   &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR120.')


            if (iflag == 1)                                                              &
                call SetError (WARNING_, KEYWORD_,                                       &
                               'Change keyword IMPLICIT_VERTCONVECTION to IMPLICIT_VERTADVECTION; ModuleHydrodynamics')

                                                         

        endif



        Me%ComputeOptions%ImplicitVertAdvection = ImplicitVertAdvection


        !<BeginKeyword>
            !Keyword          : IMPLICIT_VERTDIFFUSION
            !<BeginDescription>       
               ! 
               ! Check if the vertical advection is implicit
               ! 
            !<EndDescription>
            !Type             : Real (0,1) 
            !Default          : 1
            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (explicit), 1 (implicit), >0 and <1 (hybrid)
            !Search Type      : From File
        !<EndKeyword>
 
        call GetData(ImplicitVertDiffusion,                                   &
                     Me%ObjEnterData, iflag,                     &
                     keyword    = 'IMPLICIT_VERTDIFFUSION',                   &
                    !By default vertical diffusion is computed implicit
                     Default    = 1.,                                         &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR130.')

        Me%ComputeOptions%ImplicitVertDiffusion = ImplicitVertDiffusion

        !<BeginKeyword>
            !Keyword          : DISCRETIZATION
            !<BeginDescription>       
               ! 
               ! Check what type of implicit discretization in time 
               ! is choose for the global equations
               ! 
            !<EndDescription>
            !Type             : Integer 
            !Default          : 2
            !File keyword     : IN_DAD3D 
            !Multiple Options : 2 (Leendertse Scheme - 6 equations per iteration), 1 (Abbott Scheme - 4 equations per iteration)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Num_Discretization,                    &
                     Me%ObjEnterData, iflag,                     &
                     keyword    = 'DISCRETIZATION',                           & 
                    !By default is use the Leendertse Scheme (6 equations per iteration)
                     Default    = Leendertse,                                 &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR140.')


        Me%ComputeOptions%Num_Discretization = Num_Discretization

        !<BeginKeyword>
            !Keyword          : UPSTREAM
            !<BeginDescription>       
               ! 
               ! Check what type of upstream scheme is used in the horizontal advection
               ! 
            !<EndDescription>
            !Type             : Character 
            !Default          : Upwind
            !File keyword     : IN_DAD3D 
            !Multiple Options : Upwind , Quick
            !Search Type      : From File
        !<EndKeyword>

        call GetData(string,                                                    &
                     Me%ObjEnterData,                              &
                     iflag,                                                     &
                     SearchType   = FromFile,                                   &
                     keyword      ='UPSTREAM',                                  &
                     ClientModule ='ModuleHydrodynamic',                        &
                     default      = Char_Upwind_Scheme,                         &
                     STAT         = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                              &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR150.')

        String = trim(adjustl(String))
case2 : select case(String)
            case(Char_Upwind_Scheme)

                Me%ComputeOptions%UpStream = Upwind_Scheme

                Me%HorAdvection%Coef1_Up =  0.0
                Me%HorAdvection%Coef2_Up =  1.0
                Me%HorAdvection%Coef3_Up =  0.0
                      
            case(Char_Quick_Scheme )

                Me%ComputeOptions%UpStream = Quick_Scheme

                Me%HorAdvection%Coef1_Up = -1.0 / 8.0
                Me%HorAdvection%Coef2_Up =  6.0 / 8.0
                Me%HorAdvection%Coef3_Up =  3.0 / 8.0
                      
            case default

                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR160.')
        end select case2


        !<BeginKeyword>
            !Keyword          : TIME_SERIE
            !<BeginDescription>       
               ! 
               !Checks out if the user pretends to write a time serie
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. , .false.
            !Search Type      : From File
        !<EndKeyword>
        call GetData(Me%Output%TimeSerieON,                                   &
                     Me%ObjEnterData, iflag,                                  &
                     keyword    = 'TIME_SERIE',                               &
                     Default    = .false.,                                    &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR170.')


        !<BeginKeyword>
            !Keyword          : OUTPUT_PROFILE
            !<BeginDescription>       
               ! 
               !Checks out if the user pretends to write a profile output
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. , .false.
            !Search Type      : From File
        !<EndKeyword>
        call GetData(Me%OutPut%ProfileON,                                     &
                     Me%ObjEnterData, iflag,                                  &
                     keyword    = 'OUTPUT_PROFILE',                           &
                     Default    = .false.,                                    &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR180.')



        !<BeginKeyword>
            !Keyword          : OUTPUT_WATER_LEVEL_UNITS
            !<BeginDescription>       
               ! 
               !Checks the type of units for the water level output
               ! 
            !<EndDescription>
            !Type             : integer
            !Default          : meters_
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. , .false.
            !Search Type      : From File
        !<EndKeyword>
        call GetData(AuxInt,                                                            &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'OUTPUT_WATER_LEVEL_UNITS',                           &
                     Default    = meters_,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)                                            
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR190.')

        if (AuxInt /= meters_ .and. AuxInt /= centimeters_)                             &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR200.')

        if      (AuxInt == meters_      ) then
            
            Me%OutPut%WaterLevelUnits = 1.
            
        else if (AuxInt ==  centimeters_) then

            Me%OutPut%WaterLevelUnits = 100.

        endif

        !<BeginKeyword>
            !Keyword          : EVOLUTION
            !<BeginDescription>       
               ! 
               !Checks out if the user pretends to actualize the hydrodynamic
               !properties computing the equations or reading them from a file 
               !there is also the possibility of read the residual flow of the 
               !last run and maintain the instant properties equal to the residual ones
               !The user can also say that the hydrodynamic properties have always null value
               !
            !<EndDescription>
            !Type             : Character 
            !Default          : Solve_Equations
            !File keyword     : IN_DAD3D 
            !Multiple Options : Solve_Equations, Read_File, No_hydrodynamic, Residual_hydrodynamic
            !Search Type      : From File
        !<EndKeyword>

        call GetData(string,                                                    &
                     Me%ObjEnterData,                                           &
                     iflag,                                                     &
                     SearchType   = FromFile,                                   &
                     keyword      ='EVOLUTION',                                 &
                     ClientModule ='ModuleHydrodynamic',                        &
                     !By default the model solve the momentum equations and the continuity equation
                     default      = Char_Solve_Equations,                       &
                     STAT         = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                              &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR210.')


        String = trim(adjustl(String))
case1 : select case(String)
            case(Char_Solve_Equations      )

                Me%ComputeOptions%Evolution = Solve_Equations_
                      
            case(Char_Read_File            )

                Me%ComputeOptions%Evolution = Read_File_
                      
            case(Char_No_hydrodynamic      ) 

                Me%ComputeOptions%Evolution = No_hydrodynamic_
                      
            case(Char_Residual_hydrodynamic)

                Me%ComputeOptions%Evolution = Residual_hydrodynamic_

            case(Char_Run_Off              )

                Me%ComputeOptions%Evolution = Run_Off_

            case(Char_ImposedSolution      )

                Me%ComputeOptions%Evolution = ImposedSolution_

            case(Char_Vertical1D           )

                Me%ComputeOptions%Evolution = Vertical1D_

            case(Char_Harmonics            )

                Me%ComputeOptions%Evolution = Harmonics_
                Me%ComputeOptions%Compute_Tide = .true. 

            case default

                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR220.')

        end select case1




        !<BeginKeyword>
            !Keyword          : CORIOLIS
            !<BeginDescription>       
               ! 
               !Checks  if the user pretends to compute the coriolis force effect
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (compute coriolis) , .false.  (do not compute coriolis)
            !Search Type      : From File
        !<EndKeyword>
        call GetData(Coriolis,                                                &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'CORIOLIS',                                 &
                    !By default the model compute always the coriolis force
                     Default    = .True.,                                     &  
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR230.')


        Me%ComputeOptions%Coriolis = Coriolis

        !<BeginKeyword>
            !Keyword          : VOLUMEVARIATION
            !<BeginDescription>       
               ! 
               !Checks  if the user pretends to compute the volume variation effect
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true.  , .false. 
            !Search Type      : From File
        !<EndKeyword>

        call GetData(VolumeVariation,                                         &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'VOLUMEVARIATION',                          &
                    !By default the model compute always the volume variation effect
                     Default    = .True.,                                     &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR240.')

        Me%ComputeOptions%VolumeVariation = VolumeVariation



        !<BeginKeyword>
            !Keyword          : HORIZONTALADVECTION
            !<BeginDescription>       
               ! 
               !Checks  if the user pretends to compute the horizontal advection effect 
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true.  , .false. 
            !Search Type      : From File
        !<EndKeyword>

        call GetData(HorizontalAdvection,                                                &
                     Me%ObjEnterData, iflag,                                &
                     Keyword    = 'HORIZONTALADVECTION',                                 &
                     !By default compute always the Horizontal Advection
                     Default    = .True.,                                                &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR250.')

        ! If the new keyword is not find the model tries to read the old one.
        if (iflag == 0) then

            call GetData(HorizontalAdvection,                                            &
                         Me%ObjEnterData, iflag,                            &
                         Keyword    = 'HORIZONTALCONVECTION',                            &
                         !By default compute always the Horizontal Advection
                         Default    = .True.,                                            &
                         SearchType = FromFile,                                          &
                         ClientModule ='ModuleHydrodynamic',                             &
                         STAT       = STAT_CALL)            

            if (STAT_CALL /= SUCCESS_)                                                   &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR260.')



            if (iflag == 1)then
                call SetError (WARNING_, KEYWORD_,                                       &
                     'Change keyword HORIZONTALCONVECTION to HORIZONTALADVECTION; ModuleHydrodynamics')
            end if
                                                    

        endif



        Me%ComputeOptions%HorizontalAdvection = HorizontalAdvection

        !<BeginKeyword>
            !Keyword          : HORIZONTALDIFFUSION
            !<BeginDescription>       
               ! 
               !Checks  if the user pretends to compute the horizontal diffusion effect 
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true.  , .false. 
            !Search Type      : From File
        !<EndKeyword>

        call GetData(HorizontalDiffusion,                                     &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'HORIZONTALDIFFUSION',                      &
                     !By default compute always the Horizontal Diffusion
                     Default    = .True.,                                     &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR270.')


        Me%ComputeOptions%HorizontalDiffusion = HorizontalDiffusion

        !<BeginKeyword>
            !Keyword          : INITIAL_ELEVATION
            !<BeginDescription>       
               ! 
               !Checks if the user wants to impose a initial elevation 
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : Do not Have 
            !Search Type      : From File
        !<EndKeyword>


        call GetData(InitialElevation,                                                   &
                     Me%ObjEnterData, iflag,                                &
                     Keyword    = 'INITIAL_ELEVATION',                                   &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR280.')

        Me%ComputeOptions%InitialElevation = InitialElevation



        !<BeginKeyword>
            !Keyword          : INITIAL_ELEVATION_VALUE
            !<BeginDescription>       
               ! 
               !The user define with this keyword the initial elevation value 
               ! 
            !<EndDescription>
            !Type             : Real
            !Default          : 0.
            !File keyword     : IN_DAD3D 
            !Multiple Options : Do not Have 
            !Search Type      : From File
        !<EndKeyword>


        call GetData(InitialElevationValue,                                   &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'INITIAL_ELEVATION_VALUE',                  &
                     !By default the initial elevation is zero
                     Default    = 0.,                                         &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR290')

        Me%WaterLevel%Default = InitialElevationValue

        !<BeginKeyword>
            !Keyword          : INITIAL_VEL_U
            !<BeginDescription>       
               ! 
               !Checks  if the user pretends to impose a initial U (X) velocity
               ! 
            !<EndDescription>
            !Type             : Real
            !Default          : 0.
            !File keyword     : IN_DAD3D 
            !Search Type      : From File
        !<EndKeyword>

        call GetData(InitialVelocityU,                                        &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'INITIAL_VEL_U',                            &
                    !By default do not impose a initial U velocity
                     Default    = 0.,                                         &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR300')

        Me%Velocity%Horizontal%U%Default = InitialVelocityU

        !<BeginKeyword>
            !Keyword          : INITIAL_VEL_V
            !<BeginDescription>       
               ! 
               !Checks  if the user pretends to impose a initial V (Y) velocity
               ! 
            !<EndDescription>
            !Type             : Real
            !Default          : 0.
            !File keyword     : IN_DAD3D 
            !Search Type      : From File
        !<EndKeyword>

        call GetData(InitialVelocityV,                                        &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'INITIAL_VEL_V',                            &
                    !By default do not impose a initial V velocity
                     Default    = 0.,                                         &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR310')

        Me%Velocity%Horizontal%V%Default = InitialVelocityV



cd21:   if (Baroclinic) then



            !<BeginKeyword>
                !Keyword          : BOUNDARYBAROCLINIC
                !<BeginDescription>       
                   ! 
                   !Check if the user wants to compute the baroclinic force in the boundary faces
                   ! 
                !<EndDescription>
                !Type             : Logical
                !Default          : .true.
                !File keyword     : IN_DAD3D 
                !Multiple Options : .true. (Yes), .false. (No)
                !Search Type      : From File
            !<EndKeyword>

            call GetData(BoundaryBaroclinic,                                      &
                         Me%ObjEnterData, iflag,                     &
                         Keyword    = 'BOUNDARYBAROCLINIC',                       & 
                         !By default the model computes always the baroclinic force in the boundary
                         Default    = .true.,                                     &
                         SearchType = FromFile,                                   &
                         ClientModule ='ModuleHydrodynamic',                      &
                         STAT       = STAT_CALL)            
        
            if (STAT_CALL /= SUCCESS_)                                            &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR320')



            Me%ComputeOptions%BoundaryBaroclinic = BoundaryBaroclinic


            !<BeginKeyword>
                !Keyword          : RAMP
                !<BeginDescription>       
                   ! 
                   !Check if the user wants to start with baroclinic 
                   !force null and only after a specific period the total force is compute
                   !
                   ! 
                !<EndDescription>
                !Type             : Logical
                !Default          : .false.
                !File keyword     : IN_DAD3D 
                !Multiple Options : .true. (Yes), .false. (No)
                !Search Type      : From File
            !<EndKeyword>

            call GetData(BaroclinicRamp,                                          &
                         Me%ObjEnterData, iflag,                     &
                        !BaroclinicRamp option by default is false
                         Keyword    = 'RAMP',                                     &
                         Default    = .false.,                                    & 
                         SearchType = FromFile,                                   &
                         ClientModule ='ModuleHydrodynamic',                      &
                         STAT       = STAT_CALL)            

            if (STAT_CALL /= SUCCESS_)                                            &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR330')

            Me%ComputeOptions%BaroclinicRamp = BaroclinicRamp

            if (BaroclinicRamp) then

                !<BeginKeyword>
                    !Keyword          : INERTIAL_PERIODS
                    !<BeginDescription>       
                       ! 
                       !The period after which the total effect of the baroclinic force is compute
                       !
                       ! 
                    !<EndDescription>
                    !Type             : Real
                    !Default          : 1
                    !File keyword     : IN_DAD3D 
                    !Multiple Options : Do Not Have
                    !Search Type      : From File
                !<EndKeyword>

                call GetData(InertialPeriods,                                         &
                             Me%ObjEnterData, iflag,                                  &
                             Keyword    = 'INERTIAL_PERIODS',                         &
                             Default    = 1.,                                         &
                             SearchType = FromFile,                                   &
                             ClientModule ='ModuleHydrodynamic',                      &
                             STAT       = STAT_CALL)            

                if (STAT_CALL /= SUCCESS_)                                            &
                    call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR340')

                Me%ComputeOptions%InertialPeriods = InertialPeriods
                
                if (Me%ComputeOptions%Continuous) then

                  !<beginkeyword>
                  !Keyword      : RAMP_START
                  !Description  : This keyword is used to read the initial data Year Month Day Hour Minutes Seconds
                  !Default      : *
                  !File keyword : 
                  !<endkeyword>
                   call GetData(Me%ComputeOptions%RAMP_BeginTime,                                                 &
                          Me%ObjEnterData,                                             &
                          iflag,                                                             &
                          keyword      = 'RAMP_START',                                            &
                          SearchType   = FromFile,                                           &
                          ClientModule ='ModuleHydrodynamic',                                &
                          STAT       = STAT_CALL)          
               
                     if (STAT_CALL /= SUCCESS_)                                            &
                        call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR350')
                
                     if (iflag == 0) &
                        stop 'Define RAMP_START!!! Construct_Numerical_Options - Hydrodynamic - ERR360' 
                  else
                   
                    Me%ComputeOptions%RAMP_BeginTime = Me%BeginTime
                 
                  endif

                !<BeginKeyword>
                    !Keyword          : RAMP_PERIOD
                    !<BeginDescription>       
                       ! 
                       !The period after which the total effect of the baroclinic force is compute
                       !
                       ! 
                    !<EndDescription>
                    !Type             : Real
                    !Default          : 1
                    !File keyword     : IN_DAD3D 
                    !Multiple Options : Do Not Have
                    !Search Type      : From File
                !<EndKeyword>

                call GetData(Me%ComputeOptions%RampPeriod,                            &
                             Me%ObjEnterData, iflag,                                  &
                             Keyword    = 'RAMP_PERIOD',                              &
                             Default    = FillValueReal,                              &
                             SearchType = FromFile,                                   &
                             ClientModule ='ModuleHydrodynamic',                      &
                             STAT       = STAT_CALL)            

                if (STAT_CALL /= SUCCESS_)                                            &
                    call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR345')

            endif
              
       
        endif cd21



        !<BeginKeyword>
            !Keyword          : VERTICALADVECTION
            !<BeginDescription>       
               ! 
               !Checks  if the user pretends to compute the vertical advection effect 
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true.  , .false. 
            !Search Type      : From File
        !<EndKeyword>

        call GetData(VerticalAdvection,                                                  &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'VERTICALADVECTION',                                   &
                    !By default compute always the Vertical Advection
                     Default    = .True.,                                                &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR380')

        ! If the new keyword is not find the model tries to read the old one.
        if (iflag == 0) then

            call GetData(VerticalAdvection,                                              &
                         Me%ObjEnterData, iflag,                                         &
                         Keyword    = 'VERTICALCONVECTION',                              &
                        !By default compute always the Vertical Advection
                         Default    = .True.,                                            &
                         SearchType = FromFile,                                          &
                         ClientModule ='ModuleHydrodynamic',                             &
                         STAT       = STAT_CALL)            

            if (STAT_CALL /= SUCCESS_)                                                   &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR390')



            if (iflag == 1)then
                call SetError (WARNING_, KEYWORD_,                                   &
                     'Change keyword VERTICALCONVECTION to VERTICALADVECTION; ModuleHydrodynamics')
            end if
                                                                   

        endif




        Me%ComputeOptions%VerticalAdvection = VerticalAdvection


        !<BeginKeyword>
            !Keyword          : VERTICALDIFFUSION
            !<BeginDescription>       
               ! 
               !Checks  if the user pretends to compute the vertical diffusion effect 
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true.  , .false. 
            !Search Type      : From File
        !<EndKeyword>


        call GetData(VerticalDiffusion,                                       &
                     Me%ObjEnterData, iflag,                                  &
                     Keyword    = 'VERTICALDIFFUSION',                        &
                    !By default compute always the Vertical Diffusion
                     Default    = .True.,                                     &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR400')

        Me%ComputeOptions%VerticalDiffusion = VerticalDiffusion


        !<BeginKeyword>
            !Keyword          : VELTANGENTIALBOUNDARY
            !<BeginDescription>       
               ! 
               !Checks the velocities the user want to impose between two boundary points
               ! 
            !<EndDescription>
            !Type             : Integer
            !Default          : 1
            !File keyword     : IN_DAD3D 
            !Multiple Options : 1 (null value)  , 2 (null gradient)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(VelTangentialBoundary,                                   &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'VELTANGENTIALBOUNDARY',                    &
                    !By default impose a null velocity tangential to the boundary
                     Default    = NULL_GRADIENT,                              & 
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR410')


        if (VelTangentialBoundary /= NULL_VALUE    .and. &
            VelTangentialBoundary /= NULL_GRADIENT) then

            call SetError(FATAL_, KEYWORD_, 'Construct_Numerical_Options - Hydrodynamic - ERR420')

        endif

        Me%ComputeOptions%VelTangentialBoundary = VelTangentialBoundary


        !<BeginKeyword>
            !Keyword          : VELNORMALBOUNDARY
            !<BeginDescription>       
               ! 
               !Checks the velocities the user want to impose in the exterior faces
               ! 
            !<EndDescription>
            !Type             : Integer
            !Default          : 1
            !File keyword     : IN_DAD3D 
            !Multiple Options : 1 (null value)  , 2 (null gradient)
            !Search Type      : From File
        !<EndKeyword>


        call GetData(VelNormalBoundary,                                       &
                     Me%ObjEnterData, iflag,                     &
                    !By default is imposed a velocity in the exterior faces equal to the nearest compute face 
                    !The exterior faces have in one side a boundary point and in another a exterior point
                    !The model don't compute advection and diffusion in the boundary points
                     Keyword    = 'VELNORMALBOUNDARY',                        &
                     Default    = NULL_GRADIENT,                              &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR430')


        if (VelNormalBoundary /= NULL_VALUE .and. &
            VelNormalBoundary /= NULL_GRADIENT) then

            call SetError(FATAL_, KEYWORD_, 'Construct_Numerical_Options - Hydrodynamic - ERR440')

        endif

        Me%ComputeOptions%VelNormalBoundary = VelNormalBoundary


        !<BeginKeyword>
            !Keyword          : NULL_BOUND_HORADV
            !<BeginDescription>       
               ! 
               !Checks if the user want to assumed null horizontal advection in the open boundary
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Null Horizontal boundary advection), .false. (compute boundary advection)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(NullBoundaryHorAdv,                                                 &
                     Me%ObjEnterData, iflag,                                &
                     Keyword    = 'NULL_BOUND_HORADV',                                   &
                    !By default the model do not compute advection and diffusion in the boundary points
                     Default    = .true.,                                                &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR450')


        ! If the new keyword is not find the model tries to read the old one.
        if (iflag == 0) then


            call GetData(NullBoundaryHorAdv,                                             &
                         Me%ObjEnterData, iflag,                            &
                         Keyword    = 'NULL_BOUND_HORCONV',                              &
                        !By default the model do not compute advection and diffusion in the boundary points
                         Default    = .true.,                                            &
                         SearchType = FromFile,                                          &
                         ClientModule ='ModuleHydrodynamic',                             &
                         STAT       = STAT_CALL)            

            if (STAT_CALL /= SUCCESS_)                                                   &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR460')


            if (iflag == 1)                                                              &
                call SetError (WARNING_, KEYWORD_,                                       &
                               'Change keyword NULL_BOUND_HORCONV to NULL_BOUND_HORADV; ModuleHydrodynamics')

        endif


        Me%ComputeOptions%NullBoundaryHorAdv = NullBoundaryHorAdv


        !<BeginKeyword>
            !Keyword          : TIDEPOTENTIAL
            !<BeginDescription>       
               ! 
               !Checks if the user want to consider the effect of the potential tide
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(ComputeTidePotential,                                               &
                     Me%ObjEnterData, iflag,                                &
                     Keyword    = 'TIDEPOTENTIAL',                                       &
                    !By default the tide potential is not compute
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR470')


        Me%TidePotential%Compute = ComputeTidePotential


        !<BeginKeyword>
            !Keyword          : ATM_RAMP
            !<BeginDescription>       
               ! 
               !Checks if the the user wants to slowly activate the atmospheric forcing
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(AtmosphereRAMP,                                                    &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'ATM_RAMP',                                           &
                    !By default the Atmospheric RAMP is not computed
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR480')

        Me%ComputeOptions%AtmosphereRAMP = AtmosphereRAMP

        !<BeginKeyword>
            !Keyword          : ATM_PERIOD
            !<BeginDescription>       
               ! 
               !The user specify the atmosphere smooth period
               ! 
            !<EndDescription>
            !Type             : real
            !Default          : 86400. 
            !File keyword     : IN_DAD3D 
            !Search Type      : From File
        !<EndKeyword>

        call GetData(AtmospherePeriod,                                                  & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'ATM_PERIOD',                                         &
                     Default    = 86400.,                                               &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR490')

        Me%ComputeOptions%AtmospherePeriod = AtmospherePeriod
        Me%ComputeOptions%AtmosphereCoef = 1.
        
        if (Me%ComputeOptions%AtmospherePeriod <= 0.)                                   &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR500')
            
        !<BeginKeyword>
            !Keyword          : IMPOSE_INVERTED_BAROMETER
            !<BeginDescription>       
               ! 
               !Check if the user wants to impose in the open boundary the inverted barometer approximation
               ! 
            !<EndDescription>
            !Type             : logical
            !Default          : .false. 
            !File keyword     : IN_DAD3D 
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%InvertBarometer,                                 & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'IMPOSE_INVERTED_BAROMETER',                          &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR501')

        if (Me%ComputeOptions%InvertBarometer) then
            Me%State%Surface = .true.             
        
            !<BeginKeyword>
                !Keyword          : INVERTED_BAROMETER_CELLS
                !<BeginDescription>       
                   ! 
                   !Check if the user wants to restrain to specific cells in the open boundary the inverted barometer approximation 
                   !This can be usefull imposing the invert barometer approximation in specific boundaries.
                   ! 
                !<EndDescription>
                !Type             : logical
                !Default          : .false. 
                !File keyword     : IN_DAD3D 
                !Search Type      : From File
            !<EndKeyword>

            call GetData(Me%ComputeOptions%InvertBaromSomeBound,                            & 
                         Me%ObjEnterData, iflag,                                            & 
                         Keyword    = 'INVERTED_BAROMETER_CELLS',                           &
                         Default    = .false.,                                              &
                         SearchType = FromFile,                                             &
                         ClientModule ='ModuleHydrodynamic',                                &
                         STAT       = STAT_CALL)            

            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR502')
                
            if (Me%ComputeOptions%InvertBaromSomeBound) then 
            
                allocate(Me%ComputeOptions%InvertBarometerCells(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB))
                
                Me%ComputeOptions%InvertBarometerCells(:,:) = 0. 
            
                BeginBlock = "<begin_InvertBarometerCells>"
                EndBlock   = "<end_InvertBarometerCells>"

                !Searches for InvertBarometerCells 
                call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                     &
                                             BeginBlock, EndBlock,                              &
                                             BlockFound, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Numerical_Options  - ModuleHydrodynamic - ERR503'

                if (BlockFound) then

                    !Gets WaterPoints2D
                    call GetWaterPoints2D(Me%ObjHorizontalMap,                                  &
                                          Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                                  &
                        stop 'Construct_Numerical_Options  - ModuleHydrodynamic - ERR504'

                    call ConstructPropertyID  (GenericID, Me%ObjEnterData, FromBlock)

                    call ConstructFillMatrix  (PropertyID           = GenericID,                    &
                                               EnterDataID          = Me%ObjEnterData,              &
                                               TimeID               = Me%ObjTime,                   &
                                               HorizontalGridID     = Me%ObjHorizontalGrid,         &
                                               ExtractType          = FromBlock,                    &
                                               PointsToFill2D       = Me%External_Var%WaterPoints2D,&
                                               Matrix2D             = Me%ComputeOptions%InvertBarometerCells,&
                                               TypeZUV              = TypeZ_,                       &
                                               STAT                 = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Numerical_Options  - ModuleHydrodynamic - ERR505'
                    
                    !UnGets WaterPoints2D
                    call UnGetHorizontalMap(Me%ObjHorizontalMap,                                &                      
                                          Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                                  &
                        stop 'Construct_Numerical_Options  - ModuleHydrodynamic - ERR506'

                    call KillFillMatrix(GenericID%ObjFillMatrix, STAT = STAT_CALL)

                    call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Numerical_Options  - ModuleHydrodynamic - ERR507'

                    call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Numerical_Options  - ModuleHydrodynamic - ERR508'
                    
                endif
            
            endif                
        
        endif

        !<BeginKeyword>
            !Keyword          : WIND
            !<BeginDescription>       
               ! 
               !Checks if the user want to consider the effect of the wind stress
               !By default the wind stress is not compute
               ! 
            !<EndDescription>
            !Type             : integer
            !Default          : 0 (No wind forcing)
            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (No wind forcing), 1(wind forcing), 2(wind forcing with a smooth start)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(ComputeWind,                                              & 
                     Me%ObjEnterData, iflag,                      & 
                     Keyword    = 'WIND',                                      &
                     Default    = NoWind_,                                     &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR510')

        Me%ComputeOptions%Wind = ComputeWind


        !<BeginKeyword>
            !Keyword          : WIND_SMOOTH_PERIOD
            !<BeginDescription>       
               ! 
               !The user specify the wind smooth period
               ! 
            !<EndDescription>
            !Type             : real
            !Default          : 86400. 
            !File keyword     : IN_DAD3D 
            !Search Type      : From File
        !<EndKeyword>

        call GetData(SmoothInitialPeriod,                                      & 
                     Me%ObjEnterData, iflag,                      & 
                     Keyword    = 'WIND_SMOOTH_PERIOD',                        &
                     Default    = 86400.,                                      &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                             &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR520')

        Me%ComputeOptions%SmoothInitialPeriod = SmoothInitialPeriod

        if (Me%ComputeOptions%SmoothInitialPeriod <= 0.)          &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR530')
        
        if ( .not. Me%State%Surface .and. ComputeWind /= NoWind_) &
            Me%State%Surface = .true.

        !<BeginKeyword>
            !Keyword          : ATM_PRESSURE
            !<BeginDescription>       
               ! 
               !Checks if the user wants to consider the effect of the Atmospheric Pressure
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(ComputeAtmPressure,                                       &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'ATM_PRESSURE',                              &
                    !By default the Atmospheric Pressure is not compute
                     Default    = .false.,                                     &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR540')

        Me%ComputeOptions%AtmPressure = ComputeAtmPressure

        if (Me%ComputeOptions%AtmPressure .or. Me%ComputeOptions%InvertBarometer) then
            !<BeginKeyword>
                !Keyword          : ATM_PRESSURE_TYPE
                !<BeginDescription>       
                   ! 
                   !User selects which type of atmospheric pressure he wants to use: 
                   ! 1 - Atmospheric Pressure,
                   ! 2 - Mean Sea Level Atmospheric Pressure
                   ! 
                !<EndDescription>
                !Type             : Logical
                !Default          : .false.
                !File keyword     : IN_DAD3D 
                !Multiple Options : .true. (Yes), .false. (No)
                !Search Type      : From File
            !<EndKeyword>

            call GetData(ComputeAtmPressureType,                                       &
                         Me%ObjEnterData, iflag,                      &
                         Keyword    = 'ATM_PRESSURE_TYPE',                              &
                        !By default the user wants the Atmospheric Pressure type
                         Default    = 1,                                     &
                         SearchType = FromFile,                                    &
                         ClientModule ='ModuleHydrodynamic',                       &
                         STAT       = STAT_CALL)            

            if (STAT_CALL /= SUCCESS_)                                            &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR550')

            Me%ComputeOptions%AtmPressureType = ComputeAtmPressureType

        endif

        if (ComputeAtmPressure) Me%State%Surface = .true. 

        !<BeginKeyword>
            !Keyword          : SURFACEWATERFLUX
            !<BeginDescription>       
               ! 
               !Checks if the user want to consider the effect of precipitation and evaporation
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>
        

        call GetData(ComputeSurfaceWaterFlux,                                  &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'SURFACEWATERFLUX',                          &
                     !By default the SurfaceWaterFlux is not compute
                     Default    = .false.,                                     &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR560')

        Me%ComputeOptions%SurfaceWaterFlux = ComputeSurfaceWaterFlux

        if (.not. Me%State%Surface) &
            Me%State%Surface = ComputeSurfaceWaterFlux


        !<BeginKeyword>
            !Keyword          : HMIN_CHEZY
            !<BeginDescription>       
               ! 
               !Checks the minimum water column height below which the chezy coefficient is constant
               !By default Hmin_Chezy is equal to 10 cm 
               ! 
            !<EndDescription>
            !Type             : Real
            !Default          : 0.10  
            !Units            : meters
            !File keyword     : IN_DAD3D 
            !Search Type      : From File
        !<EndKeyword>
        
        call GetData(Hmin_Chezy,                                               &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'HMIN_CHEZY',                                &
                     Default    = 0.10,                                        &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                             &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR570')
        

        Me%External_Var%Hmin_Chezy = Hmin_Chezy

        !<BeginKeyword>
            !Keyword          : VMIN_CHEZY
            !<BeginDescription>       
               ! 
               !Checks the minimum velocity (Vmin_Chezy) below which the chezy coefficient 
               !is constant if the water column is smaller than Hmin_Chezy
               !By default Vmin_Chezy is equal to 0.10 m/s
               ! 
            !<EndDescription>
            !Type             : Real
            !Default          : 0.10  
            !Units            : m/s
            !File keyword     : IN_DAD3D 
            !Search Type      : From File
        !<EndKeyword>
        
        call GetData(Vmin_Chezy,                                               &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'VMIN_CHEZY',                                &
                     Default    = 0.10,                                        &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                             &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR580')
        

        Me%External_Var%Vmin_Chezy = Vmin_Chezy



        !<BeginKeyword>
            !Keyword          : DATA_ASSIMILATION
            !<BeginDescription>       
               ! 
               !Checks if the user want to impose a flow relaxation boundary condition
               !By default do not use flow relaxation boundary condition
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>
        
        call GetData(Relaxation,                                                         &
                     Me%ObjEnterData, iflag,                                &
                     Keyword    = 'DATA_ASSIMILATION',                                   &
                     Default    = .false.,                                               & 
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            

        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR590') 

        Me%ComputeOptions%Relaxation = Relaxation

        !<BeginKeyword>
            !Keyword          : WATERLEVEL_MAX_MIN
            !<BeginDescription>       
               ! 
               ! Check if the user wants to compute the maximum and the minimum
               ! water elevation map.
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>
        
        call GetData(Me%ComputeOptions%WaterLevelMaxMin,                                                         &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'WATERLEVEL_MAX_MIN',                             &
                     Default    = .false.,                                               & 
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            
        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR596') 


        !<BeginKeyword>
            !Keyword          : ALTIMETRIC_ASSIMILATION
            !<BeginDescription>       
               ! 
               ! Check if the user wants to assimilate altimetry with Cooper-Haines
               ! method.
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>
        
        call GetData(Me%ComputeOptions%AltimetryAssimilation%Yes,                                                         &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'ALTIMETRIC_ASSIMILATION',                             &
                     Default    = .false.,                                               & 
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            
        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR591') 

        !<BeginKeyword>
            !Keyword          : GEOST_INITIALIZATION
            !<BeginDescription>       
               ! 
               !Check if the user wants to initialize the model with geostrophic
               !velocities computed with initial fields and elevations.
               !By default do not use geostrophic initialization.
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>
        
        call GetData(Geost_Initialization,                                               &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'GEOST_INITIALIZATION',                                &
                     Default    = .false.,                                               & 
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            

        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR592') 

        Me%ComputeOptions%Geost_Initialization = Geost_Initialization

        if (Geost_Initialization .and. Me%ComputeOptions%Continuous)  then
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR593') 
        endif

        !<BeginKeyword>
            !Keyword          : LEVEL_BOTTOM_ANOMALY
            !<BeginDescription>       
               ! 
               !Check if the user wants to compute the change on bottom 
               !pressure (converted in level anomaly). This keyword is used
               !if the user wants a time serie for compute admitance betwen
               !sea level anomaly and pressure bottom change.
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>
        
        call GetData(Level_Bottom_Anomaly,                                               &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'LEVEL_BOTTOM_ANOMALY',                                &
                     Default    = .false.,                                               & 
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            

        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR595') 

        Me%ComputeOptions%Level_Bottom_Anomaly = Level_Bottom_Anomaly

#ifdef _USE_SEQASSIMILATION
        call GetData(Me%RunSeqAssimilation,                                              &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'SEQUENTIAL_ASSIMILATION',                             &
                     Default    = .false.,                                               & 
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            
        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR610') 

        if (Me%RunSeqAssimilation .and. Me%ComputeOptions%AltimetryAssimilation%Yes) then
            write(*,*)  
            write(*,*) 'Sequential and altimetry assimilation cannot be used together.'
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR620')
        endif
#endif _USE_SEQASSIMILATION

        !<BeginKeyword>
            !Keyword          : RECORDING
            !<BeginDescription>       
               ! 
               !Checks if the user wants to record the hydrodynamic properties in binary format
               !that can be used latter by the option 'Read_File' of the Keyword = EVOLUTION
               !By default the model do not record the flow properties
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>


        call GetData(Me%ComputeOptions%Recording,                          &
                     Me%ObjEnterData, iflag,                               &
                     Keyword    = 'RECORDING',                                          &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR630')


        !<BeginKeyword>
            !Keyword          : MOMENTUM_DISCHARGE
            !<BeginDescription>       
               ! 
               !Checks if the user wants to do a discharge of momentum
               !By default the model do not have momentum discharges
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%MomentumDischarge,                   &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'MOMENTUM_DISCHARGE',                                  &
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR640')


        !<BeginKeyword>
            !Keyword          : SLOWSTART
            !<BeginDescription>       
               ! 
               !Imposed a specific period in seconds after which
               !the model consider the total imposed boundary wave 
               !Along this period the wave amplitude is multiplie by
               !coefficiente that has linear evolution between 0 and 1.
               !By default this period is zero seconds
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 0
            !Units            : seconds
            !File keyword     : IN_DAD3D 
            !Multiple Options : Do not 
            !Search Type      : From File
        !<EndKeyword>


        !By default do not make a slow start TideSlowStartCoef = 0.
        call GetData(TideSlowStartCoef,                                       & 
                     Me%ObjEnterData, iflag,                     &
                     keyword    = 'SLOWSTART',                                & 
                     default    = 0.,                                         &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            

        
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR650') 


        Me%ComputeOptions%TideSlowStartCoef = TideSlowStartCoef

        !<BeginKeyword>
            !Keyword          : HMIN_ADVECTION
            !<BeginDescription>       
               ! 
               !The user can impose a specific water column heigth below which the 
               !horizontal advection is not compute
               !By default when the water column has less then 0.5 m the advection in not compute
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 0.5 
            !Units            : meters
            !File keyword     : IN_DAD3D 
            !Multiple Options : Do not 
            !Search Type      : From File
        !<EndKeyword>



        call GetData(Hmin_Advection,                                          & 
                     Me%ObjEnterData, iflag,                     &
                     keyword    = 'HMIN_ADVECTION',                           & 
                     default    = 0.50,                                       &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            

        
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR660') 

        ! If the new keyword is not find the model tries to read the old one.
        if (iflag == 0) then

            call GetData(Hmin_Advection,                                          & 
                         Me%ObjEnterData, iflag,                     &
                         keyword    = 'HMIN_CONVECTION',                          & 
                         default    = 0.50,                                       &
                         SearchType = FromFile,                                   &
                         ClientModule ='ModuleHydrodynamic',                      &
                         STAT       = STAT_CALL)            

        
            if (STAT_CALL /= SUCCESS_)                                            &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR670') 


            if (iflag == 1)                                                              &
                call SetError (WARNING_, KEYWORD_,                                       &
                               'Change keyword HMIN_CONVECTION to HMIN_ADVECTION; ModuleHydrodynamics')

        endif




        Me%ComputeOptions%Hmin_Advection = Hmin_Advection


        !<BeginKeyword>
            !Keyword          : LOCAL_DENSITY
            !<BeginDescription>       
               ! 
               ! Check if the user want to devide the baroclinic pressure by the 
               ! local density to compute. if this option is false is used the reference density 
               !  
               ! 
            !<EndDescription>
            !Type             : Logical 
            !Default          : .true.
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (false), 1 (true)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%LocalDensity,                          & 
                     Me%ObjEnterData, iflag,                                  &
                     keyword    = 'LOCAL_DENSITY',                            & 
                     default    = .true.,                                     &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)            

        
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR680') 


        
        !<BeginKeyword>
            !Keyword          : CYCLIC_BOUNDARY
            !<BeginDescription>       
               ! 
               ! Check if the user wants to impose a CYCLIC boundary condition
               !  
               ! 
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .false. (without Cyclic boundary), .true. (with Cyclic boundary)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%CyclicBoundary%ON,                                               & 
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'CYCLIC_BOUNDARY',                                     & 
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            

        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR690') 


        !<BeginKeyword>
            !Keyword          : CYCLIC_DIRECTION
            !<BeginDescription>       
               ! 
               ! Check along which direction the user wants to impose a CYCLIC boundary condition
               !  
               ! 
            !<EndDescription>
            !Type             : integer
            !Default          : DirectionXY_
            !File keyword     : IN_DAD3D
            !Multiple Options : DirectionXY_ (Directions X and Y), DirectionX_ (X direction), DirectionY_ (Y direction)
            !Search Type      : From File
        !<EndKeyword>



        if (Me%CyclicBoundary%ON) then

            call GetData(Me%CyclicBoundary%Direction,                                    & 
                         Me%ObjEnterData, iflag,                                         &
                         keyword    = 'CYCLIC_DIRECTION',                                & 
                         default    = DirectionXY_,                                      &
                         SearchType = FromFile,                                          &
                         ClientModule ='ModuleHydrodynamic',                             &
                         STAT       = STAT_CALL)            
        
            if (STAT_CALL /= SUCCESS_)                                                   &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR700') 

        endif

        !<BeginKeyword>
            !Keyword          : CONSERVATIVE_HOR_DIF
            !<BeginDescription>       
               ! 
               ! Check if the user wants to compute the horizontal 
               ! diffusion in a conservative way.
               !  
               ! 
            !<EndDescription>
            !Type             : logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%ConservativeHorDif,                  & 
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'CONSERVATIVE_HOR_DIF',                                & 
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            
        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR710') 

    
        !<BeginKeyword>
            !Keyword          : BIHARMONIC
            !<BeginDescription>       
               ! 
               ! Check if the user wants to compute the horizontal diffusion 
               ! of momentum with a bi-harmonic formulation
               !  
               ! 
            !<EndDescription>
            !Type             : logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%BiHarmonic,                                      & 
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'BIHARMONIC',                                         & 
                     default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            
        
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR720') 

        !<BeginKeyword>
            !Keyword          : BIHARMONIC_COEF
            !<BeginDescription>       
               ! 
               ! horizontal diffusion ocefficent used when the bi-harmonic option is on
               !  
               ! 
            !<EndDescription>
            !Type             : real 
            !Default          : 1e9
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        if (Me%ComputeOptions%BiHarmonic) then

            call GetData(Me%ComputeOptions%BiHarmonicCoef,                              & 
                         Me%ObjEnterData, iflag,                                        &
                         keyword    = 'BIHARMONIC_COEF',                                & 
                         default    = 1e9,                                              &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)            
        
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR730') 
        endif

        !<BeginKeyword>
            !Keyword          : SUBMODEL
            !<BeginDescription>       
               ! 
               ! Check if the user wants to run this model as a submodel
               !  
               ! 
            !<EndDescription>
            !Type             : logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%ON,                                        & 
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'SUBMODEL',                                            & 
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            
        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR740') 

        !<BeginKeyword>
            !Keyword          : SUBMODEL_FATHER_HOT_START
            !<BeginDescription>       
               ! 
               ! Check if the user wants to the submodel with a father hot start
               !  
               ! 
            !<EndDescription>
            !Type             : logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%FatherHotStart,                                        & 
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'SUBMODEL_FATHER_HOT_START',                          & 
                     default    = .true.,                                               &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            
        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR745') 



        !<BeginKeyword>
            !Keyword          : MISSING_NULL
            !<BeginDescription>       
               ! 
               ! Check if the user wants to replace the missing values by zero 
               !  
               ! 
            !<EndDescription>
            !Type             : logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%MissingNull,                               & 
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'MISSING_NULL',                                        & 
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            
        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR750') 


        !<BeginKeyword>
            !Keyword          : SUBMODEL_EXTRAPOL
            !<BeginDescription>       
               ! 
               ! Check if the user wants to extrapolate the father velocities and water levels  
               !  
               ! 
            !<EndDescription>
            !Type             : logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%Extrapolate,                                           & 
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'SUBMODEL_EXTRAPOLATE',                               & 
                     default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            
        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR750') 



        !<BeginKeyword>
            !Keyword          : DEADZONE
            !<BeginDescription>       
               ! 
               ! Check if the user wants to define a dead zone where the submodel do not 
               ! look for information in the father model
               !  
               ! 
            !<EndDescription>
            !Type             : logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%DeadZone,                                  & 
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'DEADZONE',                                            & 
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            
        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR760') 

        !<BeginKeyword>
            !Keyword          : DEADZONE_FILE
            !<BeginDescription>       
               ! 
               ! file name where the dead zone is defined was polygon 
               !  
               ! 
            !<EndDescription>
            !Type             : logical 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%DeadZoneFile,                              & 
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'DEADZONE_FILE',                                       & 
                     default    = '******.***',                                          &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            
        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR780') 

        !Ang: New father-son 3D connection implementation: option of momentum conserv.
        !<BeginKeyword>
            !Keyword          : MOMENTUM_CONSERV
            !<BeginDescription>       
               ! 
               !Checks if the user wants to maintain, in son, momentum by father   
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : Do not Have 
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%MomentConserv,                                          &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'MOMENTUM_CONSERV',                                    &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR790')

!Manuel MRV

        !<BeginKeyword>
            !Keyword          : BOTTOMVISC_LIM
            !<BeginDescription>       
               ! 
               !Limitation of viscosity at the bottom due to semi-implicit discretization of shear stress on hydrodynamic
               ! equations.
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. , .false.
            !Search Type      : From File
        !<EndKeyword> 
        
        call GetData(Me%ComputeOptions%BottomVisc_LIM,                      &
             Me%ObjEnterData, iflag,                                        &
             keyword    = 'BOTTOMVISC_LIM',                                              &
             Default    = .false.,                                                       &
             ClientModule ='ModuleHydrodynamic',                                         &
             STAT       = STAT_CALL)            
    
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR800')
        
        if (Me%ComputeOptions%BottomVisc_LIM) then

        !<BeginKeyword>
            !Keyword          : BOTTOMVISC_COEF
            !<BeginDescription>       
               ! 
               ! Factor that multiplies diffusion number for imposing a maximum viscosity at bottom layer 
               ! ( coefficient of turbulence transport between layers kbottom and kbottom +1, i.e. viscosity(kbottom+1) )
               ! Maximum viscosity = BottomVisc_MAX*dz*dz/2/dt/Viscosity(kbottom+1)
               ! 
            !<EndDescription>
            !Type             : Real
            !Default          : 5.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>         
                              
            call GetData(Me%ComputeOptions%BottomViscCoef,                  & 
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'BOTTOMVISC_COEF',                                     & 
                     default    = 5.,                                                    &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)                                            
                                                                                        
            if (STAT_CALL /= SUCCESS_)                                                   &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR810') 

        endif
        
!EndManuel

        !<BeginKeyword>
            !Keyword          : BAROCLINIC_RADIATION
            !<BeginDescription>       
               ! 
               ! Check if the user wants to radiate internal tides
               !  
               ! 
            !<EndDescription>
            !Type             : integer 
            !Default          : NoRadiation_
            !Options          : 0 - NoRadiation_, 1 - Horizontal_, 2 - Vertical_
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%BaroclinicRadia,                     & 
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'BAROCLINIC_RADIATION',                                & 
                     default    = NoRadiation_,                                          &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)            
        
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR820')


        !<BeginKeyword>
            !Keyword          : LOCAL_SOLUTION
            !<BeginDescription>       
               ! 
               !Check what type o local (or reference) solution the user wants to use as a reference for the radiative and 
               !relaxation boundary conditions
               !  
               ! 
            !<EndDescription>
            !Type             : integer 
            !Default          : NoRadiation_
            !Options          : 1 - NoLocalSolution_,      2 - Submodel_, 3 - AssimilationField_, 4 - Gauge_, 
            !                   5 - AssimilaPlusSubModel_, 6 - GaugePlusSubModel_, 7 -AssimilaGaugeSubModel_
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>


        call GetData(Me%ComputeOptions%LocalSolution,                   &  
                     Me%ObjEnterData, iflag,                            &
                     keyword    = 'LOCAL_SOLUTION',                                  & 
                     default    = NoLocalSolution_,                                  &
                     SearchType = FromFile,                                          &
                     ClientModule ='ModuleHydrodynamic',                             &
                     STAT       = STAT_CALL)            
    
        if (STAT_CALL /= SUCCESS_)                                                   &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR830')

        if (BarotropicRadia == FlatherLocalSolution_ .and.                              &
            (Me%ComputeOptions%LocalSolution == AssimilationField_ .or.                 &
             Me%ComputeOptions%LocalSolution == AssimilaPlusSubModel_ .or.              &
             Me%ComputeOptions%LocalSolution == GaugePlusSubModel_    .or.              &
             Me%ComputeOptions%LocalSolution == AssimilaGaugeSubModel_)) then 


            !<BeginKeyword>
                !Keyword          : FLAHER_COLD_PERIOD
                !<BeginDescription>       
                   ! 
                   !Periode along each the local solution defined in the assimilation module is slowly
                   !connected
                   ! 
                !<EndDescription>
                !Type             : real 
                !Default          : 0.
                !File keyword     : IN_DAD3D
                !Search Type      : From File
            !<EndKeyword>


            call GetData(Me%ComputeOptions%FlatherColdPeriod,                           &  
                         Me%ObjEnterData, iflag,                                        &
                         keyword    = 'FLATHER_COLD_PERIOD',                            & 
                         default    = 0.,                                               &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)                                            
                                                                                        
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR840')

            if (Me%ComputeOptions%FlatherColdPeriod > (Me%EndTime - Me%BeginTime))      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR850')


            !<BeginKeyword>
                !Keyword          : FLAHER_COLD_SEALEVEL
                !<BeginDescription>       
                   ! 
                   !Average water level for SSH defined in the assimilation module
                   ! 
                !<EndDescription>
                !Type             : real 
                !Default          : 0.
                !File keyword     : IN_DAD3D
                !Search Type      : From File
            !<EndKeyword>


            call GetData(Me%ComputeOptions%FlatherColdSeaLevel,                         &  
                         Me%ObjEnterData, iflag,                                        &
                         keyword    = 'FLATHER_COLD_SEALEVEL',                          & 
                         default    = 0.,                                               &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)                                            
                                                                                        
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR860')

  
        endif

        !<BeginKeyword>
            !Keyword          : CORRECT_WATERLEVEL
            !<BeginDescription>       
               ! 
               !check if the user wants to corrected the water level when it is lower than a
               !reference water level
               ! 
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>
        

        call GetData(Me%ComputeOptions%CorrectWaterLevel,               &  
                     Me%ObjEnterData, iflag,                            &
                     keyword    = 'CORRECT_WATERLEVEL',                              & 
                     default    = .false.,                                           &
                     SearchType = FromFile,                                          &
                     ClientModule ='ModuleHydrodynamic',                             &
                     STAT       = STAT_CALL)            
    
        if (STAT_CALL /= SUCCESS_)                                                   &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR870')

        !<BeginKeyword>
            !Keyword          : MIN_WATERLEVEL
            !<BeginDescription>       
               ! 
               !reference level below which the water level is corrected.
               !
            !<EndDescription>
            !Type             : real
            !Default          : 0.
            !File keyword     : IN_DAD3D 
            !Multiple Options : 
            !Search Type      : From File
        !<EndKeyword>
        

        call GetData(Me%ComputeOptions%WaterLevelMin,                   &  
                     Me%ObjEnterData, iflag,                            &
                     keyword    = 'MIN_WATERLEVEL',                                  & 
                     default    = 0.,                                                &
                     SearchType = FromFile,                                          &
                     ClientModule ='ModuleHydrodynamic',                             &
                     STAT       = STAT_CALL)            
    
        if (STAT_CALL /= SUCCESS_)                                                   &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR880')


        !<BeginKeyword>
            !Keyword          : BOTTOMWATERFLUX
            !<BeginDescription>       
               ! 
               !Checks if the user want to consider the effect of the soil infiltration or consolidation
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>
        

        call GetData(Me%ComputeOptions%BottomWaterFlux,                                 &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'BOTTOMWATERFLUX',                                    &
                     !By default the SurfaceWaterFlux is not compute
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR890')

        !<BeginKeyword>
            !Keyword          : SLIPPING_CONDITION
            !<BeginDescription>       
               ! 
               !Checks if the user want to consider the slipping conditition for horizontal diffusion
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>
        

        call GetData(Me%ComputeOptions%SlippingCondition,         &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'SLIPPING_CONDITION',                        &
                     !By default the splipping condition is on
                     Default    = .true.,                                      &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR900')


        if (Me%TidePotential%Compute) then

            !<BeginKeyword>
                !Keyword          : POTENTIAL_ALGORITHM 
                !<BeginDescription>       
                   ! 
                   ! 
                   ! 
                !<EndDescription>
                !Type             : integer 
                !Default          : .false.
                !File keyword     : IN_DAD3D
                !Multiple Options : Do not have
                !Search Type      : FromFile
            !<EndKeyword>
            call GetData(Me%TidePotential%Algorithm,                            &
                         Me%ObjEnterData, iflag,                                &
                         keyword    = 'POTENTIAL_ALGORITHM',                                 & 
                         default    = Lefevre,                                               &
                         SearchType = FromFile,                                              &
                         ClientModule ='ModuleHydrodynamic',                                 &
                         STAT       = STAT_CALL)            
            if (STAT_CALL /= SUCCESS_)                                                       &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR910')

        endif

        !<BeginKeyword>
            !Keyword          : NONHYDROSTATIC
            !<BeginDescription>       
               ! 
               !Checks if the user want to compute the effect of local vertical aceleration over the pressure field
               ! 
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D 
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>
        

        call GetData(Me%NonHydrostatic%ON,                                     &
                     Me%ObjEnterData, iflag,                                   &
                     Keyword    = 'NONHYDROSTATIC',                            &
                     !By default the model is hydrostatic
                     Default    = .false.,                                     &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR920')


        !<BeginKeyword>
            !Keyword          : WATERCOLUMN2D
            !<BeginDescription>       
               ! 
               !water column thickness below which the 3D proceesses are disconnected 
               ! 
            !<EndDescription>
            !Type             : real
            !Default          : -9e+15
            !File keyword     : IN_DAD3D 
            !Multiple Options : 
            !Search Type      : From File
        !<EndKeyword>
        

        call GetData(Me%ComputeOptions%WaterColumn2D,             &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'WATERCOLUMN2D',                             &
                     !By default the model do not disconnect the 3D processes
                     Default    = FillValueReal,                               &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR930')

        !<BeginKeyword>
            !Keyword          : WAVE_STRESS
            !<BeginDescription>       
               ! 
               !Checks if the user want to consider the effect of the waves stress
               !By default the waves stress is not compute
               ! 
            !<EndDescription>
            !Type             : logical
            !Default          : 0 (No wave stress)
            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (No), 1(Yes)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%WaveStress,                             & 
                     Me%ObjEnterData, iflag,                                   & 
                     Keyword    = 'WAVE_STRESS',                               &
                     Default    = .false.,                                     &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                             &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR940')

        !<BeginKeyword>
            !Keyword          : OBSTACLE
            !<BeginDescription>       
               ! 
               !Checks if the user want to parameteriza the influence of an
               !OBSTACLE in the flow, giving a determined drag coefficient
               !By default the OBSTACLE force is not compute
               ! 
            !<EndDescription>
            !Type             : logical
            !Default          : 0 (No OBSTACLE)
            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (No OBSTACLE, 1(OBSTACLE parameterization)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%Obstacle,                                & 
                     Me%ObjEnterData, iflag,                                    & 
                     Keyword    = 'OBSTACLE',                                   &
                     Default    = .false.,                                      &
                     SearchType = FromFile,                                     &
                     ClientModule ='ModuleHydrodynamic',                        &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                              &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR950')


        !<BeginKeyword>
            !Keyword          : CENTRIFUGAL
            !<BeginDescription>       
               ! 
               !Checks if the user want to consider the CENTRIFUGAL force
               !By default the CENTRIFUGAL force is not compute
               ! 
            !<EndDescription>
            !Type             : logical
            !Default          : 0 (No CENTRIFUGAL force)
            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (No CENTRIFUGAL force), 1(CENTRIFUGAL force)
            !Search Type      : From File
        !<EndKeyword>
        
        call GetCoordTypeList(SIMPLE_GEOG  = SIMPLE_GEOG, GEOG = GEOG)

        call GetGridCoordType(Me%ObjHorizontalGrid, ICOORD_TIP, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR952')

        call GetCheckDistortion (Me%ObjHorizontalGrid,                                  &
                                 Me%External_Var%Distortion,                            &
                                 STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR953')

        if (ICOORD_TIP == SIMPLE_GEOG .or. ICOORD_TIP == GEOG .or. Me%External_Var%Distortion) then
            DefaultAux = .true.
        else
            DefaultAux = .false.
        endif

        call GetData(Me%ComputeOptions%CentrifugalForce,                                & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'CENTRIFUGAL',                                        &
                     Default    = DefaultAux,                                           &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR960')


        if (Me%ComputeOptions%CentrifugalForce .or. Me%ComputeOptions%Coriolis) then

            Me%ComputeOptions%InertiaForces = .true.

        else

            Me%ComputeOptions%InertiaForces = .false.

        endif

        call GetData(Me%ComputeOptions%AdvectionMethodH,                                & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'ADV_METHOD_H',                                       &
                     Default    = UpwindOrder1,                                         &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR970')


        call GetData(Me%ComputeOptions%AdvectionMethodV,                                & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'ADV_METHOD_V',                                       &     
                     Default    = UpwindOrder1,                                         &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR980')

        call GetData(Me%ComputeOptions%TVD_LimH,                                        & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'TVD_LIMIT_H',                                        &
                     Default    = Superbee,                                             &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR990')


        call GetData(Me%ComputeOptions%TVD_LimV,                                        & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'TVD_LIMIT_V',                                        &
                     Default    = Superbee,                                             &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1000')


        call GetData(Me%ComputeOptions%VolumeRelMax,                                    & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'VOLUME_RELATION_MAX',                                &
                     Default    = 2.,                                                   &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1010')

        if (Me%ComputeOptions%AdvectionMethodH == UpwindOrder2 .or.                      &
            Me%ComputeOptions%AdvectionMethodH == UpwindOrder3 .or.                      &
            Me%ComputeOptions%AdvectionMethodH == P2_TVD) then
            Me%ComputeOptions%Upwind2H = .true.
        else
            Me%ComputeOptions%Upwind2H = .false.
        endif

        if (Me%ComputeOptions%AdvectionMethodV == UpwindOrder2 .or.                      &
            Me%ComputeOptions%AdvectionMethodV == UpwindOrder3 .or.                      &
            Me%ComputeOptions%AdvectionMethodV == P2_TVD) then
            Me%ComputeOptions%Upwind2V = .true.
        else
            Me%ComputeOptions%Upwind2V = .false.
        endif


        call GetData(Me%ComputeOptions%BaroclinicMethod,                                & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'BAROCLINIC_METHOD',                                  &
                     Default    = Leibniz,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1020.')

        call GetData(Me%ComputeOptions%BaroclinicPoliDegree,                            & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'BAROCLINIC_POLIDEGREE',                              &
                     Default    = 3,                                                    &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1030')

        call GetData(Me%NonHydroStatic%Residual,                                        & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'NH_RESIDUAL',                                        &
                     Default    = 10e-6,                                                &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1040')        

        call GetData(Me%NonHydroStatic%Maxit,                                           & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'NH_MAXIT',                                           &
                     Default    = 500,                                                  &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1050')        

         call GetData(Me%NonHydroStatic%NormalizedResidual,                             & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'NH_NORMALIZED_RESIDUAL',                             &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1060')        

        call GetData(Me%NonHydroStatic%AlphaLU,                                         & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'NH_ALPHA_LU',                                        &
                     Default    = 0.5,                                                  &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1080')        

        if((Me%NonHydroStatic%AlphaLU<0.).or.(Me%NonHydroStatic%AlphaLU>1.0)) then
            Me%NonHydroStatic%AlphaLU = 0.5
        endif


        call GetData(Me%ComputeOptions%Vertical_AxiSymmetric_Model,            & 
                     Me%ObjEnterData, iflag,                                   &
                     Keyword    = 'VERTICAL_AXISYMMETRIC',                     &
                     Default    = 0,                                           &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1090')    
            
        if (Me%ComputeOptions%Vertical_AxiSymmetric_Model /= 0           .and.          &
            Me%ComputeOptions%Vertical_AxiSymmetric_Model /= DirectionX_ .and.          &                 
            Me%ComputeOptions%Vertical_AxiSymmetric_Model /= DirectionY_ ) then
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1100')    
        endif 

        if (Me%ComputeOptions%Vertical_AxiSymmetric_Model == DirectionX_ .and. Me%WorkSize%IUB /= 3) &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1110')    

        if (Me%ComputeOptions%Vertical_AxiSymmetric_Model == DirectionY_ .and. Me%WorkSize%JUB /= 3) &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1120')    


        call GetData(Me%ComputeOptions%XZFlow,                                 & 
                     Me%ObjEnterData, iflag,                                   &
                     Keyword    = 'XZ_FLOW',                                   &
                     Default    = .false.,                                     &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1130')    

        call GetData(Me%ComputeOptions%ExternalBarotropicVel2D,                & 
                     Me%ObjEnterData, iflag,                                   &
                     Keyword    = 'EXTERNAL_BAROTROPIC_2D',                    &
                     Default    = .true.,                                      &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1140')    


        !<BeginKeyword>
            !Keyword          : SCRAPER
            !<BeginDescription>       
               ! 
               !Checks if the user want to parameteriza the influence of an
               !SCRAPER in the flow, giving a determined a velocity of the scraper

               ! 
            !<EndDescription>
            !Type             : logical
            !Default          : 0 (No SCRAPER)
            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (No SCRAPER, 1(SCRAPER parameterization)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%Scraper,                                         & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'SCRAPER',                                            &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1150')

        !<BeginKeyword>
            !Keyword          : SCRAPER_TIME_SCALE
            !<BeginDescription>       
               ! 
               !Checks what is the time scale for computing the accelaration induced by scraper
               !in the flow

               ! 
            !<EndDescription>
            !Type             : real
            !Default          : 10*DT 
            !File keyword     : IN_DAD3D 
            !Search Type      : From File
        !<EndKeyword>
        
        call GetComputeTimeStep(Me%ObjTime, DT_Model, STAT = STAT_CALL)        

        call GetData(Me%Scraper%TimeScale,                                              & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'SCRAPER_TIME_SCALE',                                 &
                     Default    = 10.*DT_Model,                                         &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1160')

        call GetData(Me%ThinWalls%ON,                                                   & 
                     Me%ObjEnterData, iflag,                                            & 
                     Keyword    = 'THIN_WALLS',                                         &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1170')


    End Subroutine Construct_Numerical_Options

    !End-----------------------------------------------------------------------

    Subroutine Construct_RadiaBaroclinic
    
        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------

        integer :: FromFile
        integer :: status, iflag

        integer :: ILB, IUB
        integer :: JLB, JUB
        integer :: KLB, KUB
        integer :: MaxNormX, MaxNormY
        integer :: MaxTangX, MaxTangY, i

        !Begin-----------------------------------------------------------------

        ILB = Me%Size%ILB 
        IUB = Me%Size%IUB 

        JLB = Me%Size%JLB 
        JUB = Me%Size%JUB 

        KLB = Me%Size%KLB 
        KUB = Me%Size%KUB 

        
     
        call GetExtractType(FromFile = FromFile)


        call GetData(Me%VelBaroclinic%CelerityType,                                      & 
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'CELERITY_TYPE',                                       &  
                     default    = Constant_,                                             &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)            
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR01')


        call GetData(Me%VelBaroclinic%InternalCelerity,                                  & 
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'INTERNAL_CELERITY',                                   & 
                     default    = 2.,                                                    &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)            
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR02')

        call GetData(Me%VelBaroclinic%TRelaxIn,                                          &  
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'DECAY_IN',                                            & 
                     default    = 86400.,                                                &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)            
    
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR03')


        call GetData(Me%VelBaroclinic%TRelaxOut,                                         &  
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'DECAY_OUT',                                           & 
                     default    = 8640000.,                                              &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)            
    
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR04')


        call GetData(Me%VelBaroclinic%MinLeavingBaroclincVel,                            &  
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'MINVEL_BAROCLINIC',                                   & 
                     default    = 1e-6,                                                  &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)            
    
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR05')

        call GetData(Me%VelBaroclinic%BaroclinicNormalRadiation,                         &  
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'NORMAL_BAROCLINIC',                                   & 
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)            
    
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR06')




        call GetData(Me%VelBaroclinic%BaroclinicOBCDiscret,                              &  
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'BAROCLINIC_OBC_DISCRET',                              & 
                     default    = Implicit_,                                             &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)            
    
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR07')

        if (Me%VelBaroclinic%BaroclinicOBCDiscret == StoreWave_) then

            call GetData(Me%VelBaroclinic%DTWave,                                        &    
                         Me%ObjEnterData, iflag,                                         &
                         keyword    = 'BAROCLINIC_WAVE_DT',                              & 
                         default    = Me%Velocity%DT,                                    &
                         SearchType = FromFile,                                          &
                         ClientModule ='ModuleHydrodynamic',                             &
                         STAT       = status)            
    
            if (status /= SUCCESS_)                                                      &
                call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR07a')

        endif
                   
                   
        allocate (Me%VelBaroclinic%W_New(ILB:IUB, JLB:JUB, KLB:KUB)) 
        allocate (Me%VelBaroclinic%W_Old(ILB:IUB, JLB:JUB, KLB:KUB)) 
        allocate (Me%VelBaroclinic%U%New(ILB:IUB, JLB:JUB, KLB:KUB)) 
        allocate (Me%VelBaroclinic%U%Old(ILB:IUB, JLB:JUB, KLB:KUB)) 
        allocate (Me%VelBaroclinic%V%New(ILB:IUB, JLB:JUB, KLB:KUB)) 
        allocate (Me%VelBaroclinic%V%Old(ILB:IUB, JLB:JUB, KLB:KUB)) 
        allocate (Me%VelBaroclinic%U2D  (ILB:IUB, JLB:JUB))
        allocate (Me%VelBaroclinic%V2D  (ILB:IUB, JLB:JUB)) 

        Me%VelBaroclinic%W_New(:,:,:) = FillValueReal
        Me%VelBaroclinic%W_Old(:,:,:) = FillValueReal
        Me%VelBaroclinic%U%New(:,:,:) = FillValueReal
        Me%VelBaroclinic%U%Old(:,:,:) = FillValueReal
        Me%VelBaroclinic%V%New(:,:,:) = FillValueReal
        Me%VelBaroclinic%V%Old(:,:,:) = FillValueReal
        Me%VelBaroclinic%U2D(:,:)     = 0.
        Me%VelBaroclinic%V2D(:,:)     = 0.

       !Auxiliar horizontal baroclinic velocity pointers
        nullify (Me%VelBaroclinic%UV%New) 
        nullify (Me%VelBaroclinic%UV%Old) 

        nullify (Me%VelBaroclinic%VU%New) 
        nullify (Me%VelBaroclinic%VU%Old) 

        nullify (Me%VelBaroclinic%UV2D) 



        if (Me%VelBaroclinic%BaroclinicOBCDiscret == StoreWave_) then

            MaxTangX = (JUB - JLB    ) * 2 * (KUB - KLB + 1) 
            MaxNormY = (JUB - JLB - 1) * 2 * (KUB - KLB + 1) 

            MaxTangY = (IUB - ILB    ) * 2 * (KUB - KLB + 1) 
            MaxNormX = (IUB - ILB - 1) * 2 * (KUB - KLB + 1) 

            allocate(Me%VelBaroclinic%ImposedNormX(MaxNormX))
            do i = 1, MaxNormX
                nullify(Me%VelBaroclinic%ImposedNormX(i)%FirstInstant)
                nullify(Me%VelBaroclinic%ImposedNormX(i)%LastInstant)
            enddo
                        
            allocate(Me%VelBaroclinic%ImposedNormY(MaxNormY))
            do i = 1, MaxNormY
                nullify(Me%VelBaroclinic%ImposedNormY(i)%FirstInstant)
                nullify(Me%VelBaroclinic%ImposedNormY(i)%LastInstant)
            enddo

            allocate(Me%VelBaroclinic%ImposedTangX(MaxTangX))
            do i = 1, MaxTangX
                nullify(Me%VelBaroclinic%ImposedTangX(i)%FirstInstant)
                nullify(Me%VelBaroclinic%ImposedTangX(i)%LastInstant)
            enddo
 
                        
            allocate(Me%VelBaroclinic%ImposedTangY(MaxTangY))
            do i = 1, MaxTangY
                nullify(Me%VelBaroclinic%ImposedTangY(i)%FirstInstant)
                nullify(Me%VelBaroclinic%ImposedTangY(i)%LastInstant)
            enddo
 
        endif

    end subroutine Construct_RadiaBaroclinic

    !End--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine Verify_Numerical_Options 

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------

        integer :: WorkKUB, WorkIUB, WorkJUB, WorkILB, WorkJLB, STAT_CALL
        real    :: Total_RunPeriod, InertialPeriods, RampPeriod

        !Begin-----------------------------------------------------------------
        

        WorkKUB = Me%WorkSize%KUB

        WorkIUB = Me%WorkSize%IUB
        WorkILB = Me%WorkSize%ILB

        WorkJUB = Me%WorkSize%JUB
        WorkJLB = Me%WorkSize%JLB


        if (Me%ComputeOptions%Baroclinic .and. WorkKUB == 1)                &
            call SetError(FATAL_, KEYWORD_, 'Inconsistency: mode baroclinic active in a 2D model - ERR01') 
        


        if (Me%ComputeOptions%BarotropicRadia /= NoRadiation_ .and.         &
            Me%ComputeOptions%Imposed_BoundaryWave)                         &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR02.')

        if (Me%ComputeOptions%BarotropicRadia /= NoRadiation_ .and.         &
            Me%ComputeOptions%Compute_Tide)                                 &
            call SetError(WARNING_, KEYWORD_, 'The model is imposing in the open boundary tide together with radiation')

        !MRV A clamped condition or a BK condition should be imposed
        if (Me%ComputeOptions%BarotropicRadia == BlumbergKantha_ .and.      &
            Me%ComputeOptions%Imposed_BoundaryWave)                         &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR02.')


        if (Me%ComputeOptions%UpStream_CenterDif < 0 .or.                   &
            Me%ComputeOptions%UpStream_CenterDif > 1)                       &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR04.') 

        !This variable must greather then 0 (total explicit) and smaller then 1 (total implicit)
        if (Me%ComputeOptions%ImplicitVertAdvection < 0 .or.               &
            Me%ComputeOptions%ImplicitVertAdvection > 1)                   &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR05.')

        !This variable must greather then 0 (total explicit) and smaller then 1 (total implicit)
        if (Me%ComputeOptions%ImplicitVertDiffusion < 0 .or.                &
            Me%ComputeOptions%ImplicitVertDiffusion > 1)                    &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR06.')

        !The model only know how to compute hydrodynamic using the Abbott scheme (time-split with 4 equations)
        ! or the Leendertse scheme (time-split with 6 equations)
        if (.not. (Me%ComputeOptions%Num_Discretization == Abbott .or.      &
                   Me%ComputeOptions%Num_Discretization == Leendertse))     & 
            call SetError(FATAL_, KEYWORD_,  'Verify_Numerical_Options - Hydrodynamic - ERR07.')

        !The model only know how to compute horizontal advection using central differences or a 
        !upstream scheme. There are only two upstream schemes implemented (first order Upwind and 
        !second order Upwind that we call Quick). The true Quick scheme is more complex see Leonard, 1979 ????
        if (.not. (Me%ComputeOptions%UpStream == Upwind_Scheme .or.         &
                   Me%ComputeOptions%UpStream == Quick_Scheme))             &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR08.')

        
cd1:    if (Me%ComputeOptions%Baroclinic) then
            
cd2:        if (Me%ComputeOptions%BaroclinicRamp) then 
                
                Total_RunPeriod = Me%EndTime - Me%BeginTime

                InertialPeriods = Me%ComputeOptions%InertialPeriods
                
                if (Me%ComputeOptions%RampPeriod > 0.) then
                    RampPeriod = Me%ComputeOptions%RampPeriod
                else                    
                    RampPeriod = 86400. * InertialPeriods
                endif
                
                if (Total_RunPeriod < RampPeriod )                                       &
                    call SetError (WARNING_, KEYWORD_, &
                                  'The RAMP option only work for bigger runs. Check RAMP_START in following files')
                

cd3:            if (Me%ComputeOptions%Continuous) then
                                          
                     call SetError(WARNING_, KEYWORD_, 'You are using the RAMP option with continuous calculus. Check RAMP_START')

                end if cd3

            end if cd2

        endif cd1

        if (Me%ComputeOptions%VelTangentialBoundary /= NULL_VALUE    .and.  &
            Me%ComputeOptions%VelTangentialBoundary /= NULL_GRADIENT)       &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR09.')

        if (Me%ComputeOptions%VelNormalBoundary /= NULL_VALUE .and.         &
            Me%ComputeOptions%VelNormalBoundary /= NULL_GRADIENT)           &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR10.')

        if (Me%ComputeOptions%Evolution /= Solve_Equations_       .and.     &
            Me%ComputeOptions%Evolution /= Read_File_             .and.     &
            Me%ComputeOptions%Evolution /= No_hydrodynamic_       .and.     &
            Me%ComputeOptions%Evolution /= Run_Off_               .and.     &
            Me%ComputeOptions%Evolution /= ImposedSolution_       .and.     &
            Me%ComputeOptions%Evolution /= Vertical1D_            .and.     &
            Me%ComputeOptions%Evolution /= Harmonics_             .and.     &            
            Me%ComputeOptions%Evolution /= Residual_hydrodynamic_         ) &   
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR11.')

        if (Me%ComputeOptions%Evolution == Residual_hydrodynamic_ .and.     &
            .not. Me%ComputeOptions%Continuous )                            &        
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR12.')


        if (Me%ComputeOptions%Evolution == Residual_hydrodynamic_ .and.     &
            .not. Me%ComputeOptions%Residual)                               &        
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR13.')

       !Guillaume
       if ( Me%ComputeOptions%Evolution == Vertical1D_ ) then
       if (    Me%ComputeOptions%Obstacle  .or. & 
               Me%TidePotential%Compute    .or. &
               Me%TidePotential%Compute    .or. &
               Me%Relaxation%Force         .or. &
               Me%ComputeOptions%HorizontalAdvection   .or. &
               Me%ComputeOptions%HorizontalDiffusion   .or. &
               Me%ComputeOptions%VolumeVariation       .or. &
               Me%ComputeOptions%MomentumDischarge     ) then
                
            call SetError(WARNING_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR13a.')
       endif
       endif

        if ((Me%ComputeOptions%Evolution == Read_File_             .or.                 &
             Me%ComputeOptions%Evolution == No_hydrodynamic_       .or.                 &
             Me%ComputeOptions%Evolution == Run_Off_               .or.                 &
             Me%ComputeOptions%Evolution == Harmonics_             .or.                 &             
             Me%ComputeOptions%Evolution == ImposedSolution_      ).and.                &
             Me%ComputeOptions%Continuous)                                              &        
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR14.')


        if (Me%ComputeOptions%SurfaceWaterFlux .and.                                    &
            Me%ComputeOptions%Evolution == Read_File_)                                  &
            call SetError(FATAL_, INTERNAL_, 'Verify_Numerical_Options - Hydrodynamic - ERR18.') 

!        if (Me%ComputeOptions%SurfaceWaterFlux .and.                           &
!            Me%ComputeOptions%Recording             )                       &
!            call SetError(FATAL_, INTERNAL_, 'Verify_Numerical_Options - Hydrodynamic - ERR19.') 

        
        if (Me%ComputeOptions%TideSlowStartCoef > 0. .and.                              &
            .not. (Me%ComputeOptions%Compute_Tide    .or.                               &
                   Me%TidePotential%Compute    ))                                       &
            call SetError(FATAL_, INTERNAL_, 'Verify_Numerical_Options - Hydrodynamic - ERR20.') 

        if (Me%ComputeOptions%TideSlowStartCoef > 0. .and.                              &
            Me%ComputeOptions%Continuous) then 
                write(*,*) 'Hot Start is ON' 
                write(*,*) 'SLOWSTART keyword present'
                write(*,*) 'SlowStart period is set to zero by default in all Hot Start' 
                Me%ComputeOptions%TideSlowStartCoef = 0.
                call SetError(WARNING_, INTERNAL_, 'Verify_Numerical_Options - Hydrodynamic - WRN20a.') 
        endif

        if (.not. Me%ComputeOptions%Compute_Tide .and.                                  &
                  Me%TidePotential%Compute )                                            &
            call SetError(WARNING_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - WRN21.') 



!        if (Me%ComputeOptions%BarotropicRadia /= FlatherLocalSolution_ .and.&
!            Me%SubModel%ON)                                                 &
!            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR25.')

        if (Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_ .and.            &
            Me%ComputeOptions%LocalSolution   /= SubModel_             .and.            &
            Me%ComputeOptions%LocalSolution   /= AssimilaPlusSubModel_ .and.            &
            Me%ComputeOptions%LocalSolution   /= GaugePlusSubModel_    .and.            &
            Me%ComputeOptions%LocalSolution   /= AssimilaGaugeSubModel_.and.            & 
            Me%SubModel%ON)                                                             &
            call SetError(WARNING_, KEYWORD_, 'The model is not using in the flather OBC the submodel as the local solution')
        

!        if (.not. Me%ComputeOptions%Imposed_BoundaryWave .and.              &
!            Me%SubModel%ON)                                                 &
!            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR26.')


        if (Me%ComputeOptions%BaroclinicRadia /= Horizontal_ .and.                      &
            Me%ComputeOptions%BaroclinicRadia /= Vertical_   .and.                      &
            Me%ComputeOptions%BaroclinicRadia /= NoRadiation_)                          &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR28.')            

        if (Me%ComputeOptions%LocalSolution /= NoLocalSolution_      .and.              &
            Me%ComputeOptions%LocalSolution /= Submodel_             .and.              &
            Me%ComputeOptions%LocalSolution /= AssimilationField_    .and.              &
            Me%ComputeOptions%LocalSolution /= AssimilaPlusSubModel_ .and.              &
            Me%ComputeOptions%LocalSolution /= GaugePlusSubModel_    .and.              &
            Me%ComputeOptions%LocalSolution /= AssimilaGaugeSubModel_.and.              &
            Me%ComputeOptions%LocalSolution /= Gauge_)                                  &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR29.')            

        if (.not. Me%SubModel%ON .and.                                                  &
            Me%ComputeOptions%LocalSolution == Submodel_                       )        &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR30.')            

        if (Me%ComputeOptions%Wind /= NoWind_             .and.                         &
            Me%ComputeOptions%Wind /= WithWind_           .and.                         &
            Me%ComputeOptions%Wind /= InitialSmoothWind_)                               &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR31.')            

        if (Me%ComputeOptions%Wind == InitialSmoothWind_  .and.                         &
            Me%ComputeOptions%Continuous )                                              &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR32.')            

        call GetCheckDistortion (Me%ObjHorizontalGrid,                                  &
                                 Me%External_Var%Distortion,                            &
                                 STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR62.')            

        if (Me%External_Var%Distortion .and. .not. Me%ComputeOptions%CentrifugalForce) then
            write(*,*) 'The grid has a distortion but the centrifugal force is not actvie'
            write(*,*) 'Verify_Numerical_Options - Hydrodynamic - WARN62.'
        endif

        if (Me%ComputeOptions%ImplicitVertAdvection> 0.         .and.                   &
           (Me%ComputeOptions%AdvectionMethodV == UpwindOrder2  .or.                    &
            Me%ComputeOptions%AdvectionMethodV == UpwindOrder3)) then

            write(*,*) 'If the advection of momentum in the vertical is implicit'
            write(*,*) 'the advection method can not be a second or third order upwind' 
            stop 'Verify_Numerical_Options - Hydrodynamic - ERR40.'            

        endif

       if ((Me%ComputeOptions%Residual)                     .and.                       &
           (Me%ComputeOptions%Evolution /= Solve_Equations_ .and.                       &
            Me%ComputeOptions%Evolution /= ImposedSolution_)) then

            write(*,*) 'Unable to retrieve residuals if not solving equations.'
            write(*,*) 'Check either RESIDUAL or EVOLUTION keywords.' 
            stop 'Verify_Numerical_Options - Hydrodynamic - ERR41.'            

        endif

        if (Me%ComputeOptions%LocalSolution   == NoLocalSolution_      .and.            &
            Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_ .and.            &
            Me%ComputeOptions%Relaxation) then
            write(*,*) 'NUDGING option ON '
            write(*,*) 'FLATHER RADIATION ON radiating over a null local solution' 
            write(*,*) 'Verify_Numerical_Options - Hydrodynamic - ERR42.'            
        endif
            
        if ((Me%ComputeOptions%LocalSolution == GaugePlusSubModel_ .or.                 &
             Me%ComputeOptions%LocalSolution ==  AssimilaGaugeSubModel_)   .and.        &
           (.not.(Me%ComputeOptions%Compute_Tide .or. Me%ComputeOptions%InvertBarometer) )) then
            write(*,*) 'To activate the local solution Gauge + SubModel'
            write(*,*) 'One of the options TIDE or INVERTBAROMETER must be on' 
            write(*,*) 'Verify_Numerical_Options - Hydrodynamic - ERR60.'            
        endif
            


    End Subroutine Verify_Numerical_Options

    !-----------------------------------------------------------------

    Subroutine ConstructBlumbergKantha

        !Arguments-------------------------------------------------------------



        !Local-----------------------------------------------------------------
        real, dimension(:), allocatable     :: AuxVector
        integer                             :: ILB, IUB, JLB, JUB
        integer                             :: ILBWork, IUBWork, JLBWork, JUBWork
        integer                             :: STATUS
       
        integer                             :: ClientNumber
        integer                             :: FirstLine, LastLine    
        integer                             :: Line, iflag, FromFile
        integer                             :: i,j

        Character(LEN = StringLength)       :: FileName
        Character(LEN = StringLength)       :: block_begin, block_end

        logical                             :: BlockFound

        !Begin Algorithm -------------------------------------------------------- 
        

        call GetExtractType( FromFile = FromFile)


        IUB = Me%Size%IUB
        ILB = Me%Size%ILB
        JUB = Me%Size%JUB
        JLB = Me%Size%JLB



        IUBWork = Me%WorkSize%IUB
        ILBWork = Me%WorkSize%ILB
        JUBWork = Me%WorkSize%JUB
        JLBWork = Me%WorkSize%JLB

        allocate (Me%ComputeOptions%Tlag(ILB : IUB, JLB : JUB), STAT = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR01") 

        Me%ComputeOptions%Tlag(ILBWork : IUBWork, JLBWork : JUBWork) = 1E-12

        !<BeginKeyword>
            !Keyword          : TLAG_FILE
            !<BeginDescription>      
                ! The name file where are the relaxation times defined for the radiation boundary condition 
            !<EndDescription>
            !Type             : Character  
            !Default          : Do not have
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : From File
        !<EndKeyword>


        call GetData(FileName,    Me%ObjEnterData, iflag,                   &  
                     SearchType = FromFile,                                              &
                     keyword    = 'TLAG_FILE',                                           &   
                     default    = '******.***',                                          &    
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR02") 
        
        if (iflag == 0) &
            call SetError (FATAL_, OUT_OF_MEM_, "ConstructBlumbergKantha - Hydrodynamic - ERR03")


        call ConstructEnterData(Me%ObjEnterData1, FileName, STAT = status) 

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR04") 


        block_begin = '<TlagBegin>'
        block_begin = trim(block_begin)

        block_end   = '<TlagEnd>'
        block_end   = trim(block_end)


        call ExtractBlockFromBuffer(Me%ObjEnterData1, ClientNumber,         &
                                    block_begin, block_end, BlockFound,                  &
                                    FirstLine, LastLine,                                 &  
                                    STAT = status)
        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR05") 


cd43:   if (.NOT. BlockFound) then   

            write(*,*) 
            write(*,'(a)') 'Error reading file: ', FileName
            write(*,*)     '    Values should be detween labels:'
            write(*,*)     '        <TlagBegin>'
            write(*,*)     '            .'
            write(*,*)     '            .'
            write(*,*)     '            .'
            write(*,*)     '        <TlagEnd>'
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR06") 

        end if cd43



        allocate (AuxVector(3), STAT = status) 

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR07") 



        do Line = FirstLine + 1, LastLine - 1        !Frank -start one line after firstline

        
            call GetData(AuxVector,                                                      &
                         Me%ObjEnterData1,                                  &
                         iflag, Buffer_Line  = Line, STAT = status)

            if (status /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR08") 

            if (iflag /= 3)                                                              &          
                call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR09") 


            i = int(AuxVector(1))
            j = int(AuxVector(2))

            if (i < ILBWork .or. i > IUBWork .or. j < JLBWork .or. j > JUBWork)          &          
                call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR10") 


            Me%ComputeOptions%Tlag(i, j) = AuxVector(3)

            if(Me%ComputeOptions%Tlag(i, j) < Me%WaterLevel%DT ) &
               Me%ComputeOptions%Tlag(i, j) = Me%WaterLevel%DT 
    
        enddo

        deallocate (AuxVector, STAT = status) 

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR11") 


        call Block_Unlock(Me%ObjEnterData1, ClientNumber, STAT = status) 

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR12") 


        call KillEnterData(Me%ObjEnterData1, STAT = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR13") 

    End Subroutine ConstructBlumbergKantha


    Subroutine AllocateVariables

        !Arguments-------------------------------------------------------------

        

        !Local-----------------------------------------------------------------

        integer :: ILB, IUB
        integer :: JLB, JUB
        integer :: KLB, KUB

        integer :: IJKLB, IJKUB, imin, imax

        integer :: STAT_CALL

        integer :: JImin, JImax
        
        !griflet
        type(T_Coef_Baroc), pointer :: LocalBaroc
        type(T_VECGW), pointer      :: VECGW
        integer                     :: p

        !Begin------------------------------------------------------------------

        ILB = Me%Size%ILB 
        IUB = Me%Size%IUB 

        JLB = Me%Size%JLB 
        JUB = Me%Size%JUB 

        KLB = Me%Size%KLB 
        KUB = Me%Size%KUB 

        !Variables allocation
        allocate (Me%WaterLevel%New             (ILB:Pad(ILB, IUB), JLB:JUB         )) 
        allocate (Me%WaterLevel%Old             (ILB:Pad(ILB, IUB), JLB:JUB         )) 
        allocate (Me%WaterLevel%VolumeCreated   (ILB:Pad(ILB, IUB), JLB:JUB         )) 
        allocate (Me%WaterLevel%Maxi            (ILB:Pad(ILB, IUB), JLB:JUB         )) 
        allocate (Me%WaterLevel%Mini            (ILB:Pad(ILB, IUB), JLB:JUB         ))
#ifdef _USE_PAGELOCKED
        call Alloc3DPageLocked(Me%ObjCuda, Me%Velocity%Horizontal%U%NewPtr, Me%Velocity%Horizontal%U%New, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Velocity%Horizontal%U%OldPtr, Me%Velocity%Horizontal%U%Old, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Velocity%Horizontal%V%NewPtr, Me%Velocity%Horizontal%V%New, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Velocity%Horizontal%V%OldPtr, Me%Velocity%Horizontal%V%Old, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Velocity%Vertical%CartesianPtr, Me%Velocity%Vertical%Cartesian, IUB + 1, JUB + 1, KUB + 1)
#else
        allocate (Me%Velocity%Horizontal%U%New  (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
        allocate (Me%Velocity%Horizontal%U%Old  (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
        allocate (Me%Velocity%Horizontal%V%New  (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
        allocate (Me%Velocity%Horizontal%V%Old  (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
        allocate (Me%Velocity%Vertical%Cartesian(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
#endif  

        allocate (Me%Velocity%Vertical%Across   (ILB:IUB, JLB:JUB, KLB:KUB)) 
        
        ! guillaume
        if (Me%ComputeOptions%AltimetryAssimilation%Yes .or.                            &
            Me%ComputeOptions%Geost_Initialization) then
            Me%Geostroph%ON  = .true.
        endif
        
        if (Me%Geostroph%ON) then
            allocate (Me%Geostroph%U               (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
            allocate (Me%Geostroph%V               (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
            allocate (Me%Geostroph%AuxDesCentre    (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
            allocate (Me%Geostroph%PressGrad       (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))             
            allocate (Me%Geostroph%U_barotropic    (ILB:Pad(ILB, IUB), JLB:JUB)) 
            allocate (Me%Geostroph%V_barotropic    (ILB:Pad(ILB, IUB), JLB:JUB)) 
            Me%Geostroph%U                      (:,:,:) = 0.     
            Me%Geostroph%V                      (:,:,:) = 0.
            Me%Geostroph%AuxDesCentre           (:,:,:) = 0.
            Me%Geostroph%PressGrad              (:,:,:) = 0.            
            Me%Geostroph%U_barotropic           (:,:)   = 0.     
            Me%Geostroph%V_barotropic           (:,:)   = 0.
        endif

        Me%WaterLevel%New(:,:)                  = FillValueReal
        Me%WaterLevel%Old(:,:)                  = FillValueReal
        Me%WaterLevel%VolumeCreated(:,:)        = 0.
        Me%WaterLevel%Maxi(:,:)                 = FillValueReal
        Me%WaterLevel%Mini(:,:)                 = -FillValueReal
        Me%Velocity%Horizontal%U%New(:,:,:)     = FillValueReal     
        Me%Velocity%Horizontal%U%Old(:,:,:)     = FillValueReal    
        Me%Velocity%Horizontal%V%New(:,:,:)     = FillValueReal
        Me%Velocity%Horizontal%V%Old(:,:,:)     = FillValueReal
        Me%Velocity%Vertical%Across(:,:,:)      = FillValueReal
        Me%Velocity%Vertical%Cartesian(:,:,:)   = FillValueReal
        !Auxiliar horizontal velocity pointers
        nullify (Me%Velocity%Horizontal%UV%New) 
        nullify (Me%Velocity%Horizontal%UV%Old) 

        nullify (Me%Velocity%Horizontal%VU%New) 
        nullify (Me%Velocity%Horizontal%VU%Old) 

        !NonHydrostatic
        if (Me%NonHydrostatic%ON) then

            allocate (Me%Velocity%Vertical%CartesianOld(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
            allocate (Me%NonHydrostatic%PressureCorrect(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%NonHydrostatic%PrevisionalQ(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%NonHydrostatic%CCoef(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%NonHydrostatic%GCoef(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            Me%Velocity%Vertical%CartesianOld (:,:,:) = FillValueReal
            Me%NonHydrostatic%PressureCorrect (:,:,:) = FillValueReal
            Me%NonHydrostatic%PrevisionalQ(:, : ,:)   = FillValueReal
        endif



        allocate (Me%WaterFluxes%X          (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
        allocate (Me%WaterFluxes%Y          (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
        allocate (Me%WaterFluxes%Z          (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
        allocate (Me%WaterFluxes%Discharges (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        if (Me%ComputeOptions%MomentumDischarge) then
            allocate (Me%WaterFluxes%DischargesVelU (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%WaterFluxes%DischargesVelV (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))            
            Me%WaterFluxes%DischargesVelU(:,:,:) = 0.
            Me%WaterFluxes%DischargesVelV(:,:,:) = 0.
        endif
 
        Me%WaterFluxes%X         (:,:,:) = FillValueReal
        Me%WaterFluxes%Y         (:,:,:) = FillValueReal
        Me%WaterFluxes%Z         (:,:,:) = FillValueReal
        Me%WaterFluxes%Discharges(:,:,:) = FillValueReal

        !If compute Residual properties then must allocate residual variables
        nullify (Me%Residual%WaterLevel) 

        nullify (Me%Residual%Velocity_U)
        nullify (Me%Residual%Velocity_V) 

        nullify (Me%Residual%DWZ)

        nullify (Me%Residual%Vertical_Velocity)

        !Residual water fluxes
        nullify (Me%Residual%WaterFlux_X) 
        nullify (Me%Residual%WaterFlux_Y) 

        Me%Residual%ResidualTime = FillValueReal

cd1:    if (Me%ComputeOptions%Residual) then 

            !Can be interesting to compute the average water level
            allocate (Me%Residual%WaterLevel        (ILB:Pad(ILB, IUB), JLB:JUB))        
            allocate (Me%Residual%Velocity_U        (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
            allocate (Me%Residual%Velocity_V        (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
            allocate (Me%Residual%Vertical_Velocity (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
            allocate (Me%Residual%WaterFlux_X       (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
            allocate (Me%Residual%WaterFlux_Y       (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
            allocate (Me%Residual%DWZ               (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 

            Me%Residual%WaterLevel          (:,:)   = FillValueReal
            Me%Residual%Velocity_U        (:,:,:)   = FillValueReal
            Me%Residual%Velocity_V        (:,:,:)   = FillValueReal
            Me%Residual%Vertical_Velocity (:,:,:)   = FillValueReal
            Me%Residual%WaterFlux_X       (:,:,:)   = FillValueReal
            Me%Residual%WaterFlux_Y       (:,:,:)   = FillValueReal
            Me%Residual%DWZ               (:,:,:)   = FillValueReal

        endif cd1


        !Forces 
        allocate (Me%Forces%Rox3X                   (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
        allocate (Me%Forces%Rox3Y                   (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 

        allocate (Me%Forces%Horizontal_Transport    (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
        allocate (Me%Forces%Inertial_Aceleration    (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
        allocate (Me%Forces%TidePotentialLevel      (ILB:Pad(ILB, IUB), JLB:JUB)) 

        if(Me%ComputeOptions%AltimetryAssimilation%Yes) then 
            allocate (Me%Forces%Altim_Relax_Aceleration (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 
            Me%Forces%Altim_Relax_Aceleration(:,:,:)= 0.
        endif

        Me%Forces%Rox3X(:,:,:)                  = FillValueReal
        Me%Forces%Rox3Y(:,:,:)                  = FillValueReal
        Me%Forces%Horizontal_Transport(:,:,:)   = FillValueReal
        Me%Forces%Inertial_Aceleration(:,:,:)   = FillValueReal
        Me%Forces%TidePotentialLevel(:,:)       = FillValueReal


        allocate (Me%Coef%D2%D                      (ILB:Pad(ILB, IUB), JLB:JUB)) 
        allocate (Me%Coef%D2%E                      (ILB:Pad(ILB, IUB), JLB:JUB)) 
        allocate (Me%Coef%D2%Eaux                   (ILB:Pad(ILB, IUB), JLB:JUB))         
        allocate (Me%Coef%D2%F                      (ILB:Pad(ILB, IUB), JLB:JUB)) 
        allocate (Me%Coef%D2%Ti                     (ILB:Pad(ILB, IUB), JLB:JUB)) 
        allocate (Me%Coef%D2%TiAux                  (ILB:Pad(ILB, IUB), JLB:JUB)) 


        Me%Coef%D2%D(:,:)                       = FillValueReal
        Me%Coef%D2%E(:,:)                       = FillValueReal
        Me%Coef%D2%F(:,:)                       = FillValueReal
        Me%Coef%D2%Ti(:,:)                      = FillValueReal

        Me%Coef%D2%Eaux (:,:)                   = FillValueReal
        Me%Coef%D2%TiAux(:,:)                   = FillValueReal

        nullify (Me%Coef%D2%Rad  ) 
        nullify (Me%Coef%D2%TiRad) 

cd2:    if (Me%ComputeOptions%BarotropicRadia == FlatherWindWave_ .or.      &
            Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then 

            allocate (Me%Coef%D2%Rad  (ILB:Pad(ILB, IUB), JLB:JUB)) 
            allocate (Me%Coef%D2%TiRad(ILB:Pad(ILB, IUB), JLB:JUB)) 

            Me%Coef%D2%Rad   = FillValueReal
            Me%Coef%D2%TiRad = FillValueReal
        endif cd2

#ifdef _USE_PAGELOCKED
        call Alloc3DPageLocked(Me%ObjCuda, Me%Coef%D3%DPtr, Me%Coef%D3%D, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Coef%D3%EPtr, Me%Coef%D3%E, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Coef%D3%FPtr, Me%Coef%D3%F, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Coef%D3%TiPtr, Me%Coef%D3%Ti, IUB + 1, JUB + 1, KUB + 1)
#else
        allocate (Me%Coef%D3%D(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB), STAT = STAT_CALL) 
        allocate (Me%Coef%D3%E(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB), STAT = STAT_CALL) 
        allocate (Me%Coef%D3%F(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB), STAT = STAT_CALL) 
        allocate (Me%Coef%D3%Ti(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB), STAT = STAT_CALL) 
#endif _USE_PAGELOCKED

        Me%Coef%D3%D = FillValueReal
        Me%Coef%D3%E = FillValueReal 
        Me%Coef%D3%F = FillValueReal     
        Me%Coef%D3%Ti = FillValueReal
        
        !Bottom boundary: these variables in the future must migrate to the module ModuleBottom
        allocate (Me%External_Var%ChezyZ    (ILB:Pad(ILB, IUB), JLB:JUB)) 
        allocate (Me%External_Var%ChezyVelUV(ILB:Pad(ILB, IUB), JLB:JUB)) 

        Me%External_Var%ChezyZ    (:,:) = 0.
        Me%External_Var%ChezyVelUV(:,:) = 0.

        IJKLB = MIN(ILB, JLB, KLB)
        IJKUB = MAX(IUB, JUB, KUB)

        allocate (Me%VECG_3D(IJKLB : IJKUB))
        allocate (Me%VECW_3D(IJKLB : IJKUB))

        Me%VECG_3D = FillValueReal
        Me%VECW_3D = FillValueReal


        JImin = MIN(ILB,JLB)
        JImax = MAX(IUB,JUB)

        allocate (Me%VECG_2D(JImin : JImax), STAT = STAT_CALL)
        allocate (Me%VECW_2D(JImin : JImax),    STAT = STAT_CALL)

        Me%VECG_2D = FillValueReal
        Me%VECW_2D = FillValueReal

        !griflet
        !griflet start                
        Me%MaxThreads=1
        !$ Me%MaxThreads = omp_get_max_threads()
        
        allocate(Me%THOMAS)
        allocate(Me%THOMAS%COEF3)
        allocate(Me%THOMAS%VEC(1:Me%MaxThreads))  
                      
        allocate(Me%THOMAS2D)
        allocate(Me%THOMAS2D%COEF2)
        allocate(Me%THOMAS2D%VEC(1:Me%MaxThreads))  

        allocate(Me%Coef%Baroc(1:Me%MaxThreads))        
        
        do p=1,Me%MaxThreads
        
            LocalBaroc => Me%Coef%Baroc(p)
                        
    cd3:    if (Me%ComputeOptions%Baroclinic) then 

                allocate (LocalBaroc%Kleft       (KLB : KUB+1))
                allocate (LocalBaroc%Kright      (KLB : KUB+1))
                allocate (LocalBaroc%Depth_integ (KLB : KUB+1))
                allocate (LocalBaroc%Hcenter     (KLB : KUB+1))
                allocate (LocalBaroc%Hleft       (KLB : KUB+1))
                allocate (LocalBaroc%Hright      (KLB : KUB+1))
                allocate (LocalBaroc%HroLeft     (KLB : KUB+1))
                allocate (LocalBaroc%HroRight    (KLB : KUB+1))
                allocate (LocalBaroc%DensLeft    (KLB : KUB+1))
                allocate (LocalBaroc%DensRight   (KLB : KUB+1))
    
                LocalBaroc%Kleft         = FillValueInt
                LocalBaroc%Kright        = FillValueInt
                LocalBaroc%Depth_integ   = FillValueReal
                LocalBaroc%Hcenter       = FillValueReal 
                LocalBaroc%Hleft         = FillValueReal
                LocalBaroc%Hright        = FillValueReal
                LocalBaroc%HroLeft       = FillValueReal
                LocalBaroc%HroRight      = FillValueReal
                LocalBaroc%DensLeft      = FillValueReal
                LocalBaroc%DensRight     = FillValueReal
                
            endif cd3
        
            VECGW => Me%THOMAS2D%VEC(p)

            allocate(VECGW%G(JImin:JImax))
            allocate(VECGW%W(JImin:JImax))

            VECGW => Me%THOMAS%VEC(p)

            allocate(VECGW%G(IJKLB:IJKUB))
            allocate(VECGW%W(IJKLB:IJKUB))
            
        enddo
        
        Me%THOMAS2D%COEF2%D => Me%Coef%D2%D
        Me%THOMAS2D%COEF2%F => Me%Coef%D2%F
        Me%THOMAS2D%TI => Me%Coef%D2%Ti
        Me%THOMAS2D%COEF2%E => Me%Coef%D2%E
        
        Me%THOMAS%COEF3%D => Me%Coef%D3%D
        Me%THOMAS%COEF3%F => Me%Coef%D3%F
        Me%THOMAS%Ti => Me%Coef%D3%Ti
        Me%THOMAS%COEF3%E => Me%Coef%D3%E

        !griflet: END
        
        if (Me%ComputeOptions%BarotropicRadia == BlumbergKantha_)           &
            call ConstructBlumbergKantha


        if (Me%ComputeOptions%BiHarmonic) then

            allocate (Me%ComputeOptions%BiHarmonicUX_VY(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%ComputeOptions%BiHarmonicUY_VX(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            
            Me%ComputeOptions%BiHarmonicUX_VY(:,:,:) = FillValueReal
            Me%ComputeOptions%BiHarmonicUY_VX(:,:,:) = FillValueReal


        endif

ic1:    if (Me%CyclicBoundary%ON) then

            imin = min (ILB, JLB, KLB)
            imax = max (IUB, JUB, KUB)

            allocate (Me%Coef%D1%a  (imin : imax)) 
            allocate (Me%Coef%D1%b  (imin : imax)) 
            allocate (Me%Coef%D1%bb (imin : imax)) 
            allocate (Me%Coef%D1%c  (imin : imax)) 
            allocate (Me%Coef%D1%r  (imin : imax)) 
            allocate (Me%Coef%D1%u  (imin : imax)) 
            allocate (Me%Coef%D1%x  (imin : imax)) 
            allocate (Me%Coef%D1%z  (imin : imax)) 
            allocate (Me%Coef%D1%gam(imin : imax)) 

            Me%Coef%D1%a(:)     = FillValueReal
            Me%Coef%D1%b(:)     = FillValueReal
            Me%Coef%D1%bb(:)    = FillValueReal
            Me%Coef%D1%c(:)     = FillValueReal
            Me%Coef%D1%r(:)     = FillValueReal
            Me%Coef%D1%u(:)     = FillValueReal
            Me%Coef%D1%x(:)     = FillValueReal
            Me%Coef%D1%z(:)     = FillValueReal
            Me%Coef%D1%gam(:)   = FillValueReal

        endif ic1

        if(Me%ComputeOptions%Obstacle)then

            allocate (Me%Drag%Coef                          (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%Forces%ObstacleDrag_Aceleration    (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB)) 

            Me%Forces%ObstacleDrag_Aceleration(:,:,:) = 0.
            Me%Drag%Coef                      (:,:,:) = FillValueReal
  
        endif

        if (Me%SubModel%ON) then

            nullify(Me%SubModel%Z)

            nullify(Me%SubModel%U_New )
            nullify(Me%SubModel%V_New )
            nullify(Me%SubModel%UV_New)

            nullify(Me%SubModel%U_Old )
            nullify(Me%SubModel%V_Old )
            nullify(Me%SubModel%UV_Old)


            nullify(Me%SubModel%DUZ_New )
            nullify(Me%SubModel%DVZ_New )

            nullify(Me%SubModel%DUZ_Old )
            nullify(Me%SubModel%DVZ_Old )
            nullify(Me%SubModel%DUVZ_Old)

            nullify(Me%SubModel%qX      )
            nullify(Me%SubModel%qY      )
            nullify(Me%SubModel%qXY     )
            nullify(Me%SubModel%qYX     )


            allocate (Me%SubModel%Z         (ILB:Pad(ILB, IUB), JLB:JUB))
            allocate (Me%SubModel%U_New     (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%DUZ_New   (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%V_New     (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%DVZ_New   (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%qX        (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%qY        (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%DUZ_Old   (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%DVZ_Old   (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%U_Old     (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%V_Old     (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))

            Me%SubModel%Z  (:,:  )          = FillValueReal
            Me%SubModel%U_New  (:,:,:)      = FillValueReal
            Me%SubModel%DUZ_New  (:,:,:)    = FillValueReal
            Me%SubModel%V_New(:,:,:)        = FillValueReal
            Me%SubModel%DVZ_New  (:,:,:)    = FillValueReal
            Me%SubModel%qX(:,:,:)           = FillValueReal
            Me%SubModel%qY(:,:,:)           = FillValueReal
            Me%SubModel%DUZ_Old(:,:,:)      = FillValueReal
            Me%SubModel%DVZ_Old(:,:,:)      = FillValueReal
            Me%SubModel%U_Old  (:,:,:)      = FillValueReal
            Me%SubModel%V_Old  (:,:,:)      = FillValueReal
        
        
        endif
        
        allocate(Me%Aux3DFlux(ILB:IUB, JLB:JUB, KLB:KUB))
        
        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(FillValueReal))
        
      !----------------------------------------------------------------------

    end subroutine AllocateVariables   

    !--------------------------------------------------------------------------
    !If needed the sub-modules responsible for the:
    !   - Turbulence
    !   - OpenBoundary
    !   - Discharges
    !   - Surface conditions
    !   - Bottom Conditions
    !will be construct in this subroutine

    subroutine Construct_Sub_Modules(DischargesID, AssimilationID)

        !Arguments-------------------------------------------------------------
        integer                         :: DischargesID
        integer                         :: AssimilationID
    
        !Local-----------------------------------------------------------------
        type (T_Lines),   pointer       :: LineX
        type (T_Polygon), pointer       :: PolygonX
        character(len=StringLength)     :: DischargeName
        real                            :: CoordinateX, CoordinateY
        logical                         :: CoordinatesON, IgnoreOK
        logical                         :: WaterDischarges, ModelGOTM, ContinuousGOTM
        integer, dimension(:,:), pointer:: WaterPoints2D
        integer, dimension(:),   pointer:: VectorI, VectorJ, VectorK
        integer                         :: Id, Jd, Kd, dn, DischargesNumber, nC
        integer                         :: SpatialEmission, nCells, DischVertical
        integer                         :: STAT_CALL
        
        !----------------------------------------------------------------------

        
        WaterDischarges = Me%ComputeOptions%WaterDischarges

i1:     if (WaterDischarges) then
            
i2:          if (DischargesID == 0) then
                call Construct_Discharges(Me%ObjDischarges,                             &
                                          Me%ObjTime,                                   &
                                          STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR10'  

                DischargesID = Me%ObjDischarges

                call GetDischargesNumber(Me%ObjDischarges, DischargesNumber, STAT  = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR20'  

                !Gets WaterPoints2D
                call GetWaterPoints2D(Me%ObjHorizontalMap, WaterPoints2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR30' 


d1:             do dn = 1, DischargesNumber

                    call GetDischargesGridLocalization(Me%ObjDischarges, dn,            &
                                                       DischVertical = DischVertical,   &
                                                       KGrid         = Kd,              &
                                                       CoordinateX   = CoordinateX,     &
                                                       CoordinateY   = CoordinateY,     & 
                                                       CoordinatesON = CoordinatesON,   &
                                                       TimeX         = Me%CurrentTime,  &
                                                       STAT          = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR40' 
                    
                    call GetDischargesIDName (Me%ObjDischarges, dn, DischargeName, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR45' 

                    if (CoordinatesON) then
                        call GetXYCellZ(Me%ObjHorizontalGrid, CoordinateX, CoordinateY, Id, Jd, STAT = STAT_CALL)
                        
                        if (STAT_CALL /= SUCCESS_ .and. STAT_CALL /= OUT_OF_BOUNDS_ERR_) then
                            stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR50'
                        endif                            

                        if (STAT_CALL == OUT_OF_BOUNDS_ERR_ .or. Id < 0 .or. Jd < 0) then
                
                            call TryIgnoreDischarge(Me%ObjDischarges, dn, IgnoreOK, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR60'

                            if (IgnoreOK) then
                                write(*,*) 'Discharge outside the domain - ',trim(DischargeName),' - ',trim(Me%ModelName)
                                cycle
                            else
                                stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR70'
                            endif

                        endif

                        call CorrectsCellsDischarges(Me%ObjDischarges, dn, Id, Jd, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR80'
                    endif

                    call GetDischargeSpatialEmission(Me%ObjDischarges, dn, LineX, PolygonX, &
                                                     SpatialEmission, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR90'
                    
i3:                 if (SpatialEmission == DischPoint_) then
 
                        call GetDischargesGridLocalization(Me%ObjDischarges, dn,            &
                                                           DischVertical = DischVertical,   &
                                                           Igrid         = Id,              &
                                                           JGrid         = Jd,              &
                                                           TimeX         = Me%CurrentTime,  &
                                                           STAT          = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR100'

                        if (WaterPoints2D(Id,Jd) /= WaterPoint) then
                            call TryIgnoreDischarge(Me%ObjDischarges, dn, IgnoreOK, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR110'

                            write(*,*) 'A discharge in an land cell I=',Id,' J=',Jd,'Model name=',trim(Me%ModelName)

                            if (IgnoreOK) then
                                write(*,*) 'Discharge in a land cell - ',trim(DischargeName),' - ',trim(Me%ModelName)
                                cycle
                            else
                                stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR120'
                            endif
                        endif

                        nCells    = 1
                        allocate(VectorI(nCells), VectorJ(nCells), VectorK(nCells))
                        VectorJ(nCells) = Jd
                        VectorI(nCells) = Id

                    else i3

                        if (SpatialEmission == DischLine_) then
                            call GetCellZInterceptByLine(Me%ObjHorizontalGrid, LineX,       &
                                                         WaterPoints2D, VectorI, VectorJ,   &
                                                         VectorK, nCells, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR130'

                            if (nCells < 1) then
                                write(*,*) 'Discharge line intercept 0 cells'       
                                stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR140'
                            endif

                        endif 


                        if (SpatialEmission == DischPolygon_) then
                            call GetCellZInterceptByPolygon(Me%ObjHorizontalGrid, PolygonX, &
                                                         WaterPoints2D, VectorI, VectorJ,   &
                                                         VectorK, nCells, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR150'

                            if (nCells < 1) then
                                write(*,*) 'Discharge contains 0 center cells'       
                                write(*,*) 'Or the polygon is to small and is best to a discharge in a point or'
                                write(*,*) 'the polygon not define properly'
                                stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR160'
                            endif

                        endif


                    endif i3
                        
c1:                 select case (DischVertical)
                                
                        case (DischLayer_)

                            VectorK(:) = Kd

                        case (DischDepth_)
                
                            write(*,*) "VERTICAL DISCHARGE option not active - Depth  =",DischDepth_
                            write(*,*) 'This option is not active'
                            stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR170'

                        case (DischBottom_)

                            call GetGeometryKFloor(Me%ObjGeometry,                  &
                                                   Z = Me%External_Var%KFloor_Z,    &
                                                   STAT = STAT_CALL)

                            if (STAT_CALL /= SUCCESS_)                              &
                                stop 'Subroutine ReadLock_ModuleGeometry; module ModuleHydrodynamic. ERR180.'

n1:                         do nC =1, nCells

                                VectorK(nC) = Me%External_Var%Kfloor_Z(VectorI(nC), VectorJ(nC))

                            enddo n1
            
                            call UnGetGeometry(Me%ObjGeometry,                      &
                                                   Me%External_Var%KFloor_Z,        &
                                                   STAT = STAT_CALL)

                            if (STAT_CALL /= SUCCESS_)                              &
                                stop 'Subroutine ReadLock_ModuleGeometry; module ModuleHydrodynamic. ERR190.'


                        case (DischSurf_)
            
                            VectorK(:) = Me%WorkSize%KUB
            
                        case (DischUniform_)
                            !do not do nothing 
                        case default
                            write(*,*) "VERTICAL DISCHARGE option not known ", DischVertical

                            write(*,*) "The known options are : "," Bottom=",DischBottom_," Surface=",DischSurf_,&
                                                                  " Layer =",DischLayer_, " Depth  =",DischDepth_,&
                                                                  " Uniform=",DischUniform_
                            stop 'Subroutine ConstDischargeLoc; Module ModuleDischarges. ERR200'

                    end select c1

i4:                 if (SpatialEmission /= DischPoint_) then


                        call SetLocationCellsZ (Me%ObjDischarges, dn, nCells, VectorI, VectorJ, VectorK, STAT= STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR210'

                    else  i4
                        if (DischVertical == DischBottom_ .or. DischVertical == DischSurf_) then
                            call SetLayer (Me%ObjDischarges, dn, VectorK(nCells), STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR220' 
                        endif
                        deallocate(VectorI, VectorJ, VectorK)
                    endif i4

                enddo d1

                call UnGetHorizontalMap(Me%ObjHorizontalMap, WaterPoints2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR230' 
                
            else  i2
                Me%ObjDischarges = AssociateInstance (mDISCHARGES_, DischargesID)
            endif i2
            
            if (Me%OutPut%TimeSerieDischON) then
                call Construct_Time_Serie_Discharge
            endif                    

        endif i1

i8:     if (Me%ComputeOptions%Relaxation .or. Me%ComputeOptions%AltimetryAssimilation%Yes) then

            if (AssimilationID == 0) then   
                call StartAssimilation(Me%ObjAssimilation,                               &
                                       Me%ObjTime,                                       &
                                       Me%ObjGridData,                                   &
                                       Me%ObjHorizontalGrid,                             &
                                       Me%ObjHorizontalMap,                              &
                                       Me%ObjMap,                                        &
                                       Me%ObjGeometry,                                   &
                                       STAT = STAT_CALL)

                 if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR240'  
                                
                 AssimilationID = Me%ObjAssimilation
            else
                Me%ObjAssimilation = AssociateInstance (mASSIMILATION_, AssimilationID)
            endif       
        
        endif i8


        call GetContinuousGOTM(Me%ObjTurbulence, ContinuousGOTM, ModelGOTM, STAT = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Sub_Modules - Hydrodynamic - ERR250.')

i5:     if (ModelGOTM) then
i6:         if (Me%ComputeOptions%Continuous) then
i7:             if (.not. ContinuousGOTM)  then
                    write(*,*) 'Construct_Sub_Modules - Hydrodynamic - WARN01.'
                    write(*,*) 'Hydrodynamic - Continuous YES'
                    write(*,*) 'GOTM         - Continuous NO'
                    write(*,*) 'Press enter to procede OR controle break to stop the run'
                    read (*,*)
                endif i7
            endif i6

            if (.not.Me%ComputeOptions%Continuous) then
                if (ContinuousGOTM)                                                      &
                    call SetError(FATAL_, INTERNAL_, 'Construct_Sub_Modules - Hydrodynamic - ERR260.')
            endif
        endif i5


        !Opens the energy result file and allocates the buffer to store the data
        if (Me%ComputeOptions%Energy) &
            call ConstructEnergy

        if (Me%ComputeOptions%Relaxation) &
            call ConstructRelaxation     


        !Allocates and initialise the variables necessary to compute 
        !the tide potential
        if (Me%TidePotential%Compute)                                       &
            call ConstructTidePotential 


        !Allocates and initialise the variables necessary to run this model as submodel
        if (Me%SubModel%ON)                                                 &
            call ConstructSubModel 


        call ConstructHydroStatistic
        

    end subroutine Construct_Sub_Modules 
    
    
#ifdef OVERLAP
    subroutine ConstructHydroOverlap


        !Local-----------------------------------------------------------------
        integer                            :: STAT_CALL, iflag
        
        !----------------------------------------------------------------------

        call GetData(Me%ComputeOptions%Overlap,                                         &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'OVERLAP',                                        &
                     Default        = .false.,                                          & 
                     SearchType     = FromFile,                                         &
                     ClientModule   ='ModuleWaterProperties',                           &
                     STAT           = STAT_CALL)            
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'ConstructHydroOverlap - ModuleHydrodynamic - ERR01' 


    end subroutine ConstructHydroOverlap
#endif OVERLAP

  

    !End----------------------------------------------------------------------

!-------------------------------------------------------------------------
!        IST/MARETEC, Marine Modelling Group, Mohid2000 modelling system
!-------------------------------------------------------------------------

!BOP
!
! !ROUTINE: ConstructHydroStatistic

! !INTERFACE:

    subroutine ConstructHydroStatistic

! !INPUT PARAMETERS:


! !DESCRIPTION: 
!   This subroutine reads all the information needed to construct a statistic
!   object 
!   


 
! !REVISION HISTORY: 
!  01Nov2002   Paulo Chambel  the ConstructHydroStatistic routine calls from
!                             the ModuleStatistic the routine ConstructStatistic           

           
!EOP

!       Local ------------------------------------------------------------------------------
        integer                     :: Status
        integer                     :: iflag, FromFile, i
               
        !Begin----------------------------------------------------------------------------


        call GetExtractType     (FromFile = FromFile)

        !<BeginKeyword>
            !Keyword          : STATISTICS
            !<BeginDescription>       
               ! 
               ! Checks out if the user pretends the statistics of the hydrodynamic properties
               ! 
            !<EndDescription>
            !Type             : Boolean 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>
        call GetData(Me%Statistics%ON,                                                  &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword      = 'STATISTICS',                                       &
                     Default      = .false.,                                            &
                     SearchType   =  FromFile,                                          &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     STAT = Status)
        if (Status /= SUCCESS_)                                                         &
            call SetError(FATAL_, INTERNAL_, 'ConstructHydroStatistic - Hydrodynamic - ERR01') 

        
        if (Me%Statistics%ON) then

            !<BeginKeyword>
                !Keyword          : STATISTICS_FILE
                !<BeginDescription>       
                   ! 
                   ! The statistics definition file of the hydrodynamic properties
                   ! 
                !<EndDescription>
                !Type             : Character
                !Default          : Do not have
                !File keyword     : IN_DAD3D
                !Multiple Options : Do not have
                !Search Type      : FromFile
            !<EndKeyword>
            call GetData(Me%Statistics%File,                                            &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword      = 'STATISTICS_FILE',                              &
                         SearchType   = FromFile,                                       &
                         ClientModule = 'ModuleHydrodynamic',                           &
                         STAT = Status)
            if (Status /= SUCCESS_ .or. iflag /= 1)                                     &
                call SetError(FATAL_, INTERNAL_, 'ConstructHydroStatistic - Hydrodynamic - ERR02') 

            Me%Statistics%NProp = 4

            allocate(Me%Statistics%PropList(Me%Statistics%NProp))
            allocate(Me%Statistics%ID      (Me%Statistics%NProp))


            Me%Statistics%PropList(1) = VelocityU_
            Me%Statistics%PropList(2) = VelocityV_
            Me%Statistics%PropList(3) = VelocityW_
            Me%Statistics%PropList(4) = VelocityModulus_            
            
            Me%Statistics%ID(:) = 0

            do i=1, Me%Statistics%NProp

                call ConstructStatistic (Me%Statistics%ID(i),                               &
                                         Me%ObjTime,                                        &
                                         Me%ObjHDF5,                                        &
                                         Me%Size,                                           &
                                         Me%WorkSize,                                       &
                                         Me%Statistics%File,                                &
                                         GetPropertyName (Me%Statistics%PropList(i)),       &
                                         STAT = Status)
                if (Status /= SUCCESS_)                                                     &
                    call SetError(FATAL_, INTERNAL_, 'ConstructHydroStatistic - Hydrodynamic - ERR04') 
            enddo

        endif    

        !<BeginKeyword>
            !Keyword          : STATISTICS_2D
            !<BeginDescription>       
               ! 
               ! Checks out if the user pretends the statistics of the hydrodynamic properties
               ! 
            !<EndDescription>
            !Type             : Boolean 
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>
        call GetData(Me%Statistics2D%ON,                                                &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword      = 'STATISTICS_2D',                                    &
                     Default      = .false.,                                            &
                     SearchType   =  FromFile,                                          &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     STAT = Status)
        if (Status /= SUCCESS_)                                                         &
            call SetError(FATAL_, INTERNAL_, 'ConstructHydroStatistic - Hydrodynamic - ERR01') 
        
        if (Me%Statistics2D%ON) then

            !<BeginKeyword>
                !Keyword          : STATISTICS_FILE_2D
                !<BeginDescription>       
                   ! 
                   ! The statistics definition file of the hydrodynamic properties
                   ! 
                !<EndDescription>
                !Type             : Character
                !Default          : Do not have
                !File keyword     : IN_DAD3D
                !Multiple Options : Do not have
                !Search Type      : FromFile
            !<EndKeyword>
            call GetData(Me%Statistics2D%File,                                          &
                 Me%ObjEnterData, iflag,                                                &
                 Keyword      = 'STATISTICS_FILE_2D',                                   &
                 SearchType   = FromFile,                                               &
                 ClientModule = 'ModuleHydrodynamic',                                   &
                 STAT = Status)
            if (Status /= SUCCESS_ .or. iflag /= 1)                                     &
                call SetError(FATAL_, INTERNAL_, 'ConstructHydroStatistic - Hydrodynamic - ERR07') 
                
            Me%Statistics2D%NProp = 2

            allocate(Me%Statistics2D%PropList(Me%Statistics2D%NProp))

            Me%Statistics2D%PropList(1) = WaterLevel_
            Me%Statistics2D%PropList(2) = WaterColumn_

            allocate(Me%Statistics2D%ID      (Me%Statistics2D%NProp))
            Me%Statistics2D%ID(:) = 0

            
            do i=1, Me%Statistics2D%NProp
                
                call ConstructStatistic (Me%Statistics2D%ID(i),                             &
                                         Me%ObjTime,                                        &
                                         Me%ObjHDF5,                                        &
                                         Me%Size,                                           &
                                         Me%WorkSize,                                       &
                                         Me%Statistics2D%File,                              &
                                         GetPropertyName (Me%Statistics2D%PropList(i)),     &
                                         STAT = Status)
                if (Status /= SUCCESS_)                                                     &
                    call SetError(FATAL_, INTERNAL_, 'ConstructHydroStatistic - Hydrodynamic - ERR08') 
            enddo
        endif

        
    end subroutine ConstructHydroStatistic

    !--------------------------------------------------------------------------




    !--------------------------------------------------------------------------

    subroutine StartOutputBoxFluxes

        !Arguments-------------------------------------------------------------

         

        !External--------------------------------------------------------------

        integer :: STAT_CALL
        integer :: iflag, FromFile
        integer :: ILB, IUB
        integer :: JLB, JUB
        integer :: KLB, KUB

        logical :: exist, opened
        character(len=StringLength), dimension(:),  pointer :: FluxesOutputList
        character(len=StringLength), dimension(:),  pointer :: ScalarOutputList

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB 
        IUB = Me%Size%IUB 

        JLB = Me%Size%JLB 
        JUB = Me%Size%JUB 

        KLB = Me%Size%KLB 
        KUB = Me%Size%KUB 

        call GetWaterPoints3D(Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) stop 'StartOutputBoxFluxes - ModuleHydrodynamic - ERR01'
        
        call GetExtractType  (FromFile = FromFile)

        !<BeginKeyword>
            !Keyword          : BOXFLUXES
            !<BeginDescription>       
               ! 
               !The user can give the name of the file boxes definition
               !If this file exist then the model computes water fluxes between boxes
               !
            !<EndDescription>
            !Type             : Character 
            !Default          : ******.***

            !File keyword     : IN_DAD3D 
            !Multiple Options : Do not 
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%Files%BoxFluxesFileName,                                        &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'BOXFLUXES',                                      &
                     Default        = '******.***',                                     &
                     SearchType     = FromFile,                                         &
                     ClientModule   ='ModuleHydrodynamic',                              &
                     STAT           = STAT_CALL)                                      

        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Subroutine StartOutputBoxFluxes; Module ModuleHydrodynamic. ERR02.'

cd6 :   if (iflag .EQ. 1) then
            inquire(FILE = Me%Files%BoxFluxesFileName, EXIST = exist)
cd4 :       if (exist) then
                Me%State%BOXFLUXES = ACTIVE

                inquire(FILE = Me%Files%BoxFluxesFileName, OPENED  = opened)
cd5 :           if (opened) then
                    write(*,*    ) 
                    write(*,'(A)') 'BoxFluxesFileName = ', Me%Files%BoxFluxesFileName
                    write(*,*    ) 'Already opened.'
                    stop           'Subroutine StartOutputBoxFluxes; Module Hydrodynamic. ERR04'    
                end if cd5

                allocate(FluxesOutputList(1), ScalarOutputList(1)) 

                FluxesOutputList = Char_Water
                ScalarOutputList = Char_Water

                call StartBoxDif(BoxDifID         = Me%ObjBoxDif,                    &
                                 TimeID           = Me%ObjTime,                      &
                                 HorizontalGridID = Me%ObjHorizontalGrid,            &
                                 BoxesFilePath    = Me%Files%BoxFluxesFileName,      &
                                 FluxesOutputList = FluxesOutputList,                &
                                 ScalarOutputList = ScalarOutputList,                &
                                 WaterPoints3D    = Me%External_Var%WaterPoints3D,   &
                                 Size3D           = Me%Size,                         &
                                 WorkSize3D       = Me%WorkSize,                     &
                                 STAT             = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                         &
                    stop 'Subroutine StartOutputBoxFluxes; module ModuleWaterProperties. ERR15.'

                deallocate(FluxesOutputList, ScalarOutputList) 
                nullify   (FluxesOutputList, ScalarOutputList)
                
            else
                write(*,*) 
                write(*,*)     'Error dont have the file box.'
                write(*,'(A)') 'BoxFileName = ', Me%Files%BoxFluxesFileName
                stop           'Subroutine StartOutputBoxFluxes; Module Hydrodynamic. ERR03'    
            end if cd4

        else
            Me%State%BOXFLUXES = IDLE
        end if cd6
        
        call UnGetMap (Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) stop 'StartOutputBoxFluxes - ModuleHydrodynamic - ERR99'


        !----------------------------------------------------------------------

    end subroutine StartOutputBoxFluxes

    !--------------------------------------------------------------------------
!-------------------------------------------------------------------------
!        IST/MARETEC, Marine Modelling Group, Mohid2000 modelling system
!-------------------------------------------------------------------------

!BOP
!
! !ROUTINE: Construct_OutPutTime

! !INTERFACE:

    subroutine Construct_OutPutTime

! !INPUT PARAMETERS:

! !DESCRIPTION: 
!     This routine is a public one and is responsible for the definition 
!     of the hydrodynamic output results

 
! !REVISION HISTORY: 
!  20Nov2000   Paulo Chambel  the Construct_OutPutTime calls from
!                             the ModuleEnterData the routine GetOutPutTime           


           
!EOP

!       Local ------------------------------------------------------------------------------
        integer                             :: STAT_CALL
        integer                             :: iflag, iW
       
        !Begin----------------------------------------------------------------------------


        call GetOutPutTime(Me%ObjEnterData,                                             &
                           CurrentTime   = Me%CurrentTime,                              &
                           EndTime       = Me%EndTime,                                  &
                           keyword       = 'OUTPUT_TIME',                               &
                           SearchType    = FromFile,                                    &
                           OutPutsTime   = Me%OutPut%OutTime,                           &
                           OutPutsOn     = Me%OutPut%HDF5ON,                            &
                           OutPutsNumber = Me%OutPut%Number,                            &
                           STAT          = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_OutPutTime - Hydrodynamic - ERR10') 

                    
        if (Me%OutPut%HDF5ON) then 

            Me%OutPut%NextOutPut = 1

        endif


        call GetOutPutTime(Me%ObjEnterData,                                             &
                           CurrentTime  = Me%CurrentTime,                               &
                           EndTime      = Me%EndTime,                                   &
                           keyword      = 'RESTART_FILE_OUTPUT_TIME',                   &
                           SearchType   = FromFile,                                     &
                           OutPutsTime  = Me%OutPut%RestartOutTime,                     &
                           OutPutsOn    = Me%OutPut%WriteRestartFile,                   &
                           STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_OutPutTime - Hydrodynamic - ERR20') 

        if(Me%OutPut%WriteRestartFile)then

            Me%OutPut%NextRestartOutput = 1

        end if 

        !<BeginKeyword>
            !Keyword          : RESTART_FILE_OVERWRITE
            !<BeginDescription>       
               ! 
               ! This option checks wether the restart file is to be overwritten or not
               ! 
            !<EndDescription>
            !Type             : logical 
            !Default          : .true.
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>
        
        call GetData(Me%OutPut%RestartOverwrite,                                        &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'RESTART_FILE_OVERWRITE',                           &
                     Default      = .true.,                                             &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, "Construct_OutPutTime - Hydrodynamic - ERR30")


        call GetOutPutTime(Me%ObjEnterData,                                             &
                           CurrentTime  = Me%CurrentTime,                               &
                           EndTime      = Me%EndTime,                                   &
                           keyword      = 'SURFACE_OUTPUT_TIME',                        &
                           SearchType   = FromFile,                                     &
                           OutPutsTime  = Me%OutPut%SurfaceOutTime,                     &
                           OutPutsOn    = Me%OutPut%HDF5_Surface_ON,                    &
                           OutputsNumber= Me%OutPut%NumberSurfaceOutputs,               &
                           STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_OutPutTime - Hydrodynamic - ERR40') 

        if(Me%OutPut%HDF5_Surface_ON)then

            Me%OutPut%NextSurfaceOutput = 1

        end if

        call GetData(Me%OutPut%Faces,                                                   &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'OUTPUT_FACES',                                     &
                     Default      = .false.,                                            &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, 'Construct_OutPutTime - Hydrodynamic - ERR50')
            
        call GetOutPutTimeWindows(EnterDataID     = Me%ObjEnterData,                    & 
                                  CurrentTime     = Me%CurrentTime,                     &
                                  EndTime         = Me%EndTime,                         &
                                  OutPutWindows   = Me%OutW%OutPutWindows,              &   
                                  OutPutWindowsON = Me%OutW%OutPutWindowsON,            & 
                                  WindowsNumber   = Me%OutW%WindowsNumber,              &   
                                  STAT            = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_OutPutTime - Hydrodynamic - ERR60')
            
         if(Me%OutW%OutPutWindowsON)then

            allocate(Me%OutW%ObjHDF5(Me%OutW%WindowsNumber))
            
            do iW = 1, Me%OutW%WindowsNumber
                Me%OutW%OutPutWindows%NextOutPut = 1
            enddo 

        end if
   
      
        !<BeginKeyword>
            !Keyword          : SIMPLE_WINDOW_OUTPUT
            !<BeginDescription>       
               ! 
               ! This option checks wether the end user wants to output only the basic properties in the window output
               ! 
            !<EndDescription>
            !Type             : logical 
            !Default          : .true.
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>
        
        call GetData(Me%OutW%Simple,                                                    &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'SIMPLE_WINDOW_OUTPUT',                             &
                     Default      = .true.,                                             &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, "Construct_OutPutTime - Hydrodynamic - ERR40")

    

    end subroutine Construct_OutPutTime

    !----------------------------------------------------------------------------

    subroutine ConstructHydrodynamicProperties

        !Local----------------------------------------------------------------
        real,    dimension(:,:  ), pointer  :: Bathymetry
        integer, dimension(:,:,:), pointer  :: InitialComputeFacesU3D, InitialComputeFacesV3D
        real                                :: InteriorElevation
        real                                :: AverageBoundaryElevation
        real                                :: MinWaterColumn
        integer                             :: ILB, IUB
        integer                             :: JLB, JUB
        integer                             :: KLB, KUB
        integer                             :: i, j, k, STAT_CALL, Evolution
        integer                             :: InputStateEx

        !Begin----------------------------------------------------------------
        
        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB


        !The open boundary module must be initialised here because the OpenBoundary is
        !used in this subroutine to estimate the initial water level.
        call ConstructOpenBoundary(Me%ObjOpenBoundary,                                  &
                                   Me%ObjHorizontalGrid,                                &
                                   Me%ObjHorizontalMap,                                 &
                                   Me%ObjTime,                                          &
                                   Me%ComputeOptions%Compute_Tide,                      &
                                   Me%WaterLevel%Default,                               &
                                   Me%ComputeOptions%TideSlowStartCoef,                 &
                                   Me%ComputeOptions%InvertBarometer,                   &
                                   Me%ComputeOptions%InvertBaromSomeBound,              &
                                   Me%ComputeOptions%InvertBarometerCells,              &
                                   STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &       
            stop 'Subroutine ConstructHydrodynamicProperties; ModuleHydrodynamic. ERR10.'  


do1:    do  j=JLB, JUB
do2:    do  i=ILB, IUB

do3:        do  k=KLB, KUB
                !Explicit Forces
                Me%Forces%Horizontal_Transport          (i, j, k) = 0.
                Me%Forces%Inertial_Aceleration          (i, j, k) = 0.
                Me%Forces%Rox3X                         (i, j, k) = 0.
                Me%Forces%Rox3Y                         (i, j, k) = 0.
            enddo do3

            do  k=KLB, KUB+1
                !Vertical velocity
                Me%Velocity%Vertical%Across             (i, j, k) = 0.
                Me%Velocity%Vertical%Cartesian          (i, j, k) = 0.
                !NonHydrostatic
                if (Me%NonHydrostatic%ON) then
                    Me%Velocity%Vertical%CartesianOld   (i, j, k) = 0.
                    Me%NonHydrostatic%PressureCorrect   (i, j, k) = 0.
                    Me%NonHydrostatic%PrevisionalQ      (i, j, k) = 0.
                endif
            enddo 
 
            !Tide potential
            Me%Forces%TidePotentialLevel   (i, j) = 0.

        enddo do2   
        enddo do1

cd1:    if (Me%ComputeOptions%Continuous) then

            call Read_Final_Hydrodynamic_File

        else cd1


cd2:        if (Me%ComputeOptions%Num_Discretization == Leendertse) then

                !By default the previous direction is X to alow the model start 
                !the calculations in X direction when using the Leendertse Scheme
                Me%Direction%XY = DirectionX_
                Me%Direction%YX = DirectionY_

            else if (Me%ComputeOptions%Num_Discretization == Abbott) then cd2


                !By default the previous direction is Y to alow the model start 
                !the calculations in X direction when using the Abbott Scheme
                Me%Direction%XY = DirectionY_  
                Me%Direction%YX = DirectionX_  


            endif cd2


            if      (Me%ComputeOptions%Vertical_AxiSymmetric_Model == DirectionX_) then

                Me%Direction%XY = DirectionX_
                Me%Direction%YX = DirectionY_

            else if (Me%ComputeOptions%Vertical_AxiSymmetric_Model == DirectionY_) then

                Me%Direction%XY = DirectionY_
                Me%Direction%YX = DirectionX_

            endif 

            !Gets Bathymetry
            call GetGridData(Me%ObjGridData, &
                               Bathymetry, STAT = STAT_CALL)
            
            if (STAT_CALL /= SUCCESS_) &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR20'


            call GetGeometryMinWaterColumn(Me%ObjGeometry, &
                                           MinWaterColumn, STAT = STAT_CALL)
            
            if (STAT_CALL /= SUCCESS_) &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR30'



            !Water elevation initialization
            call Modify_OpenBoundary(Me%ObjOpenBoundary,                                 &
                                     Me%CurrentTime,                                     &
                                     Me%External_Var%AtmosphericPressure,                &
                                     Me%ComputeOptions%AtmosphereCoef,                   & 
                                     STAT        = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR40'

            call GetAverageImposedElevation (Me%ObjOpenBoundary, &
                                             AverageBoundaryElevation, STAT =STAT_CALL )

            if (STAT_CALL /= SUCCESS_)                                        &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR50'


cd3:        if (Me%ComputeOptions%InitialElevation) then
                
                InteriorElevation = Me%WaterLevel%Default

            else  cd3

                InteriorElevation = AverageBoundaryElevation 

            endif cd3

            !Gets WaterPoints2D
            call GetWaterPoints2D(Me%ObjHorizontalMap, &
                                  Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR60'


do4:        do  j=JLB, JUB
do5:        do  i=ILB, IUB
                    
cd4:            if (Me%External_Var%WaterPoints2D(i, j) == WaterPoint) then
                    
cd5:                if (InteriorElevation > (- Bathymetry(i, j) + MinWaterColumn)) then

                        Me%WaterLevel%New(i, j) =  InteriorElevation            

                    else  cd5
               
                        !The next line is changed to avoid rounding erros.
                        !Frank Jan 2001
!                        Me%WaterLevel%New(i, j) =  - Bathymetry(i, j) + MinWaterColumn
                        Me%WaterLevel%New(i, j) =  - Bathymetry(i, j) + 0.999 * MinWaterColumn

                    endif cd5

                    Me%WaterLevel%Old(i, j) = Me%WaterLevel%New(i, j)

                endif cd4

            enddo do5
            enddo do4   

            !UnGets WaterPoints2D
            call UnGetHorizontalMap(Me%ObjHorizontalMap, &
                                  Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR70'


cd6:        if (Me%ComputeOptions%Residual) then 

do8:            do  j=JLB, JUB
do9:            do  i=ILB, IUB

                    Me%Residual%WaterLevel(i, j) = Me%WaterLevel%New(i, j)

                enddo do9
                enddo do8
            
            endif cd6


            ! Z direction
do10:       do  k=KLB, KUB+1
do11:       do  j=JLB, JUB
do12:       do  i=ILB, IUB

                Me%WaterFluxes%Z(i, j, k) =    0.

                if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_)  then

                    Me%VelBaroclinic%W_New   (i, j, k) =   0.
                    Me%VelBaroclinic%W_Old   (i, j, k) =   0.

                endif

                
cd7:            if (Me%ComputeOptions%Residual) then 

                    !Vertical velocity
                    Me%Residual%Vertical_Velocity (i, j, k) = 0.

                endif cd7

            enddo do12
            enddo do11  
            enddo do10

            if (Me%ComputeOptions%Residual) then
                !Number of iterations where residual properties was compute
                Me%Residual%ResidualTime    = 0
                !Residual Layer Thickness
                Me%Residual%DWZ(ILB:IUB, JLB:JUB, KLB:KUB) = 0.

            endif
                

            !X direction
do13:       do  k=KLB, KUB
do14:       do  j=JLB, JUB + 1
do15:       do  i=ILB, IUB

                !Horizontal Velocity
                Me%Velocity%Horizontal%U%New(i, j, k) =                     &
                    Me%Velocity%Horizontal%U%Default

                !Water fluxes D3
                Me%WaterFluxes%X(i, j, k)             =   0.

                if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_)  then

                    Me%VelBaroclinic%U%New(i, j, k) =   0.
                    Me%VelBaroclinic%U%Old(i, j, k) =   0.

                endif


                
cd8:            if (Me%ComputeOptions%Residual) then 


                    !Horizontal velocity
                    Me%Residual%Velocity_U(i, j, k)   =   0.

                    !Residual specific water fluxes
                    Me%Residual%WaterFlux_X(i, j, k)  =   0. 

                endif cd8

            enddo do15
            enddo do14  
            enddo do13


            ! Y direction
do16:       do  k=KLB, KUB
do17:       do  j=JLB, JUB
do18:       do  i=ILB, IUB + 1

                !Horizontal Velocity
                Me%Velocity%Horizontal%V%New(i, j, k) = Me%Velocity%Horizontal%V%Default



                !Water fluxes D3
                Me%WaterFluxes%Y(i, j, k)                =   0.

                if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_)  then

                    Me%VelBaroclinic%V%New(i, j, k) =   0.
                    Me%VelBaroclinic%V%Old(i, j, k) =   0.

                endif

               
cd9:            if (Me%ComputeOptions%Residual) then 

                    !Horizontal velocity
                    Me%Residual%Velocity_V (i, j, k)  =   0.

                    !Residual water fluxes
                    Me%Residual%WaterFlux_Y(i, j, k)  =   0.  

                endif cd9

            enddo do18
            enddo do17  
            enddo do16


            !Disposes pointer to the Bathymetry
            call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR80'



        endif cd1




        !If the hydrodynamic is read from a file
        Evolution = Me%ComputeOptions%Evolution


cd10:   if (Evolution == Read_File_) then
            call GetHydrodynamicFileIOState(InputStateEx = InputStateEx)
            call StartHydrodynamicFile (Me%ObjHydrodynamicFileIn,                       &
                                        Me%ObjGridData,                                 &
                                        Me%ObjHorizontalGrid,                           &
                                        Me%ObjGeometry,                                 &
                                        Me%ObjMap,                                      &
                                        Me%ObjHorizontalMap,                            &
                                        Me%ObjTime,                                     &
                                        InputStateEx,                                   &
                                        InitialWaterLevel      =                        &
                                        Me%WaterLevel%New,                              &
                                        InitialWaterFluxX      =                        &
                                        Me%WaterFluxes%X,                               &
                                        InitialWaterFluxY      =                        &
                                        Me%WaterFluxes%Y,                               &
                                        InitialDischarges      =                        &
                                        Me%WaterFluxes%Discharges,                      &
                                        InitialComputeFacesU3D =                        &
                                        InitialComputeFacesU3D,                         &
                                        InitialComputeFacesV3D =                        &
                                        InitialComputeFacesV3D,                         &
                                        STAT = STAT_CALL)            

             if (STAT_CALL /= SUCCESS_)                                                 &
                stop 'Subroutine ConstructHydrodynamicProperties; Module ModuleHydrodynamic. ERR90.' 

             call SetComputesFaces3D(Me%ObjMap,                                         &
                                InitialComputeFacesU3D,                                 &
                                InitialComputeFacesV3D,                                 &
                                Me%CurrentTime,                                         &
                                STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine ConstructHydrodynamicProperties; Module ModuleHydrodynamic. ERR100.' 
 
            nullify(InitialComputeFacesU3D, InitialComputeFacesV3D)

        endif cd10

        if(Me%ComputeOptions%Obstacle)then

            call ConstructDragCoefficients

        end if
        
        if (Me%ComputeOptions%Scraper) then        
        
            call ConstructScraper
            
        endif
        !------------------------------------------------------------------------

    end subroutine ConstructHydrodynamicProperties
    
    !----------------------------------------------------------------------------


    !----------------------------------------------------------------------------

    subroutine InitialReferenceWaterFluxes

        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_X, WaterFlux_Y
        real,    dimension(:,:,:), pointer :: Velocity_U, Velocity_V, Area_U, Area_V

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_U, ComputeFaces3D_V
        integer, dimension(:,:),   pointer :: KFloor_U, KFloor_V

        integer                            :: I, J, K, Kbottom

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, Grid, Evolution

        !--------------------------------------------------------------------------

        !If the hydrodynamic is read from a file
        Evolution = Me%ComputeOptions%Evolution


        !PCL
cd1:    if (.not. Me%ComputeOptions%Continuous .and.                        &
            .not. Evolution == Read_File_ .and. Me%Relaxation%Velocity )  then               
            

            !To let the model take access to the Mapping and geometry variables
            call ReadLock_External_Modules


            !Begin - Shorten variables name 
            IUB = Me%WorkSize%IUB
            ILB = Me%WorkSize%ILB
            JUB = Me%WorkSize%JUB
            JLB = Me%WorkSize%JLB
            KUB = Me%WorkSize%KUB
            KLB = Me%WorkSize%KLB


            WaterFlux_X      => Me%WaterFluxes%X
            WaterFlux_Y      => Me%WaterFluxes%Y

            Velocity_U       => Me%Velocity%Horizontal%U%New
            Velocity_V       => Me%Velocity%Horizontal%V%New

            ComputeFaces3D_U => Me%External_Var%ComputeFaces3D_U
            ComputeFaces3D_V => Me%External_Var%ComputeFaces3D_V

            KFloor_U         => Me%External_Var%KFloor_U
            KFloor_V         => Me%External_Var%KFloor_V

            Area_U           => Me%External_Var%Area_U
            Area_V           => Me%External_Var%Area_V


            !End - Shorten variables name 

            call SetMatrixValue(WaterFlux_X, Me%WorkSize, dble(0.0))

        doj: do j = JLB, JUB
        doi: do i = ILB, IUB

        Cov1:   if (ComputeFaces3D_U(I, J, KUB) == Covered) then

                    Kbottom = KFloor_U(i, j)

        dok:        do  k = Kbottom, KUB
 
                        ![m^3/s]              = [ ] * [m/s] * [m^2]
                        WaterFlux_X(i, j, k) = Velocity_U(i, j, k) * &
                                                dble(Area_U(i, j, k))
                    enddo dok

                endif Cov1

            enddo doi
            enddo doj

            call SetMatrixValue(WaterFlux_Y, Me%WorkSize, dble(0.0))

        doj1: do j = JLB, JUB
        doi1: do i = ILB, IUB

        Cov2:   if (ComputeFaces3D_V(I, J, KUB) == Covered) then

                    Kbottom = KFloor_V(i, j)

        dok1:        do  k = Kbottom, KUB
 
                        ![m^3/s]              = [ ] * [m/s] * [m^2]
                        WaterFlux_Y(i, j, k) = Velocity_V(i, j, k) * &
                                                dble(Area_V(i, j, k))
                    enddo dok1

                endif Cov2

            enddo doi1
            enddo doj1

            !Nullify auxiliar variables
            nullify (WaterFlux_X)
            nullify (WaterFlux_Y)
            nullify (Velocity_U)
            nullify (Velocity_V)

            nullify (ComputeFaces3D_U)
            nullify (ComputeFaces3D_V)
            
            nullify (KFloor_U)
            nullify (KFloor_V)

            nullify (Area_U) 
            nullify (Area_V)

            call ModifyWaterDischarges 

            Grid = Fix

            call New_VerticalHydrodynamic( Grid)

            !Unget the Mapping and geometry variables
            call ReadUnLock_External_Modules

        endif cd1


        !This is necessary because the Residual Vertical flux is not been compute
cd2:    if (Me%ComputeOptions%Evolution == Residual_hydrodynamic_ .or.      &
            Me%ComputeOptions%Evolution == No_hydrodynamic_) then

            !To let the model take access to the Mapping and geometry variables
            call ReadLock_External_Modules

            Grid = Fix

            call New_VerticalHydrodynamic( Grid)

            !Unget the Mapping and geometry variables
            call ReadUnLock_External_Modules

        endif cd2


    end subroutine InitialReferenceWaterFluxes

    !----------------------------------------------------------------------------

    subroutine InitialHydrodynamicFileVel

        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_X, WaterFlux_Y
        real,    dimension(:,:,:), pointer :: Velocity_U, Velocity_V, Area_U, Area_V

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_U, ComputeFaces3D_V
        integer, dimension(:,:),   pointer :: KFloor_U, KFloor_V

        integer                            :: I, J, K, Kbottom

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, Evolution, Grid

        !--------------------------------------------------------------------------

        !If the hydrodynamic is read from a file
        Evolution = Me%ComputeOptions%Evolution

cd1:    if (Evolution == Read_File_) then

            !To let the model take access to the Mapping and geometry variables
            call ReadLock_External_Modules


            !Begin - Shorten variables name 
            IUB = Me%WorkSize%IUB
            ILB = Me%WorkSize%ILB
            JUB = Me%WorkSize%JUB
            JLB = Me%WorkSize%JLB
            KUB = Me%WorkSize%KUB
            KLB = Me%WorkSize%KLB


            WaterFlux_X      => Me%WaterFluxes%X
            WaterFlux_Y      => Me%WaterFluxes%Y

            Velocity_U       => Me%Velocity%Horizontal%U%New
            Velocity_V       => Me%Velocity%Horizontal%V%New

            ComputeFaces3D_U => Me%External_Var%ComputeFaces3D_U
            ComputeFaces3D_V => Me%External_Var%ComputeFaces3D_V

            KFloor_U         => Me%External_Var%KFloor_U
            KFloor_V         => Me%External_Var%KFloor_V

            Area_U           => Me%External_Var%Area_U
            Area_V           => Me%External_Var%Area_V


            !End - Shorten variables name 



            Velocity_U(:,:,:) = 0.

        doj: do j = JLB, JUB
        doi: do i = ILB, IUB

        Cov1:   if (ComputeFaces3D_U(I, J, KUB) == Covered) then

                    Kbottom = KFloor_U(i, j)

        dok:        do  k = Kbottom, KUB
 
                        ! [m/s]               = [m^3/s] / [m^2]
                        Velocity_U(i, j, k)   = real(WaterFlux_X(i, j, k) /              &
                                                dble(Area_U(i, j, k)))
                    enddo dok

                endif Cov1

            enddo doi
            enddo doj


            Velocity_V(:,:,:) = 0.

        doj1: do j = JLB, JUB
        doi1: do i = ILB, IUB

        Cov2:   if (ComputeFaces3D_V(I, J, KUB) == Covered) then

                    Kbottom = KFloor_V(i, j)

        dok1:        do  k = Kbottom, KUB
 
                        ! [m/s]               = [m^3/s] / [m^2]
                        Velocity_V(i, j, k)   = real(WaterFlux_Y(i, j, k) /              &
                                                dble(Area_V(i, j, k)))
                    enddo dok1

                endif Cov2

            enddo doi1
            enddo doj1

            !Nullify auxiliar variables
            nullify (WaterFlux_X)
            nullify (WaterFlux_Y)
            nullify (Velocity_U)
            nullify (Velocity_V)

            nullify (ComputeFaces3D_U)
            nullify (ComputeFaces3D_V)
            
            nullify (KFloor_U)
            nullify (KFloor_V)

            nullify (Area_U) 
            nullify (Area_V)

            call ModifyWaterDischarges 

            Grid = Fix

            call New_VerticalHydrodynamic( Grid)

            !Unget the Mapping and geometry variables
            call ReadUnLock_External_Modules

        endif cd1


    end subroutine InitialHydrodynamicFileVel


    !----------------------------------------------------------------------------

    subroutine NewEqualsOld

        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------

            Me%Velocity%Horizontal%U%Old(:,:,:) = Me%Velocity%Horizontal%U%New(:,:,:)
            Me%Velocity%Horizontal%V%Old(:,:,:) = Me%Velocity%Horizontal%V%New(:,:,:)

            Me%WaterLevel%Old(:,:)              = Me%WaterLevel%New(:,:)

    end subroutine NewEqualsOld


    !--------------------------------------------------------------------------
    !If the user want's to use the values of a previous   
    ! run the read the property values form the final      
    ! results file of a previous run. By default this      
    ! file is in HDF format                                

    subroutine Read_Final_Hydrodynamic_File

        !Arguments-------------------------------------------------------------

         

        !External--------------------------------------------------------------

        integer :: STAT_CALL

        !Local-----------------------------------------------------------------
        real   , dimension(:,:  ), pointer :: Aux2D
        real   , dimension(:,:,:), pointer :: Aux3D
        real(8), dimension(:,:,:), pointer :: Aux3DDouble

        type (T_Time)                      :: BeginTime, EndTimeFile, EndTime

        real                               :: Year_File, Month_File, Day_File,           &
                                              Hour_File, Minute_File, Second_File,       &
                                              DT_error
        real                               :: Previous_Discretization

        integer                            :: IUB, JUB, KUB, ILB, JLB, KLB
        integer                            :: InitialFile, i, j, k, Evolution
        integer                            :: BaroclinicRadia
        logical                            :: EXT, Residual
        !----------------------------------------------------------------------

        ILB = Me%Size%ILB 
        IUB = Me%Size%IUB

        JLB = Me%Size%JLB 
        JUB = Me%Size%JUB 

        KLB = Me%Size%KLB 
        KUB = Me%Size%KUB 


        inquire (FILE=Me%Files%InitialHydrodynamic, EXIST=EXT) 

        if (.not.EXT)                                                                    &
            call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR01.')


        call UnitsManager(InitialFile, FileOpen, STAT = STAT_CALL) 

        if (STAT_CALL /= SUCCESS_)                                                          &
             call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR02.')

        open(Unit = InitialFile, File = Me%Files%InitialHydrodynamic,       &
             Form = 'UNFORMATTED', status = 'OLD', IOSTAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                          &
             call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR03.')

        !Start reading the end file of the previous run 
        read(InitialFile) Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File


        call SetDate(EndTimeFile, Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File)


        call GetComputeTimeLimits(Me%ObjTime, BeginTime = BeginTime, &
                                  EndTime = EndTime, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                          &
             call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR04.')
        
        DT_error = EndTimeFile - BeginTime

        !Avoid rounding erros - Frank 08-2001
        if (abs(DT_error) >= 0.01) then
            
            write(*,*) 'The end time of the previous run is different from the start time of this run'
            write(*,*) 'Date in the file'
            write(*,*) Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File
            write(*,*) 'DT_error', DT_error
            call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR05.')


        endif

        read(InitialFile) Previous_Discretization
        
        if (Previous_Discretization /= Me%ComputeOptions%Num_Discretization) then

            write(*,*) 'previous run time discretization is different from this one'

            call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR06.')


        endif


        read(InitialFile) Residual

        !Read the last direction computed implicit by the model
        read(InitialFile) Me%Direction%XY 
        

        !Water level

        read(InitialFile) ((Me%WaterLevel%New(i, j), &
                           i = ILB, IUB), j = JLB, JUB)

        Me%WaterLevel%Old (:,:) = Me%WaterLevel%New(:,:)


        !Horizontal velocity Old
        read(InitialFile) (((Me%Velocity%Horizontal%U%Old(i, j, k), &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


        read(InitialFile) (((Me%Velocity%Horizontal%V%Old(i, j, k), &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        !Horizontal velocity New
        read(InitialFile) (((Me%Velocity%Horizontal%U%New(i, j, k), &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        read(InitialFile) (((Me%Velocity%Horizontal%V%New(i, j, k), &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


        !Water fluxes
        read(InitialFile) (((Me%WaterFluxes%X(i, j, k), &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        read(InitialFile) (((Me%WaterFluxes%Y(i, j, k) , &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                            
        read(InitialFile) (((Me%WaterFluxes%Z(i, j, k), &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


        Evolution = Me%ComputeOptions%Evolution

        
        if (Evolution == Residual_hydrodynamic_ .and. .not. Residual) then

            write(*,*) 'Can not have a residual evolution with out a initial file with residual values'
                        
            call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR07.')


        endif 

      
cd1:    if (Residual .and. .not. Me%ComputeOptions%Residual) then
   
            write(*,*)  
            write(*,*)  
            write(*,*)  
            write(*,*) 'Warning: YOU HAVE STOPPED THE RESIDUAL CALCULATION, '                   
            write(*,*) 'In the run before this one you have compute residual currents, '                   
            write(*,*) 'In this run you dont want to compute residual currents ? '                   
            write(*,*) '                        '
            write(*,*) 'SUBROUTINE Read_Final_Hydrodynamic_File; Module ModuleHydrodynamic. WRN01.'
            write(*,*)  
            write(*,*)  
            write(*,*)  

            allocate (Aux2D         (ILB:IUB, JLB:JUB))
            allocate (Aux3D         (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Aux3DDouble   (ILB:IUB, JLB:JUB, KLB:KUB))

            read(InitialFile) Me%Residual%ResidualTime

            !Average water level 
            read(InitialFile) ((Aux2D(i, j), i = ILB, IUB), j = JLB, JUB)

            !Residual horizontal velocities
            read(InitialFile) (((Aux3D(i, j, k), i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            read(InitialFile) (((Aux3D(i, j, k), i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !Residual vertical velocity  
            read(InitialFile) (((Aux3D(i, j, k), i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !Residual Water specific fluxes 
            read(InitialFile) (((Aux3DDouble(i, j, k), i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            read(InitialFile) (((Aux3DDouble(i, j, k), i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


            deallocate (Aux2D)
            deallocate (Aux3D)
            deallocate (Aux3DDouble)
       
        else if (Residual .and. Me%ComputeOptions%Residual) then cd1

           
            read(InitialFile) Me%Residual%ResidualTime

            !Average water level 
            read(InitialFile) ((Me%Residual%WaterLevel(i, j),               &
                               i = ILB, IUB), j = JLB, JUB)

            !Residual horizontal velocities
            read(InitialFile) (((Me%Residual%Velocity_U(i, j, k),           &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            read(InitialFile) (((Me%Residual%Velocity_V(i, j, k),           &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !Residual vertical velocity  
            read(InitialFile) (((Me%Residual%Vertical_Velocity(i, j, k),    &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !Residual Water specific fluxes 
            read(InitialFile) (((Me%Residual%WaterFlux_X(i, j, k),          &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            read(InitialFile) (((Me%Residual%WaterFlux_Y(i, j, k) ,         &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            
cd2:        if (Evolution == Residual_hydrodynamic_) then

                Me%WaterLevel%Old(:,:) = Me%Residual%WaterLevel(:,:)

                Me%WaterLevel%New(:,:) = Me%Residual%WaterLevel(:,:)


                Me%Velocity%Horizontal%U%Old(:,:,:) = Me%Residual%Velocity_U(:,:,:)

                Me%Velocity%Horizontal%U%New(:,:,:) = Me%Residual%Velocity_U(:,:,:)


                Me%Velocity%Horizontal%V%Old(:,:,:) = Me%Residual%Velocity_V(:,:,:)

                Me%Velocity%Horizontal%V%New(:,:,:) = Me%Residual%Velocity_V(:,:,:)

                !Module - ModuleHorizontalGrid
                !Horizontal Grid properties
                 call GetHorizontalGrid(Me%ObjHorizontalGrid,                           &
                                        DXX  = Me%External_Var%DXX,                     &
                                        DYY  = Me%External_Var%DYY,                     &
                                        STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                              &
                     call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR40.')

                do k = KLB, KUB
                do j = JLB, JUB
                do i = ILB, IUB

                    ![m3/s]                 = [m2/s] * [m]
                    Me%WaterFluxes%X(i,j,k) = Me%Residual%WaterFlux_X(i,j,k) * Me%External_Var%DYY(i, J)
                    Me%WaterFluxes%Y(i,j,k) = Me%Residual%WaterFlux_Y(i,j,k) * Me%External_Var%DXX(i, J)

                enddo
                enddo
                enddo
                    
                call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Me%External_Var%DXX,     &
                                         STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                     call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR50.')



                call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Me%External_Var%DYY,     &
                                         STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                     call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR60.')




            endif cd2


        else if (.not. Residual .and. Me%ComputeOptions%Residual) then cd1

                Me%Residual%ResidualTime    =  0


                do  j = JLB, JUB 
                do  i = ILB, IUB

                    Me%Residual%WaterLevel(i, j)    =  0.

                    do  k = KLB, KUB

                        !Residual horizontal velocity
                        Me%Residual%Velocity_U(i, j, k) =  0.
                        Me%Residual%Velocity_V(i, j, k) =  0.

                        !Residual vertical velocity
                        Me%Residual%Vertical_Velocity(i, j, k) =  0.              

                        !Residual Water fluxes
                        Me%Residual%WaterFlux_X(i, j, k) = 0.
                        Me%Residual%WaterFlux_Y(i, j, k) = 0.

                        !Read residual layer thickness
                        Me%Residual%DWZ(i, j, k) = 0

                    enddo

                enddo
                enddo
     
        endif cd1

        call ReadGeometry(Me%ObjGeometry, InitialFile, STAT = STAT_CALL) 

        if (STAT_CALL /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR70.')

cd3:    if (Residual .and. Me%ComputeOptions%Residual) then 
            !Read residual layer thickness
            read(InitialFile, END = 10) (((Me%Residual%DWZ(i, j, k),        &
                                i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

10          continue  

        endif cd3


        read(InitialFile, END = 20) BaroclinicRadia


cd4:    if (.not. BaroclinicRadia                                == NoRadiation_ .and.   &
            .not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then


            !Horizontal baroclinic velocity Old
            read(InitialFile, END = 20) (((Me%VelBaroclinic%U%Old(i, j, k), &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


            read(InitialFile, END = 20) (((Me%VelBaroclinic%V%Old(i, j, k), &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !Horizontal baroclinic velocity New
            read(InitialFile, END = 20) (((Me%VelBaroclinic%U%New(i, j, k), &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            read(InitialFile, END = 20) (((Me%VelBaroclinic%V%New(i, j, k), &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !vertical baroclinic velocity 
            read(InitialFile, END = 20) (((Me%VelBaroclinic%W_New(i, j, k), &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            read(InitialFile, END = 20) (((Me%VelBaroclinic%W_Old(i, j, k), &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        endif cd4

20      continue 

        !NonHydrostatic
        if (Me%NonHydrostatic%ON) then

            read(InitialFile, IOSTAT = STAT_CALL)                                       &  
                (((Me%Velocity%Vertical%CartesianOld(i, j, k),                          &
                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            if (STAT_CALL /= SUCCESS_) then
                call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR80.')
            endif

        endif
        
        !Submodel
        if (Me%SubModel%ON) then
        
            Me%SubModel%HotStartData = .false. 

            read(InitialFile, END = 30, IOSTAT = STAT_CALL)                             &  
                (((Me%SubModel%qX(i, j, k),                                             &
                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            if (STAT_CALL /= SUCCESS_) then
                call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR90.')
            endif

            read(InitialFile, END = 30, IOSTAT = STAT_CALL)                                       &  
                (((Me%SubModel%qY(i, j, k),                                             &
                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            if (STAT_CALL /= SUCCESS_) then
                call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR100.')
            endif
            
            Me%SubModel%HotStartData = .true. 
            
30          continue

            if (.not. Me%SubModel%HotStartData) then 
                write(*,*) 'you are doing a hot start based in a old version of MOHID'
                write(*,*) 'version before Nov 2010'
                write(*,*) 'in this case in the first iteration if the South/North boundaries are open'
                write(*,*) 'and the follow options are on (RADIATION : 2; LOCAL_SOLUTION : 2)'
                write(*,*) 'the mpodel will generate a perturbation that might take some type to dissipate'
                write(*,*) 'in less dissipative enviroments like the Ocean'
            endif 

        endif        

        call UnitsManager(InitialFile, FileClose, STAT = STAT_CALL) 

        if (STAT_CALL /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_,'Read_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR110.')



    end subroutine Read_Final_Hydrodynamic_File

    !--------------------------------------------------------------------------


    subroutine Initial_Geometry( ExternalWaterLevel)

        !Arguments------------------------------------------------------------
        real, dimension(:,:), pointer, optional  :: ExternalWaterLevel

        !Local----------------------------------------------------------------
        integer, dimension(:,:,:), pointer  :: WaterPoints3D
        real,    dimension(:,:  ), pointer  :: SurfaceElevation, Bathymetry
        real                                :: MinWaterColumn
        type(T_Time)                        :: CurrentTime
        logical                             :: Continuous_Compute
        integer                             :: STAT_CALL, i, j

        !Begin----------------------------------------------------------------
        
        CurrentTime = Me%CurrentTime

        call GetWaterPoints3D(Me%ObjMap, WaterPoints3D,                                 &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            Stop 'Sub. Initial_Geometry - ModuleHydrodynamic - ERR10.'

        if (present(ExternalWaterLevel) .and. Me%WaterLevel%InitalizedByFile) then

            write(*,*) 'Sub. Initial_Geometry - ModuleHydrodynamic - WARN10.'
            write(*,*) 'When a water level field is define using a file it is assume that'
            write(*,*) 'the field define via file is more consistent from the one interpolated directly'
            write(*,*) 'from the father model'

        endif

        if (present(ExternalWaterLevel) .and. .not. Me%WaterLevel%InitalizedByFile) then

            SurfaceElevation   => ExternalWaterLevel

            !This is redundant in some cases but in the case of the Sea Surface High interpolate
            !directly from the Father model it avoid water columns with 0 meters of tickness 

            !Gets Bathymetry
            call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                Stop 'Sub. Initial_Geometry - ModuleHydrodynamic - ERR20.'

            call GetGeometryMinWaterColumn(Me%ObjGeometry, MinWaterColumn, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &                    
                Stop 'Sub. Initial_Geometry - ModuleHydrodynamic - ERR30.'
            
do4:        do  j=Me%WorkSize%JLB, Me%WorkSize%JUB
do5:        do  i=Me%WorkSize%ILB, Me%WorkSize%IUB
                    
cd4:            if (WaterPoints3D(i, j, Me%WorkSize%KUB) == WaterPoint) then
                    
cd5:                if (SurfaceElevation(i,j) < (- Bathymetry(i, j) + 0.999 * MinWaterColumn)) then
                        SurfaceElevation(i,j) =  - Bathymetry(i, j) + 0.999 * MinWaterColumn
                    endif cd5
                endif cd4
            enddo do5
            enddo do4

            !UnGets Bathymetry
            call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                Stop 'Sub. Initial_Geometry - ModuleHydrodynamic - ERR40.'

        else

            SurfaceElevation   => Me%WaterLevel%New

        endif

        Continuous_Compute =  Me%ComputeOptions%Continuous

        !Compute new volume 
        call ComputeInitialGeometry(Me%ObjGeometry, WaterPoints3D,                      &
                                    SurfaceElevation,                                   &
                                    ActualTime = Me%CurrentTime,                        &
                                    ContinuesCompute = Continuous_Compute,              &
                                    NonHydrostatic   = Me%NonHydrostatic%ON,            & 
                                    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &                    
            Stop 'Sub. Initial_Geometry - ModuleHydrodynamic - ERR50.'


        call UnGetMap(Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            Stop 'Sub. Initial_Geometry - ModuleHydrodynamic - ERR60.'


        !Update the moving boundary (boundary of the tidal areas covered)
        call UpdateComputeFaces3D(Me%ObjMap, SurfaceElevation,                          &
                                  CurrentTime, STAT = STAT_CALL)      
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine Initial_Geometry; module ModuleHydrodynamic. ERR70.'

        nullify(SurfaceElevation)
                    
    end subroutine Initial_Geometry
    
    !End----------------------------------------------------------------------

    subroutine Open_HDF5_OutPut_File(iW)

        !Arguments-------------------------------------------------------------
        integer, optional                           :: iW

        !Local-----------------------------------------------------------------
        real, pointer, dimension(:, :)              :: Bathymetry
        integer, pointer, dimension(:, :, :)        :: WaterPoints3D
        type(T_Size2D)                              :: WorkSize2D
        character (Len = PathLength)                :: FileName
        character (Len = StringLength)              :: AuxChar
        integer                                     :: STAT_CALL
        integer                                     :: WorkILB, WorkIUB
        integer                                     :: WorkJLB, WorkJUB
        integer                                     :: WorkKLB, WorkKUB
        integer                                     :: HDF5_CREATE, ObjHDF5, i, n, j
        logical                                     :: SimpleOutPut 

        !----------------------------------------------------------------------
        !Bounds

        FileName = trim(Me%Files%OutPutFields)//"5"

        SimpleOutPut = .false. 

        if (present(iW)) then

            WorkILB = Me%OutW%OutPutWindows(iW)%ILB
            WorkIUB = Me%OutW%OutPutWindows(iW)%IUB

            WorkJLB = Me%OutW%OutPutWindows(iW)%JLB
            WorkJUB = Me%OutW%OutPutWindows(iW)%JUB

            WorkKLB = Me%OutW%OutPutWindows(iW)%KLB
            WorkKUB = Me%OutW%OutPutWindows(iW)%KUB
            
            WorkSize2D%ILB = Me%OutW%OutPutWindows(iW)%ILB            
            WorkSize2D%IUB = Me%OutW%OutPutWindows(iW)%IUB 
            
            WorkSize2D%JLB = Me%OutW%OutPutWindows(iW)%JLB 
            WorkSize2D%JUB = Me%OutW%OutPutWindows(iW)%JUB 
            
            write(AuxChar,fmt='(i5)') iW
            Auxchar           = "_w"//trim(adjustl(Auxchar))//".hdf5"
            n                 = len_trim(Auxchar) 
            do j=1,len_trim(Filename)  
                if(FileName(j:j+4)==".hdf5") then
                    i = j
                    exit
                endif
            enddo
            FileName(i:i+n-1) = trim(Auxchar)

            if (Me%OutW%Simple) SimpleOutPut = .true.             
            
        else

            WorkILB = Me%WorkSize%ILB 
            WorkIUB = Me%WorkSize%IUB 

            WorkJLB = Me%WorkSize%JLB 
            WorkJUB = Me%WorkSize%JUB 

            WorkKLB = Me%WorkSize%KLB 
            WorkKUB = Me%WorkSize%KUB 
            
            WorkSize2D = Me%WorkSize2D 
            

        endif

        !Gets a pointer to Bathymetry
        call GetGridData      (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR10'

        !Gets WaterPoints3D
        call GetWaterPoints3D   (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR20'


        !Gets File Access Code
        call GetHDF5FileAccess  (HDF5_CREATE = HDF5_CREATE)

        ObjHDF5 = 0

        !Opens HDF File
        call ConstructHDF5      (ObjHDF5,                                               &
                                 trim(FileName),                                        &
                                 HDF5_CREATE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR30'
        
        
        if (present(iW)) then

            Me%OutW%ObjHDF5(iW) = ObjHDF5
          
        else
          
            Me%ObjHDF5          = ObjHDF5

        endif


        
        
        !Write the Horizontal Grid
        call WriteHorizontalGrid(Me%ObjHorizontalGrid, ObjHDF5,                         &
                                 WorkSize = WorkSize2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR410'

        !Sets limits for next write operations
        call HDF5SetLimits   (ObjHDF5, WorkILB, WorkIUB, WorkJLB,                       &
                              WorkJUB, WorkKLB, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR420'


        !Writes the Grid
        call HDF5WriteData   (ObjHDF5, "/Grid", "Bathymetry", "m",                      &
                              Array2D = Bathymetry,                                     &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR430'

        call HDF5WriteData   (ObjHDF5, "/Grid", "WaterPoints3D", "-",                   &  
                              Array3D = WaterPoints3D,                                  &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR440'


        !Writes everything to disk
        call HDF5FlushMemory (ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR460'


        !Ungets the Bathymetry
        call UngetGridData (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR470'

        !Ungets the WaterPoints
        call UnGetMap        (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR480'


        !----------------------------------------------------------------------

    end subroutine Open_HDF5_OutPut_File
    
    !--------------------------------------------------------------------------


    subroutine Open_Surface_HDF5_OutPut_File

        !Arguments-------------------------------------------------------------
 

        !Local-----------------------------------------------------------------
        real, pointer, dimension(:, :)              :: Bathymetry
        integer, pointer, dimension(:, :, :)        :: WaterPoints3D
        integer                                     :: STAT_CALL
        integer                                     :: WorkILB, WorkIUB
        integer                                     :: WorkJLB, WorkJUB
        integer                                     :: WorkKLB, WorkKUB
        integer                                     :: HDF5_CREATE
        character(len=PathLength)                   :: SurfaceHDF5FileName
        integer                                     :: FileNameLength
        character(len=5)                            :: Extension         !.hdf5

        !----------------------------------------------------------------------

        !Bounds
        WorkILB = Me%WorkSize%ILB 
        WorkIUB = Me%WorkSize%IUB 

        WorkJLB = Me%WorkSize%JLB 
        WorkJUB = Me%WorkSize%JUB 

        WorkKLB = Me%WorkSize%KLB 
        WorkKUB = Me%WorkSize%KUB 

        !Gets a pointer to Bathymetry
        call GetGridData      (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR00'

        !Gets WaterPoints3D
        call GetWaterPoints3D   (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR10'

        FileNameLength      = len_trim(Me%Files%OutPutFields) + 1
        Extension           = trim(Me%Files%OutPutFields(FileNameLength-4:FileNameLength))
        Extension(5:5)      = "5"
        SurfaceHDF5FileName = Me%Files%OutPutFields(1:FileNameLength-5)//"_Surface"//trim(Extension)
    

        !Gets File Access Code
        call GetHDF5FileAccess  (HDF5_CREATE = HDF5_CREATE)

        !Opens HDF File
        call ConstructHDF5      (Me%ObjSurfaceHDF5,                                     &
                                 trim(SurfaceHDF5FileName),                             &
                                 HDF5_CREATE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR20'

        !Write the Horizontal Grid
        call WriteHorizontalGrid(Me%ObjHorizontalGrid, Me%ObjSurfaceHDF5,               &
                                 STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR30'

        !Sets limits for next write operations
        call HDF5SetLimits   (Me%ObjSurfaceHDF5, WorkILB, WorkIUB, WorkJLB,             &
                              WorkJUB, WorkKUB, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR40'

        !Writes the Bathymetry
        call HDF5WriteData   (Me%ObjSurfaceHDF5, "/Grid", "Bathymetry", "m",            &
                              Array2D = Bathymetry,                                     &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR50'

        call HDF5WriteData   (Me%ObjSurfaceHDF5, "/Grid", "WaterPoints3D", "-",         &
                              Array3D = WaterPoints3D,                                  &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR60'

        !Writes everything to disk
        call HDF5FlushMemory (Me%ObjSurfaceHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR80'

        !Ungets the Bathymetry
        call UngetGridData (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR90'

        !Ungets the WaterPoints
        call UnGetMap        (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR100'

        !----------------------------------------------------------------------

    end subroutine Open_Surface_HDF5_OutPut_File
    
    !--------------------------------------------------------------------------

    subroutine Construct_Time_Serie

        !Arguments-------------------------------------------------------------

        !External--------------------------------------------------------------
        character(len=StringLength), dimension(:), pointer  :: PropertyList

        !Local-----------------------------------------------------------------
        real                                                :: CoordX, CoordY
        logical                                             :: CoordON, IgnoreOK
        integer                                             :: nProperties
        integer                                             :: STAT_CALL
        integer                                             :: iflag, dn, Id, Jd, TimeSerieNumber, i, j
        character(len=PathLength)                           :: TimeSerieLocationFile
        character(len=StringLength)                         :: TimeSerieName

        !Begin-----------------------------------------------------------------


        call GetWaterPoints3D(Me%ObjMap,                                                &
                              Me%External_Var%WaterPoints3D,                            &
                              STAT = STAT_CALL)
        
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, OUT_OF_MEM_, "Construct_Time_Serie - Hydrodynamic - ERR10")
        
        nProperties = 7 !3 velocity components  (West-East, North-South, vertical), intensity, direction, elevation and open points 

        !Allocates PropertyList
        allocate(PropertyList(nProperties), STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, OUT_OF_MEM_, "Construct_Time_Serie - Hydrodynamic - ERR20")

        !Fills up PropertyList
        PropertyList(1) = trim(GetPropertyName (VelocityU_      ))
        PropertyList(2) = trim(GetPropertyName (VelocityV_      ))
        PropertyList(3) = trim(GetPropertyName (VelocityW_      ))
        PropertyList(4) = trim(GetPropertyName (VelocityModulus_))
        PropertyList(5) = trim(GetPropertyName (VelocityDirection_))
        PropertyList(6) = trim(GetPropertyName (WaterLevel_))
        PropertyList(7) = 'OpenPoint'

        do i=1,nProperties
            do j=1,len_trim(PropertyList(i))
                if (PropertyList(i)(j:j)==' ') PropertyList(i)(j:j)='_'
            enddo
        enddo

        call GetData(TimeSerieLocationFile,                                             &
                     Me%ObjEnterData,iflag,                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'TIME_SERIE_LOCATION',                              &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     Default      = Me%Files%ConstructData,                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_Time_Serie - Hydrodynamic - ERR30' 

        !Constructs TimeSerie
        call StartTimeSerie(Me%ObjTimeSerie, Me%ObjTime,                                &
                            TimeSerieLocationFile,                                      &
                            PropertyList, "srh",                                        &
                            WaterPoints3D = Me%External_Var%WaterPoints3D,              &
                            ModelName     = Me%ModelName,                               &
                            STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, OUT_OF_MEM_, "Construct_Time_Serie - Hydrodynamic - ERR40")


        !Deallocates PropertyList
        deallocate(PropertyList, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, OUT_OF_MEM_, "Construct_Time_Serie - Hydrodynamic - ERR50")

        !Corrects if necessary the cell of the time serie based in the time serie coordinates
        call GetNumberOfTimeSeries(Me%ObjTimeSerie, TimeSerieNumber, STAT  = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR60'  

        do dn = 1, TimeSerieNumber

            call GetTimeSerieLocation(Me%ObjTimeSerie, dn,                              &  
                                      CoordX   = CoordX,                                &
                                      CoordY   = CoordY,                                & 
                                      CoordON  = CoordON,                               &
                                      STAT     = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR70'
            
            call GetTimeSerieName(Me%ObjTimeSerie, dn, TimeSerieName, STAT  = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR80'  
            
i1:         if (CoordON) then
                call GetXYCellZ(Me%ObjHorizontalGrid, CoordX, CoordY, Id, Jd, STAT = STAT_CALL)
                       
                if (STAT_CALL /= SUCCESS_ .and. STAT_CALL /= OUT_OF_BOUNDS_ERR_) then
                    stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR90'
                endif                            

                if (STAT_CALL == OUT_OF_BOUNDS_ERR_ .or. Id < 0 .or. Jd < 0) then
                
                    call TryIgnoreTimeSerie(Me%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR100'

                    if (IgnoreOK) then
                        write(*,*) 'Time Serie outside the domain - ',trim(TimeSerieName),' - ',trim(Me%ModelName)
                        cycle
                    else
                        stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR110'
                    endif

                endif


                call CorrectsCellsTimeSerie(Me%ObjTimeSerie, dn, Id, Jd, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR120'

            endif i1

            call GetTimeSerieLocation(Me%ObjTimeSerie, dn,                              &  
                                      LocalizationI   = Id,                             &
                                      LocalizationJ   = Jd,                             & 
                                      STAT     = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR130'

            if (Me%External_Var%WaterPoints3D(Id, Jd, Me%WorkSize%KUB) /= WaterPoint) then
                
                 write(*,*) 'Time Serie in a land cell - ',trim(TimeSerieName),' - ',trim(Me%ModelName)

            endif


        enddo



        call UnGetMap(Me%ObjMap,                                                        &
                      Me%External_Var%WaterPoints3D,                                    &
                      STAT = STAT_CALL)
        
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, OUT_OF_MEM_, "Construct_Time_Serie - Hydrodynamic - ERR140")
    
        
    end subroutine Construct_Time_Serie

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine Construct_Time_Serie_Discharge

        !Arguments-------------------------------------------------------------

        !External--------------------------------------------------------------
        character(len=StringLength), dimension(:), pointer  :: PropertyList

        !Local-----------------------------------------------------------------
        integer                                             :: nProperties
        integer                                             :: STAT_CALL
        integer                                             :: iflag, dis, i, j
        character(len=PathLength)                           :: TimeSerieLocationFile
        character(len=StringLength)                         :: Extension, DischargeName

        !Begin-----------------------------------------------------------------


        call GetDischargesNumber(Me%ObjDischarges, Me%OutPut%DischargesNumber, STAT = STAT_CALL)
        if (STAT_CALL/=SUCCESS_)stop 'Construct_Time_Serie_Discharge - ModuleHydrodynamic - ERR10'

        allocate(Me%OutPut%TimeSerieDischID(Me%OutPut%DischargesNumber))
        
        Me%OutPut%TimeSerieDischID(:) = 0
        
        nProperties = 4 !1 - flow, 2- Velocity U; 3 - Velocity V; 4 - Velocity W
        
        allocate(Me%OutPut%TimeSerieDischProp(1:Me%OutPut%DischargesNumber,1:nProperties))
        
        Me%OutPut%TimeSerieDischProp(:,:) = FillValueReal

        !Allocates PropertyList
        allocate(PropertyList(nProperties), STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, OUT_OF_MEM_, "Construct_Time_Serie_Discharge - Hydrodynamic - ERR20")

        !Fills up PropertyList
        PropertyList(1) = "water_flux"
        PropertyList(2) = trim(GetPropertyName (VelocityU_      ))
        PropertyList(3) = trim(GetPropertyName (VelocityV_      ))
        PropertyList(4) = trim(GetPropertyName (VelocityW_      ))

        do i=1,nProperties
            do j=1,len_trim(PropertyList(i))
                if (PropertyList(i)(j:j)==' ') PropertyList(i)(j:j)='_'
            enddo
        enddo
  
       Extension       = '.fds'

       call GetData(TimeSerieLocationFile,                                              &
                     Me%ObjEnterData,iflag,                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'TIME_SERIE_LOCATION',                              &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     Default      = Me%Files%ConstructData,                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_Time_Serie_Discharge - Hydrodynamic - ERR30'         

        do dis = 1, Me%OutPut%DischargesNumber
        
            call GetDischargesIDName (Me%ObjDischarges, dis, DischargeName, STAT = STAT_CALL)
        
            call StartTimeSerie(TimeSerieID         = Me%OutPut%TimeSerieDischID(dis),  &
                                ObjTime             = Me%ObjTime,                       &
                                TimeSerieDataFile   = TimeSerieLocationFile,            &
                                PropertyList        = PropertyList,                     &
                                Extension           = Extension,                        &
                                ResultFileName      = "hydro_"//trim(DischargeName),    &
                                STAT                = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie_Discharge - Hydrodynamic - ERR40'
        
        enddo
        !----------------------------------------------------------------------
        
        
    end subroutine Construct_Time_Serie_Discharge

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine Construct_Output_Profile

        !Local-----------------------------------------------------------------
        integer                                             :: STAT_CALL, iflag
        character(len=PathLength)                           :: TimeSerieLocationFile
        integer                                             :: nProperties
        character(len=StringLength), dimension(:,:), pointer:: PropertyList

        !----------------------------------------------------------------------

        call ReadLock_ModuleHorizontalMap

        call GetData(TimeSerieLocationFile,                                             &
                     Me%ObjEnterData,iflag,                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'TIME_SERIE_LOCATION',                              &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     Default      = Me%Files%ConstructData,                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_Output_Profile - ModuleWaterProperties - ERR01' 
            
        nProperties = 5

        !Allocates PropertyList
        allocate(PropertyList(1:nProperties,1:2))

        PropertyList(1,1) = trim(GetPropertyName (VelocityU_      ))
        PropertyList(2,1) = trim(GetPropertyName (VelocityV_      ))
        PropertyList(3,1) = trim(GetPropertyName (VelocityW_      ))
        PropertyList(4,1) = trim(GetPropertyName (VelocityModulus_))
        PropertyList(5,1) = "Direction"

        PropertyList(1,2) = "m/s"
        PropertyList(2,2) = "m/s"
        PropertyList(3,2) = "m/s"
        PropertyList(4,2) = "m/s"
        PropertyList(5,2) = "º"

        call StartProfile  (ProfileID       = Me%ObjProfile,                            &
                            ObjTime         = Me%ObjTime,                               &
                            ProfileDataFile = trim(TimeSerieLocationFile),              &
                            WaterPoints2D   = Me%External_Var%WaterPoints2D,            &
                            KUB             = Me%WorkSize%KUB,                          &
                            nProperties     = nProperties,                              &
                            PropertyList    = PropertyList,                             &
                            ClientName      = "Hydrodynamic",                           &
                            STAT            = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Construct_Output_Profile - ModuleWaterProperties - ERR02'
       
        deallocate(PropertyList)

        call ReadUnLock_ModuleHorizontalMap

    end subroutine Construct_Output_Profile

    !--------------------------------------------------------------------------

    subroutine ConstructMatrixesOutput

        !Arguments-------------------------------------------------------------
        

        !Local-----------------------------------------------------------------
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: STAT_CALL

        !----------------------------------------------------------------------

        !Bounds
        ILB = Me%Size%ILB 
        IUB = Me%Size%IUB 

        JLB = Me%Size%JLB 
        JUB = Me%Size%JUB 

        KLB = Me%Size%KLB 
        KUB = Me%Size%KUB 

        !Horizontal Velocity

        nullify  (Me%OutPut%CenterU   )
        nullify  (Me%OutPut%CenterV   )
        nullify  (Me%OutPut%ModulusH  )
        nullify  (Me%OutPut%DirectionH)
        nullify  (Me%OutPut%CenterW   )
        nullify  (Me%OutPut%Vorticity3D )        
        nullify  (Me%OutPut%CenterUaux  ) 
        nullify  (Me%OutPut%CenterVaux  ) 
        nullify  (Me%OutPut%ModulusUVaux)        
        nullify  (Me%OutPut%CenterWaux) 
        nullify  (Me%OutPut%Aux2D) 
        nullify  (Me%OutPut%WaterLevelMax) 
        nullify  (Me%OutPut%WaterLevelMin) 

        allocate(Me%OutPut%CenterU     (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%CenterV     (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%ModulusH    (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%DirectionH  (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%CenterW     (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%Vorticity3D (ILB:IUB, JLB:JUB, KLB:KUB),                     &                 
                 Me%OutPut%CenterUaux  (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%CenterVaux  (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%ModulusUVaux(ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%CenterWaux  (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%Aux2D       (ILB:IUB, JLB:JUB         ),                     &
                 Me%OutPut%WaterLevelMax (ILB:IUB, JLB:JUB       ),                     &
                 Me%OutPut%WaterLevelMin (ILB:IUB, JLB:JUB       ),                     &
                 STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructMatrixesOutput - ModuleHydrodynamic - ERR10'

        Me%OutPut%CenterU       (:,:,:) = 0.
        Me%OutPut%CenterV       (:,:,:) = 0.
        Me%OutPut%ModulusH      (:,:,:) = 0.
        Me%OutPut%DirectionH    (:,:,:) = 0.
        Me%OutPut%CenterW       (:,:,:) = 0.
        Me%OutPut%Vorticity3D   (:,:,:) = 0.         
        Me%OutPut%CenterUaux    (:,:,:) = 0.
        Me%OutPut%CenterVaux    (:,:,:) = 0.
        Me%OutPut%ModulusUVaux  (:,:,:) = 0.
        Me%OutPut%CenterWaux    (:,:,:) = 0.
        Me%OutPut%Aux2D         (:,:  ) = 0. 
        Me%OutPut%WaterLevelMax (:,:  ) = 0. 
        Me%OutPut%WaterLevelMin (:,:  ) = 0. 
    
    end subroutine ConstructMatrixesOutput

    !--------------------------------------------------------------------------

    subroutine ConstructEnergy

        !Local-----------------------------------------------------------------
        integer                             :: status
        integer, dimension(:), pointer      :: aux
        integer                             :: iflag
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB

        !----------------------------------------------------------------------

        !Bounds
        ILB = Me%Size%ILB 
        IUB = Me%Size%IUB 
        JLB = Me%Size%JLB 
        JUB = Me%Size%JUB 
        KLB = Me%Size%KLB 
        KUB = Me%Size%KUB 

        allocate (aux(6))

        call GetData(aux,                                                               &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'ENERGY_WINDOW',                                      &
                     Default    = FillValueInt,                                         &                                           
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = status)            
        if (status /= SUCCESS_)                                                         &
            call SetError(FATAL_, KEYWORD_, 'ConstructEnergy - Hydrodynamic - ERR02') 

        if   (iflag == 0) then 

            Me%Energy%Window%ILB = Me%WorkSize%ILB
            Me%Energy%Window%IUB = Me%WorkSize%IUB

            Me%Energy%Window%JLB = Me%WorkSize%JLB
            Me%Energy%Window%JUB = Me%WorkSize%JUB

            Me%Energy%Window%KLB = Me%WorkSize%KLB
            Me%Energy%Window%KUB = Me%WorkSize%KUB


        else if (iflag == 6) then

            Me%Energy%Window%ILB = aux(1) 
            Me%Energy%Window%IUB = aux(2) 

            Me%Energy%Window%JLB = aux(3) 
            Me%Energy%Window%JUB = aux(4) 

            Me%Energy%Window%KLB = aux(5) 
            Me%Energy%Window%KUB = aux(6) 

        else

            call SetError(FATAL_, KEYWORD_, 'ConstructEnergy - Hydrodynamic - ERR03') 

        endif

        deallocate (aux)

       
        call UnitsManager(Me%Energy%FileID, FileOpen, STAT = status)
        if (status /= SUCCESS_)     &
            call SetError(FATAL_, INTERNAL_, 'ConstructEnergy - Hydrodynamic - ERR05') 

        open(unit = Me%Energy%FileID, file = Me%Files%Energy, &
             form = 'FORMATTED', status = 'UNKNOWN')

        !Inits the buffer count
        Me%Energy%BufferCount = 0

        write (Me%Energy%FileID,*)  'Year Month Day Hour Minute Second '  // &
                                    'KEtotal PEtotal KE PE M V '          // & 
                                    'OpenV Level BarotropicKE '           // &
                                    'BaroclinicKE VelMax VelMaxBaroclinic'// &
                                    'Enstrophy'   
                        
        !Allocates the buffer
        allocate(Me%Energy%YearBuffer            (1:EnergyBufferSize))
        allocate(Me%Energy%MonthBuffer           (1:EnergyBufferSize))
        allocate(Me%Energy%DayBuffer             (1:EnergyBufferSize))
        allocate(Me%Energy%HourBuffer            (1:EnergyBufferSize))
        allocate(Me%Energy%MinuteBuffer          (1:EnergyBufferSize))
        allocate(Me%Energy%SecondBuffer          (1:EnergyBufferSize))
        allocate(Me%Energy%KineticBuffer         (1:EnergyBufferSize))
        allocate(Me%Energy%PotentialBuffer       (1:EnergyBufferSize))
        allocate(Me%Energy%VorticityBuffer       (1:EnergyBufferSize))
        allocate(Me%Energy%MassBuffer            (1:EnergyBufferSize))
        allocate(Me%Energy%VolumeBuffer          (1:EnergyBufferSize))
        allocate(Me%Energy%OpenVolumeBuffer      (1:EnergyBufferSize))
        allocate(Me%Energy%WaterLevelBuffer      (1:EnergyBufferSize))
        allocate(Me%Energy%BarotropicKEBuffer    (1:EnergyBufferSize))
        allocate(Me%Energy%BaroclinicKEBuffer    (1:EnergyBufferSize))
        allocate(Me%Energy%RelativeKEBuffer      (1:EnergyBufferSize))
        allocate(Me%Energy%RelativePEBuffer      (1:EnergyBufferSize))
        allocate(Me%Energy%VelMaxBuffer          (1:EnergyBufferSize))
        allocate(Me%Energy%VelMaxBaroclinicBuffer(1:EnergyBufferSize))


        allocate(Me%Energy%CenterU      (ILB:IUB,JLB:JUB,KLB:KUB))
        allocate(Me%Energy%CenterV      (ILB:IUB,JLB:JUB,KLB:KUB))
        allocate(Me%Energy%CenterW      (ILB:IUB,JLB:JUB,KLB:KUB))
        allocate(Me%Energy%BarotropicU  (ILB:IUB,JLB:JUB        ))
        allocate(Me%Energy%BarotropicV  (ILB:IUB,JLB:JUB        ))

        call GetData(Me%Energy%DtOut,                                                    &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType = FromFile,                                              &
                     keyword    = 'ENERGY_DT',                                           &
                     Default    = 600.,                                                  &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)            
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'ConstructEnergy - Hydrodynamic - ERR21') 

        Me%Energy%NextOutPut = Me%BeginTime

    end subroutine ConstructEnergy


    !--------------------------------------------------------------------------

    Subroutine ConstructTidePotential

        !Arguments-------------------------------------------------------------

        

        !Local-----------------------------------------------------------------
        integer               :: ILB, IUB, JLB, JUB, NComp
        

        NComp = Me%TidePotential%ComponentsNumber


        IUB = Me%Size%IUB
        ILB = Me%Size%ILB
        JUB = Me%Size%JUB
        JLB = Me%Size%JLB

        allocate (Me%TidePotential%Frequency(NComp))
        allocate (Me%TidePotential%Amplitude(NComp))
        allocate (Me%TidePotential%Arguments(NComp))
        allocate (Me%TidePotential%Beta     (NComp))
        allocate (Me%TidePotential%m        (NComp))
        allocate (Me%TidePotential%L        (0:2  ))

!
! ---> Compute 
!
        !Load factor (Specie 0,2 Alpha = 0.953, Specie 1 (diurnal) Alpha = 0.940 (Kantha e Clayson, 2000)
        !Compromise value
        !Alpha = 0.95
        Me%TidePotential%Alpha = 0.95

        !Elasticity Factor (Table 6.1.1 Kantha and Clayson, 2000)
        Me%TidePotential%Beta (Ssa) = 0.693
        Me%TidePotential%Beta (Mm ) = 0.693
        Me%TidePotential%Beta (Mf ) = 0.693

        Me%TidePotential%Beta (K1 ) = 0.7364
        Me%TidePotential%Beta (O1 ) = 0.6950
        Me%TidePotential%Beta (P1 ) = 0.7059
        Me%TidePotential%Beta (Q1 ) = 0.6946

        Me%TidePotential%Beta (M2 ) = 0.693
        Me%TidePotential%Beta (S2 ) = 0.693
        Me%TidePotential%Beta (N2 ) = 0.693
        Me%TidePotential%Beta (K2 ) = 0.693

        !Equilibrium tide amplitude (m) (Table 6.1.1 Kantha and Clayson, 2000)
        Me%TidePotential%Amplitude (Ssa) = 0.019542
        Me%TidePotential%Amplitude (Mm ) = 0.022191
        Me%TidePotential%Amplitude (Mf ) = 0.042017

        Me%TidePotential%Amplitude (K1 ) = 0.142408
        Me%TidePotential%Amplitude (O1 ) = 0.101266
        Me%TidePotential%Amplitude (P1 ) = 0.047129
        Me%TidePotential%Amplitude (Q1 ) = 0.019387

        Me%TidePotential%Amplitude (M2 ) = 0.244102
        Me%TidePotential%Amplitude (S2 ) = 0.113572
        Me%TidePotential%Amplitude (N2 ) = 0.046735
        Me%TidePotential%Amplitude (K2 ) = 0.030875


        !frequency in radianos./hr. (Table 6.1.1 Kantha and Clayson, 2000)
        Me%TidePotential%Frequency (Ssa) = 0.0821373  * Pi / 180.
        Me%TidePotential%Frequency (Mm ) = 0.5443747  * Pi / 180.
        Me%TidePotential%Frequency (Mf ) = 1.0980331  * Pi / 180.

        Me%TidePotential%Frequency (K1 ) = 15.0410686 * Pi / 180.
        Me%TidePotential%Frequency (O1 ) = 13.9430356 * Pi / 180.
        Me%TidePotential%Frequency (P1 ) = 14.9589314 * Pi / 180.
        Me%TidePotential%Frequency (Q1 ) = 13.3986609 * Pi / 180.

        Me%TidePotential%Frequency (M2 ) = 28.9841042 * Pi / 180.
        Me%TidePotential%Frequency (S2 ) = 30.0000000 * Pi / 180. 
        Me%TidePotential%Frequency (N2 ) = 28.4397295 * Pi / 180.
        Me%TidePotential%Frequency (K2 ) = 30.0821373 * Pi / 180.


        !griflet: changed values from 0,1,2 to 1,2,3. Added +1 (array index correction).
        !Species m
        Me%TidePotential%m(Ssa) = 1
        Me%TidePotential%m(Mm ) = 1
        Me%TidePotential%m(Mf ) = 1

        Me%TidePotential%m(K1 ) = 2
        Me%TidePotential%m(O1 ) = 2
        Me%TidePotential%m(P1 ) = 2
        Me%TidePotential%m(Q1 ) = 2

        Me%TidePotential%m(M2 ) = 3
        Me%TidePotential%m(S2 ) = 3
        Me%TidePotential%m(N2 ) = 3
        Me%TidePotential%m(K2 ) = 3


        call SetDate(Me%TidePotential%TimeRef, 1900, 1, 1, 0, 0, 0)


    end subroutine ConstructTidePotential


    !--------------------------------------------------------------------------

    Subroutine ConstructSubModel

        !Arguments-------------------------------------------------------------

        

        !Local-----------------------------------------------------------------
        integer, dimension(:,:,:), pointer :: IC3D
        integer               :: ILB, IUB, JLB, JUB, KLB, KUB
        integer               :: STATUS
        integer               :: i, j, k

        !Begin-----------------------------------------------------------------
       


        IUB = Me%Size%IUB
        ILB = Me%Size%ILB
        JUB = Me%Size%JUB
        JLB = Me%Size%JLB
        KUB = Me%Size%KUB
        KLB = Me%Size%KLB

cd1:    if (Me%SubModel%DeadZone) then
            
            call GetWaterPoints3D(Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STATUS)
            if (STATUS .NE. SUCCESS_) stop 'ConstructSubModel - ModuleHydrodynamic - ERR01'

            allocate (Me%SubModel%DeadZonePoint(ILB:IUB, JLB:JUB, KLB:KUB))
            Me%SubModel%DeadZonePoint(:,:,:) = .false.

            call StartBoxDif(BoxDifID         = Me%SubModel%ObjBoxDif,           &
                             TimeID           = Me%ObjTime,                      &
                             HorizontalGridID = Me%ObjHorizontalGrid,            &
                             BoxesFilePath = Me%SubModel%DeadZoneFile,                   &
                             WaterPoints3D = Me%External_Var%WaterPoints3D,              &
                             Size3D        = Me%Size,                                    &
                             WorkSize3D    = Me%WorkSize,                                &
                             STAT          = STATUS)
            if (STATUS /= SUCCESS_) stop 'ConstructSubModel - Hydrodynamic - ERR02'

            call GetBoxes(Me%SubModel%ObjBoxDif, IC3D, STAT = STATUS)
            if (STATUS /= SUCCESS_) stop 'ConstructSubModel - Hydrodynamic - ERR03'

            do j = JLB, JUB
            do i = ILB, IUB
            do k = KLB, KUB
           
cd2 :           if (IC3D(i,j,k)>0) then

                    Me%SubModel%DeadZonePoint(i,j,k) = .true.
                
                end if cd2

            end do
            end do
            end do


            call UngetBoxDif(Me%SubModel%ObjBoxDif, IC3D, STAT = STATUS)
            if (STATUS /= SUCCESS_) stop 'ConstructSubModel - Hydrodynamic - ERR04'


            call KillBoxDif(Me%SubModel%ObjBoxDif, STAT = STATUS)
            if (STATUS /= SUCCESS_) stop 'ConstructSubModel - Hydrodynamic - ERR05'

            call UnGetMap(Me%ObjMap,Me%External_Var%WaterPoints3D, STAT = STATUS)
            if (STATUS /= SUCCESS_) stop 'ConstructSubModel - Hydrodynamic - ERR06'

        endif cd1


        Me%SubModel%Set = .false.

    end subroutine ConstructSubModel


    !-----------------------------------------------------------------
    Subroutine ConstructRelaxation

        !Arguments-------------------------------------------------------------

        

        !Local-----------------------------------------------------------------
        
        integer                          :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                          :: ILBWork, IUBWork, JLBWork, JUBWork, KLBWork, KUBWork
        integer                          :: STATUS
        
        integer                          :: iflag,fromfile


        IUB = Me%Size%IUB
        ILB = Me%Size%ILB
        JUB = Me%Size%JUB
        JLB = Me%Size%JLB
        KUB = Me%Size%KUB
        KLB = Me%Size%KLB


        IUBWork = Me%WorkSize%IUB
        ILBWork = Me%WorkSize%ILB
        JUBWork = Me%WorkSize%JUB
        JLBWork = Me%WorkSize%JLB
        KUBWork = Me%WorkSize%KUB
        KLBWork = Me%WorkSize%KLB

        

        call GetExtractType(FromFile = FromFile)

! ---> Compute 
!

        !<BeginKeyword>
            !Keyword          : BOUNDARYFILE
            !<BeginDescription>       
               ! 
               !The file name of 3D file where the relaxation coefficient are. 
               !               
            !<EndDescription>
            !Type             : Character 
            !Default          : ******.***

            !File keyword     : IN_DAD3D 
            !Multiple Options : Do not 
            !Search Type      : From File
        !<EndKeyword>



!        call GetData(FileName, Me%ObjEnterData, iflag,                      &
!                     Keyword    = 'BOUNDARYFILE',                                        &
!                     Default    = '********.***',                                        &
!                     SearchType = FromFile,                                              &
!                     STAT       = status)

!        if (status /= SUCCESS_)                                                          &
!           call SetError(FATAL_, INTERNAL_, "ConstructDataAssimilation - Hydrodynamic - ERR02") 
                
!        if (iflag == 0) &
!           call SetError(FATAL_, INTERNAL_, "ConstructDataAssimilation - Hydrodynamic - ERR03") 

!        Me%DataAssimilation%BRfilename = FileName

        !<BeginKeyword>
            !Keyword          : BRCORIOLIS
            !<BeginDescription>       
               ! 
               !Checks if the user wants to relax the coriolis force
               !
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.

            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (.false.), 1 (.true.)
            !Search Type      : From File
        !<EndKeyword>

         call GetData(Me%Relaxation%coriolis,                         &
                     Me%ObjEnterData, iflag,                                &
                     Keyword    = 'BRCORIOLIS',                                          &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR04")


        !<BeginKeyword>
            !Keyword          : BRROX3
            !<BeginDescription>       
               ! 
               !Checks if the user wants to relax the baroclinic force
               !
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.

            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (.false.), 1 (.true.)
            !Search Type      : From File
        !<EndKeyword>
      

         call GetData(Me%Relaxation%rox3,                                               &
                      Me%ObjEnterData, iflag,                                           &
                      Keyword    = 'BRROX3',                                            &
                      Default    = .false.,                                             &
                      SearchType = FromFile,                                            &
                      ClientModule ='ModuleHydrodynamic',                               &
                      STAT       = status)

        if (status /= SUCCESS_)                                                         &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR05")
        
        
        !<BeginKeyword>
            !Keyword          : BRTRANSPORT
            !<BeginDescription>       
               ! 
               !Checks if the user wants to relax the horizontal momentum transport 
               !
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.

            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (.false.), 1 (.true.)
            !Search Type      : From File
        !<EndKeyword>
      


        call GetData(Me%Relaxation%HorizAdv,                                &
                     Me%ObjEnterData, iflag,                                &
                     Keyword    = 'BRHORIZ_ADV',                                         &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR06")
           


! ---> Velocity field relaxation
!
        !<BeginKeyword>
            !Keyword          : BRVELOCITY
            !<BeginDescription>       
               ! 
               !Checks if the user wants to relax the horizontal velocity 
               !
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.

            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (.false.), 1 (.true.)
            !Search Type      : From File
        !<EndKeyword>
      

         call GetData(Me%Relaxation%Velocity,                         &
                      Me%ObjEnterData, iflag,                               &
                      keyword = 'BRVELOCITY',                                            &
                      default = .false.,                                                 &
                      SearchType = FromFile,                                             &
                      ClientModule ='ModuleHydrodynamic',                                &
                      STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR14")



! ---> Water Level field relaxation
!
        !<BeginKeyword>
            !Keyword          : BRWATERLEVEL
            !<BeginDescription>       
               ! 
               !Checks if the user wants to relax the water level 
               !
            !<EndDescription>
            !Type             : Logical 
            !Default          : .false.

            !File keyword     : IN_DAD3D 
            !Multiple Options : 0 (.false.), 1 (.true.)
            !Search Type      : From File
        !<EndKeyword>
      

         call GetData(Me%Relaxation%WaterLevel,                             &
                      Me%ObjEnterData, iflag,                               &
                      keyword = 'BRWATERLEVEL',                                          &
                      default = .false.,                                                 &
                      SearchType = FromFile,                                             &
                      ClientModule ='ModuleHydrodynamic',                                &
                      STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR15")



         call GetData(Me%Relaxation%RefBoundWaterLevel,                     &
                      Me%ObjEnterData, iflag,                               &
                      keyword = 'REF_BOUND_WATERLEVEL',                                  &
                      default = .false.,                                                 &
                      SearchType = FromFile,                                             &
                      ClientModule ='ModuleHydrodynamic',                                &
                      STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR16")

        call GetData(Me%Relaxation%ReferenceVelocity,                       &
                      Me%ObjEnterData, iflag,                               &
                      keyword = 'RELAX_REF_VEL',                                         &
                      default = TotalVel_,                                               &
                      SearchType = FromFile,                                             &
                      ClientModule ='ModuleHydrodynamic',                                &
                      STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR16a")

        if (Me%Relaxation%ReferenceVelocity /= TotalVel_          .and.     &
            Me%Relaxation%ReferenceVelocity /= BarotrVel_         .and.     &
            Me%Relaxation%ReferenceVelocity /= BaroclVel_)                  &
            call SetError(FATAL_, KEYWORD_, 'ConstructRelaxation - Hydrodynamic - ERR31.')            



         call GetData(Me%Relaxation%Force,                                  &
                      Me%ObjEnterData, iflag,                               &
                      keyword = 'BRFORCE',                                               &
                      default = .false.,                                                 &
                      SearchType = FromFile,                                             &
                      ClientModule ='ModuleHydrodynamic',                                &
                      STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR17")

        if (Me%Relaxation%Force .and. Me%Relaxation%Velocity) then

            call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR18")

        endif


        if (Me%Relaxation%Force) then

            !Forces 
            allocate (Me%Forces%Relax_Aceleration(ILB:IUB, JLB:JUB, KLB:KUB), STAT = status)

            if (status /= SUCCESS_)                                                          &
               call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR19")
 
                Me%Forces%Relax_Aceleration(:,:,:) = FillValueReal


        endif 


         call GetData(Me%Relaxation%Geometry,                                           &
                      Me%ObjEnterData, iflag,                                           &
                      keyword = 'BRGEOMETRY',                                           &
                      default = .false.,                                                &
                      SearchType = FromFile,                                            &
                      ClientModule ='ModuleHydrodynamic',                               &
                      STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR200")

        if (Me%Relaxation%Geometry) then

            !Forces 
            allocate (Me%Relaxation%DecayTimeGeo(ILB:IUB, JLB:JUB, KLB:KUB), STAT = status)

            if (status /= SUCCESS_)                                                          &
               call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR210")
 
            Me%Relaxation%DecayTimeGeo(:,:,:) = FillValueReal


        endif 



    end subroutine ConstructRelaxation

    !----------------------------------------------------------------------------



    !----------------------------------------------------------------------------

    subroutine CourantGH

        !Arguments---------------------------------------------------------------

        

        !External----------------------------------------------------------------

        integer :: STAT_CALL
        integer :: I_Courant, J_Courant

        real    :: DT
        real    :: Velocity

        !Local-------------------------------------------------------------------

        integer :: I, J
        integer :: IUB, ILB
        integer :: JUB, JLB

        real    :: Courant, Courant_temp
        real    :: DX

        real,    dimension(:,:), pointer :: WaterColumn

        !------------------------------------------------------------------------

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB


        call ReadLock_External_Modules

        call GetComputeTimeStep(Me%ObjTime, DT = DT, STAT = STAT_CALL)                                       
        if (STAT_CALL /= SUCCESS_) stop 'CourantGH - ModuleHydrodynamic - ERR01'                               
                                                                                        
                                                                                        
        WaterColumn => Me%External_Var%WaterColumn



        Courant = FillValueReal

        I_Courant = FillValueInt
        J_Courant = FillValueInt

do2 :   do J = JLB, JUB
do3 :   do I = ILB, IUB
cd1 :   if (Me%External_Var%WaterPoints2D(I,J) .EQ. 1) then
            if (WaterColumn(I,J) < 0.) WaterColumn(I,J) = 0.

            Velocity     = SQRT(WaterColumn(I,J) * Gravity)
            DX           = MIN(Me%External_Var%DXX(I,J), Me%External_Var%DYY(I,J))

            Courant_temp = F_Courant(Velocity = Velocity,                       &
                                     DT       = 2. * DT,                        &
                                     DX       = DX)

cd2 :       if (Courant .LT. Courant_temp) then
                I_Courant = I
                J_Courant = J

                Courant = Courant_temp
            end if cd2
        end if cd1
        end do do3
        end do do2



        call OutputCourant(Courant, I_Courant, J_Courant)


        call ReadUnLock_External_Modules


        nullify(WaterColumn)

        !------------------------------------------------------------------------

    end subroutine CourantGH

    !----------------------------------------------------------------------------



    !----------------------------------------------------------------------------

    function F_Courant(Velocity, DT, DX)
    real ::  F_Courant

        !Arguments---------------------------------------------------------------
        
        real, intent(IN) :: Velocity, DT, DX

        !------------------------------------------------------------------------

        F_Courant = Velocity * DT / DX

        !------------------------------------------------------------------------

    end function F_Courant

    !----------------------------------------------------------------------------

    subroutine OutputCourant(Courant, I, J)

        !Arguments---------------------------------------------------------------
        
        integer, intent(IN) :: I, J
        real,    intent(IN) :: Courant

        !------------------------------------------------------------------------

#ifndef _OUTPUT_OFF_
        write(*, *)"---------------------- HYDRODYNAMICS ---------------------"
        write(*, *)
        write(*, *)"Courant Number is : ", Courant
        write(*, *)"In Grid Cell[i,j] : ", i, j
        write(*, *)
#endif

        !------------------------------------------------------------------------

    end subroutine OutputCourant

    !----------------------------------------------------------------------------

#ifdef _USE_SEQASSIMILATION

    subroutine PointToHydroState(HydrodynamicID, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: HydrodynamicID
        integer,            optional, intent(OUT)    :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_          
        integer                                      :: STAT_    

        !------------------------------------------------------------------------

        !This is a compilation of points (one for each variable) for internal memory spaces

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            Me%AuxPointer%WaterLevelNew => Me%WaterLevel%New

            Me%AuxPointer%VelocityUNew => Me%Velocity%Horizontal%U%New

            Me%AuxPointer%VelocityVNew => Me%Velocity%Horizontal%V%New

            Me%AuxPointer%VelocityUOld => Me%Velocity%Horizontal%U%Old

            Me%AuxPointer%VelocityVOld => Me%Velocity%Horizontal%V%Old

            Me%AuxPointer%VelVerticalCartesian => Me%Velocity%Vertical%Cartesian

            Me%AuxPointer%VelVerticalAcross => Me%Velocity%Vertical%Across

            Me%AuxPointer%WaterFluxX => Me%WaterFluxes%X

            Me%AuxPointer%WaterFluxY => Me%WaterFluxes%Y

            Me%AuxPointer%WaterFluxZ => Me%WaterFluxes%Z

            if (Me%SubModel%ON) then
                Me%AuxPointer%SubModelqX => Me%SubModel%qX

                Me%AuxPointer%SubModelqY => Me%SubModel%qY
            endif

            Me%AuxPointer%ChezyVelUV => Me%External_Var%ChezyVelUV

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if cd1

        if (present(STAT))STAT = STAT_

    end subroutine PointToHydroState

    !--------------------------------------------------------------------------

    subroutine CopyWaterLevel(HydrodynamicID, Size2D, WaterLevel, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )                  :: HydrodynamicID
        type (T_Size2D)                                 :: Size2D
        real, dimension(:,:), pointer                   :: WaterLevel
        !integer, dimension(:, :), pointer               :: MapMatrix
        integer, optional, intent(OUT)                  :: STAT

        !External--------------------------------------------------------------
        integer :: ready_        

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            !call Read_Lock(mHydrodynamic_, Me%InstanceID)

            call SetMatrixValue(Me%WaterLevel%New, Size2D, WaterLevel) !, MapMatrix)

            !call Read_UnLock?

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !------------------------------------------------------------------------

    end subroutine CopyWaterLevel

    !--------------------------------------------------------------------------

    subroutine CopyHorizontalVelocity(HydrodynamicID, Size3D, Velocity_U,       &
                                      Velocity_V, OldVelocity_U, OldVelocity_V, &
                                      STAT)

        !Arguments-------------------------------------------------------------
        integer,              intent(IN )           :: HydrodynamicID
        type (T_Size3D)                             :: Size3D
        real, dimension(:,:,:), pointer, optional   :: Velocity_U, Velocity_V
        real, dimension(:,:,:), pointer, optional   :: OldVelocity_U, OldVelocity_V
        !integer, dimension(:, :,:), pointer         :: MapMatrix
        integer, optional,    intent(OUT)           :: STAT

        !External--------------------------------------------------------------
        integer :: ready_        

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            
cd2 :       if (present(Velocity_U)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%Velocity%Horizontal%U%New, Size3D,       &
                                    Velocity_U) !, MapMatrix)

                !call Read_UnLock?
            end if cd2

cd3 :       if (present(Velocity_V)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%Velocity%Horizontal%V%New, Size3D,       &
                                    Velocity_V) !, MapMatrix)

                !call Read_UnLock?
            end if cd3

cd4 :       if (present(OldVelocity_U)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%Velocity%Horizontal%U%Old, Size3D,       &
                                    OldVelocity_U) !, MapMatrix)

                !call Read_UnLock?
            end if cd4

cd5 :       if (present(OldVelocity_V)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%Velocity%Horizontal%V%Old, Size3D,       &
                                    OldVelocity_V) !, MapMatrix)

                !call Read_UnLock?
            end if cd5

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopyHorizontalVelocity

    !--------------------------------------------------------------------------

    subroutine CopyVerticalVelocity(HydrodynamicID, Size3D, Velocity_W,         &
                                    Velocity_Across, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )              :: HydrodynamicID  
        type (T_Size3D)                             :: Size3D
        real, dimension(:,:,:), optional, pointer   :: Velocity_W
        real, dimension(:,:,:), optional, pointer   :: Velocity_Across
        !integer, dimension(:, :,:), pointer         :: MapMatrix
        integer, optional, intent(OUT)              :: STAT

        !External--------------------------------------------------------------
        integer :: ready_        

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            if (present(Velocity_W     )) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%Velocity%Vertical%Cartesian, Size3D,     &
                Velocity_W) !, MapMatrix)

                !call Read_UnLock?
            endif

            if (present(Velocity_Across)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%Velocity%Vertical%Across, Size3D,        &
                Velocity_Across) !, MapMatrix)

                !call Read_UnLock?
            endif

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopyVerticalVelocity

    !--------------------------------------------------------------------------

    subroutine CopyWaterFluxes(HydrodynamicID, Size3D, WaterFluxX, WaterFluxY,  &
                               WaterFluxZ, STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN )    :: HydrodynamicID   
        type (T_Size3D)                                 :: Size3D
        real(8), dimension(:,:,:), pointer, optional    :: WaterFluxX 
        real(8), dimension(:,:,:), pointer, optional    :: WaterFluxY
        real(8), dimension(:,:,:), pointer, optional    :: WaterFluxZ
        !integer, dimension(:, :,:), pointer             :: MapMatrix
        integer, optional, intent(OUT)                  :: STAT

        !External--------------------------------------------------------------
        integer :: ready_        

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then

cd2 :       if (present(WaterFluxX)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%WaterFluxes%X, Size3D, WaterFluxX) !, MapMatrix)

                !call Read_UnLock?
            end if cd2


cd3 :       if (present(WaterFluxY)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%WaterFluxes%Y, Size3D, WaterFluxY) !, MapMatrix)

                !call Read_UnLock?
            end if cd3


cd4 :       if (present(WaterFluxZ)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%WaterFluxes%Z, Size3D, WaterFluxZ) !, MapMatrix)

                !call Read_UnLock?
            end if cd4

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopyWaterFluxes

    !--------------------------------------------------------------------------

    subroutine CopySubModelFluxes(HydrodynamicID, Size3D, SubModelqX,           &
                                  SubModelqY, STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN )    :: HydrodynamicID   
        type (T_Size3D)                                 :: Size3D
        real(8), dimension(:,:,:), pointer, optional    :: SubModelqX 
        real(8), dimension(:,:,:), pointer, optional    :: SubModelqY
        integer, optional, intent(OUT)                  :: STAT

        !External--------------------------------------------------------------
        integer :: ready_        

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then

cd2 :       if (present(SubModelqX)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%SubModel%qX, Size3D, SubModelqX)

                !call Read_UnLock?
            end if cd2


cd3 :       if (present(SubModelqY)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%SubModel%qY, Size3D, SubModelqY)

                !call Read_UnLock?
            end if cd3

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopySubModelFluxes

    !--------------------------------------------------------------------------

    subroutine CopyChezyVelUV(HydrodynamicID, Size2D, ChezyVelUV, STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN )    :: HydrodynamicID   
        type (T_Size2D)                                 :: Size2D
        real,    dimension(:,:),   pointer              :: ChezyVelUV 
        integer, optional, intent(OUT)                  :: STAT

        !External--------------------------------------------------------------
        integer :: ready_        

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            !call Read_Lock(mHydrodynamic_, Me%InstanceID)

            call SetMatrixValue(Me%External_Var%ChezyVelUV, Size2D, ChezyVelUV)

            !call Read_UnLock?

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopyChezyVelUV

#endif _USE_SEQASSIMILATION

    !--------------------------------------------------------------------------


    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELE

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    !--------------------------------------------------------------------------

    subroutine GetDirection(HydrodynamicID, ImplicitDirection,                           &
                            DirectionX, DirectionY, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID
        integer, optional, intent(OUT) :: ImplicitDirection
        integer, optional, intent(OUT) :: DirectionX, DirectionY
        integer, optional, intent(OUT) :: STAT

        

        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mHydrodynamic_, Me%InstanceID)

        
            if (present(DirectionX)) DirectionX = DirectionX_
            if (present(DirectionY)) DirectionY = DirectionY_

            if (present(ImplicitDirection))                                              &
                ImplicitDirection = Me%Direction%XY

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "GetDirection")

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetDirection


    !--------------------------------------------------------------------------

    subroutine GetHydrodynamicSource(HydrodynamicID,                            &
                                     HydrodynamicSource,                        &
                                     Solve_Equations,                           &
                                     Read_File,                                 &
                                     No_hydrodynamic,                           &
                                     Residual_hydrodynamic,                     &
                                     Run_Off,                                   &
                                     ImposedSolution,                           &
                                     Vertical1D,                                &
                                     STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID
        integer,           intent(OUT) :: HydrodynamicSource
        integer, optional, intent(OUT) :: Solve_Equations, Read_File, No_hydrodynamic,  &
                                          Residual_hydrodynamic, Run_Off,               &
                                          ImposedSolution, Vertical1D
        integer, optional, intent(OUT) :: STAT

        

        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mHydrodynamic_, Me%InstanceID)

        
            if (present(Solve_Equations       )) Solve_Equations       = Solve_Equations_
            if (present(Read_File             )) Read_File             = Read_File_
            if (present(No_hydrodynamic       )) No_hydrodynamic       = No_hydrodynamic_
            if (present(Residual_hydrodynamic )) Residual_hydrodynamic = Residual_hydrodynamic_
            if (present(ImposedSolution       )) ImposedSolution       = ImposedSolution_
            if (present(Vertical1D            )) Vertical1D            = Vertical1D_
            if (present(Run_Off               )) Run_Off               = Run_Off_
            

            HydrodynamicSource = Me%ComputeOptions%Evolution

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "GetHydrodynamicSource")

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetHydrodynamicSource
    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetWaterFluxes(HydrodynamicID, WaterFluxX, WaterFluxY, WaterFluxZ,        &
                              STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN ) :: HydrodynamicID   
        real(8), dimension(:,:,:), pointer, optional :: WaterFluxX 
        real(8), dimension(:,:,:), pointer, optional :: WaterFluxY
        real(8), dimension(:,:,:), pointer, optional :: WaterFluxZ

        integer, optional, intent(OUT) :: STAT

        

        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then


cd2 :       if (present(WaterFluxX)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                WaterFluxX => Me%WaterFluxes%X
            end if cd2


cd3 :       if (present(WaterFluxY)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                WaterFluxY => Me%WaterFluxes%Y
            end if cd3


cd4 :       if (present(WaterFluxZ)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                WaterFluxZ => Me%WaterFluxes%Z
            end if cd4


            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetWaterFluxes

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetDischargesFluxes(HydrodynamicID, Discharges, STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN ) :: HydrodynamicID   
        real(8), dimension(:,:,:), pointer, optional :: Discharges 

        integer, optional, intent(OUT)               :: STAT

        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            call Read_Lock(mHydrodynamic_, Me%InstanceID)

            Discharges => Me%WaterFluxes%Discharges

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetDischargesFluxes

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine GetWavesStressON(HydrodynamicID, WavesStressON, STAT)

        !Arguments-------------------------------------------------------------
   
        integer,           intent(IN ) :: HydrodynamicID
        logical                        :: WavesStressON
        integer, optional, intent(OUT) :: STAT

        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            WavesStressON = Me%ComputeOptions%WaveStress
            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetWavesStressON

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetPointDischargesState(HydrodynamicID, DischargesON, STAT)

        !Arguments-------------------------------------------------------------
   
        integer,           intent(IN ) :: HydrodynamicID
        logical                        :: DischargesON
        integer, optional, intent(OUT) :: STAT

        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            DischargesON = Me%ComputeOptions%WaterDischarges

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetPointDischargesState

    !--------------------------------------------------------------------------




    !--------------------------------------------------------------------------

    subroutine GetHorizontalVelocity(HydrodynamicID, Velocity_U, Velocity_V, STAT)

        !Arguments-------------------------------------------------------------
        integer,              intent(IN )           :: HydrodynamicID   
        real, dimension(:,:,:), pointer, optional   :: Velocity_U, Velocity_V
        integer, optional,    intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            
cd2 :       if (present(Velocity_U)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                Velocity_U => Me%Velocity%Horizontal%U%New
            end if cd2

cd3 :       if (present(Velocity_V)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                Velocity_V => Me%Velocity%Horizontal%V%New
            end if cd3

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetHorizontalVelocity

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetOldHorizontalVelocity(HydrodynamicID, OldVelocity_U, OldVelocity_V, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )              :: HydrodynamicID   
        real, dimension(:,:,:), pointer, optional   :: OldVelocity_U, OldVelocity_V
        integer, optional, intent(OUT)              :: STAT


        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            
cd2 :       if (present(OldVelocity_U)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                OldVelocity_U => Me%Velocity%Horizontal%U%Old
            end if cd2

cd3 :       if (present(OldVelocity_V)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                OldVelocity_V => Me%Velocity%Horizontal%V%Old
            end if cd3

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetOldHorizontalVelocity

    !--------------------------------------------------------------------------
    
    !--------------------------------------------------------------------------

    subroutine GetVelocityModulus(HydrodynamicID, VelocityModulus, STAT)

        !Arguments-------------------------------------------------------------
        integer,              intent(IN )           :: HydrodynamicID   
        real, dimension(:,:,:), pointer, optional   :: VelocityModulus
        integer, optional,    intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            
            if(.not. associated(Me%OutPut%ModulusH))then
            
                write(*,*)'Please activate Hydrodynamic outputs'
                call SetError(FATAL_, INTERNAL_, 'GetVelocityModulus - Hydrodynamic - ERR01') 

            endif
            
            call Read_Lock(mHydrodynamic_, Me%InstanceID)
            VelocityModulus => Me%OutPut%ModulusH


            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetVelocityModulus

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetVerticalVelocity(HydrodynamicID, Velocity_W, Velocity_Across, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )              :: HydrodynamicID   
        real, dimension(:,:,:), optional, pointer   :: Velocity_W
        real, dimension(:,:,:), optional, pointer   :: Velocity_Across

        integer, optional, intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            if (present(Velocity_W     )) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                Velocity_W      => Me%Velocity%Vertical%Cartesian
            endif

            if (present(Velocity_Across)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                Velocity_Across => Me%Velocity%Vertical%Across
            endif

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))  STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetVerticalVelocity

    !--------------------------------------------------------------------------

    subroutine GetWaterLevel(HydrodynamicID, WaterLevel, WaterLevelOld, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )           :: HydrodynamicID   
        real, dimension(:,:), optional, pointer  :: WaterLevelOld
        real, dimension(:,:), pointer            :: WaterLevel
        integer, optional, intent(OUT)           :: STAT


        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            call Read_Lock(mHydrodynamic_, Me%InstanceID)
            WaterLevel => Me%WaterLevel%New
            
            !this routine was changed (added if bellow) to be able to simulat exactly 
            !the same tide conditions as in the standalone project for the population
            ! in the Balgzand Area 
            if(present(WaterLevelOld))then
                WaterLevelOld => Me%WaterLevel%Old
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
            endif

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetWaterLevel

    !--------------------------------------------------------------------------
    
    subroutine GetHydrodynamicAirOptions (HydrodynamicID,      &
                                          SurfaceWaterFluxYes, &
                                          WindYes,             &
                                          AtmPressureYes,      &
                                          MslpYes,             &
                                          STAT)
        !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID   
        logical                        :: SurfaceWaterFluxYes, WindYes, AtmPressureYes 
        logical                        :: MslpYes               !Mean Sea Level Pressure
        integer, optional, intent(OUT) :: STAT
        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            SurfaceWaterFluxYes  = Me%ComputeOptions%SurfaceWaterFlux

            if (Me%ComputeOptions%AtmPressure .or. Me%ComputeOptions%InvertBarometer) then

case1 :         select case(Me%ComputeOptions%AtmPressureType)

                    !Use atmospheric pressure
                    case(1)

                        AtmPressureYes       = .true. 
                        MslpYes              = .false. 
                
                    !Use Mean Sea Level Pressure (MSLP)
                    case(2)

                        AtmPressureYes       = .false. 
                        MslpYes              = .true. 

                    !Same as case(1)
                    case default

                        AtmPressureYes       = .true. 
                        MslpYes              = .false. 

                end select case1

            endif

            if (Me%ComputeOptions%Wind == NoWind_) then
                WindYes = .false.
            else
                WindYes = .true.
            endif
            
            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT)) STAT = STAT_
            

        !----------------------------------------------------------------------
    end subroutine GetHydrodynamicAirOptions

    !--------------------------------------------------------------------------

    subroutine GetChezy(HydrodynamicID, Chezy, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID   
        real, dimension(:,:), pointer  :: Chezy
        integer, optional, intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            call Read_Lock(mHydrodynamic_, Me%InstanceID)
            Chezy => Me%External_Var%ChezyZ

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetChezy

    !--------------------------------------------------------------------------
    !--------------------------------------------------------------------------

    subroutine GetHydroNeedsFather (HydrodynamicID, cdsubModel, STAT)
         !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID
        logical,           intent(OUT) :: cdsubModel
        integer, optional, intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            cdsubModel = Me%SubModel%ON 

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetHydroNeedsFather

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine GetHydroAltimAssim (AssimilationID, AltimetricAssimilation, STAT)

        !Arguments------------------------------------------------------------ 
        integer                                     :: AssimilationID
        logical,        intent(OUT)                 :: AltimetricAssimilation
        integer,       intent(OUT),   optional      :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(AssimilationID, ready_) 
        
if1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then
    
            AltimetricAssimilation = Me%ComputeOptions%AltimetryAssimilation%Yes
                           
            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if if1

        if (present(STAT)) STAT = STAT_

    end subroutine GetHydroAltimAssim

    !--------------------------------------------------------------------------


    subroutine GetVertical1D (HydrodynamicID, Vertical1D, STAT)
         !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID
        logical,           intent(OUT) :: Vertical1D
        integer, optional, intent(OUT) :: STAT


        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
if1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then
    
            if (Me%ComputeOptions%Evolution == Vertical1D_) then
            
                Vertical1D = .true.

            else
                Vertical1D = .false.
            endif
                           
            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if if1

        if (present(STAT)) STAT = STAT_

    end subroutine GetVertical1D

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------


    subroutine GetXZFlow (HydrodynamicID, XZFlow, STAT)
         !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID
        logical,           intent(OUT) :: XZFlow
        integer, optional, intent(OUT) :: STAT


        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
if1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then
    
            XZFlow = Me%ComputeOptions%XZFlow
                           
            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if if1

        if (present(STAT)) STAT = STAT_

    end subroutine GetXZFlow

    !--------------------------------------------------------------------------

#ifdef _USE_SEQASSIMILATION

    subroutine GetHydroSeqAssimilation(HydrodynamicID, RunSeqAssimilation, STAT)

        !Arguments------------------------------------------------------------ 
        integer                                     :: HydrodynamicID
        logical                                     :: RunSeqAssimilation
        integer, intent(OUT), optional              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
if1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                               &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            RunSeqAssimilation = Me%RunSeqAssimilation
                
            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if if1

        if (present(STAT)) STAT = STAT_

    end subroutine GetHydroSeqAssimilation

    !--------------------------------------------------------------------------

    subroutine GetCyclicBoundary(HydrodynamicID, CyclicBoundaryON,          &
                                 CyclicBoundaryDirection, STAT)

        !Arguments------------------------------------------------------------ 
        integer                                     :: HydrodynamicID
        logical                                     :: CyclicBoundaryON
        integer                                     :: CyclicBoundaryDirection
        integer, intent(OUT), optional              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
if1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                               &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            CyclicBoundaryON = Me%CyclicBoundary%ON
            CyclicBoundaryDirection = Me%CyclicBoundary%Direction
                
            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if if1

        if (present(STAT)) STAT = STAT_

    end subroutine GetCyclicBoundary

    !--------------------------------------------------------------------------

    subroutine GetSubModelFluxes(HydrodynamicID, SubModelqX, SubModelqY, STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN ) :: HydrodynamicID   
        real(8), dimension(:,:,:), pointer, optional :: SubModelqX 
        real(8), dimension(:,:,:), pointer, optional :: SubModelqY

        integer, optional, intent(OUT) :: STAT      

        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                               &
            (ready_ .EQ. READ_LOCK_ERR_)) then


cd2 :       if (present(SubModelqX)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                SubModelqX => Me%SubModel%qX
            end if cd2

cd3 :       if (present(SubModelqY)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                SubModelqY => Me%SubModel%qY
            end if cd3

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                  &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetSubModelFluxes

    !--------------------------------------------------------------------------

    subroutine GetChezyVelUV(HydrodynamicID, ChezyVelUV, STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN ) :: HydrodynamicID   
        real,    dimension(:,:),   pointer           :: ChezyVelUV 
        integer, optional, intent(OUT)               :: STAT      

        !External--------------------------------------------------------------

        integer :: ready_        

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                               &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            call Read_Lock(mHydrodynamic_, Me%InstanceID)
            ChezyVelUV => Me%External_Var%ChezyVelUV

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                  &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetChezyVelUV

#endif _USE_SEQASSIMILATION

    !--------------------------------------------------------------------------

    subroutine UngetHydrodynamic3Dreal4(HydrodynamicID, Array, STAT)

        !Arguments-------------------------------------------------------------

        integer,               intent(IN ) :: HydrodynamicID
        real(4), pointer, dimension(:,:,:) :: Array
        integer, optional,     intent(OUT) :: STAT
   
        

        !External--------------------------------------------------------------

        integer :: ready_   

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "UngetHydrodynamic3Dreal4")

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetHydrodynamic3Dreal4

    !--------------------------------------------------------------------------



    !--------------------------------------------------------------------------

    subroutine UngetHydrodynamic2Dreal4(HydrodynamicID, Array, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )   :: HydrodynamicID
        real(4), pointer, dimension(:,:) :: Array
        integer, optional, intent(OUT)   :: STAT
   
        

        !External--------------------------------------------------------------

        integer :: ready_   

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "UngetHydrodynamic2Dreal4")

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetHydrodynamic2Dreal4

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine UngetHydrodynamic2Dreal8(HydrodynamicID, Array, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )   :: HydrodynamicID
        real(8), pointer, dimension(:,:) :: Array
        integer, optional, intent(OUT)   :: STAT
   
        

        !External--------------------------------------------------------------

        integer :: ready_   

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "UngetHydrodynamic2Dreal8")

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetHydrodynamic2Dreal8

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine UngetHydrodynamic3Dreal8(HydrodynamicID, Array, STAT)

        !Arguments-------------------------------------------------------------

        integer,               intent(IN ) :: HydrodynamicID
        real(8), pointer, dimension(:,:,:) :: Array
        integer, optional,    intent (OUT) :: STAT
   
        

        !External--------------------------------------------------------------

        integer :: ready_   

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "UngetHydrodynamic3Dreal8")

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetHydrodynamic3Dreal8

    !--------------------------------------------------------------------------

    subroutine SetHydrodynamicManning (HydrodynamicID, Manning, STAT)

        !Arguments-------------------------------------------------------------
        integer                         :: HydrodynamicID
        logical, intent(IN)             :: Manning
        integer, optional, intent(OUT)  :: STAT

        !Local-----------------------------------------------------------------
        integer                         :: ready_              
        integer                         :: STAT_            

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)  
        
cd1 :   if (ready_ == IDLE_ERR_)then

            Me%External_Var%Manning = Manning            
   
            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine SetHydrodynamicManning

    !--------------------------------------------------------------------------

    subroutine SetHydrodynamicChezy (HydrodynamicID, Chezy, ChezyCoef, STAT)

        !Arguments-------------------------------------------------------------
        integer                         :: HydrodynamicID
        logical, intent(IN)             :: Chezy
        real,    intent(IN)             :: ChezyCoef
        integer, optional, intent(OUT)  :: STAT

        !Local-----------------------------------------------------------------
        integer                         :: ready_              
        integer                         :: STAT_            

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)  
        
cd1 :   if (ready_ == IDLE_ERR_)then

            Me%External_Var%Chezy     = Chezy            
            Me%External_Var%ChezyCoef = ChezyCoef            
   
            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine SetHydrodynamicChezy
    
    !--------------------------------------------------------------------------

    subroutine SetHydrodynamicRugosityMatrix (HydrodynamicID, RugosityMatrix, STAT)

        !Arguments-------------------------------------------------------------
        integer                         :: HydrodynamicID
        real, dimension(:, :), pointer  :: RugosityMatrix
        integer, optional, intent(OUT)  :: STAT

        !Local-----------------------------------------------------------------
        integer                         :: ready_              
        integer                         :: STAT_            

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)  
        
cd1 :   if (ready_ == IDLE_ERR_)then

            Me%External_Var%RugosityMatrix => RugosityMatrix            
   
            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_

    end subroutine SetHydrodynamicRugosityMatrix

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    subroutine SetSurfaceWaterFlux(HydrodynamicID, SurfaceWaterFlux, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, pointer, dimension(:,:)               :: SurfaceWaterFlux
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_          
        integer                                     :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
        if (ready_ .EQ. IDLE_ERR_)then

            Me%External_Var%SurfaceWaterFlux       => SurfaceWaterFlux

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_
            
    end subroutine SetSurfaceWaterFlux
    
    
    !--------------------------------------------------------------------------

    
    subroutine SetBottomWaterFlux(HydrodynamicID, BottomWaterFlux, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real(8), pointer, dimension(:,:)            :: BottomWaterFlux
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_          
        integer                                     :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
        if (ready_ .EQ. IDLE_ERR_)then

            Me%External_Var%BottomWaterFlux       => BottomWaterFlux

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_
            
    end subroutine SetBottomWaterFlux

    !--------------------------------------------------------------------------
   
    subroutine SetWindStress(HydrodynamicID, WindStress_X, WindStress_Y, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, pointer, dimension(:,:)               :: WindStress_X
        real, pointer, dimension(:,:)               :: WindStress_Y
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_          
        integer                                     :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
        if (ready_ .EQ. IDLE_ERR_)then

            Me%External_Var%TauWindU       => WindStress_X
            Me%External_Var%TauWindV       => WindStress_Y

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_
            
    end subroutine SetWindStress
    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    subroutine SetAtmosphericPressure(HydrodynamicID, AtmosphericPressure, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, pointer, dimension(:,:)               :: AtmosphericPressure
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_          
        integer                                     :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
        if (ready_ .EQ. IDLE_ERR_)then

            Me%External_Var%AtmosphericPressure       => AtmosphericPressure

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_
            
    end subroutine SetAtmosphericPressure

    !--------------------------------------------------------------------------
    subroutine SetWaveChezyVel(HydrodynamicID, WaveChezyVel, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, pointer, dimension(:,:)               :: WaveChezyVel
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_          
        integer                                     :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
        if (ready_ .EQ. IDLE_ERR_)then

            Me%External_Var%WaveChezyVel  => WaveChezyVel

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_
            
    end subroutine SetWaveChezyVel

    !--------------------------------------------------------------------------

#ifdef _USE_SEQASSIMILATION

    subroutine SetWaterLevel(HydrodynamicID, WaterLevel, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, dimension(:,:), pointer               :: WaterLevel
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_          
        integer                                     :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
        if (ready_ .EQ. IDLE_ERR_) then

            Me%WaterLevel%New => WaterLevel
            !CAUTION: WaterLevel is an external variable/memory space!

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_
            
    end subroutine SetWaterLevel

    !--------------------------------------------------------------------------

    subroutine SetHorizontalVelocity(HydrodynamicID, Velocity_U, Velocity_V,    &
                                     OldVelocity_U, OldVelocity_V, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, dimension(:,:,:), pointer, optional   :: Velocity_U, Velocity_V
        real, dimension(:,:,:), pointer, optional   :: OldVelocity_U, OldVelocity_V
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_          
        integer                                     :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if (ready_ .EQ. IDLE_ERR_) then

cd2 :       if (present(Velocity_U)) then
                Me%Velocity%Horizontal%U%New => Velocity_U
            end if cd2

cd3 :       if (present(Velocity_V)) then
                Me%Velocity%Horizontal%V%New => Velocity_V
            end if cd3

cd4 :       if (present(OldVelocity_U)) then
                Me%Velocity%Horizontal%U%Old => OldVelocity_U
            end if cd4

cd5 :       if (present(OldVelocity_V)) then
                Me%Velocity%Horizontal%V%Old => OldVelocity_V
            end if cd5
            !CAUTION: Velocity_U/Velocity_V is an external variable/memory space!

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))STAT = STAT_
            
    end subroutine SetHorizontalVelocity

    !--------------------------------------------------------------------------

    subroutine SetVerticalVelocity(HydrodynamicID, Velocity_W, Velocity_Across, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, dimension(:,:,:), optional, pointer   :: Velocity_W
        real, dimension(:,:,:), optional, pointer   :: Velocity_Across
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_          
        integer                                     :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if (ready_ .EQ. IDLE_ERR_) then

cd2 :       if (present(Velocity_W)) then
                Me%Velocity%Vertical%Cartesian => Velocity_W
            end if cd2

cd3 :       if (present(Velocity_Across)) then
                Me%Velocity%Vertical%Across => Velocity_Across
            end if cd3
            !CAUTION: Velocity_W/Velocity_Across is an external variable/memory space!

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))STAT = STAT_
            
    end subroutine SetVerticalVelocity

    !--------------------------------------------------------------------------

    subroutine SetWaterFluxes(HydrodynamicID, WaterFluxX, WaterFluxY, WaterFluxZ, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: HydrodynamicID
        real(8), dimension(:,:,:), pointer, optional :: WaterFluxX 
        real(8), dimension(:,:,:), pointer, optional :: WaterFluxY
        real(8), dimension(:,:,:), pointer, optional :: WaterFluxZ
        integer,            optional, intent(OUT)    :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_          
        integer                                      :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if (ready_ .EQ. IDLE_ERR_) then

cd2 :       if (present(WaterFluxX)) then
                Me%WaterFluxes%X => WaterFluxX
            end if cd2

cd3 :       if (present(WaterFluxY)) then
                Me%WaterFluxes%Y => WaterFluxY
            end if cd3

cd4 :       if (present(WaterFluxZ)) then
                Me%WaterFluxes%Z => WaterFluxZ
            end if cd4
            !CAUTION: WaterFluxX/WaterFluxY/WaterFluxZ is an external variable/memory space!


            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))STAT = STAT_
            
    end subroutine SetWaterFluxes

    !--------------------------------------------------------------------------

    subroutine SetSubModelFluxes(HydrodynamicID, SubModelqX, SubModelqY, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: HydrodynamicID
        real(8), dimension(:,:,:), pointer, optional :: SubModelqX 
        real(8), dimension(:,:,:), pointer, optional :: SubModelqY
        integer,            optional, intent(OUT)    :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_          
        integer                                      :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if (ready_ .EQ. IDLE_ERR_) then

cd2 :       if (present(SubModelqX)) then
                Me%SubModel%qX => SubModelqX
            end if cd2

cd3 :       if (present(SubModelqY)) then
                Me%SubModel%qY => SubModelqY
            end if cd3
            !CAUTION: SubModelqX/SubModelqY is an external variable/memory space!

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))STAT = STAT_
            
    end subroutine SetSubModelFluxes

    !--------------------------------------------------------------------------

    subroutine SetChezyVelUV(HydrodynamicID, ChezyVelUV, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: HydrodynamicID
        real,    dimension(:,:),   pointer           :: ChezyVelUV 
        integer,            optional, intent(OUT)    :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_          
        integer                                      :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            Me%External_Var%ChezyVelUV => ChezyVelUV
            !CAUTION: ChezyVelUV is an external variable/memory space!

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))STAT = STAT_
            
    end subroutine SetChezyVelUV

    !--------------------------------------------------------------------------

    subroutine SetHydroVirtualRun(HydrodynamicID, VirtualRun, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: HydrodynamicID
        logical                                      :: VirtualRun
        integer, optional, intent(OUT)               :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_          
        integer                                      :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)  
        
cd1 :   if (ready_ == IDLE_ERR_)then

            Me%VirtualRun     = VirtualRun            
   
            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_

    end subroutine SetHydroVirtualRun

    !--------------------------------------------------------------------------

    subroutine ReSetHydrodynamicProperties(HydrodynamicID, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: HydrodynamicID
        integer,            optional, intent(OUT)    :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_          
        integer                                      :: STAT_    

        !------------------------------------------------------------------------

        !This is a compilation of sets (one for each variable) for internal memory spaces

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            Me%WaterLevel%New => Me%AuxPointer%WaterLevelNew

            Me%Velocity%Horizontal%U%New => Me%AuxPointer%VelocityUNew

            Me%Velocity%Horizontal%V%New => Me%AuxPointer%VelocityVNew

            Me%Velocity%Horizontal%U%Old => Me%AuxPointer%VelocityUOld

            Me%Velocity%Horizontal%V%Old => Me%AuxPointer%VelocityVOld

            Me%Velocity%Vertical%Cartesian => Me%AuxPointer%VelVerticalCartesian

            Me%Velocity%Vertical%Across => Me%AuxPointer%VelVerticalAcross

            Me%WaterFluxes%X => Me%AuxPointer%WaterFluxX

            Me%WaterFluxes%Y => Me%AuxPointer%WaterFluxY

            Me%WaterFluxes%Z => Me%AuxPointer%WaterFluxZ

            if (Me%SubModel%ON) then
                Me%SubModel%qX => Me%AuxPointer%SubModelqX

                Me%SubModel%qY => Me%AuxPointer%SubModelqY
            endif

            Me%External_Var%ChezyVelUV => Me%AuxPointer%ChezyVelUV

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))STAT = STAT_

    end subroutine ReSetHydrodynamicProperties

#endif _USE_SEQASSIMILATION

    !--------------------------------------------------------------------------


    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MO 

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!BOP
!
! !ROUTINE: Modify_Hydrodynamic

! !DESCRIPTION: 
!     This routine is responsible for the evolution of flow properties: 
!     velocities, water fluxes and water level.
!     
 
! !REVISION HISTORY: 
!  1Jan2000    Paulo Chambel  First experimental version.
!  22Nov2000   Paulo Chambel  Comments are introduce in the Protex format 
!                             to produce a manual

!   !INTERFACE:

    subroutine Modify_Hydrodynamic(HydrodynamicID,                             &
                                   Density,                                    &
                                   SigmaDens,                                  &
                                   NewDT,                                      &
                                   STAT)
        

!   !INPUT PARAMETERS:        
        integer, intent (IN )           :: HydrodynamicID
        real, dimension(:,:,:), pointer :: Density
        real, dimension(:,:,:), pointer :: SigmaDens
        type(T_NewDT),    intent (OUT)  :: NewDT

!   !OUTPUT PARAMETERS:        

        integer, optional, intent (OUT) :: STAT

!EOP

        !External--------------------------------------------------------------

        integer :: ready_ 

        !Local-----------------------------------------------------------------

        integer :: STAT_, STAT_CALL           !Auxiliar local variable
        logical :: VariableDT
        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Modify_Hydrodynamic")


            !This hydrodynamic model do not has variable time step
            !NewDT    = FillValueReal


            !Time Properties - Actualises CurrentTime
            call GetComputeCurrentTime(Me%ObjTime, Me%CurrentTime, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'Subroutine Modify_Hydrodynamic; module ModuleHydrodynamic. ERR01.'

            !Read density values
            Me%External_Var%SigmaDens   => SigmaDens
            Me%External_Var%Density     => Density

            call Actualises_Hydrodynamic 


            !Read Lock variables external variables
            !The modules responsible for this variables were 
            !built outside the hydrodynamic module. This modules are
            !call External Modules
            call ReadLock_External_Modules

            
            call ReadLock_ModuleTurbulence 
#ifndef _WAVES_
            if (Me%ComputeOptions%WaveStress) call ReadLock_ModuleWaves
#endif
 
            call One_Iteration 

#ifdef _USE_SEQASSIMILATION
            if (.not. Me%VirtualRun) then
            !(the following is not required when evoluting disturbed states in
            !sequential assimilation, i.e. VirtualRun = .true.)
#endif _USE_SEQASSIMILATION

            !Compute Water Fluxes
            call ComputeBoxesWaterFluxes

            !Compute Residual Flow Properties
            if (Me%ComputeOptions%Residual)                                 &
                call ComputeResidualFlowProperties

            !Calculates the energy of the system - Frank Out 99
            if (Me%ComputeOptions%Energy)                                   &
                call ComputeSystemEnergy

            call Hydrodynamic_OutPut 

            !Records results to binary file
            if (Me%ComputeOptions%Recording) then

                call ModifyHydrodynamicFile(Me%ObjHydrodynamicFileOut,                           &
                                            WaterLevel       = Me%WaterLevel%New,                &
                                            WaterFluxX       = Me%WaterFluxes%X,                 &
                                            WaterFluxY       = Me%WaterFluxes%Y,                 &
                                            Discharges       = Me%WaterFluxes%Discharges,        &
                                            ComputeFacesU3D  = Me%External_Var%ComputeFaces3D_U, &
                                            ComputeFacesV3D  = Me%External_Var%ComputeFaces3D_V, &
                                            HydrodynamicTime = Me%CurrentTime,                   &
                                            STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) &
                    stop 'Subroutine Modify_Hydrodynamic; module ModuleHydrodynamic. ERR02.'
            
            endif

            call GetVariableDT (Me%ObjTime, VariableDT, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Modify_Hydrodynamic - ModuleHydrodynamic - ERR02a'

            if (VariableDT) then
                call CalcNewDT (NewDT)
            endif

#ifdef _USE_SEQASSIMILATION
            endif
#endif _USE_SEQASSIMILATION

            !Output of the Turbulence variaveis
            call ReadUnLock_ModuleTurbulence  
#ifndef _WAVES_
            if (Me%ComputeOptions%WaveStress) call ReadUnLock_ModuleWaves
#endif
            !Read UnLock variables external variables
            !The modules responsible for this variables were 
            !built outside the hydrodynamic module. This modules are
            !call External Modules
            call ReadUnLock_External_Modules

#ifdef _USE_SEQASSIMILATION
            if (.not. Me%VirtualRun) then
            !(the following is not required when evoluting disturbed states in
            !sequential assimilation, i.e. VirtualRun = .true.)
#endif _USE_SEQASSIMILATION

            Me%LastIteration = Me%CurrentTime

#ifdef _USE_SEQASSIMILATION
            endif
#endif _USE_SEQASSIMILATION

            Me%FirstIteration = .false.

            call null_time    (Me%CurrentTime)

            if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Modify_Hydrodynamic")
           
            STAT_ = SUCCESS_
        else              
         
            STAT_ = ready_

        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine Modify_Hydrodynamic

    !--------------------------------------------------------------------------

    subroutine CalcNewDT (NewDT)

        !Arguments-------------------------------------------------------------
        type(T_NewDT)                               :: NewDT

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k, status
        real(8)                                     :: TotalFlux  
        real(8)                                     :: CourantDT, Courant, AuxDT
        real                                        :: DT_Model
        !$ integer                                     :: CHUNK, TID
        !$ type(T_NewDT)                               :: StoredDT
        !$ type(T_NewDT), dimension(Me%MaxThreads)     :: NewDTs
        !$ real(8), dimension(Me%MaxThreads)           :: CourantDTs

        !CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "CalcNewDT")
        
        NewDT%property = 'momentum'
        !$ StoredDT = NewDT

        !$OMP PARALLEL PRIVATE(i,j,k,TotalFlux,AuxDT,CourantDT,NewDT,TID)
                        
        !$ TID = 1 + omp_get_thread_num()
        !$ NewDT = StoredDT
                        
        !Test Frank.
        !Calculates new DT which guarantees a transport Courant < 1 for horizontal fluxes
        !Just consider Fluxes which leave cell
        CourantDT = -FillValueReal
                        
        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            if (Me%External_Var%WaterPoints3D(i, j, k) == WaterPoint) then
                                
                !Verifies the horizontal condition
                TotalFlux   = 0.0

                if (Me%External_Var%ComputeFaces3D_U(i, j, k) == Compute .and. &
                    Me%WaterFluxes%X(i, j, k) < 0.0) then
                    TotalFlux = TotalFlux - Me%WaterFluxes%X(i, j, k)
                endif
                if (Me%External_Var%ComputeFaces3D_U(i, j+1, k) == Compute .and. &
                    Me%WaterFluxes%X(i, j+1, k) > 0.0) then
                    TotalFlux = TotalFlux + Me%WaterFluxes%X(i, j+1, k)
                endif
                if (Me%External_Var%ComputeFaces3D_V(i, j, k) == Compute .and. &
                    Me%WaterFluxes%Y(i, j, k) < 0.0) then
                    TotalFlux = TotalFlux - Me%WaterFluxes%Y(i, j, k)
                endif
                if (Me%External_Var%ComputeFaces3D_V(i+1, j, k) == Compute .and. &
                    Me%WaterFluxes%Y(i+1, j, k) > 0.0) then
                    TotalFlux = TotalFlux + Me%WaterFluxes%Y(i+1, j, k)
                endif

                if (Me%External_Var%ComputeFaces3D_W(i, j, k) == Compute .and. &
                    Me%WaterFluxes%Z(i, j, k) < 0.0) then
                endif

                if (Me%External_Var%ComputeFaces3D_W(i, j, k+1) == Compute .and. &
                    Me%WaterFluxes%Z(i, j, k+1) > 0.0) then
                    TotalFlux = TotalFlux + Me%WaterFluxes%Z(i, j, k+1)
                endif

                if (TotalFlux > 0.0 .and. Me%External_Var%Volume_Z_New(i, j, k) > 0. ) then   !To avoid division by zero. 
                    AuxDT = Me%External_Var%Volume_Z_New(i, j, k) / TotalFlux
                    if (AuxDT < CourantDT) then
                        CourantDT = AuxDT
                        NewDT%i = i; NewDT%j = j; NewDT%k = k
                    endif
                endif
                   
            endif
        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        !$ CourantDTs(TID) = CourantDT
        !$ NewDTs(TID) = NewDT                        
                        
        !$OMP END PARALLEL

        !$ CourantDT = - FillValueReal
        !$ NewDT = StoredDT
        !$ do i = 1, Me%MaxThreads
        !$    if (CourantDTs(i) < CourantDT) then
        !$        CourantDT = CourantDTs(i)
        !$        NewDT = NewDTs(i)
        !$    endif
        !$ enddo

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "CalcNewDT")

        call GetComputeTimeStep(Me%ObjTime, DT_Model, STAT = status)
        
        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, 'CalcNewDT - ModuleHydrodynamic - ERR10')

        Courant = CourantDT / dble(DT_Model)

!        !If variation is over 60.0% shut down DT quickly
!        if     (Courant > 0.6) then
!            NewDT%DT = 0.5  * CourantDT
!        !If variation is over  40% shut down DT slowly
!        elseif (Courant > 0.4 .and. Courant <= .6) then
!            NewDT%DT = 0.8  * CourantDT
!        elseif (Courant > 0.2 .and. Courant <= .4) then
!            NewDT%DT = CourantDT
!        elseif (Courant <= 0.20) then
!            NewDT%DT = 1.2 * CourantDT
!        !Increase DT
!        endif
        
        !Previous formulation was decreasing dt if CourantDT was
        !higher than dt and let dt higher than CourantDT when it should
        !be cutted down.
        !If Courant is over 1 DTCourant is higher than ModelDT
        !use DTCourant because it is not expected problems
        if     (Courant > 1) then
            NewDT%DT = CourantDT
        !If Courant is over  50% shut down DT slowly
        elseif (Courant > 0.5 .and. Courant <= 1) then
            NewDT%DT = 0.75  * CourantDT
        !If Courant below 50%, CourantDT is lower than half ModelDT
        !shut down DT quickly
        elseif (Courant <= 0.50) then
            NewDT%DT = 0.5 * CourantDT
        endif


    end subroutine CalcNewDT

    !End--------------------------------------------------------------------------

    subroutine Statistics_OutPut ( CenterU, CenterV, CenterW, ModulusH, WaterLevel)

        !Arguments-------------------------------------------------------------
         
        real,    dimension(:,:,:), pointer      :: CenterU, CenterV, CenterW, ModulusH
        real,    dimension(:,:  ), pointer      :: WaterLevel

        !Local-----------------------------------------------------------------
        real,    dimension(:,:,:), pointer      :: Value3D
        real,    dimension(:,:  ), pointer      :: Value2D
        !real,    dimension(:,:  ), pointer      :: MLD_Surf
        real,    dimension(:,:  ), pointer      :: Bathymetry
        integer                                 :: MethodStatistic, LayerDefinition
        integer                                 :: Depth, Layer, Value3DStatLayers,      &
                                                   LayersNumber, np, ln
        integer                                 :: ILB, IUB, JLB, JUB, STAT_CALL
        integer                                 :: status
        !Begin-----------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB


        if (Me%Statistics%ON) then

            do np = 1, Me%Statistics%NProp

                if (Me%Statistics%PropList(np) == VelocityU_)           &
                    Value3D => CenterU

                if (Me%Statistics%PropList(np) == VelocityV_)           &
                    Value3D => CenterV

                if (Me%Statistics%PropList(np) == VelocityW_)           &
                    Value3D => CenterW

                if (Me%Statistics%PropList(np) == VelocityModulus_)           &
                    Value3D => ModulusH

                call GetStatisticMethod (Me%Statistics%ID(np), MethodStatistic, &
                                        STAT = status)
                                            
                if (status /= SUCCESS_)                                                  &
                    call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR01')

                call GetStatisticParameters (Me%Statistics%ID(np),          &
                                             Value3DStatLayers = Value3DStatLayers,      &
                                             Depth             = Depth,                  &
                                             Layer             = Layer,                  &
                                             STAT = status)
                                            
                if (status /= SUCCESS_)                                                  &
                    call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR02')


cd1:            if (MethodStatistic == Value3DStatLayers) then


!                    nullify(MLD_Surf)

                    !Gets Bathymetry
                    call GetGridData(Me%ObjGridData,                    &
                                       Bathymetry, STAT = status)
        
                    if (status /= SUCCESS_)                                              &
                        call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR03')

                
                    call GetStatisticLayersNumber(Me%Statistics%ID(np), LayersNumber, STAT = status)
                                                
                    if (status /= SUCCESS_)                                              &
                            call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR04')

                    do ln = 1, LayersNumber

                        call GetStatisticLayerDef(Me%Statistics%ID(np),     &
                                                  ln, LayerDefinition, STAT = status)
                                                    
                        if (status /= SUCCESS_)                                          &
                            call SetError (FATAL_, INTERNAL_, 'OutPut_Statistics - ModuleHydrodynamic - ERR06')
                       !Statistic of properties values along the bottom 
                        if (LayerDefinition == Layer) then 


                            call AddStatisticLayers (StatisticID    = Me%Statistics%ID(np),         &
                                                     Value3D        = Value3D,                      &
                                                     WaterPoints3D  = Me%External_Var%WaterPoints3D,&
                                                     DZ3D           = Me%External_Var%DWZ,          &
                                                     LayerNumber    = ln,                           &
                                                     STAT= STAT_CALL) 

                            if (STAT_CALL /= SUCCESS_)                                              &
                                call SetError (FATAL_, KEYWORD_, 'OutPut_Statistics - ModuleWaterProperties - ERR06')


                        !Statistic of properties values in the surface mixed layer 
                        else if (LayerDefinition == Depth) then 

!                            call GetMLD_Surf(Me%ObjTurbulence, MLD_Surf, STAT = status) 
!
!                            if (status /= SUCCESS_)                                              &
!                                call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR08')

                            call AddStatisticLayers (Me%Statistics%ID(np),                          &
                                                     Value3D       = Value3D,                       &
                                                     WaterPoints3D = Me%External_Var%WaterPoints3D, &
                                                     DZ3D          = Me%External_Var%DWZ,           &
                                                     LayerNumber   = ln,                             &
!                                                     LowerDepth    = MLD_Surf,                      &
                                                     STAT= status) 

                            if (status /= SUCCESS_)                                              &
                                call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR10')

                    
!                            call UnGetTurbulence(Me%ObjTurbulence, MLD_Surf, STAT = status) 

!                            if (status /= SUCCESS_)                                              &
!                                call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR13')

                        endif
 

                    enddo



                endif  cd1

                call ModifyStatistic (Me%Statistics%ID(np),                              &
                                      Value3D       = Value3D,                           &
                                      WaterPoints3D = Me%External_Var%WaterPoints3D,     &
                                      STAT          = status)
                if (status /= SUCCESS_)                                                  &
                    call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR12')


  
            enddo
            
        endif

        if (Me%Statistics2D%ON) then

            do np = 1, Me%Statistics2D%NProp

                if (Me%Statistics2D%PropList(np) == WaterLevel_)           &
                    Value2D => WaterLevel

                if (Me%Statistics2D%PropList(np) == WaterColumn_)          &
                    Value2D => Me%External_Var%WaterColumn

                call GetStatisticMethod (Me%Statistics2D%ID(np), MethodStatistic, &
                                        STAT = status)
                                            
                if (status /= SUCCESS_)                                                  &
                    call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR01b')

                call ModifyStatistic (Me%Statistics2D%ID(np),                              &
                                      Value2D       = Value2D,                           &
                                      WaterPoints2D = Me%External_Var%WaterPoints2D,     &
                                      STAT          = status)
                if (status /= SUCCESS_)                                                  &
                    call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR12')

            enddo
           
        endif

    end subroutine Statistics_OutPut

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine SetHydroFather (HydrodynamicID, HydrodynamicFatherID, InitialField, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )              :: HydrodynamicID, HydrodynamicFatherID
        logical,           intent(IN )              :: InitialField
        integer, optional, intent(OUT)              :: STAT


        !Local-----------------------------------------------------------------
        type (T_Hydrodynamic), pointer              :: ObjHydrodynamicFather
        integer                                     :: ready_, readyFather_
        integer                                     :: STAT_
        real                                        :: DT_Father
        real,    dimension(:,:,:), pointer          :: UFather, VFather, DUZFather, DVZFather
        real(8), dimension(:,:,:), pointer          :: FluxXFather, FluxYFather
        real,    dimension(:,:  ), pointer          :: ZFather
        integer, dimension(:,:,:), pointer          :: Open3DFather
        integer, dimension(:,:,:), pointer          :: WetFaces_UFather    
        integer, dimension(:,:,:), pointer          :: WetFaces_VFather
        integer, dimension(:,:,:), pointer          :: Faces3D_UFather    
        integer, dimension(:,:,:), pointer          :: Faces3D_VFather  
        real                                        :: DT_Son
        integer                                     :: status

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "SetHydroFather")

        STAT_ = UNKNOWN_

        call Ready      (HydrodynamicID, ready_)

        call ReadyFather(HydrodynamicFatherID, ObjHydrodynamicFather, readyFather_)

cd1 :   if (ready_ .EQ. IDLE_ERR_ .and. readyFather_ .EQ. IDLE_ERR_) then

            if(InitialField) then
                call TestSubModelOptionsConsistence (ObjHydrodynamicFather%ComputeOptions%Continuous)
                call GetComputeTimeStep             (ObjHydrodynamicFather%ObjTime, DT_Father)
                
                !Ang: new implementation
                Me%SubModel%FatherKLB = ObjHydrodynamicFather%WorkSize%KLB
                Me%SubModel%FatherKUB = ObjHydrodynamicFather%WorkSize%KUB
                
                call ConstructTimeInterpolation     (DT_Father)

            endif

            call SetMatrixValue(Me%SubModel%DUZ_Old, Me%Size, Me%SubModel%DUZ_New)
            call SetMatrixValue(Me%SubModel%DVZ_Old, Me%Size, Me%SubModel%DVZ_New)

            !Me%SubModel%DUZ_Old(:,:,:) = Me%SubModel%DUZ_New(:,:,:)
            !Me%SubModel%DVZ_Old(:,:,:) = Me%SubModel%DVZ_New(:,:,:)

            if (ObjHydrodynamicFather%LastIteration > Me%SubModel%NextTime &
                .or. InitialField) then

                call ReadLockFather(ObjHydrodynamicFather,                               &
                                    FluxXFather, FluxYFather,                            &
                                    Open3DFather, Faces3D_UFather, Faces3D_VFather,      &
                                    WetFaces_UFather, WetFaces_VFather,                  &
                                    UFather, VFather, ZFather, DUZFather, DVZFather)


                call ReadNextOrInitialField (UFather, VFather, DUZFather, DVZFather,     &
                                       FluxXFather, FluxYFather, ZFather, Open3DFather,  &
                                       Faces3D_UFather, Faces3D_VFather,                 &
                                       WetFaces_UFather, WetFaces_VFather, InitialField, &
                                       ObjHydrodynamicFather%ObjHorizontalGrid)


                !Unget Father information
                call ReadUnLockFather(ObjHydrodynamicFather,                             &
                                      FluxXFather, FluxYFather,                          &
                                      Open3DFather, Faces3D_UFather, Faces3D_VFather,    &
                                      WetFaces_UFather, WetFaces_VFather,                &
                                      UFather, VFather, ZFather, DUZFather, DVZFather)
           

                if (.not. InitialField) then

                    if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.                &
                        (Me%SubModel%VertComunic == Father3DSon2D)) then

                        !Ang: new father-son implementation
                        call GetComputeTimeStep(Me%ObjTime, DT_Son, STAT = status)

                        if (status /= SUCCESS_)                                          &
                        call SetError(FATAL_, INTERNAL_,                                 &
                            "SetHydroFather; Hydrodynamic. ERR01") 

                        !Get time for interpolation from aux variables
                        Me%SubModel%GetFatherTime = Me%SubModel%NextTime + DT_Son

                    endif

                    Me%SubModel%PreviousTime = Me%SubModel%NextTime
                    Me%SubModel%NextTime     = ObjHydrodynamicFather%LastIteration 
                endif

            endif
            if      (Me%SubModel%VertComunic == FatherSonEqualDim) then
                
                call ActualizeSubModelValues(InitialField)

            else if (Me%SubModel%VertComunic == Father2DSon3D) then

                call ActualizeSon3DWithFather2D (InitialField)

            else if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.                   &
                      (Me%SubModel%VertComunic == Father3DSon2D)) then

                !Ang: new implementation
                call ActualizeSon3DWithFather3D (InitialField)

            endif

!            if (Me%SubModel%DeadZone .and. InitialField  .and.           &
            if (InitialField  .and.                                                     &
                .not. Me%ComputeOptions%Continuous .and. Me%SubModel%FatherHotStart)                                      &
                call Initial_Geometry(Me%WaterLevel%New)


            STAT_ = SUCCESS_
        else cd1
         
            STAT_ = ready_

        end if cd1

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "SetHydroFather")

        if (present(STAT))  STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine SetHydroFather

    !--------------------------------------------------------------------------

    subroutine TestSubModelOptionsConsistence(FatherContinuous)

        !Arguments-------------------------------------------------------------
        logical                                     :: FatherContinuous

        !Local-----------------------------------------------------------------
        logical                                     :: ModelGOTM, ContinuousGOTM
        integer                                     :: STAT_CALL

        !----------------------------------------------------------------------
     
        !Begin - Shorten variables name 

        call GetContinuousGOTM(Me%ObjTurbulence, ContinuousGOTM, ModelGOTM, STAT = STAT_CALL)            

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'TestSubModelOptionsConsistence - Hydrodynamic - ERR01.')


        if (FatherContinuous                      .and.                   &
           .not. Me%ComputeOptions%Continuous     .and.                   &
           .not. Me%ComputeOptions%BottomVisc_LIM .and.                   &
            ModelGOTM .and. .not. ContinuousGOTM) then

            write (*,*) 'In this case the submodel initial non-turbulent hydrodynamic properties' 
            write (*,*) 'are initialised based in the father model but the turbulent properties are not.'
            write (*,*) 'In areas of strong velocities numerical instabilities mabe hObjen.'
            write (*,*) 'In this case the user is advised to use the option BOTTOMVISC_LIM.' 
            write (*,*) 'See the user manual for more information about this option http://www.mohid.com.' 

        endif

    end subroutine TestSubModelOptionsConsistence
    
    !--------------------------------------------------------------------------

    subroutine ActualizeSubModelValues (InitialField)

        !Arguments-------------------------------------------------------------
        logical,           intent(IN )     :: InitialField

        !Local-----------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: DUZ_Son, DVZ_Son
        real,    dimension(:,:  ), pointer :: DXX_Son, DYY_Son, Bathymetry
        integer, dimension(:,:  ), pointer :: Boundary2DSon
        integer, dimension(:,:,:), pointer :: Water3DSon
        integer, dimension(:,:,:), pointer :: Faces3D_USon  
        integer, dimension(:,:,:), pointer :: Faces3D_VSon
        integer, dimension(:,:,:), pointer :: ImposedTangFacesUSon, ImposedTangFacesVSon
        integer, dimension(:,:,:), pointer :: ImposedNormFacesUSon, ImposedNormFacesVSon
        real                               :: TimeCoef, MinWaterColumn
        integer                            :: status
        integer                            :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                            :: i, j, k
        logical                            :: ErrorOccured, DeadZoneSon
        integer                            :: CHUNK

        !Begin-----------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB


        if (Me%SubModel%InterPolTime .and. .not. InitialField) then

            !Time Properties - Actualises CurrentTime
            call GetComputeCurrentTime(Me%ObjTime,                       &
                                       Me%CurrentTime, STAT = status)
            if (status /= SUCCESS_)                                                      &                    
                    call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR01") 

            TimeCoef = (Me%CurrentTime       - Me%SubModel%PreviousTime) / &
                       (Me%SubModel%NextTime - Me%SubModel%PreviousTime)

            call null_Time(Me%CurrentTime)


        else 
        
            TimeCoef = 1                    
            
        endif



        
        !Gets Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = status)
        if (status /= SUCCESS_)                                                          &                    
                call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR02") 



        call GetGeometryMinWaterColumn(Me%ObjGeometry, MinWaterColumn, STAT = status)
        if (status /= SUCCESS_)                                                          &                    
            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR03") 
            


        call ReadLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,                     &
                         ImposedNormFacesUSon, ImposedNormFacesVSon,                     &
                         Water3DSon, Boundary2DSon,                                       &
                         Faces3D_USon, Faces3D_VSon,                                     &
                         DUZ_Son, DVZ_Son,                                               &
                         DXX_Son, DYY_Son)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ActualizeSubModelValues")

cd3:    if (InitialField) then

            ErrorOccured = .false.

            CHUNK = CHUNK_J(JLB, JUB + 1)

            !$OMP PARALLEL PRIVATE(i,j,k,DeadZoneSon)

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB + 1
            do i = ILB, IUB

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                else

                    DeadZoneSon = .false.

                endif
                
!cd4:            if (((Faces3D_USon        (i, j, k) == Covered              .and.        &
!                      .not. Me%ComputeOptions%Continuous)   .or.         &

cd4:            if (( Faces3D_USon        (i, j, k) == Covered              .or.         &
                      ImposedTangFacesUSon(i, j, k) == Imposed              .or.         &
                      ImposedNormFacesUSon(i, j, k) == Imposed)             .and.        & 
                      .not. DeadZoneSon .and. .not. Me%SubModel%HotStartData) then
                
                    if (Me%SubModel%qX(i, j, k)  < FillValueReal / 2.) then
#ifndef _USE_MPI
                        !!!! $OMP CRITICAL (ASMV1_OUT01)
                        write(*,*)'Point [i,j,k] not covered',i, j,k
                        ErrorOccured = .true.
                        !!!! $OMP END CRITICAL (ASMV1_OUT01)
#endif
                        if (Me%SubModel%MissingNull)                                    &
                            Me%SubModel%qX(i, j, k) = 0.
                    endif
                    
                    if (.not. Me%ComputeOptions%Continuous)                             &
                        Me%WaterFluxes%X(i, j, k)               =                       &
                        Me%SubModel%qX (i, j, k) * DYY_Son(i, j)
            
                endif cd4

            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo

            !$OMP MASTER
            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP END MASTER
            !$OMP BARRIER

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB + 1


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                else

                    DeadZoneSon = .false.

                endif
                
!cd5:            if (((Faces3D_VSon        (i, j, k) == Covered              .and.        &
!                      .not. Me%ComputeOptions%Continuous)   .or.         &
!                      ImposedTangFacesVSon(i, j, k) == Imposed              .or.         &
!                      ImposedNormFacesVSon(i, j, k) == Imposed)             .and.        & 
!                      .not. DeadZoneSon) then

cd5:            if (( Faces3D_VSon        (i, j, k) == Covered              .or.         &
                      ImposedTangFacesVSon(i, j, k) == Imposed              .or.         &
                      ImposedNormFacesVSon(i, j, k) == Imposed)             .and.        & 
                      .not. DeadZoneSon .and. .not. Me%SubModel%HotStartData) then


                
                    if (Me%SubModel%qY  (i, j, k) < FillValueReal / 2.) then
#ifndef _USE_MPI
                        !!!! $OMP CRITICAL (ASMV2_OUT02)
                        write(*,*)'Point [i,j,k] not covered',i, j,k
                        ErrorOccured = .true.
                        !!!! $OMP END CRITICAL (ASMV2_OUT02)
#endif
                        if (Me%SubModel%MissingNull)                     &
                            Me%SubModel%qY(i, j, k) = 0.
                    endif

                    if (.not. Me%ComputeOptions%Continuous)                             &
                        Me%WaterFluxes%Y(i, j, k)               =                       &
                        Me%SubModel%qY  (i, j, k) * DXX_Son(i, j)

                endif cd5

            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo
            !$OMP END PARALLEL

            if (ErrorOccured .and. .not. Me%SubModel%MissingNull)        &
                call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR04") 


        endif cd3

        CHUNK = CHUNK_J(JLB, JUB)
            
cd66:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous) .or. & 
             Me%Relaxation%WaterLevel                               .or. &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_)  then

            !$OMP PARALLEL PRIVATE(i,j,DeadZoneSon)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                !The test must be done for the water points because the water levels in the corner (no open points) 
                !are used to compute face areas where momentum fluxes are computed.
cd6:            if (Water3DSon(i, j, KUB) == WaterPoint .and. .not. DeadZoneSon) then
                
                    Me%SubModel%Z(i, j)  =                                   &
                            Me%SubModel%Z_Next    (i, j) * TimeCoef  +       &
                            Me%SubModel%Z_Previous(i, j) * (1 - TimeCoef)

                    if (Me%SubModel%Z(i, j) < (- Bathymetry(i, j) + 0.75 * MinWaterColumn)) then
                        Me%SubModel%Z(i, j) =  - Bathymetry(i, j) + 0.75 * MinWaterColumn
                    endif

                    if (Me%SubModel%Z_Next    (i, j) < FillValueReal / 2. .or.   &
                        Me%SubModel%Z_Previous(i, j) < FillValueReal / 2.) then


                        if (.not.Me%SubModel%MissingNull) then
                            !!!! $OMP CRITICAL (ASMV3_ERR05)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR05") 
                            !!!! $OMP END CRITICAL (ASMV3_ERR05)
                        endif

                    endif

                    if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                       .and. Me%SubModel%FatherHotStart)                       &
                        Me%WaterLevel%New(i, j) = Me%SubModel%Z(i, j)


                endif cd6

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (Me%SubModel%MissingNull)                                                &
                call RemoveLowerSpikes (Me%WaterLevel%New, Water3DSon,                  &
                                        Bathymetry, MinWaterColumn,                     &
                                        Me%SubModel%DeadZonePoint, Me%SubModel%DeadZone,&
                                        ILB, IUB, JLB, JUB, KUB) 

        else cd66

            !$OMP PARALLEL PRIVATE(i,j,DeadZoneSon)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                !The test must be done for the water points because the water levels in the corner (no open points) 
                !are used to compute face areas where momentum fluxes are computed.                    
cd67:           if (Boundary2DSon(i, j) == Boundary .and. Water3DSon(i, j, KUB) == WaterPoint  &
                   .and. .not. DeadZoneSon) then

                    Me%SubModel%Z(i, j)  =                                   &
                            Me%SubModel%Z_Next    (i, j) * TimeCoef  +       &
                            Me%SubModel%Z_Previous(i, j) * (1 - TimeCoef)
                
                    if (Me%SubModel%Z_Next    (i, j) < FillValueReal / 2. .or.   &
                        Me%SubModel%Z_Previous(i, j) < FillValueReal / 2.)   then

                        if (Me%SubModel%MissingNull) then
                            !The cell is considered uncovered if WaterColumn < MinWaterColumn 
                            !if WaterColumn < MinWaterColumn / 2 the model put WaterColumn = MinWaterColumn / 2 (creates water)
                            ! Using WaterColumn = 3/4MinWaterColumn garantes that the cell is uncovered but mass is not created
                            Me%SubModel%Z(i, j)  = - Bathymetry(i, j) + 0.75 * MinWaterColumn 

                        else
                            !!!! $OMP CRITICAL (ASMV4_ERR06)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR06") 
                            !!!! $OMP END CRITICAL (ASMV4_ERR06)
                        endif
                    endif


                endif cd67

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (Me%SubModel%MissingNull)                                                &
                call RemoveLowerSpikes (Me%SubModel%Z, Water3DSon,                      &
                                        Bathymetry, MinWaterColumn,                     &
                                        Me%SubModel%DeadZonePoint, Me%SubModel%DeadZone,&
                                        ILB, IUB, JLB, JUB, KUB, Boundary2DSon) 



        endif cd66
        
        CHUNK = CHUNK_J(JLB, JUB + 1)
        !$OMP PARALLEL PRIVATE(i,j,k,DeadZoneSon)

cd8:    if ((InitialField .and. .not. Me%ComputeOptions%Continuous)          .or. & 
             Me%Relaxation%Force .or. Me%Relaxation%Velocity .or. &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB + 1
            do i = ILB, IUB

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                else

                    DeadZoneSon = .false.

                endif
                    

cd7:            if (Faces3D_USon(i, j, k) == Covered .and. .not. DeadZoneSon) then
                
                    Me%SubModel%U_New(i, j, k)  =                            &
                            Me%SubModel%U_Next    (i, j, k) * TimeCoef  +    &
                            Me%SubModel%U_Previous(i, j, k) * (1 - TimeCoef)


                    if (Me%SubModel%U_Next    (i, j, k) < FillValueReal / 2. .or.&
                        Me%SubModel%U_Previous(i, j, k) < FillValueReal / 2.)   then

                        if (Me%SubModel%MissingNull) then 
                            Me%SubModel%U_New(i, j, k)  = 0.
                        else
                            !!!! $OMP CRITICAL (ASMV5_ERR07)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR07") 
                            !!!! $OMP END CRITICAL (ASMV5_ERR07)
                        endif

                    endif

                    if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                        .and. Me%SubModel%FatherHotStart)                      &
                        Me%Velocity%Horizontal%U%New(i, j, k) =                &
                                   Me%SubModel%U_New(i, j, k)

   
                    Me%SubModel%DUZ_New(i, j, k)  =                          &
                            Me%SubModel%DUZ_Next    (i, j, k) * TimeCoef  +  &
                            Me%SubModel%DUZ_Previous(i, j, k) * (1 - TimeCoef)

                    if (Me%SubModel%DUZ_Next    (i, j, k) < FillValueReal / 2. .or.&
                        Me%SubModel%DUZ_Previous(i, j, k) < FillValueReal / 2.)    then

                        if (Me%SubModel%MissingNull) then 
                            Me%SubModel%DUZ_New(i, j, k)  = 0.
                        else
                            !!!! $OMP CRITICAL (ASMV6_ERR08)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR08") 
                            !!!! $OMP END CRITICAL (ASMV6_ERR08)
                        endif

                    endif




                endif cd7

            enddo
            enddo
            !$OMP END DO
            enddo
            
        endif cd8


        do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB + 1
        do i = ILB, IUB

            if (Me%SubModel%DeadZone) then

                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

            else

                DeadZoneSon = .false.

            endif

            
cd77:       if ((ImposedTangFacesUSon(i, j, k) == Imposed  .or.                          &
                 ImposedNormFacesUSon(i, j, k) == Imposed) .and. .not. DeadZoneSon) then
                
                Me%SubModel%U_New(i, j, k)  =                            &
                        Me%SubModel%U_Next    (i, j, k) * TimeCoef  +    &
                        Me%SubModel%U_Previous(i, j, k) * (1 - TimeCoef)

                if (Me%SubModel%U_Next    (i, j, k) < FillValueReal / 2. .or.&
                    Me%SubModel%U_Previous(i, j, k) < FillValueReal / 2.)  then

                    if (Me%SubModel%MissingNull) then 
                        Me%SubModel%U_New(i, j, k)  = 0.
                    else
                        !!!! $OMP CRITICAL (ASMV7_ERR09)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR09") 
                        !!!! $OMP END CRITICAL (ASMV7_ERR09)
                    endif
                endif


                if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                    .and. Me%SubModel%FatherHotStart)                      &
                    Me%Velocity%Horizontal%U%New(i, j, k) =                &
                               Me%SubModel%U_New(i, j, k)

                Me%SubModel%DUZ_New(i, j, k)  =                          &
                        Me%SubModel%DUZ_Next    (i, j, k) * TimeCoef  +  &
                        Me%SubModel%DUZ_Previous(i, j, k) * (1 - TimeCoef)

                if (Me%SubModel%DUZ_Next    (i, j, k) < FillValueReal / 2. .or.&
                    Me%SubModel%DUZ_Previous(i, j, k) < FillValueReal / 2.)  then

                    if (Me%SubModel%MissingNull) then 
                        Me%SubModel%DUZ_New(i, j, k)  = 0.
                    else
                        !!!! $OMP CRITICAL (ASMV8_ERR10)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR10") 
                        !!!! $OMP END CRITICAL (ASMV8_ERR10)
                    endif

                endif



            endif cd77

        enddo
        enddo
        !$OMP END DO
        enddo

        !$OMP MASTER
        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP END MASTER
        !$OMP BARRIER

cd10:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous)          .or. & 
             Me%Relaxation%Force .or. Me%Relaxation%Velocity .or. &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB + 1

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                else

                    DeadZoneSon = .false.

                endif


cd9:            if (Faces3D_VSon(i, j, k) == Covered .and. .not. DeadZoneSon) then


                    Me%SubModel%V_New(i, j, k)      =                        &
                            Me%SubModel%V_Next    (i, j, k) * TimeCoef  +    &
                            Me%SubModel%V_Previous(i, j, k) * (1 - TimeCoef)

                    if (Me%SubModel%V_Next    (i, j, k) < FillValueReal / 2. .or.&
                        Me%SubModel%V_Previous(i, j, k) < FillValueReal / 2.) then

                        if (Me%SubModel%MissingNull) then 
                            Me%SubModel%V_New(i, j, k)  = 0.
                        else
                            !!!! $OMP CRITICAL (ASMV9_ERR11)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR11") 
                            !!!! $OMP END CRITICAL (ASMV9_ERR11)
                        endif
                    endif


                    if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                       .and. Me%SubModel%FatherHotStart)                       &
                        Me%Velocity%Horizontal%V%New(i, j, k) =                &
                                   Me%SubModel%V_New(i, j, k)


                    Me%SubModel%DVZ_New(i, j, k)  =                          &
                            Me%SubModel%DVZ_Next    (i, j, k) * TimeCoef  +  &
                            Me%SubModel%DVZ_Previous(i, j, k) * (1 - TimeCoef)


                    if (Me%SubModel%DVZ_Next    (i, j, k) < FillValueReal / 2. .or.&
                        Me%SubModel%DVZ_Previous(i, j, k) < FillValueReal / 2.)    then

                        if (Me%SubModel%MissingNull) then 
                            Me%SubModel%DVZ_New(i, j, k)  = 0.
                        else
                            !!!! $OMP CRITICAL (ASMV10_ERR12)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR12") 
                            !!!! $OMP END CRITICAL (ASMV10_ERR12)
                        endif

                    endif


                endif cd9


            enddo
            enddo
            !$OMP END DO
            enddo

        endif cd10


        do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB + 1

            if (Me%SubModel%DeadZone) then

                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

            else

                DeadZoneSon = .false.

            endif


cd99:       if ((ImposedTangFacesVSon(i, j, k) == Imposed  .or.                          &
                 ImposedNormFacesVSon(i, j, k) == Imposed) .and. .not. DeadZoneSon) then


                Me%SubModel%V_New(i, j, k)      =                        &
                        Me%SubModel%V_Next    (i, j, k) * TimeCoef  +    &
                        Me%SubModel%V_Previous(i, j, k) * (1 - TimeCoef)

                
                if (Me%SubModel%V_Next    (i, j, k) < FillValueReal / 2. .or.&
                    Me%SubModel%V_Previous(i, j, k) < FillValueReal / 2.)  then
 
                    if (Me%SubModel%MissingNull) then 
                        Me%SubModel%V_New(i, j, k)  = 0.
                    else
                        !!!! $OMP CRITICAL (ASMV11_ERR13)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR13") 
                        !!!! $OMP END CRITICAL (ASMV11_ERR13)
                    endif

                endif

                if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                    .and. Me%SubModel%FatherHotStart)                      &
                    Me%Velocity%Horizontal%V%New(i, j, k) =                &
                               Me%SubModel%V_New(i, j, k)

                Me%SubModel%DVZ_New(i, j, k)  =                          &
                        Me%SubModel%DVZ_Next    (i, j, k) * TimeCoef  +  &
                        Me%SubModel%DVZ_Previous(i, j, k) * (1 - TimeCoef)


                if (Me%SubModel%DVZ_Next    (i, j, k) < FillValueReal / 2. .or.&
                    Me%SubModel%DVZ_Previous(i, j, k) < FillValueReal / 2.)   then

                    if (Me%SubModel%MissingNull) then 
                        Me%SubModel%DVZ_New(i, j, k)  = 0.
                    else
                        !!!! $OMP CRITICAL (ASMV12_ERR14)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR14") 
                        !!!! $OMP END CRITICAL (ASMV12_ERR14)
                    endif

                endif
                        
            endif cd99

        enddo
        enddo
        !$OMP END DO
        enddo

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ActualizeSubModelValues")

        !This is only done for graphical reasons
        if (InitialField .and. .not. Me%ComputeOptions%Continuous .and. Me%SubModel%FatherHotStart) then

            !U corners            
            Me%Velocity%Horizontal%U%New(ILB,JLB    , KLB:KUB)   =       &
            Me%SubModel%U_New           (ILB,JLB    , KLB:KUB)

            Me%Velocity%Horizontal%U%New(ILB,JUB + 1, KLB:KUB)   =       &
            Me%SubModel%U_New           (ILB,JUB + 1, KLB:KUB)

            Me%Velocity%Horizontal%U%New(IUB,JLB    , KLB:KUB)   =       &
            Me%SubModel%U_New           (IUB,JLB    , KLB:KUB)

            Me%Velocity%Horizontal%U%New(IUB,JUB + 1, KLB:KUB)   =       &
            Me%SubModel%U_New           (IUB,JUB + 1, KLB:KUB)

           
            !V corners
            Me%Velocity%Horizontal%V%New(ILB,JLB    , KLB:KUB)   =       &
            Me%SubModel%V_New           (ILB,JLB    , KLB:KUB)

            Me%Velocity%Horizontal%V%New(ILB,JUB    , KLB:KUB)   =       &
            Me%SubModel%V_New           (ILB,JUB    , KLB:KUB)

            Me%Velocity%Horizontal%V%New(IUB + 1,JLB, KLB:KUB)   =       &
            Me%SubModel%V_New           (IUB + 1,JLB, KLB:KUB)

            Me%Velocity%Horizontal%V%New(IUB + 1,JUB, KLB:KUB)   =       &
            Me%SubModel%V_New           (IUB + 1,JUB, KLB:KUB)

            
        endif

        Me%SubModel%Set      = .true.


        !UnGet son information 
        call ReadUnLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,                   &
                           ImposedNormFacesUSon, ImposedNormFacesVSon,                   &
                           Water3DSon, Boundary2DSon,                                     &
                           Faces3D_USon, Faces3D_VSon,                                   &
                           DUZ_Son, DVZ_Son,                                             &
                           DXX_Son, DYY_Son)


cd11:   if (InitialField .and. .not. Me%ComputeOptions%Continuous) then

            Me%WaterLevel%Old               (:,:  ) =                    &
                Me%WaterLevel%New           (:,:  )

            Me%Velocity%Horizontal%V%Old    (:,:,:) =                    &
                Me%Velocity%Horizontal%V%New(:,:,:)

            Me%Velocity%Horizontal%U%Old    (:,:,:) =                    &
                Me%Velocity%Horizontal%U%New(:,:,:)

            Me%SubModel%DUZ_Old(:,:,:)              =                    &
                Me%SubModel%DUZ_Next(:,:,:)

            Me%SubModel%DVZ_Old(:,:,:)              =                    &
                Me%SubModel%DVZ_Next(:,:,:)

        endif cd11

       !UnGets Bathymetry
        call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR15") 

    end subroutine ActualizeSubModelValues

    !--------------------------------------------------------------------------
    subroutine ActualizeSon3DWithFather2D (InitialField)

        !Arguments-------------------------------------------------------------
        logical,           intent(IN )  :: InitialField

        !Local-----------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: DUZ_Son, DVZ_Son
        real,    dimension(:,:  ), pointer :: DXX_Son, DYY_Son, WaterColumnU, WaterColumnV, Bathymetry
        integer, dimension(:,:  ), pointer :: Boundary2DSon, KFloor_U, KFloor_V
        integer, dimension(:,:,:), pointer :: Water3DSon
        integer, dimension(:,:,:), pointer :: Faces3D_USon  
        integer, dimension(:,:,:), pointer :: Faces3D_VSon
        integer, dimension(:,:,:), pointer :: ImposedTangFacesUSon, ImposedTangFacesVSon
        integer, dimension(:,:,:), pointer :: ImposedNormFacesUSon, ImposedNormFacesVSon
        real                               :: TimeCoef, RelativeThickness, MinWaterColumn
        integer                            :: status
        integer                            :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                            :: i, j, k, Kbottom, i_Thick, j_Thick
        logical                            :: ErrorOccured, DeadZoneSon, NullValue

        integer                            :: CHUNK

        !Begin-----------------------------------------------------------------


        call GetGeometryWaterColumn(Me%ObjGeometry,                          &
                                    WaterColumnU= WaterColumnU, WaterColumnV= WaterColumnV,  &
                                    STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR01") 


        call GetGeometryKFloor(Me%ObjGeometry,                           &
                               U = KFloor_U, V = KFloor_V, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR02") 


       !Gets Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR03") 


        call GetGeometryMinWaterColumn(Me%ObjGeometry,                   &
                                       MinWaterColumn, STAT = status)

        if (status /= SUCCESS_)                                                          &                    
            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR04") 


        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        if (Me%SubModel%InterPolTime .and. .not. InitialField) then

            !Time Properties - Actualises CurrentTime
            call GetComputeCurrentTime(Me%ObjTime,                       &
                                       Me%CurrentTime, STAT = status)
            if (status /= SUCCESS_)                                                      &                    
                    call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR05") 

            TimeCoef = (Me%CurrentTime       - Me%SubModel%PreviousTime) / &
                       (Me%SubModel%NextTime - Me%SubModel%PreviousTime)

            call null_Time(Me%CurrentTime)

        else 
        
            TimeCoef = 1                    
            
        endif


        call ReadLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,                     &
                         ImposedNormFacesUSon, ImposedNormFacesVSon,                     &
                         Water3DSon, Boundary2DSon,                                       &
                         Faces3D_USon, Faces3D_VSon,                                     &
                         DUZ_Son, DVZ_Son,                                               &
                         DXX_Son, DYY_Son)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ActualizeSon3DWithFather2D")

cd3:    if (InitialField) then

            ErrorOccured = .false.

            CHUNK = CHUNK_J(JLB, JUB + 1)

            !$OMP PARALLEL PRIVATE(i,j,DeadZoneSon,NullValue,i_thick,j_thick) &
            !$OMP PRIVATE(Kbottom,k,RelativeThickness)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB + 1
            do i = ILB, IUB

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                
cd4:            if ((Faces3D_USon        (i, j, KUB) == Covered   .or.                   &
                     ImposedTangFacesUSon(i, j, KUB) == Imposed   .or.                   &
                     ImposedNormFacesUSon(i, j, KUB) == Imposed)  .and.                  & 
                     .not. DeadZoneSon .and. .not. Me%SubModel%HotStartData) then

                    NullValue = .false.
                
                    if (Me%SubModel%qX(i, j, KUB)  < FillValueReal / 2.) then
#ifndef _USE_MPI
                        !!!! $OMP CRITICAL (AS3DWF2D1_OUT01)
                        write(*,*)'Point [i,j,k] not covered',i, j,KUB
                        !!!! $OMP END CRITICAL (AS3DWF2D1_OUT01)
#endif
                        ErrorOccured = .true.
                        if (Me%SubModel%MissingNull)                     &
                            NullValue = .true.

                    endif


                    if      (ImposedTangFacesUSon(i, j, KUB) == Imposed .or.             &
                             Faces3D_USon        (i, j, KUB) == Covered) then

                        i_thick = i
                        j_thick = j

                    else if (ImposedNormFacesUSon(i, j, KUB) == Imposed) then

                        i_thick = i

                        if      (j == JUB + 1) then

                            j_thick = j - 1

                        else if (j == JLB) then

                            j_thick = j + 1

                        else

                            j_thick = j + Faces3D_USon(i, j + 1, KUB) - Faces3D_USon(i, j - 1, KUB)

                        endif

                    endif

                    Kbottom = KFloor_U(i_thick, j_thick)

                    do k = Kbottom, KUB
                        
                        if (NullValue) then

                            Me%SubModel%qX  (i, j, k) = 0.

                        else

                            RelativeThickness = DUZ_Son(i_thick, j_thick, k) / WaterColumnU(i_thick, j_thick)

                            Me%SubModel%qX (i, j, k) =                       &
                                Me%SubModel%qX (i, j, KUB) * RelativeThickness

                        endif

                        if (.not. Me%ComputeOptions%Continuous)                         &
                            Me%WaterFluxes%X(i, j, k)               =                   &
                                Me%SubModel%qX (i, j, k  ) * DYY_Son(i, j) 

                    enddo

            
                endif cd4

            enddo
            enddo
            !$OMP END DO

            !$OMP MASTER
            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP END MASTER
            !$OMP BARRIER

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB + 1


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                
cd5:            if ((Faces3D_VSon        (i, j, KUB) == Covered   .or.                   &
                     ImposedTangFacesVSon(i, j, KUB) == Imposed   .or.                   &
                     ImposedNormFacesVSon(i, j, KUB) == Imposed)  .and.                  & 
                     .not. DeadZoneSon .and. .not. Me%SubModel%HotStartData) then
                    
                    NullValue = .false.
                
                    if (Me%SubModel%qY  (i, j, KUB) < FillValueReal / 2.) then
#ifndef _USE_MPI
                        !!!! $OMP CRITICAL (AS3DWF2D2_OUT02)
                        write(*,*)'Point [i,j,k] not covered',i, j,KUB
                        !!!! $OMP END CRITICAL (AS3DWF2D2_OUT02)
#endif
                        ErrorOccured = .true.
                        if (Me%SubModel%MissingNull)                     &
                            NullValue = .true.
                    endif


                    if (ImposedTangFacesVSon(i, j, KUB) == Imposed .or.                  &
                        Faces3D_VSon        (i, j, KUB) == Covered ) then

                        i_thick = i
                        j_thick = j

                    else if (ImposedNormFacesVSon(i, j, KUB) == Imposed) then

                        if      (i == IUB + 1) then

                            i_thick = i - 1

                        else if (i == ILB) then

                            i_thick = i + 1

                        else

                            i_thick = i + Faces3D_VSon(i + 1, j, KUB) - Faces3D_VSon(i - 1, j, KUB)

                        endif

                        j_thick = j 

                    endif

                    Kbottom = KFloor_V(i_thick, j_thick)


                    do k = Kbottom, KUB

                        if (NullValue) then

                            Me%SubModel%qY  (i, j, k) = 0.

                        else

                            RelativeThickness = DVZ_Son(i_thick, j_thick, k) / WaterColumnV(i_thick, j_thick)

                            Me%SubModel%qY  (i, j, k) =                      &
                                Me%SubModel%qY  (i, j, KUB) * RelativeThickness

                        endif

                    enddo



                endif cd5

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (ErrorOccured .and. .not. Me%SubModel%MissingNull)        &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR06") 

        endif cd3

            
cd66:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous) .or. & 
             Me%Relaxation%WaterLevel                               .or. &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_)  then

            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP PARALLEL PRIVATE(i,j,DeadZoneSon)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                !The test must be done for the water points because the water levels in the corner (no open points) 
                !are used to compute face areas where momentum fluxes are computed.
cd6:            if (Water3DSon(i, j, KUB) == WaterPoint .and. .not. DeadZoneSon) then
                
                    Me%SubModel%Z(i, j)  =                                   &
                            Me%SubModel%Z_Next    (i, j) * TimeCoef  +       &
                            Me%SubModel%Z_Previous(i, j) * (1 - TimeCoef)


                    if (Me%SubModel%Z_Next    (i, j) < FillValueReal / 2. .or.   &
                        Me%SubModel%Z_Previous(i, j) < FillValueReal / 2.) then

                        if (Me%SubModel%MissingNull) then
                            !The cell is considered uncovered if WaterColumn < MinWaterColumn 
                            !if WaterColumn < MinWaterColumn / 2 the model put WaterColumn = MinWaterColumn / 2 (creates water)
                            ! Using WaterColumn = 3/4MinWaterColumn garantes that the cell is uncovered but mass is not created
                            Me%SubModel%Z(i, j)  = - Bathymetry(i, j) + 0.75 * MinWaterColumn 

                        else
                            !!!! $OMP CRITICAL (AS3DWF2D3_ERR07)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR07") 
                            !!!! $OMP END CRITICAL (AS3DWF2D3_ERR07)
                        endif

                    endif

!                    if (InitialField .and. .not. Me%ComputeOptions%Continuous) &
!                        Me%WaterLevel%New(i, j) =                              &
!                            Me%SubModel%Z(i, j)


                endif cd6

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (Me%SubModel%MissingNull) then

                 call RemoveLowerSpikes (Me%SubModel%Z, Water3DSon,                     &
                                        Bathymetry, MinWaterColumn,                     &
                                        Me%SubModel%DeadZonePoint, Me%SubModel%DeadZone,&
                                        ILB, IUB, JLB, JUB, KUB) 
            endif

            if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                .and. Me%SubModel%FatherHotStart)                      &
                Me%WaterLevel%New(:, :) =                              &
                    Me%SubModel%Z(:, :)



        else cd66

            CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(i,j,DeadZoneSon)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                !The test must be done for the water points because the water levels in the corner (no open points) 
                !are used to compute face areas where momentum fluxes are computed.
cd67:           if (Boundary2DSon(i, j) == Boundary .and. Water3DSon(i, j, KUB) == WaterPoint  &
                    .and. .not. DeadZoneSon) then
                
                    Me%SubModel%Z(i, j)  =                                   &
                            Me%SubModel%Z_Next    (i, j) * TimeCoef  +       &
                            Me%SubModel%Z_Previous(i, j) * (1 - TimeCoef)


                    if (Me%SubModel%Z_Next    (i, j) < FillValueReal / 2. .or.   &
                        Me%SubModel%Z_Previous(i, j) < FillValueReal / 2.) then

                        if (Me%SubModel%MissingNull) then
                            !The cell is considered uncovered if WaterColumn < MinWaterColumn 
                            !if WaterColumn < MinWaterColumn / 2 the model put WaterColumn = MinWaterColumn / 2 (creates water)
                            ! Using WaterColumn = 3/4MinWaterColumn garantes that the cell is uncovered but mass is not created
                            Me%SubModel%Z(i, j)  = - Bathymetry(i, j) + 0.75 * MinWaterColumn 

                        else
                            !!!! $OMP CRITICAL (AS3DWF2D4_ERR08)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR08") 
                            !!!! $OMP END CRITICAL (AS3DWF2D4_ERR08)
                        endif

                    endif

                endif cd67

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (Me%SubModel%MissingNull)                                                &
                call RemoveLowerSpikes (Me%SubModel%Z, Water3DSon,                      &
                                        Bathymetry, MinWaterColumn,                     &
                                        Me%SubModel%DeadZonePoint, Me%SubModel%DeadZone,&
                                        ILB, IUB, JLB, JUB, KUB, Boundary2DSon) 


        endif cd66

        CHUNK = CHUNK_J(JLB, JUB + 1)

        !$OMP PARALLEL PRIVATE(i,j,k,DeadZoneSon,NullValue,Kbottom) &
        !$OMP PRIVATE(RelativeThickness,i_thick,j_thick)

cd8:    if ((InitialField .and. .not. Me%ComputeOptions%Continuous)          .or. & 
             Me%Relaxation%Force .or. Me%Relaxation%Velocity .or. &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB + 1
            do i = ILB, IUB


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif




cd7:            if (Faces3D_USon(i, j, KUB) == Covered  .and. .not. DeadZoneSon) then
                
                    NullValue = .false.

                    if (Me%SubModel%U_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                        Me%SubModel%U_Previous(i, j, KUB) < FillValueReal / 2.)  then


                        if (Me%SubModel%MissingNull) then 
                            NullValue = .true.
                        else
                            !!!! $OMP CRITICAL (AS3DWF2D5_ERR09)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR09") 
                            !!!! $OMP END CRITICAL (AS3DWF2D5_ERR09)
                        endif

                    endif

                    Kbottom = KFloor_U(i, j)

                    do k = Kbottom, KUB

                        if (NullValue) then

                            Me%SubModel%U_New(i, j, k)  =  0.


                        else

                       
                            Me%SubModel%U_New(i, j, k)  =                                  &
                                     Me%SubModel%U_Next    (i, j, KUB) * TimeCoef  +       &
                                     Me%SubModel%U_Previous(i, j, KUB) * (1 - TimeCoef)


                        endif

                        if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                           .and. Me%SubModel%FatherHotStart) &
                            Me%Velocity%Horizontal%U%New(i, j, k) = &
                                       Me%SubModel%U_New(i, j, k)


                    enddo

                    NullValue = .false.


                    if (Me%SubModel%DUZ_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                        Me%SubModel%DUZ_Previous(i, j, KUB) < FillValueReal / 2.)    then

                        if (Me%SubModel%MissingNull) then 
                            
                            NullValue = .true.

                        else
                            !!!! $OMP CRITICAL (AS3DWF2D6_ERR10)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR10") 
                            !!!! $OMP END CRITICAL (AS3DWF2D6_ERR10)
                        endif

                    endif


                    Kbottom = KFloor_U(i, j)

                    do k = Kbottom, KUB

                        if (NullValue) then

                            Me%SubModel%DUZ_New(i, j, k)  =  0.


                        else

                            RelativeThickness = DUZ_Son(i, j, k) / WaterColumnU(i, j)


                            Me%SubModel%DUZ_New(i, j, k)  =                                  &
                                    (Me%SubModel%DUZ_Next    (i, j, KUB) * TimeCoef        + &
                                     Me%SubModel%DUZ_Previous(i, j, KUB) * (1 - TimeCoef)) * &
                                     RelativeThickness

                        endif

                    enddo


                endif cd7

            enddo
            enddo
            !$OMP END DO
            
        endif cd8

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB + 1
        do i = ILB, IUB

            if (Me%SubModel%DeadZone) then

                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

            else

                DeadZoneSon = .false.

            endif

            
cd77:       if ((ImposedTangFacesUSon(i, j, KUB) == Imposed  .or.                         &
                 ImposedNormFacesUSon(i, j, KUB) == Imposed)  .and. .not. DeadZoneSon) then
                

                if (ImposedTangFacesUSon(i, j, KUB) == Imposed) then

                    i_thick = i
                    j_thick = j

                else if (ImposedNormFacesUSon(i, j, KUB) == Imposed) then

                    i_thick = i

                    if      (j == JUB + 1) then

                        j_thick = j - 1

                    else if (j == JLB) then

                        j_thick = j + 1

                    else

                        j_thick = j + Faces3D_USon(i, j + 1, KUB) - Faces3D_USon(i, j - 1, KUB)

                    endif

                endif

                NullValue = .false.

                if (Me%SubModel%U_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                    Me%SubModel%U_Previous(i, j, KUB) < FillValueReal / 2.)    then

                    if (Me%SubModel%MissingNull) then 

                        NullValue = .true.

                    else
                        !!!! $OMP CRITICAL (AS3DWF2D7_ERR11)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR11") 
                        !!!! $OMP END CRITICAL (AS3DWF2D7_ERR11)
                    endif

                endif

                Kbottom = KFloor_U(i_thick, j_thick)

                do k = Kbottom, KUB

                    if (NullValue) then

                        Me%SubModel%U_New(i, j, k)  = 0.

                    else

                        Me%SubModel%U_New(i, j, k)  =                              &
                                 Me%SubModel%U_Next    (i, j, KUB) * TimeCoef  +   &
                                 Me%SubModel%U_Previous(i, j, KUB) * (1 - TimeCoef)

                    endif

                    if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                       .and. Me%SubModel%FatherHotStart)                       &
                        Me%Velocity%Horizontal%U%New(i, j, k) =                &
                                   Me%SubModel%U_New(i, j, k)


                enddo

                NullValue = .false.

                if (Me%SubModel%DUZ_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                    Me%SubModel%DUZ_Previous(i, j, KUB) < FillValueReal / 2.)    then

                    if (Me%SubModel%MissingNull) then 

                        NullValue = .true.

                    else
                        !!!! $OMP CRITICAL (AS3DWF2D8_ERR12)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR12") 
                        !!!! $OMP END CRITICAL (AS3DWF2D8_ERR12)
                    endif

                endif

                Kbottom = KFloor_U(i_thick, j_thick)

                do k = Kbottom, KUB

                    if (NullValue) then

                        Me%SubModel%DUZ_New(i, j, k) = 0.

                    else

                        RelativeThickness = DUZ_Son(i_thick, j_thick, k) / WaterColumnU(i_thick, j_thick)

                        Me%SubModel%DUZ_New(i, j, k)  =                                  &
                                (Me%SubModel%DUZ_Next    (i, j, KUB) * TimeCoef        + &
                                 Me%SubModel%DUZ_Previous(i, j, KUB) * (1 - TimeCoef)) * &
                                 RelativeThickness

                    endif

                             
                enddo



            endif cd77

        enddo
        enddo
        !$OMP END DO

        !$OMP MASTER
        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP END MASTER
        
        !$OMP BARRIER
cd10:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous)          .or. & 
             Me%Relaxation%Force .or. Me%Relaxation%Velocity .or. &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB + 1

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif


cd9:            if (Faces3D_VSon(i, j, KUB) == Covered  .and. .not. DeadZoneSon) then

                    NullValue = .false.

                    if (Me%SubModel%V_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                        Me%SubModel%V_Previous(i, j, KUB) < FillValueReal / 2.)  then

                        if (Me%SubModel%MissingNull) then 

                            NullValue = .true.

                        else
                            !!!! $OMP CRITICAL (AS3DWF2D9_ERR13)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR13") 
                            !!!! $OMP END CRITICAL (AS3DWF2D9_ERR13)
                        endif

                    endif


                    Kbottom = KFloor_V(i, j)

                    do k = Kbottom, KUB

                        if (NullValue) then

                            Me%SubModel%V_New(i, j, k)      = 0.

                        else

                            Me%SubModel%V_New(i, j, k)      =                              &
                                     Me%SubModel%V_Next    (i, j, KUB) * TimeCoef        + &
                                     Me%SubModel%V_Previous(i, j, KUB) * (1 - TimeCoef)

                        endif

                        if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                           .and. Me%SubModel%FatherHotStart)                       &
                            Me%Velocity%Horizontal%V%New(i, j, k) =                &
                                       Me%SubModel%V_New(i, j, k)

                    enddo

                    NullValue = .false.


                    if (Me%SubModel%DVZ_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                        Me%SubModel%DVZ_Previous(i, j, KUB) < FillValueReal / 2.)    then

                        if (Me%SubModel%MissingNull) then 
                            NullValue = .true.
                        else
                            !!!! $OMP CRITICAL (AS3DWF2D10_ERR14)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR14") 
                            !!!! $OMP END CRITICAL (AS3DWF2D10_ERR14)
                        endif
                        
                    endif

                    Kbottom = KFloor_V(i, j)

                    do k = Kbottom, KUB

                        if (NullValue) then

                            Me%SubModel%DVZ_New(i, j, k) = 0.

                        else

                            RelativeThickness = DVZ_Son(i, j, k) / WaterColumnV(i, j)


                            Me%SubModel%DVZ_New(i, j, k)  =                                 &
                                    (Me%SubModel%DVZ_Next    (i, j, KUB) * TimeCoef       + &
                                     Me%SubModel%DVZ_Previous(i, j, KUB) * (1 - TimeCoef))* &
                                     RelativeThickness

                        endif


                    enddo


                endif cd9


            enddo
            enddo
            !$OMP END DO

        endif cd10

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB + 1

            if (Me%SubModel%DeadZone) then

                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

            else

                DeadZoneSon = .false.

            endif



cd99:       if ((ImposedTangFacesVSon(i, j, KUB) == Imposed  .or.                           &
                 ImposedNormFacesVSon(i, j, KUB) == Imposed) .and. .not. DeadZoneSon) then

                if (ImposedTangFacesVSon(i, j, KUB) == Imposed) then

                    i_thick = i
                    j_thick = j

                else if (ImposedNormFacesVSon(i, j, KUB) == Imposed) then

                    if      (i == IUB + 1) then

                        i_thick = i - 1

                    else if (i == ILB) then

                        i_thick = i + 1

                    else

                        i_thick = i + Faces3D_VSon(i + 1, j, KUB) - Faces3D_VSon(i - 1, j, KUB)

                    endif

                    j_thick = j 

                endif

                NullValue = .false.

                if (Me%SubModel%V_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                    Me%SubModel%V_Previous(i, j, KUB) < FillValueReal / 2.)  then

                    if (Me%SubModel%MissingNull) then 
                        NullValue = .true.
                    else
                        !!!! $OMP CRITICAL (AS3DWF2D11_ERR15)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR15") 
                        !!!! $OMP END CRITICAL (AS3DWF2D11_ERR15)
                    endif

                endif

                Kbottom = KFloor_V(i_thick, j_thick)

                do k = Kbottom, KUB

                    if (NullValue) then

                        Me%SubModel%V_New(i, j, k)      = 0.

                    else

                        Me%SubModel%V_New(i, j, k)      =                              &
                                 Me%SubModel%V_Next    (i, j, KUB) * TimeCoef        + &
                                 Me%SubModel%V_Previous(i, j, KUB) * (1 - TimeCoef)

                    endif

                    if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                       .and. Me%SubModel%FatherHotStart)                       &
                        Me%Velocity%Horizontal%V%New(i, j, k) =                &
                                   Me%SubModel%V_New(i, j, k)


                enddo

                NullValue = .false.


                if (Me%SubModel%DVZ_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                    Me%SubModel%DVZ_Previous(i, j, KUB) < FillValueReal / 2.) then

                    if (Me%SubModel%MissingNull) then 
                        NullValue = .true.
                    else
                        !!!! $OMP CRITICAL (AS3DWF2D12_ERR16)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR16") 
                        !!!! $OMP END CRITICAL (AS3DWF2D12_ERR16)
                    endif

                endif


                Kbottom = KFloor_V(i_thick, j_thick)

                do k = Kbottom, KUB

                    if (NullValue) then

                        Me%SubModel%DVZ_New(i, j, k)  = 0.

                    else


                        RelativeThickness = DVZ_Son(i_thick, j_thick, k) / WaterColumnV(i_thick, j_thick)


                        Me%SubModel%DVZ_New(i, j, k)  =                                  &
                                (Me%SubModel%DVZ_Next    (i, j, KUB) * TimeCoef        + &
                                 Me%SubModel%DVZ_Previous(i, j, KUB) * (1 - TimeCoef)) * &
                                RelativeThickness

                    endif

                enddo
                        
            endif cd99

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ActualizeSon3DWithFather2D")

        !Tihs is only done for graphical reasons
        if (InitialField .and. .not. Me%ComputeOptions%Continuous) then

            !U corners            
            Me%Velocity%Horizontal%U%New(ILB,JLB    , KLB:KUB)   =       &
            Me%SubModel%U_New           (ILB,JLB    ,     KUB)

            Me%Velocity%Horizontal%U%New(ILB,JUB + 1, KLB:KUB)   =       &
            Me%SubModel%U_New           (ILB,JUB + 1,     KUB)

            Me%Velocity%Horizontal%U%New(IUB,JLB    , KLB:KUB)   =       &
            Me%SubModel%U_New           (IUB,JLB    ,     KUB)

            Me%Velocity%Horizontal%U%New(IUB,JUB + 1, KLB:KUB)   =       &
            Me%SubModel%U_New           (IUB,JUB + 1,     KUB)

            
            !V corners
            Me%Velocity%Horizontal%V%New(ILB,JLB    , KLB:KUB)   =       &
            Me%SubModel%V_New           (ILB,JLB    ,     KUB)

            Me%Velocity%Horizontal%V%New(ILB,JUB    , KLB:KUB)   =       &
            Me%SubModel%V_New           (ILB,JUB    ,     KUB)

            Me%Velocity%Horizontal%V%New(IUB + 1,JLB, KLB:KUB)   =       &
            Me%SubModel%V_New           (IUB + 1,JLB,     KUB)

            Me%Velocity%Horizontal%V%New(IUB + 1,JUB, KLB:KUB)   =       &
            Me%SubModel%V_New           (IUB + 1,JUB,     KUB)

        endif



        Me%SubModel%Set      = .true.

        !UnGet son information 
        call ReadUnLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,               &
                           ImposedNormFacesUSon, ImposedNormFacesVSon,               &
                           Water3DSon, Boundary2DSon,                                 &
                           Faces3D_USon, Faces3D_VSon,                               &
                           DUZ_Son, DVZ_Son,                                         &
                           DXX_Son, DYY_Son)

cd11:   if (InitialField .and. .not. Me%ComputeOptions%Continuous) then

            Me%WaterLevel%Old               (:,:  ) =                &
                Me%WaterLevel%New           (:,:  )

            Me%Velocity%Horizontal%V%Old    (:,:,:) =                &
                Me%Velocity%Horizontal%V%New(:,:,:)

            Me%Velocity%Horizontal%U%Old    (:,:,:) =                &
                Me%Velocity%Horizontal%U%New(:,:,:)

            Me%SubModel%DUZ_Old(:,:,:)              =                &
                Me%SubModel%DUZ_Next(:,:,:)


            Me%SubModel%DVZ_Old(:,:,:)              =                &
                Me%SubModel%DVZ_Next(:,:,:)

        endif cd11


        call UnGetGeometry(Me%ObjGeometry,                               &
                           WaterColumnU, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR17") 


        call UnGetGeometry(Me%ObjGeometry,                               &
                           WaterColumnV, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR18") 


        call UnGetGeometry(Me%ObjGeometry,                               &
                           KFloor_U, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR19") 


        call UnGetGeometry(Me%ObjGeometry,                               &
                           KFloor_V, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR20") 


       !UnGets Bathymetry
        call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR21") 


    end subroutine ActualizeSon3DWithFather2D

    !--------------------------------------------------------------------------

    subroutine ActualizeSon3DWithFather3D (InitialField) !Ang: new implementation

        !Arguments-------------------------------------------------------------
        logical,           intent(IN )  :: InitialField

        !Local-----------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: DUZ_Son, DVZ_Son
        real,    dimension(:,:  ), pointer :: DXX_Son, DYY_Son, WaterColumnU, WaterColumnV, Bathymetry
        integer, dimension(:,:  ), pointer :: Boundary2DSon, KFloor_U, KFloor_V
        integer, dimension(:,:,:), pointer :: Water3DSon
        integer, dimension(:,:,:), pointer :: Faces3D_USon  
        integer, dimension(:,:,:), pointer :: Faces3D_VSon
        integer, dimension(:,:,:), pointer :: ImposedTangFacesUSon, ImposedTangFacesVSon
        integer, dimension(:,:,:), pointer :: ImposedNormFacesUSon, ImposedNormFacesVSon
        real                               :: TimeCoef, RelativeThickness, MinWaterColumn
        integer                            :: status
        integer                            :: KLBFather, KUBFather
        integer                            :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                            :: i, j, k, Kbottom, i_Thick, j_Thick
        logical                            :: ErrorOccured, DeadZoneSon, NullValue
        logical                            :: FoundBottom, FoundSurface
        integer                            :: kfather, kfatherinic, k2, k2father
        integer                            :: NDepths, Aux
        real                               :: TotalDUVZ_Son, ExcessDUVZ_Son, AuxDepth
        real                               :: AuxDUVZ_Son, AuxDUVZ_Father, SumDUVZ_Son
        real                               :: DeficitValue_Father, ExcessValue_Father
        real                               :: AuxDeficit, AuxSonDepth
        real(8)                            :: SonDepth
        real(8), dimension (:), pointer    :: Depths, Values
        integer                            :: CHUNK
        
        !Begin-----------------------------------------------------------------


        call GetGeometryWaterColumn(Me%ObjGeometry,                                 &
                                    WaterColumnU= WaterColumnU,                     &
                                    WaterColumnV= WaterColumnV,                     &
                                    STAT = status)

        if (status /= SUCCESS_)                                                     &
                call SetError(FATAL_, INTERNAL_,                                    &
                              "ActualizeSon3DWithFather3D; Hydrodynamic. ERR01") 

        call GetGeometryKFloor(Me%ObjGeometry,                                      &
                               U = KFloor_U, V = KFloor_V, STAT = status)

        if (status /= SUCCESS_)                                                     &
                call SetError(FATAL_, INTERNAL_,                                    &
                              "ActualizeSon3DWithFather3D; Hydrodynamic. ERR02") 


       !Gets Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_)                                                     &
                call SetError(FATAL_, INTERNAL_,                                    &
                              "ActualizeSon3DWithFather3D; Hydrodynamic. ERR03") 


        call GetGeometryMinWaterColumn(Me%ObjGeometry,                              &
                                       MinWaterColumn, STAT = status)

        if (status /= SUCCESS_)                                                     &                    
                call SetError(FATAL_, INTERNAL_,                                    &
                          "ActualizeSon3DWithFather3D; Hydrodynamic. ERR04") 

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        if (Me%SubModel%InterPolTime .and. .not. InitialField) then

            !Time Properties - Actualises CurrentTime
            call GetComputeCurrentTime(Me%ObjTime,                                  &
                                       Me%CurrentTime, STAT = status)
            if (status /= SUCCESS_)                                                 &                    
                call SetError(FATAL_, INTERNAL_,                                    &
                        "ActualizeSon3DWithFather3D; Hydrodynamic. ERR05") 

            TimeCoef = (Me%CurrentTime       - Me%SubModel%PreviousTime) /          &
                       (Me%SubModel%NextTime - Me%SubModel%PreviousTime)

        else 
        
            TimeCoef = 1                    
            
        endif

        !Ang: new father-son implementation
        !Get father layers
        KLBFather = Me%SubModel%FatherKLB
        KUBFather = Me%SubModel%FatherKUB
      
        !Get data for vertical interpolation father-son layers
        if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.                    &
            Me%SubModel%InterPolTime) .or. (.not. Me%SubModel%InterPolTime)         &
            .or. InitialField) then

            !allocate father depth values arrays
            allocate(Depths(KLBFather: KUBFather),STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_,                                    &
                              "ActualizeSon3DWithFather3D; Hydrodynamic. ERR06") 

            allocate(Values(KLBFather: KUBFather),STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_,                                    &
                              "ActualizeSon3DWithFather3D; Hydrodynamic. ERR07") 

        endif

        call ReadLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,                &
                         ImposedNormFacesUSon, ImposedNormFacesVSon,                &
                         Water3DSon, Boundary2DSon,                                 &
                         Faces3D_USon, Faces3D_VSon,                                &
                         DUZ_Son, DVZ_Son,                                          &
                         DXX_Son, DYY_Son)
        
        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ActualizeSon3DWithFather3D")
        
cd1:    if (InitialField) then

            ErrorOccured = .false.

            CHUNK = CHUNK_J(JLB, JUB + 1)

            !$OMP PARALLEL PRIVATE(i,j,k,kfatherinic,RelativeThickness,TotalDUVZ_Son, &
            !$OMP                   ExcessDUVZ_Son,ExcessValue_Father,DeadZoneSon,NullValue, &
            !$OMP                   i_thick,j_thick,Kbottom,AuxDUVZ_Son,kfather, &
            !$OMP                   AuxDUVZ_Father,k2,k2father, &
            !$OMP                   SumDUVZ_Son,DeficitValue_Father,AuxDeficit)
            
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB + 1
            do i = ILB, IUB

                !look father layer beginning at the topest layer
                kfatherinic = KUBFather
                RelativeThickness = 1.0

                TotalDUVZ_Son = 0.0
                ExcessDUVZ_Son = 0.0
                ExcessValue_Father = 0.0

do1:            do k = KUB, KLB, -1
                    !(in practice cycle goes only to local Kbottom)

                    if (Me%SubModel%DeadZone) then

                        DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                    else

                        DeadZoneSon = .false.

                    endif
            
cd2:                if ((Faces3D_USon        (i, j, k) == Covered   .or.            &
                         ImposedTangFacesUSon(i, j, k) == Imposed   .or.            &
                         ImposedNormFacesUSon(i, j, k) == Imposed)  .and.           & 
                         .not. DeadZoneSon .and. .not. Me%SubModel%HotStartData) then

                        NullValue = .false.

                        if (Me%SubModel%Aux_qX(i, j, KUBFather)                     & 
                        < FillValueReal / 2.) then
#ifndef _USE_MPI
                            write(*,*)'Point [i,j,k] not covered',i, j,k
#endif
                            ErrorOccured = .true.
                            if (Me%SubModel%MissingNull)                            &
                                NullValue = .true.

                        endif

                        if      (ImposedTangFacesUSon(i, j, k) == Imposed .or.      &
                                 Faces3D_USon        (i, j, k) == Covered) then

                            i_thick = i
                            j_thick = j

                        else if (ImposedNormFacesUSon(i, j, k) == Imposed) then

                            i_thick = i

                            if      (j == JUB + 1) then

                                j_thick = j - 1

                            else if (j == JLB) then

                                j_thick = j + 1

                            else

                                j_thick = j + Faces3D_USon(i, j + 1, k) -           &
                                          Faces3D_USon(i, j - 1, k)

                            endif

                        endif

                        Kbottom = KFloor_U(i_thick, j_thick)

                        !initialize variable
                        Me%SubModel%qX(i, j, k) = 0

                        if (.not. NullValue) then
                            !(father values exist for at least one (father) layer)

                            !DUZ is need for weighting
                            AuxDUVZ_Son = DUZ_Son(i_thick, j_thick, k)

do2:                        do kfather = kfatherinic, KLBFather, -1
                        
                                !layers from surface to bottom

                                if ((Me%SubModel%Aux_qX(i, j, kfather)               & 
                                    < FillValueReal / 2.) .or.                       &
                                    (Me%SubModel%Aux_DUZ(i, j, kfather)              &
                                    < FillValueReal / 2.)) then
                                    !if father values do not exist

                                    ErrorOccured = .true.
                                    if (Me%SubModel%MissingNull)                    &
                                        !son layers assumed null values
                                        exit do2
                                        !(should all layers be null if first is null?)

                                endif

                                AuxDUVZ_Father = Me%SubModel%Aux_DUZ(i, j, kfather)
                                !(since it is father and not exited loop (i,j) value
                                ! exists!)

                                if (AuxDUVZ_Son .le.                            &
                                    RelativeThickness*AuxDUVZ_Father) then

                                    !son layer inside father layer part
                                    RelativeThickness = AuxDUVZ_Son*            &
                                        RelativeThickness / AuxDUVZ_Father

                                    Me%SubModel%qX(i, j, k) =                   &
                                        Me%SubModel%qX(i, j, k) +               &
                                        Me%SubModel%Aux_qX(i, j, kfather)       &
                                        * RelativeThickness

                                    TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                        AuxDUVZ_Son
                
                                    if (Abs(AuxDUVZ_Son - AuxDUVZ_Father) .lt.  &
                                        AllmostZero) then
                                        !(AuxDUVZ_Son == AuxDUVZ_Father)

                                        !this father layer is already solved, solve next
                                        kfatherinic = kfatherinic - 1
                                        RelativeThickness = 1
                
                                    else

                                        RelativeThickness = 1 - RelativeThickness

                                    endif

                                    AuxDUVZ_Son = 0.0

                                    exit do2

                                else

                                    !son layer includes father layer part
                                    Me%SubModel%qX(i, j, k) =                   &
                                        Me%SubModel%qX(i, j, k) +               &
                                        Me%SubModel%Aux_qX(i, j, kfather)       &
                                        * RelativeThickness
                        
                                    TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                        RelativeThickness*AuxDUVZ_Father

                                    !get the remaing part of DUZ_Son
                                    AuxDUVZ_Son = AuxDUVZ_Son -                 &
                                        RelativeThickness*AuxDUVZ_Father

                                    !seek in the next father layer
                                    kfatherinic = kfatherinic - 1
                                    RelativeThickness = 1

                                endif

                            enddo do2

                            !check if excess or deficit flux variable exists
                            if ((AuxDUVZ_Son /= 0.0) .and.                          &
                                (kfather == KLBFather)) then
                                !last son layer was not fulfilled by father values
                                !(all the next son layers are not fulfilled also)

                                if (Me%SubModel%MomentConserv) then

                                    ExcessDUVZ_Son = AuxDUVZ_Son

                                    if (k-1 .ge. KBottom) then
                                        !add DUZ of next son layers

                                        do k2 = k-1, KBottom, - 1
                                            !layers from surface to bottom

                                            ExcessDUVZ_Son = ExcessDUVZ_Son +       &
                                                DUZ_Son(i_thick, j_thick, k2)
                            
                                        enddo

                                    endif
                
                                else 

                                    if (k-1 .ge. KBottom) then
                                        !add DUZ of next son layers

                                        do k2 = k-1, KBottom, - 1
                                            !layers from surface to bottom

                                            Me%SubModel%qX(i, j, k) = 0
                            
                                        enddo

                                    endif
                            
                                endif

                                exit do1

                            else if ((k == Kbottom) .and.                           &
                                ((RelativeThickness /= 1) .or.                      &
                                (kfather /= KLBFather)) .and.                       &
                                Me%SubModel%MomentConserv) then
                                !all son layers are fulfilled with father values
                                !but excedent father layer part exist
                        
                                if (RelativeThickness /= 1)                         &
                                    ExcessValue_Father =                            &
                                    Me%SubModel%Aux_qX(i, j, kfather)*              &
                                    RelativeThickness

                                if (kfather - 1 .ge. KLBFather) then
                                    !add values of next father layers

do3:                                do k2father = kfather - 1, KLBFather, - 1
                                        !layers from surface to bottom
                        
                                        if (Me%SubModel%Aux_qX(i, j, k2father)      & 
                                            < FillValueReal / 2.) then

                                            exit do3
                                
                                        else

                                            ExcessValue_Father = ExcessValue_Father &
                                                + Me%SubModel%Aux_qX(i, j, k2father)

                                        endif

                                    enddo do3

                                endif

                            endif

                        endif

                        if (.not. Me%ComputeOptions%Continuous)                         &
                            Me%WaterFluxes%X(i, j, k)               =                   &
                                Me%SubModel%qX (i, j, k) * DYY_Son(i, j) 

                        if (k == KBottom) then 

                            exit do1
                        endif

                    endif cd2

                enddo do1

                if (Me%SubModel%MomentConserv) then

                    if (ExcessDUVZ_Son /= 0.0) then
                        !Correct son layer values for the deficit of father values

                        SumDUVZ_Son = 0.0
                        DeficitValue_Father = 0.0

                        do k = KUB, KLB, -1
                        !(in practice cycle goes only to local Kbottom)

                            if (Me%SubModel%DeadZone) then

                                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                            else

                                DeadZoneSon = .false.

                            endif
    
cd3:                        if ((Faces3D_USon        (i, j, k) == Covered   .or.    &
                             ImposedTangFacesUSon(i, j, k) == Imposed   .or.        &
                             ImposedNormFacesUSon(i, j, k) == Imposed)  .and.       & 
                             .not. DeadZoneSon .and. .not. Me%SubModel%HotStartData) then

                                if      (ImposedTangFacesUSon(i, j, k) == Imposed .or. &
                                         Faces3D_USon        (i, j, k) == Covered) then

                                    i_thick = i
                                    j_thick = j

                                else if (ImposedNormFacesUSon(i, j, k) == Imposed) then

                                    i_thick = i

                                    if      (j == JUB + 1) then

                                        j_thick = j - 1

                                    else if (j == JLB) then

                                        j_thick = j + 1

                                    else

                                        j_thick = j + Faces3D_USon(i, j + 1, k) -   &
                                                  Faces3D_USon(i, j - 1, k)

                                    endif

                                endif

                                Kbottom = KFloor_U(i_thick, j_thick)

                                SumDUVZ_Son = SumDUVZ_Son + DUZ_Son(i_thick, j_thick, k)

                                if (SumDUVZ_Son .le. TotalDUVZ_Son) then
                                    !layers having father value
                            
                                    AuxDeficit = Me%SubModel%qX(i,j,k)*             &
                                        ExcessDUVZ_Son*DUZ_Son(i_thick, j_thick, k) &
                                        /TotalDUVZ_Son

                                    !actualize the value of the father deficit
                                    DeficitValue_Father = DeficitValue_Father +     &
                                        AuxDeficit

                                    !remove flux variable from layer
                                    Me%SubModel%qX(i,j,k) = Me%SubModel%qX(i,j,k)   &
                                       - AuxDeficit

                                elseif (AuxDUVZ_Son /= 0.0) then
                                    !son layer partially with father value
                                    AuxDeficit = Me%SubModel%qX(i,j,k)*             &
                                        ExcessDUVZ_Son*(DUZ_Son(i_thick, j_thick, k) &
                                        - AuxDUVZ_Son)/TotalDUVZ_Son 

                                    !actualize the value of the father deficit
                                    DeficitValue_Father = DeficitValue_Father +     &
                                        AuxDeficit

                                    !remove and add
                                    Me%SubModel%qX(i,j,k) =                         &
                                        Me%SubModel%qX(i,j,k) - AuxDeficit +        &
                                        DeficitValue_Father*AuxDUVZ_Son/            &
                                        (WaterColumnU(i_thick, j_thick) - TotalDUVZ_Son)

                                    AuxDUVZ_Son = 0.0
                                    !(layer completed)

                                else
                                    !fill son layer without father value
                            
                                    !add collected value
                                    Me%SubModel%qX(i,j,k) = DeficitValue_Father*    &
                                        DUZ_Son(i_thick,j_thick,k)                  &
                                        /(WaterColumnU(i_thick, j_thick) - TotalDUVZ_Son)

                                endif

                                if (.not. Me%ComputeOptions%Continuous)                 &
                                    !recalculate the water fluxes
                                    Me%WaterFluxes%X(i, j, k)               =           &
                                        Me%SubModel%qX (i, j, k) * DYY_Son(i, j) 
                        
                            endif cd3

                        enddo                       

                    elseif (ExcessValue_Father /= 0.0) then
                        !Correct son layer values for the excess of father values
                    
                        do k = KUB, KLB, - 1
                            !layers from surface to bottom

                            if (Me%SubModel%DeadZone) then

                                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                            else

                                DeadZoneSon = .false.

                            endif
    
cd4:                        if ((Faces3D_USon        (i, j, k) == Covered   .or.    &
                             ImposedTangFacesUSon(i, j, k) == Imposed   .or.        &
                             ImposedNormFacesUSon(i, j, k) == Imposed)  .and.       & 
                             .not. DeadZoneSon  .and. .not. Me%SubModel%HotStartData) then

                                if (ImposedTangFacesUSon(i, j, k) == Imposed .or.   &
                                         Faces3D_USon        (i, j, k) == Covered) then

                                    i_thick = i
                                    j_thick = j

                                else if (ImposedNormFacesUSon(i, j, k) == Imposed) then

                                    i_thick = i

                                    if      (j == JUB + 1) then

                                        j_thick = j - 1

                                    else if (j == JLB) then

                                        j_thick = j + 1

                                    else

                                        j_thick = j + Faces3D_USon(i, j + 1, k) -   &
                                                  Faces3D_USon(i, j - 1, k)

                                    endif

                                endif

                                Kbottom = KFloor_U(i_thick, j_thick)

                                Me%SubModel%qX(i,j,k) = Me%SubModel%qX(i,j,k) +     &
                                    ExcessValue_Father*DUZ_Son(i_thick, j_thick, k) &
                                    / WaterColumnU(i_thick, j_thick)

                                if (.not. Me%ComputeOptions%Continuous)                 &
                                    !recalculate the water fluxes
                                    Me%WaterFluxes%X(i, j, k)               =           &
                                        Me%SubModel%qX (i, j, k) * DYY_Son(i, j) 
                     
                            endif cd4
                                           
                        enddo

                    endif       

                endif

            enddo
            enddo
            !$OMP END DO

            !$OMP MASTER
            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP END MASTER
            !$OMP BARRIER
            
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB + 1

                !look father layer beginning at the topest layer
                kfatherinic = KUBFather
                RelativeThickness = 1.0

                TotalDUVZ_Son = 0.0
                ExcessDUVZ_Son = 0.0
                ExcessValue_Father = 0.0

do4:            do k = KUB, KLB, -1
                    !(in practice cycle goes only to local Kbottom)

                    if (Me%SubModel%DeadZone) then

                        DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                    else

                        DeadZoneSon = .false.

                    endif
            
cd5:                if ((Faces3D_VSon        (i, j, k) == Covered   .or.            &
                         ImposedTangFacesVSon(i, j, k) == Imposed   .or.            &
                         ImposedNormFacesVSon(i, j, k) == Imposed)  .and.           & 
                         .not. DeadZoneSon  .and. .not. Me%SubModel%HotStartData) then

                        NullValue = .false.

                        if (Me%SubModel%Aux_qY(i, j, KUBFather)                     & 
                        < FillValueReal / 2.) then
#ifndef _USE_MPI
                            !!!! $OMP CRITICAL (AS3DWF3D1_OUT01)
                           write(*,*)'Point [i,j,k] not covered',i, j,k
                            !!!! $OMP END CRITICAL (AS3DWF3D1_OUT01)
#endif
                            ErrorOccured = .true.
                            if (Me%SubModel%MissingNull)                            &
                                NullValue = .true.

                        endif

                        if      (ImposedTangFacesVSon(i, j, k) == Imposed .or.      &
                                 Faces3D_VSon        (i, j, k) == Covered) then

                            i_thick = i
                            j_thick = j

                        else if (ImposedNormFacesVSon(i, j, k) == Imposed) then

                            if      (i == IUB + 1) then

                                i_thick = i - 1

                            else if (i == ILB) then

                                i_thick = i + 1

                            else

                                i_thick = i + Faces3D_VSon(i + 1, j, k) -           &
                                        Faces3D_VSon(i - 1, j, k)

                            endif

                            j_thick = j 

                        endif

                        Kbottom = KFloor_V(i_thick, j_thick)

                        !initialize variable
                        Me%SubModel%qY(i, j, k) = 0

                        if (.not. NullValue) then
                            !(father values exist for at least one (father) layer)

                            !DVZ is needed for weighting
                            AuxDUVZ_Son = DVZ_Son(i_thick, j_thick, k)

do5:                        do kfather = kfatherinic, KLBFather, -1
                        
                                !layers from surface to bottom

                                if ((Me%SubModel%Aux_qY(i, j, kfather)              & 
                                    < FillValueReal / 2.) .or.                      &
                                    (Me%SubModel%Aux_DVZ(i, j, kfather)             &
                                    < FillValueReal / 2.)) then
                                    !if father values do not exist

                                    ErrorOccured = .true.
                                    if (Me%SubModel%MissingNull)                    &
                                        !son layers assumed null values
                                        exit do5
                                        !(should all layers be null if first is null?)

                                endif

                                AuxDUVZ_Father = Me%SubModel%Aux_DVZ(i, j, kfather)
                                !(since it is father and not exited loop (i,j) value
                                ! exists!)

                                if (AuxDUVZ_Son .le.                            &
                                    RelativeThickness*AuxDUVZ_Father) then

                                    !son layer inside father layer part
                                    RelativeThickness = AuxDUVZ_Son*            &
                                        RelativeThickness / AuxDUVZ_Father

                                    Me%SubModel%qY(i, j, k) =                   &
                                        Me%SubModel%qY(i, j, k) +               &
                                        Me%SubModel%Aux_qY(i, j, kfather)       &
                                        * RelativeThickness

                                    TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                        AuxDUVZ_Son
                
                                    if (Abs(AuxDUVZ_Son - AuxDUVZ_Father) .lt.  &
                                        AllmostZero) then
                                        !(AuxDUVZ_Son == AuxDUVZ_Father)

                                        !this father layer is already solved, solve next
                                        kfatherinic = kfatherinic - 1
                                        RelativeThickness = 1
                
                                    else

                                        RelativeThickness = 1 - RelativeThickness

                                    endif

                                    AuxDUVZ_Son = 0.0

                                    exit do5

                                else

                                    !son layer includes father layer part
                                    Me%SubModel%qY(i, j, k) =                   &
                                        Me%SubModel%qY(i, j, k) +               &
                                        Me%SubModel%Aux_qY(i, j, kfather)       &
                                        * RelativeThickness
                        
                                    TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                        RelativeThickness*AuxDUVZ_Father

                                    !get the remaing part of DVZ_Son
                                    AuxDUVZ_Son = AuxDUVZ_Son -                 &
                                        RelativeThickness*AuxDUVZ_Father

                                    !seek in the next father layer
                                    kfatherinic = kfatherinic - 1
                                    RelativeThickness = 1

                                endif

                            enddo do5

                            !check if excess or deficit flux variable exists
                            if ((AuxDUVZ_Son /= 0.0) .and.                          &
                                (kfather == KLBFather)) then
                                !last son layer was not fulfilled by father values
                                !(all the next son layers are not fulfilled also)

                                if (Me%SubModel%MomentConserv) then

                                    ExcessDUVZ_Son = AuxDUVZ_Son

                                    if (k-1 .ge. KBottom) then
                                        !add DVZ of next son layers

                                        do k2 = k-1, KBottom, - 1
                                            !layers from surface to bottom

                                            ExcessDUVZ_Son = ExcessDUVZ_Son +       &
                                                DVZ_Son(i_thick, j_thick, k2)
                            
                                        enddo

                                    endif
                
                                else

                                    if (k-1 .ge. KBottom) then
                                        !add DUZ of next son layers

                                        do k2 = k-1, KBottom, - 1
                                            !layers from surface to bottom

                                            Me%SubModel%qY(i, j, k) = 0
                            
                                        enddo

                                    endif

                                endif

                                exit do4

                            else if ((k == Kbottom) .and.                           &
                                ((RelativeThickness /= 1) .or.                      &
                                (kfather /= KLBFather)) .and.                       &
                                Me%SubModel%MomentConserv) then
                                !all son layers are fulfilled with father values
                                !but excedent father layer part exist
                        
                                if (RelativeThickness /= 1)                         &
                                ExcessValue_Father =                                &
                                    Me%SubModel%Aux_qY(i, j, kfather)*              &
                                    RelativeThickness

                                if (kfather - 1 .ge. KLBFather) then
                                    !add values of next father layers

do6:                                do k2father = kfather - 1, KLBFather, - 1
                                        !layers from surface to bottom
                        
                                        if (Me%SubModel%Aux_qY(i, j, k2father)      & 
                                            < FillValueReal / 2.) then

                                            exit do6
                                
                                        else

                                            ExcessValue_Father = ExcessValue_Father &
                                                + Me%SubModel%Aux_qY(i, j, k2father)

                                        endif

                                    enddo do6

                                endif

                            endif

                        endif

                        if (.not. Me%ComputeOptions%Continuous)                         &
                            Me%WaterFluxes%Y(i, j, k)               =                   &
                                Me%SubModel%qY (i, j, k) * DXX_Son(i, j) 

                        if (k == KBottom) then 

                            exit do4
                        endif

                    endif cd5

                enddo do4

                if (Me%SubModel%MomentConserv) then

                    if (ExcessDUVZ_Son /= 0.0) then
                        !Correct son layer values for the deficit of father values

                        SumDUVZ_Son = 0.0
                        DeficitValue_Father = 0.0

                        do k = KUB, KLB, -1
                        !(in practice cycle goes only to local Kbottom)

                            if (Me%SubModel%DeadZone) then

                                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                            else

                                DeadZoneSon = .false.

                            endif
    
cd6:                        if ((Faces3D_VSon (i, j, k) == Covered   .or.           &
                             ImposedTangFacesVSon(i, j, k) == Imposed   .or.        &
                             ImposedNormFacesVSon(i, j, k) == Imposed)  .and.       & 
                             .not. DeadZoneSon  .and. .not. Me%SubModel%HotStartData) then

                                if      (ImposedTangFacesVSon(i, j, k) == Imposed .or. &
                                         Faces3D_VSon        (i, j, k) == Covered) then

                                    i_thick = i
                                    j_thick = j

                                else if (ImposedNormFacesVSon(i, j, k) == Imposed) then

                                    if      (i == IUB + 1) then

                                        i_thick = i - 1

                                    else if (i == ILB) then

                                        i_thick = i + 1

                                    else

                                        i_thick = i + Faces3D_VSon(i + 1, j, k) -   &
                                                  Faces3D_VSon(i - 1, j, k)

                                    endif

                                    j_thick = j 

                                endif

                                Kbottom = KFloor_V(i_thick, j_thick)

                                SumDUVZ_Son = SumDUVZ_Son + DVZ_Son(i_thick, j_thick, k)

                                if (SumDUVZ_Son .le. TotalDUVZ_Son) then
                                    !layers having father value
                            
                                    AuxDeficit = Me%SubModel%qX(i,j,k)*             &
                                        ExcessDUVZ_Son*DVZ_Son(i_thick, j_thick, k) &
                                        /TotalDUVZ_Son

                                    !actualize the value of the father deficit
                                    DeficitValue_Father = DeficitValue_Father +     &
                                        AuxDeficit

                                    !remove flux variable from layer
                                    Me%SubModel%qY(i,j,k) = Me%SubModel%qY(i,j,k)   &
                                       - AuxDeficit

                                elseif (AuxDUVZ_Son /= 0.0) then
                                    !son layer partially with father value
                                    AuxDeficit = Me%SubModel%qY(i,j,k)*             &
                                        ExcessDUVZ_Son*(DVZ_Son(i_thick, j_thick, k) &
                                        - AuxDUVZ_Son)/TotalDUVZ_Son 

                                    !actualize the value of the father deficit
                                    DeficitValue_Father = DeficitValue_Father +     &
                                        AuxDeficit

                                    !remove and add
                                    Me%SubModel%qY(i,j,k) =                         &
                                        Me%SubModel%qY(i,j,k) - AuxDeficit +        &
                                        DeficitValue_Father*AuxDUVZ_Son/            &
                                        (WaterColumnV(i_thick, j_thick) - TotalDUVZ_Son)

                                    AuxDUVZ_Son = 0.0
                                    !(layer completed)

                                else
                                    !fill son layer without father value
                            
                                    !add collected value
                                    Me%SubModel%qY(i,j,k) = DeficitValue_Father*    &
                                        DVZ_Son(i_thick,j_thick,k)                  &
                                        /(WaterColumnV(i_thick, j_thick) - TotalDUVZ_Son)

                                endif

                                if (.not. Me%ComputeOptions%Continuous)                 &
                                    !recalculate the water fluxes
                                    Me%WaterFluxes%Y(i, j, k)               =           &
                                        Me%SubModel%qY (i, j, k) * DXX_Son(i, j) 
                        
                            endif cd6

                        enddo                       

                    elseif (ExcessValue_Father /= 0.0) then
                        !Correct son layer values for the excess of father values
                    
                        do k = KUB, KLB, - 1
                            !layers from surface to bottom

                            if (Me%SubModel%DeadZone) then

                                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                            else

                                DeadZoneSon = .false.

                            endif
    
cd7:                        if ((Faces3D_VSon        (i, j, k) == Covered   .or.    &
                             ImposedTangFacesVSon(i, j, k) == Imposed   .or.        &
                             ImposedNormFacesVSon(i, j, k) == Imposed)  .and.       & 
                             .not. DeadZoneSon  .and. .not. Me%SubModel%HotStartData) then

                                if      (ImposedTangFacesVSon(i, j, k) == Imposed .or. &
                                         Faces3D_VSon        (i, j, k) == Covered) then

                                    i_thick = i
                                    j_thick = j

                                else if (ImposedNormFacesVSon(i, j, k) == Imposed) then

                                    if      (i == IUB + 1) then

                                        i_thick = i - 1

                                    else if (i == ILB) then

                                        i_thick = i + 1

                                    else

                                        i_thick = i + Faces3D_VSon(i + 1, j, k) -   &
                                                  Faces3D_VSon(i - 1, j, k)

                                    endif

                                    j_thick = j 

                                endif

                                Kbottom = KFloor_V(i_thick, j_thick)

                                Me%SubModel%qY(i,j,k) = Me%SubModel%qY(i,j,k) +     &
                                    ExcessValue_Father*DVZ_Son(i_thick, j_thick, k) &
                                    / WaterColumnV(i_thick, j_thick)

                                if (.not. Me%ComputeOptions%Continuous)                 &
                                    !recalculate the water fluxes
                                    Me%WaterFluxes%Y(i, j, k)               =           &
                                        Me%SubModel%qY (i, j, k) * DXX_Son(i, j) 
                     
                            endif cd7
                                           
                        enddo

                    endif       

                endif

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL
            
            if (ErrorOccured .and. .not. Me%SubModel%MissingNull)                   &
                call SetError(FATAL_, INTERNAL_,                                    &
                    "ActualizeSon3DWithFather3D; Hydrodynamic. ERR08") 

        endif cd1

            
cd8:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous) .or.             & 
             Me%Relaxation%WaterLevel                               .or.            &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_)  then

             CHUNK = CHUNK_J(JLB, JUB)
             
            !$OMP PARALLEL PRIVATE(i,j,k,DeadZoneSon)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                !The test must be done for the water points because the water levels in the corner (no open points) 
                !are used to compute face areas where momentum fluxes are computed.
cd9:            if (Water3DSon(i, j, KUB) == WaterPoint .and. .not. DeadZoneSon) then
                
                    Me%SubModel%Z(i, j)  =                                          &
                            Me%SubModel%Z_Next    (i, j) * TimeCoef  +              &
                            Me%SubModel%Z_Previous(i, j) * (1 - TimeCoef)


                    if (Me%SubModel%Z_Next    (i, j) < FillValueReal / 2. .or.      &
                        Me%SubModel%Z_Previous(i, j) < FillValueReal / 2.) then

                        if (Me%SubModel%MissingNull) then
                            !The cell is considered uncovered if WaterColumn < MinWaterColumn 
                            !if WaterColumn < MinWaterColumn / 2 the model put WaterColumn = MinWaterColumn / 2 (creates water)
                            !Using WaterColumn = 3/4MinWaterColumn garantes that the cell is uncovered but mass is not created
                            Me%SubModel%Z(i, j)  = - Bathymetry(i, j) + 0.75 *      &
                                                   MinWaterColumn 

                        else
                            !!!! $OMP CRITICAL (AS3DWF3D2_ERR09)
                            call SetError(FATAL_, INTERNAL_,                        &
                                "ActualizeSon3DWithFather3D; Hydrodynamic. ERR09") 
                            !!!! $OMP END CRITICAL (AS3DWF3D2_ERR09)
                        endif

                    endif

                endif cd9

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL
            
            if (Me%SubModel%MissingNull) then

                 call RemoveLowerSpikes (Me%SubModel%Z, Water3DSon,                 &
                                        Bathymetry, MinWaterColumn,                 &
                                        Me%SubModel%DeadZonePoint,                  &
                                        Me%SubModel%DeadZone,                       &
                                        ILB, IUB, JLB, JUB, KUB) 
            endif

            if (InitialField .and. .not. Me%ComputeOptions%Continuous               &
                .and. Me%SubModel%FatherHotStart)                                   &
                Me%WaterLevel%New(:, :) =                                           &
                    Me%SubModel%Z(:, :)


        else cd8

            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP PARALLEL PRIVATE(i,j,DeadZoneSon)
            
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                !The test must be done for the water points because the water levels in the corner (no open points) 
                !are used to compute face areas where momentum fluxes are computed.
cd10:           if (Boundary2DSon(i, j) == Boundary .and. Water3DSon(i, j, KUB)     &
                    == WaterPoint .and. .not. DeadZoneSon) then
                
                    Me%SubModel%Z(i, j)  =                                          &
                            Me%SubModel%Z_Next    (i, j) * TimeCoef  +              &
                            Me%SubModel%Z_Previous(i, j) * (1 - TimeCoef)


                    if (Me%SubModel%Z_Next    (i, j) < FillValueReal / 2. .or.      &
                        Me%SubModel%Z_Previous(i, j) < FillValueReal / 2.) then

                        if (Me%SubModel%MissingNull) then
                            !The cell is considered uncovered if WaterColumn < MinWaterColumn 
                            !if WaterColumn < MinWaterColumn / 2 the model put WaterColumn = MinWaterColumn / 2 (creates water)
                            ! Using WaterColumn = 3/4MinWaterColumn garantes that the cell is uncovered but mass is not created
                            Me%SubModel%Z(i, j)  = - Bathymetry(i, j) + 0.75 *      &
                                                   MinWaterColumn 

                        else
                            !!!! $OMP CRITICAL (AS3DWF3D3_ERR10)
                            call SetError(FATAL_, INTERNAL_,                        &
                                "ActualizeSon3DWithFather3D; Hydrodynamic. ERR10") 
                            !!!! $OMP END CRITICAL (AS3DWF3D3_ERR10)
                        endif

                    endif

                endif cd10

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (Me%SubModel%MissingNull)                                            &
                call RemoveLowerSpikes (Me%SubModel%Z, Water3DSon,                  &
                                        Bathymetry, MinWaterColumn,                 &
                                        Me%SubModel%DeadZonePoint,                  &
                                        Me%SubModel%DeadZone,                       &
                                        ILB, IUB, JLB, JUB, KUB, Boundary2DSon) 


        endif cd8

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ActualizeSon3DWithFather3D")

cd11:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous)        .or.     & 
             Me%Relaxation%Force .or. Me%Relaxation%Velocity .or.                   &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

             !ACanas: This subroutine following cycles were not parallelized
             !ACanas: because of function calls in cycle iterations
             !ACanas: which causes errors in results.

            do j = JLB, JUB + 1
            do i = ILB, IUB

                if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.             &
                     Me%SubModel%InterPolTime) .or. (.not. Me%SubModel%InterPolTime) &
                    .or. InitialField) then
                    !Time to interpolate vertical layers father to son!
                    
                    NullValue = .false.

                    !find the first father layer for interpolation
                    Aux = KLBFather
                    AuxDepth = 0.0

                    do kfather=KUBFather, KLBFather, -1
                        if ((Me%SubModel%Aux_U(i, j, kfather)                       &
                            < FillValueReal / 2.) .or.                              &
                            (Me%SubModel%Aux_DUZ(i, j, kfather)                     &
                            < FillValueReal / 2.)) then
                            Aux = kfather + 1
                           exit
                        else
                            Values(kfather) = Me%SubModel%Aux_U(i,j,kfather)
                            Depths(kfather) = AuxDepth +                            &
                                Me%SubModel%Aux_DUZ(i,j,kfather)/2
                            AuxDepth = AuxDepth + Me%SubModel%Aux_DUZ(i,j,kfather)
                        endif
                    enddo

                    if (Aux == KUBFather + 1) then
                        
                        if (Me%SubModel%MissingNull) then 
                            NullValue = .true.
                        else
                            call SetError(FATAL_, INTERNAL_,                        &
                                "ActualizeSon3DWithFather3D; Hydrodynamic. ERR11") 
                        endif
                    endif

                    !get number of father depths
                    NDepths = KUBFather - Aux + 1
                    AuxSonDepth = 0.0

                    !DUZ_Next calculation variables
                    !look father layer beginning at the topest layer
                    kfatherinic = KUBFather 
                    RelativeThickness = 1.0
                
                    TotalDUVZ_Son = 0.0
                    ExcessDUVZ_Son = 0.0

                    SumDUVZ_Son = 0.0
                    DeficitValue_Father = 0.0

                endif
                    
                Kbottom = KFloor_U(i, j)

do7:            do k = KUB, KLB, -1 

                    if (Me%SubModel%DeadZone) then

                        DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                    else

                        DeadZoneSon = .false.

                    endif

cd12:               if (Faces3D_USon(i, j, k) == Covered  .and. .not. DeadZoneSon) then

                        if ((((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.   &
                            Me%SubModel%InterPolTime) .or.                          &
                            (.not. Me%SubModel%InterPolTime)                        &
                            .or. InitialField) .and. (.not. NullValue)) then
                            !Time to interpolate vertical layers father to son!
                            
                            !(get U_Next from father)
                         
                            !get son cell depth
                            SonDepth = AuxSonDepth + DUZ_Son(i, j, k)/2
                            AuxSonDepth = AuxSonDepth + DUZ_Son(i, j, k)

                            !interpolate father values as a profile
                            Me%SubModel%U_Next(i,j,k) =                             &
                                            InterpolateProfileR8(SonDepth,          &
                                            NDepths, Depths(Aux:KUBFather),         &
                                            Values(Aux:KUBFather),                  &
                                            FoundBottom, FoundSurface)
                        
                            if (InitialField)                                       &
                                Me%SubModel%U_Previous(i,j,k) =                     &
                                    Me%SubModel%U_Next(i,j,k)
                        
                            if (.not. Me%SubModel%MomentConserv) then

                                !layer thicknesses are completely determined by son's
                                Me%SubModel%DUZ_Next(i, j, k) = DUZ_Son(i, j, k)

                            else

                                !initialize variable
                                Me%SubModel%DUZ_Next(i, j, k) = 0

                                !(father values exist for at least one layer)

                                !DUZ is need for weighting
                                AuxDUVZ_Son = DUZ_Son(i, j, k)

do8:                            do kfather = kfatherinic, KLBFather, -1                              
                                    !(layers from surface to bottom)

                                    if (Me%SubModel%Aux_DUZ(i, j, kfather)          & 
                                        < FillValueReal / 2.) then
                                        !if father values do not exist

                                        if (Me%SubModel%MissingNull) then
                                            !son layers assumed null values
                                            exit do8

                                        else
                                            call SetError(FATAL_, INTERNAL_,        &
                                    "ActualizeSon3DWithFather3D; Hydrodynamic. ERR12")
                                        endif

                                    endif

                                    AuxDUVZ_Father = Me%SubModel%Aux_DUZ(i,j,kfather)
                        
                                    if (AuxDUVZ_Son .le.                            &
                                        RelativeThickness*AuxDUVZ_Father) then

                                        !son layer inside father layer part
                                        RelativeThickness = AuxDUVZ_Son*            &
                                            RelativeThickness / AuxDUVZ_Father

                                        Me%SubModel%DUZ_Next(i, j, k) =             &
                                            Me%SubModel%DUZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DUZ(i, j, kfather)      &
                                            * RelativeThickness

                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            AuxDUVZ_Son
                    
                                        if (Abs(AuxDUVZ_Son - AuxDUVZ_Father) .lt.  &
                                            AllmostZero) then
                                            !(AuxDUVZ_Son == AuxDUVZ_Father)

                                            !this father layer is already solved, solve next
                                            kfatherinic = kfatherinic -1
                                            RelativeThickness = 1
                    
                                        else

                                            RelativeThickness = 1 - RelativeThickness

                                        endif

                                        AuxDUVZ_Son = 0.0

                                        exit do8

                                    else

                                        !son layer includes father layer part
                                        Me%SubModel%DUZ_Next(i, j, k) =             &
                                            Me%SubModel%DUZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DUZ(i, j, kfather)      &
                                            * RelativeThickness
                            
                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            RelativeThickness*AuxDUVZ_Father

                                        !get the remaining part of DUZ_Son
                                        AuxDUVZ_Son = AuxDUVZ_Son -                 &
                                            RelativeThickness*AuxDUVZ_Father

                                        !seek in the next father layer
                                        kfatherinic = kfatherinic - 1
                                        RelativeThickness = 1

                                    endif

                                enddo do8

                                !check if excess or deficit flux variable exists
                                if ((AuxDUVZ_Son /= 0.0) .and.                      &
                                    (kfather == KLBFather)) then
                                    !last son layer was not fulfilled by father values
                                    !(all the next son layers are not fulfilled also)

                                    ExcessDUVZ_Son = AuxDUVZ_Son

                                    if (k-1 .ge. KLB) then
                                        !add DUZ of next son layers

                                        do k2 = k-1, KLB, -1
                                            !layers from surface to bottom

                                            ExcessDUVZ_Son = ExcessDUVZ_Son +       &
                                                DUZ_Son(i, j, k2)
                            
                                        enddo

                                    endif
                
                                else if ((k == Kbottom) .and.                       &
                                    ((RelativeThickness /= 1) .or.                  &
                                    (kfather /= KLBFather))) then
                                    !all son layers are fulfilled with father values
                                    !but excedent father layer part exist
                        
                                    if (RelativeThickness /= 1)                     &
                                        ExcessValue_Father =                        &
                                                Me%SubModel%Aux_DUZ(i, j, kfather)* &
                                                RelativeThickness

                                    if (kfather - 1 .ge. KLBFather) then
                                        !add values of next father layers

do9:                                    do k2father = kfather - 1, KLBFather, - 1
                                            !layers from surface to bottom
                        
                                            if (Me%SubModel%Aux_DUZ(i, j,k2father)  & 
                                                < FillValueReal / 2.) then

                                                exit do9
                                
                                            else

                                                ExcessValue_Father =                &
                                                ExcessValue_Father                  &
                                                + Me%SubModel%Aux_DUZ(i, j, k2father)

                                            endif

                                        enddo do9

                                    endif

                                endif

                            endif

                            if (InitialField) then

                                Me%SubModel%DUZ_Previous(i,j,k) =                   &
                                    Me%SubModel%DUZ_Next(i,j,k)  

                            endif

                        endif

                        !Time interpolation of variables (performed always!)
                        !(for velocity)
                        if (Me%SubModel%U_Next    (i, j, k) < FillValueReal / 2. .or. &
                            Me%SubModel%U_Previous(i, j, k) < FillValueReal / 2.)  then

                            if (Me%SubModel%MissingNull) then 
                                
                                Me%SubModel%U_New(i, j, k)  =  0.

                            else
                                call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR13") 
                            endif

                        else

                            Me%SubModel%U_New(i, j, k)  =                           &
                                Me%SubModel%U_Next    (i, j, k) * TimeCoef  +       &
                                Me%SubModel%U_Previous(i, j, k) * (1 - TimeCoef)

                        endif

                        if (InitialField .and. .not. Me%ComputeOptions%Continuous   &
                           .and. Me%SubModel%FatherHotStart)                        &
                            Me%Velocity%Horizontal%U%New(i, j, k) =                 &
                                       Me%SubModel%U_New(i, j, k)

                        !(for DUZ it may be provisory)
                        if (Me%SubModel%DUZ_Next    (i, j, k) < FillValueReal / 2.  &
                            .or. Me%SubModel%DUZ_Previous(i, j, k) < FillValueReal  &
                            / 2.) then

                            if (Me%SubModel%MissingNull) then 
                            
                                Me%SubModel%DUZ_New(i, j, k)  =  0.

                            else
                                call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR14") 
                            endif

                        else

                            Me%SubModel%DUZ_New(i, j, k)  =                         &
                                     Me%SubModel%DUZ_Next    (i, j, k) *            &
                                     TimeCoef +                                     &
                                     Me%SubModel%DUZ_Previous(i, j, k) *            &
                                     (1 - TimeCoef)

                        endif

                    endif cd12

                    if (k == Kbottom) exit do7

                enddo do7

                if (Me%SubModel%MomentConserv) then
                    !Check if correction is needed

                    if ((ExcessDUVZ_Son /= 0.0) .or. (ExcessValue_Father /= 0.0)) then

do21:                   do k = KUB, KLB, -1 

                            if (Me%SubModel%DeadZone) then

                                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                            else

                                DeadZoneSon = .false.

                            endif

cd13:                       if (Faces3D_USon(i, j, k) == Covered  .and. .not. DeadZoneSon) then

                                if ((((Me%CurrentTime == Me%SubModel%GetFatherTime) &
                                    .and. Me%SubModel%InterPolTime) .or.            &
                                    (.not. Me%SubModel%InterPolTime)                &
                                    .or. InitialField) .and. (.not. NullValue)) then
                                    !Check if layer values from father need to be corrected
                                    !(capitalizing on the DO cycle)

                                    if (ExcessDUVZ_Son /= 0.0) then
                                        !Correct son layer values for the deficit of father values

                                        SumDUVZ_Son = SumDUVZ_Son + DUZ_Son(i, j, k)

                                        if (SumDUVZ_Son .le. TotalDUVZ_Son) then
                                            !layers having father value
                            
                                            AuxDeficit = Me%SubModel%DUZ_Next(i,j,k)* &
                                                ExcessDUVZ_Son*DUZ_Son(i, j, k)     &
                                                /TotalDUVZ_Son

                                            !actualize the value of the father deficit
                                            DeficitValue_Father = DeficitValue_Father + &
                                                AuxDeficit

                                            !remove flux variable from layer
                                            Me%SubModel%DUZ_Next(i,j,k) =           &
                                                            Me%SubModel%DUZ_Next(i,j,k) &
                                                            - AuxDeficit

                                        elseif (AuxDUVZ_Son /= 0.0) then
                                            !son layer partially with father value
                                            AuxDeficit = Me%SubModel%DUZ_next(i,j,k)* &
                                                ExcessDUVZ_Son*(DUZ_Son(i, j, k)    &
                                                - AuxDUVZ_Son)/TotalDUVZ_Son 

                                            !actualize the value of the father deficit
                                            DeficitValue_Father = DeficitValue_Father + &
                                                AuxDeficit

                                            !remove and add
                                            Me%SubModel%DUZ_Next(i,j,k) =           &
                                                Me%SubModel%DUZ_Next(i,j,k) - AuxDeficit + &
                                                DeficitValue_Father*AuxDUVZ_Son/    &
                                                (WaterColumnU(i, j) - TotalDUVZ_Son)

                                            AuxDUVZ_Son = 0.0
                                            !(layer completed)

                                        else
                                            !fill son layer without father value
                            
                                            !add collected value
                                            Me%SubModel%DUZ_Next(i,j,k) =           &
                                                DeficitValue_Father*                &
                                                DUZ_Son(i,j,k)                      &
                                                /(WaterColumnU(i, j) - TotalDUVZ_Son)

                                        endif

                                    elseif (ExcessValue_Father /= 0.0) then
                                        !Correct son layer values for the excess of father values

                                        Me%SubModel%DUZ_Next(i,j,k) =               &
                                            Me%SubModel%DUZ_Next(i,j,k) +           &
                                            ExcessValue_Father*DUZ_Son(i, j, k)/    &
                                            WaterColumnU(i, j)

                                    endif

                                    if (InitialField) then

                                        Me%SubModel%DUZ_Previous(i,j,k) =           &
                                                              Me%SubModel%DUZ_Next(i,j,k)  

                                    endif


                                endif

                                if (Me%SubModel%DUZ_Next    (i, j, k) < FillValueReal / 2. &
                                    .or. Me%SubModel%DUZ_Previous(i, j, k) < FillValueReal &
                                    / 2.) then

                                    if (Me%SubModel%MissingNull) then 
                            
                                        Me%SubModel%DUZ_New(i, j, k)  =  0.

                                    else
                                        call SetError(FATAL_, INTERNAL_,            &
                                        "ActualizeSon3DWithFather3D; Hydrodynamic. ERR15") 
                                    endif

                                else

                                    Me%SubModel%DUZ_New(i, j, k)  =                 &
                                             Me%SubModel%DUZ_Next    (i, j, k) *    &
                                             TimeCoef +                             &
                                             Me%SubModel%DUZ_Previous(i, j, k) *    &
                                             (1 - TimeCoef)

                                endif

                            endif cd13
                 
                            if (k == Kbottom) exit do21

                        enddo do21
                
                    endif

                endif

            enddo
            enddo
            
        endif cd11

        do j = JLB, JUB + 1
        do i = ILB, IUB

            if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.                &
                Me%SubModel%InterPolTime) .or.                                      &
                (.not. Me%SubModel%InterPolTime)   .or. InitialField) then
                !Time to interpolate vertical layers father to son!

                !U_Next calculation variables
                AuxSonDepth = 0.0

                !DUZ_Next calculation variables
                !look father layer beginning at the topest layer
                kfatherinic = KUBFather
                RelativeThickness = 1.0
    
                TotalDUVZ_Son = 0.0
                ExcessDUVZ_Son = 0.0

                SumDUVZ_Son = 0.0
                DeficitValue_Father = 0.0

            endif

do10:       do k = KUB, KLB, -1 

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                else

                    DeadZoneSon = .false.

                endif
            
cd14:           if ((ImposedTangFacesUSon(i, j, k) == Imposed  .or.                 &
                 ImposedNormFacesUSon(i, j, k) == Imposed)  .and.                   &
                 .not. DeadZoneSon) then
                
                    if (ImposedTangFacesUSon(i, j, k) == Imposed) then

                        i_thick = i
                        j_thick = j

                    else if (ImposedNormFacesUSon(i, j, k) == Imposed) then

                        i_thick = i

                        if      (j == JUB + 1) then

                            j_thick = j - 1

                        else if (j == JLB) then

                            j_thick = j + 1

                        else

                            j_thick = j + Faces3D_USon(i, j + 1, k) -               &
                                      Faces3D_USon(i, j - 1, k)

                        endif

                    endif

                    if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.        &
                        Me%SubModel%InterPolTime) .or.                              &
                        (.not. Me%SubModel%InterPolTime) .or. InitialField) then
                        !Time to interpolate vertical layers father to son!
                    
                        NullValue = .false.

                        !find the first father layer for interpolation
                        Aux = KLBFather
                        AuxDepth = 0.0

                        do kfather=KUBFather, KLBFather, -1
                            if ((Me%SubModel%Aux_U(i, j, kfather)                   &
                                < FillValueReal / 2.) .or.                          &
                                (Me%SubModel%Aux_DUZ(i, j, kfather)                 &
                                < FillValueReal / 2.)) then
                                Aux = kfather + 1
                               exit
                            else
                                Values(kfather) = Me%SubModel%Aux_U(i,j,kfather)
                                Depths(kfather) = AuxDepth +                        &
                                    Me%SubModel%Aux_DUZ(i, j,kfather)/2
                                AuxDepth = AuxDepth +                               &
                                    Me%SubModel%Aux_DUZ(i, j,kfather)
                                !(since it is father (i,j) value exists!)
                            endif
                        enddo

                        if (Aux == KUBFather + 1) then
                        
                            if (Me%SubModel%MissingNull) then 
                                NullValue = .true.
                            else
                                call SetError(FATAL_, INTERNAL_,                    &
                                    "ActualizeSon3DWithFather3D; Hydrodynamic. ERR16") 
                            endif
                        endif
                
                        if (.not. NullValue) then
                        !(father values exist for at least one layer)

                            !get number of father depths
                            NDepths = KUBFather - Aux + 1

                            !Time to interpolate vertical layers father to son!
                            !(get U_Next from father)

                            !get son cell depth
                            SonDepth = AuxSonDepth + DUZ_Son(i_thick, j_thick, k)/2
                            AuxSonDepth = AuxSonDepth + DUZ_Son(i_thick, j_thick, k)

                            !interpolate father values as a profile
                            Me%SubModel%U_Next(i,j,k) =                             &
                                            InterpolateProfileR8(SonDepth,          &
                                            NDepths, Depths(Aux:KUBFather),         &
                                            Values(Aux:KUBFather),                  &
                                            FoundBottom, FoundSurface)
                    
                            if (InitialField)                                       &
                                Me%SubModel%U_Previous(i,j,k) =                     &
                                    Me%SubModel%U_Next(i,j,k)
                    
                            if (.not. Me%SubModel%MomentConserv) then

                                Me%SubModel%DUZ_Next(i, j, k) = DUZ_Son(i_thick,    &
                                                                j_thick, k)
                                !(has to be used i_thick, j_thick because i,j dont exist)

                            else

                                !Time to interpolate vertical layers father to son!
                                !(get DUZ/DVZ from father)
                                !initialize variable
                                Me%SubModel%DUZ_Next(i, j, k) = 0

                                !DUZ is need for weighting
                                AuxDUVZ_Son = DUZ_Son(i_thick, j_thick, k)

do11:                           do kfather = kfatherinic, KLBFather, -1                              
                                    !(layers from surface to bottom)

                                    if (Me%SubModel%Aux_DUZ(i, j,kfather)           & 
                                        < FillValueReal / 2.) then
                                        !if father values do not exist

                                        if (Me%SubModel%MissingNull)                &
                                            !son layers assumed null values
                                            exit do11

                                    endif

                                    AuxDUVZ_Father =                                &
                                        Me%SubModel%Aux_DUZ(i, j, kfather)
                                    !(since not exited from loop (i,j) value exists!)
                        
                                    if (AuxDUVZ_Son .le.                            &
                                        RelativeThickness*AuxDUVZ_Father) then

                                        !son layer inside father layer part
                                        RelativeThickness = AuxDUVZ_Son*            &
                                            RelativeThickness / AuxDUVZ_Father

                                        Me%SubModel%DUZ_Next(i, j, k) =             &
                                            Me%SubModel%DUZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DUZ(i, j, kfather)      &
                                            * RelativeThickness

                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            AuxDUVZ_Son
                    
                                        if (Abs(AuxDUVZ_Son - AuxDUVZ_Father) .lt.  &
                                            AllmostZero) then
                                            !(AuxDUVZ_Son == AuxDUVZ_Father)

                                            !this father layer is already solved, solve next
                                            kfatherinic = kfatherinic -1
                                            RelativeThickness = 1
                    
                                        else

                                            RelativeThickness = 1 - RelativeThickness

                                        endif

                                        AuxDUVZ_Son = 0.0

                                        exit do11

                                    else

                                        !son layer includes father layer part
                                        Me%SubModel%DUZ_Next(i, j, k) =             &
                                            Me%SubModel%DUZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DUZ(i, j, kfather)      &
                                            * RelativeThickness
                            
                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            RelativeThickness*AuxDUVZ_Father

                                        !get the remaing part of DUZ_Son
                                        AuxDUVZ_Son = AuxDUVZ_Son -                 &
                                            RelativeThickness*AuxDUVZ_Father

                                        !seek in the next father layer
                                        kfatherinic = kfatherinic - 1
                                        RelativeThickness = 1
                                    endif
                                enddo do11

                                !check if excess or deficit flux variable exists
                                if ((AuxDUVZ_Son /= 0.0) .and.                      &
                                    (kfather == KLBFather)) then 
                                    !last son layer was not fulfilled by father values
                                    !(all the next son layers are not fulfilled also)

                                    ExcessDUVZ_Son = AuxDUVZ_Son

                                    if (k-1 .ge. KLB) then
                                        !add DUZ of next son layers

                                        do k2 = k-1, KLB, -1
                                            !layers from surface to bottom

                                            ExcessDUVZ_Son = ExcessDUVZ_Son +       &
                                                DUZ_Son(i_thick, j_thick, k2)
                                        enddo
                                    endif
                                else if ((k == Kbottom) .and.                       &
                                    ((RelativeThickness /= 1) .or.                  &
                                    (kfather /= KLBFather))) then
                                    !all son layers are fulfilled with father values
                                    !but excedent father layer part exist
                        
                                    if (RelativeThickness /= 1)                     &
                                        ExcessValue_Father =                        &
                                                Me%SubModel%Aux_DUZ(i, j, kfather)* &
                                                RelativeThickness

                                    if (kfather - 1 .ge. KLBFather) then
                                        !add values of next father layers

do12:                                   do k2father = kfather - 1, KLBFather, - 1
                                            !layers from surface to bottom
                        
                                            if (Me%SubModel%Aux_DUZ(i, j,k2father)  & 
                                                < FillValueReal / 2.) then

                                                exit do12
                                            else

                                                ExcessValue_Father =                &
                                                ExcessValue_Father                  &
                                                + Me%SubModel%Aux_DUZ(i, j, k2father)
                                            endif

                                        enddo do12
                                    endif
                                endif
                            endif

                            if (InitialField) then

                                Me%SubModel%DUZ_Previous(i,j,k) =                   &
                                                    Me%SubModel%DUZ_Next(i,j,k)  
                            endif               
                        endif
                    endif

                    Kbottom = KFloor_U(i_thick, j_thick)

                    !Time interpolation of variables (performed always!)
                    !(here just for velocity)
                    if (Me%SubModel%U_Next    (i, j, k) < FillValueReal / 2. .or.   &
                        Me%SubModel%U_Previous(i, j, k) < FillValueReal / 2.)  then

                        if (Me%SubModel%MissingNull) then 
                            
                            Me%SubModel%U_New(i, j, k)  =  0.

                        else
                            call SetError(FATAL_, INTERNAL_,                        &
                                 "ActualizeSon3DWithFather3D; Hydrodynamic. ERR17") 
                        endif
                    else

                        Me%SubModel%U_New(i, j, k)  =                               &
                            Me%SubModel%U_Next    (i, j, k) * TimeCoef  +           &
                            Me%SubModel%U_Previous(i, j, k) * (1 - TimeCoef)
                    endif

                    if (InitialField .and. .not. Me%ComputeOptions%Continuous       &
                        .and. Me%SubModel%FatherHotStart)                           &
                        Me%Velocity%Horizontal%U%New(i, j, k) =                     &
                                   Me%SubModel%U_New(i, j, k)

                    !(for DUZ)
                    if (Me%SubModel%DUZ_Next    (i, j, k) < FillValueReal / 2.      &
                        .or. Me%SubModel%DUZ_Previous(i, j, k) < FillValueReal      &
                        / 2.) then

                        if (Me%SubModel%MissingNull) then 
                            
                            Me%SubModel%DUZ_New(i, j, k)  =  0.

                        else
                            call SetError(FATAL_, INTERNAL_,                        &
                                 "ActualizeSon3DWithFather3D; Hydrodynamic. ERR18") 
                        endif
                    else

                        Me%SubModel%DUZ_New(i, j, k)  =                             &
                                 Me%SubModel%DUZ_Next    (i, j, k) *                &
                                 TimeCoef +                                         &
                                 Me%SubModel%DUZ_Previous(i, j, k) *                &
                                 (1 - TimeCoef)
                    endif
                endif cd14

                if (k == Kbottom) exit do10
            enddo do10


            if (Me%SubModel%MomentConserv) then

                if ((ExcessDUVZ_Son /= 0.0) .or. (ExcessValue_Father /= 0.0)) then

do22:               do k = KUB, KLB, -1 

                        if (Me%SubModel%DeadZone) then

                            DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)
                        else

                            DeadZoneSon = .false.
                        endif
            
cd15:                   if ((ImposedTangFacesUSon(i, j, k) == Imposed  .or.         &
                         ImposedNormFacesUSon(i, j, k) == Imposed)  .and.           &
                         .not. DeadZoneSon) then
                
                            if (ImposedTangFacesUSon(i, j, k) == Imposed) then

                                i_thick = i
                                j_thick = j

                            else if (ImposedNormFacesUSon(i, j, k) == Imposed) then

                                i_thick = i

                                if      (j == JUB + 1) then

                                    j_thick = j - 1

                                else if (j == JLB) then

                                    j_thick = j + 1

                                else

                                    j_thick = j + Faces3D_USon(i, j + 1, k) -       &
                                              Faces3D_USon(i, j - 1, k)

                                endif
                            endif

                            Kbottom = KFloor_U(i_thick, j_thick)

                            if ((((Me%CurrentTime == Me%SubModel%GetFatherTime) .and. &
                                Me%SubModel%InterPolTime) .or.                       &
                                (.not. Me%SubModel%InterPolTime) .or. InitialField)  &
                                .and. (.not. NullValue)) then
                                !Check if layer values from father need to be corrected
                                !(capitalizing on the DO cycle)

                                if (ExcessDUVZ_Son /= 0.0) then
                                    !Correct son layer values for the deficit of father values

                                    SumDUVZ_Son = SumDUVZ_Son + DUZ_Son(i_thick, j_thick, k)

                                    if (SumDUVZ_Son .le. TotalDUVZ_Son) then
                                        !layers having father value
                            
                                        AuxDeficit = Me%SubModel%DUZ_Next(i,j,k)*   &
                                            ExcessDUVZ_Son*DUZ_Son(i_thick, j_thick, k) &
                                            /TotalDUVZ_Son

                                        !actualize the value of the father deficit
                                        DeficitValue_Father = DeficitValue_Father + &
                                            AuxDeficit

                                        !remove flux variable from layer
                                        Me%SubModel%DUZ_Next(i,j,k) =               &
                                                        Me%SubModel%DUZ_Next(i,j,k) &
                                                        - AuxDeficit

                                    elseif (AuxDUVZ_Son /= 0.0) then
                                        !son layer partially with father value
                                        AuxDeficit = Me%SubModel%DUZ_Next(i,j,k)*   &
                                            ExcessDUVZ_Son*(DUZ_Son(i_thick, j_thick, k) &
                                            - AuxDUVZ_Son)/TotalDUVZ_Son 

                                        !actualize the value of the father deficit
                                        DeficitValue_Father = DeficitValue_Father + &
                                            AuxDeficit

                                        !remove and add
                                        Me%SubModel%DUZ_Next(i,j,k) =               &
                                            Me%SubModel%DUZ_Next(i,j,k) - AuxDeficit + &
                                            DeficitValue_Father*AuxDUVZ_Son/        &
                                            (WaterColumnU(i_thick, j_thick) - TotalDUVZ_Son)

                                        AuxDUVZ_Son = 0.0
                                        !(layer completed)

                                    else
                                        !fill son layer without father value
                            
                                        !add collected value
                                        Me%SubModel%DUZ_Next(i,j,k) =               &
                                            DeficitValue_Father*                    &
                                            DUZ_Son(i_thick, j_thick,k)             &
                                            /(WaterColumnU(i_thick, j_thick) - TotalDUVZ_Son)

                                    endif

                                elseif (ExcessValue_Father /= 0.0) then
                                    !Correct son layer values for the excess of father values

                                    Me%SubModel%DUZ_Next(i,j,k) =                   &
                                        Me%SubModel%DUZ_Next(i,j,k) +               &
                                        ExcessValue_Father*DUZ_Son(i_thick, j_thick,k)/ &
                                        WaterColumnU(i_thick, j_thick)

                                endif

                                if (InitialField) then

                                    Me%SubModel%DUZ_Previous(i,j,k) =               &
                                                            Me%SubModel%DUZ_Next(i,j,k)  

                                endif

                            endif

                            !Time interpolation of variables (performed always!)
                            !(here just for DUZ/DVZ)

                            if (Me%SubModel%DUZ_Next    (i, j, k) < FillValueReal / 2. &
                                .or. Me%SubModel%DUZ_Previous(i, j, k) < FillValueReal &
                                / 2.) then

                                if (Me%SubModel%MissingNull) then 
                            
                                    Me%SubModel%DUZ_New(i, j, k)  =  0.

                                else
                                    call SetError(FATAL_, INTERNAL_,                &
                                         "ActualizeSon3DWithFather3D; Hydrodynamic. ERR19") 
                                endif

                            else

                                Me%SubModel%DUZ_New(i, j, k)  =                     &
                                         Me%SubModel%DUZ_Next    (i, j, k) *        &
                                         TimeCoef +                                 &
                                         Me%SubModel%DUZ_Previous(i, j, k) *        &
                                         (1 - TimeCoef)

                            endif

                        endif cd15

                        if (k == Kbottom) exit do22

                    enddo do22

                endif

            endif

        enddo
        enddo

cd16:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous)        .or.     & 
             Me%Relaxation%Force .or. Me%Relaxation%Velocity .or.                   &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            do j = JLB, JUB
            do i = ILB, IUB + 1

                if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.            &
                    Me%SubModel%InterPolTime) .or. (.not. Me%SubModel%InterPolTime) &
                    .or. InitialField) then
                    !Time to interpolate vertical layers father to son!
                    
                    NullValue = .false.

                    !find the first father layer for interpolation
                    Aux = KLBFather
                    AuxDepth = 0.0

                    do kfather=KUBFather, KLBFather, -1
                        if ((Me%SubModel%Aux_V(i, j, kfather)                       &
                            < FillValueReal / 2.) .or.                              &
                            (Me%SubModel%Aux_DVZ(i, j, kfather)                     &
                            < FillValueReal / 2.)) then
                            Aux = kfather + 1
                           exit
                        else
                            Values(kfather) = Me%SubModel%Aux_V(i,j,kfather)
                            Depths(kfather) = AuxDepth +                            &
                                Me%SubModel%Aux_DVZ(i,j,kfather)/2
                            AuxDepth = AuxDepth + Me%SubModel%Aux_DVZ(i,j,kfather)
                        endif
                    enddo

                    if (Aux == KUBFather + 1) then
                        
                        if (Me%SubModel%MissingNull) then 
                            NullValue = .true.
                        else
                            call SetError(FATAL_, INTERNAL_,                        &
                                "ActualizeSon3DWithFather3D; Hydrodynamic. ERR20") 
                        endif
                    endif

                    !get number of father depths
                    NDepths = KUBFather - Aux + 1
                    AuxSonDepth = 0.0

                    !DUZ_Next calculation variables
                    !look father layer beginning at the topest layer
                    kfatherinic = KUBFather  
                    RelativeThickness = 1.0
                
                    TotalDUVZ_Son = 0.0
                    ExcessDUVZ_Son = 0.0

                    SumDUVZ_Son = 0.0
                    DeficitValue_Father = 0.0

                endif
                    
                Kbottom = KFloor_V(i, j)

do13:           do k = KUB, KLB, -1 

                    if (Me%SubModel%DeadZone) then

                        DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                    else

                        DeadZoneSon = .false.

                    endif

cd17:               if (Faces3D_VSon(i, j, k) == Covered  .and. .not. DeadZoneSon) then

                        if ((((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.   &
                            Me%SubModel%InterPolTime) .or.                          &
                            (.not. Me%SubModel%InterPolTime)                        &
                            .or. InitialField) .and. (.not. NullValue)) then
                            !Time to interpolate vertical layers father to son!
                            !(get V_Next from father)
                         
                            !get son cell depth
                            SonDepth = AuxSonDepth + DVZ_Son(i, j, k)/2
                            AuxSonDepth = AuxSonDepth + DVZ_Son(i, j, k)

                            !interpolate father values as a profile
                            Me%SubModel%V_Next(i,j,k) =                             &
                                            InterpolateProfileR8(SonDepth,          &
                                            NDepths, Depths(Aux:KUBFather),         &
                                            Values(Aux:KUBFather),                  &
                                            FoundBottom, FoundSurface)
                        
                            if (InitialField)                                       &
                                Me%SubModel%V_Previous(i,j,k) =                     &
                                    Me%SubModel%V_Next(i,j,k)
                        
                            if (.not. Me%SubModel%MomentConserv) then

                                Me%SubModel%DVZ_Next(i, j, k) = DVZ_Son(i, j, k)

                            else

                                !initialize variable
                                Me%SubModel%DVZ_Next(i, j, k) = 0

                                !(father values exist for at least one layer)

                                !DVZ is need for weighting
                                AuxDUVZ_Son = DVZ_Son(i, j, k)

do14:                           do kfather = kfatherinic, KLBFather, -1                              
                                    !(layers from surface to bottom)

                                    if (Me%SubModel%Aux_DVZ(i, j, kfather)          & 
                                        < FillValueReal / 2.) then
                                        !if father values do not exist

                                        if (Me%SubModel%MissingNull) then
                                            !son layers assumed null values
                                            exit do14

                                        else
                                            call SetError(FATAL_, INTERNAL_,        &
                                    "ActualizeSon3DWithFather3D; Hydrodynamic. ERR21")
                                        endif

                                    endif

                                    AuxDUVZ_Father = Me%SubModel%Aux_DVZ(i,j,kfather)
                        
                                    if (AuxDUVZ_Son .le.                            &
                                        RelativeThickness*AuxDUVZ_Father) then

                                        !son layer inside father layer part
                                        RelativeThickness = AuxDUVZ_Son*            &
                                            RelativeThickness / AuxDUVZ_Father

                                        Me%SubModel%DVZ_Next(i, j, k) =             &
                                            Me%SubModel%DVZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DVZ(i, j, kfather)      &
                                            * RelativeThickness

                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            AuxDUVZ_Son
                    
                                        if (Abs(AuxDUVZ_Son - AuxDUVZ_Father) .lt.  &
                                            AllmostZero) then
                                            !(AuxDUVZ_Son == AuxDUVZ_Father)

                                            !this father layer is already solved, solve next
                                            kfatherinic = kfatherinic -1
                                            RelativeThickness = 1
                    
                                        else

                                            RelativeThickness = 1 - RelativeThickness

                                        endif

                                        AuxDUVZ_Son = 0.0

                                        exit do14

                                    else

                                        !son layer includes father layer part
                                        Me%SubModel%DVZ_Next(i, j, k) =             &
                                            Me%SubModel%DVZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DVZ(i, j, kfather)      &
                                            * RelativeThickness
                            
                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            RelativeThickness*AuxDUVZ_Father

                                        !get the remaing part of DUZ_Son
                                        AuxDUVZ_Son = AuxDUVZ_Son -                 &
                                            RelativeThickness*AuxDUVZ_Father

                                        !seek in the next father layer
                                        kfatherinic = kfatherinic - 1
                                        RelativeThickness = 1

                                    endif

                                enddo do14

                                !check if excess or deficit flux variable exists
                                if ((AuxDUVZ_Son /= 0.0) .and.                      &
                                    (kfather == KLBFather)) then
                                    !last son layer was not fulfilled by father values
                                    !(all the next son layers are not fulfilled also)

                                    ExcessDUVZ_Son = AuxDUVZ_Son

                                    if (k-1 .ge. KLB) then
                                        !add DVZ of next son layers

                                        do k2 = k-1, KLB, -1
                                            !layers from surface to bottom

                                            ExcessDUVZ_Son = ExcessDUVZ_Son +       &
                                                DVZ_Son(i, j, k2)
                            
                                        enddo

                                    endif
                
                                else if ((k == Kbottom) .and.                       &
                                    ((RelativeThickness /= 1) .or.                  &
                                    (kfather /= KLBFather))) then
                                    !all son layers are fulfilled with father values
                                    !but excedent father layer part exist
                        
                                    if (RelativeThickness /= 1)                     &
                                        ExcessValue_Father =                        &
                                                Me%SubModel%Aux_DVZ(i, j, kfather)* &
                                                RelativeThickness

                                    if (kfather - 1 .ge. KLBFather) then
                                        !add values of next father layers

do15:                                   do k2father = kfather - 1, KLBFather, - 1
                                            !layers from surface to bottom
                        
                                            if (Me%SubModel%Aux_DVZ(i, j,k2father)  & 
                                                < FillValueReal / 2.) then

                                                exit do15
                                
                                            else

                                                ExcessValue_Father =                &
                                                ExcessValue_Father                  &
                                                + Me%SubModel%Aux_DVZ(i, j, k2father)

                                            endif

                                        enddo do15

                                    endif

                                endif

                            endif

                            if (InitialField) then

                                Me%SubModel%DVZ_Previous(i,j,k) =                   &
                                                        Me%SubModel%DVZ_Next(i,j,k)  
                            endif
                        endif

                        !Time interpolation of variables (performed always!)
                        !(in this place just for velocity)
                        if (Me%SubModel%V_Next    (i, j, k) < FillValueReal / 2. .or. &
                            Me%SubModel%V_Previous(i, j, k) < FillValueReal / 2.)  then

                            if (Me%SubModel%MissingNull) then 
                                
                                Me%SubModel%V_New(i, j, k)  =  0.

                            else
                                call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR22") 
                            endif

                        else

                            Me%SubModel%V_New(i, j, k)  =                           &
                                Me%SubModel%V_Next    (i, j, k) * TimeCoef  +       &
                                Me%SubModel%V_Previous(i, j, k) * (1 - TimeCoef)

                        endif

                        if (InitialField .and. .not. Me%ComputeOptions%Continuous   &
                            .and. Me%SubModel%FatherHotStart)                       &
                            Me%Velocity%Horizontal%V%New(i, j, k) =                 &
                                       Me%SubModel%V_New(i, j, k)

                        !(for DVZ)
                        if (Me%SubModel%DVZ_Next    (i, j, k) < FillValueReal / 2.  &
                            .or. Me%SubModel%DVZ_Previous(i, j, k) < FillValueReal  &
                            / 2.) then

                            if (Me%SubModel%MissingNull) then 
                            
                                Me%SubModel%DVZ_New(i, j, k)  =  0.

                            else
                                call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR23") 
                            endif
                        else

                            Me%SubModel%DVZ_New(i, j, k)  =                         &
                                     Me%SubModel%DVZ_Next    (i, j, k) *            &
                                     TimeCoef +                                     &
                                     Me%SubModel%DVZ_Previous(i, j, k) *            &
                                     (1 - TimeCoef)

                        endif
                    endif cd17

                    if (k == Kbottom) exit do13

                enddo do13

                if (Me%SubModel%MomentConserv) then
                !Time interpolation of variables (performed always!)
                !(this place for DUZ/DVZ)

                    if ((ExcessDUVZ_Son /= 0.0) .or. (ExcessValue_Father /= 0.0)) then

do23:                   do k = KUB, KLB, -1 !!!!do16?

                            if (Me%SubModel%DeadZone) then

                                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                            else

                                DeadZoneSon = .false.

                            endif

cd18:                       if (Faces3D_VSon(i, j, k) == Covered  .and. .not. DeadZoneSon) then

                                if ((((Me%CurrentTime == Me%SubModel%GetFatherTime) &
                                    .and. Me%SubModel%InterPolTime) .or.            &
                                    (.not. Me%SubModel%InterPolTime)                &
                                    .or. InitialField) .and. (.not. NullValue)) then
                                    !Check if layer values from father need to be corrected
                                    !(capitalizing on the DO cycle)

                                    if (ExcessDUVZ_Son /= 0.0) then
                                        !Correct son layer values for the deficit of father values

                                        SumDUVZ_Son = SumDUVZ_Son + DVZ_Son(i, j, k)

                                        if (SumDUVZ_Son .le. TotalDUVZ_Son) then
                                            !layers having father value
                            
                                            AuxDeficit = Me%SubModel%DVZ_Next(i,j,k)* &
                                                ExcessDUVZ_Son*DVZ_Son(i, j, k)     &
                                                /TotalDUVZ_Son

                                            !actualize the value of the father deficit
                                            DeficitValue_Father = DeficitValue_Father + &
                                                AuxDeficit

                                            !remove flux variable from layer
                                            Me%SubModel%DVZ_Next(i,j,k) =           &
                                                            Me%SubModel%DVZ_Next(i,j,k) &
                                                            - AuxDeficit

                                        elseif (AuxDUVZ_Son /= 0.0) then
                                            !son layer partially with father value
                                            AuxDeficit = Me%SubModel%DVZ_Next(i,j,k)* &
                                                ExcessDUVZ_Son*(DVZ_Son(i, j, k)    &
                                                - AuxDUVZ_Son)/TotalDUVZ_Son 

                                            !actualize the value of the father deficit
                                            DeficitValue_Father = DeficitValue_Father + &
                                                AuxDeficit

                                            !remove and add
                                            Me%SubModel%DVZ_Next(i,j,k) =           &
                                                Me%SubModel%DVZ_Next(i,j,k) - AuxDeficit + &
                                                DeficitValue_Father*AuxDUVZ_Son/    &
                                                (WaterColumnV(i, j) - TotalDUVZ_Son)

                                            AuxDUVZ_Son = 0.0
                                            !(layer completed)

                                        else
                                            !fill son layer without father value
                            
                                            !add collected value
                                            Me%SubModel%DVZ_Next(i,j,k) =           &
                                                DeficitValue_Father*                &
                                                DVZ_Son(i,j,k)                      &
                                                /(WaterColumnV(i, j) - TotalDUVZ_Son)

                                        endif

                                    elseif (ExcessValue_Father /= 0.0) then
                                        !Correct son layer values for the excess of father values

                                        Me%SubModel%DVZ_Next(i,j,k) =               &
                                            Me%SubModel%DVZ_Next(i,j,k) +           &
                                            ExcessValue_Father*DVZ_Son(i, j, k)/    &
                                            WaterColumnV(i, j)

                                    endif

                                    if (InitialField) then

                                        Me%SubModel%DVZ_Previous(i,j,k) =           &
                                            Me%SubModel%DVZ_Next(i,j,k)  

                                    endif

                                endif

                                if (Me%SubModel%DVZ_Next    (i, j, k) < FillValueReal / 2. &
                                    .or. Me%SubModel%DVZ_Previous(i, j, k) < FillValueReal &
                                    / 2.) then

                                    if (Me%SubModel%MissingNull) then 
                            
                                        Me%SubModel%DVZ_New(i, j, k)  =  0.

                                    else
                                        call SetError(FATAL_, INTERNAL_,            &
                                             "ActualizeSon3DWithFather3D; Hydrodynamic. ERR24") 
                                    endif

                                else

                                    Me%SubModel%DVZ_New(i, j, k)  =                 &
                                             Me%SubModel%DVZ_Next    (i, j, k) *    &
                                             TimeCoef +                             &
                                             Me%SubModel%DVZ_Previous(i, j, k) *    &
                                             (1 - TimeCoef)

                                endif

                            endif cd18

                            if (k == Kbottom) exit do23

                        enddo do23

                    endif

                endif

            enddo
            enddo
            
        endif cd16

        do j = JLB, JUB
        do i = ILB, IUB + 1

            if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.                &
                Me%SubModel%InterPolTime) .or. (.not. Me%SubModel%InterPolTime)     &
                .or. InitialField) then
                !Time to interpolate vertical layers father to son!

                !V_Next calculation variables
                AuxSonDepth = 0.0

                !DVZ_Next calculation variables
                !look father layer beginning at the topest layer
                kfatherinic = KUBFather  
                RelativeThickness = 1.0

                TotalDUVZ_Son = 0.0
                ExcessDUVZ_Son = 0.0

                SumDUVZ_Son = 0.0
                DeficitValue_Father = 0.0

            endif

do16:       do k = KUB, KLB, -1 !!!!do17?

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                else

                    DeadZoneSon = .false.

                endif
            
cd19:           if ((ImposedTangFacesVSon(i, j, k) == Imposed  .or.                 &
                 ImposedNormFacesVSon(i, j, k) == Imposed)  .and.                   &
                 .not. DeadZoneSon) then
                
                    if (ImposedTangFacesVSon(i, j, k) == Imposed) then

                        i_thick = i
                        j_thick = j

                    else if (ImposedNormFacesVSon(i, j, k) == Imposed) then

                        if      (i == IUB + 1) then

                            i_thick = i - 1

                        else if (i == ILB) then

                            i_thick = i + 1

                        else

                            i_thick = i + Faces3D_VSon(i + 1, j, k) -               &
                                        Faces3D_VSon(i - 1, j, k)

                        endif

                        j_thick = j 

                    endif

                    if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.        &
                        Me%SubModel%InterPolTime) .or.                              &
                        (.not. Me%SubModel%InterPolTime) .or. InitialField) then
                        !Time to interpolate vertical layers father to son!
                    
                        NullValue = .false.

                        !find the first father layer for interpolation
                        Aux = KLBFather
                        AuxDepth = 0.0

                        do kfather=KUBFather, KLBFather, -1
                            if ((Me%SubModel%Aux_V(i, j, kfather)                   & 
                                < FillValueReal / 2.) .or.                          &
                                (Me%SubModel%Aux_DVZ(i, j, kfather)                 & 
                                < FillValueReal / 2.)) then
                                Aux = kfather + 1
                               exit
                            else
                                Values(kfather) = Me%SubModel%Aux_V(i,j,kfather)
                                Depths(kfather) = AuxDepth +                        &
                                    Me%SubModel%Aux_DVZ(i, j, kfather)/2
                                AuxDepth = AuxDepth +                               &
                                    Me%SubModel%Aux_DVZ(i, j, kfather)
                                !(value (i,j) from father exists!)
                            endif
                        enddo

                        if (Aux == KUBFather + 1) then
                        
                            if (Me%SubModel%MissingNull) then 
                                NullValue = .true.
                            else
                                call SetError(FATAL_, INTERNAL_,                    &
                                    "ActualizeSon3DWithFather3D; Hydrodynamic. ERR25") 
                            endif
                        endif
                
                        if (.not. NullValue) then
                        !(father values exist for at least one layer)

                            !get number of father depths
                            NDepths = KUBFather - Aux + 1

                            !Time to interpolate vertical layers father to son!
                            !(get U_Next from father)

                            !get son cell depth
                            SonDepth = AuxSonDepth + DVZ_Son(i_thick, j_thick, k)/2
                            AuxSonDepth = AuxSonDepth + DVZ_Son(i_thick, j_thick, k)

                            !interpolate father values as a profile
                            Me%SubModel%V_Next(i,j,k) =                             &
                                            InterpolateProfileR8(SonDepth,          &
                                            NDepths, Depths(Aux:KUBFather),         &
                                            Values(Aux:KUBFather),                  &
                                            FoundBottom, FoundSurface)
                    
                            if (InitialField)                                       &
                                Me%SubModel%V_Previous(i,j,k) =                     &
                                    Me%SubModel%V_Next(i,j,k)

                            if (.not. Me%SubModel%MomentConserv) then

                                Me%SubModel%DVZ_Next(i, j, k) = DVZ_Son(i_thick,    &
                                                                j_thick, k)
                                !(has to be i_thick and j_thick because i, j dont exist)

                            else

                                !Time to interpolate vertical layers father to son!
                                !(get DUZ/DVZ from father)
                                !initialize variable
                                Me%SubModel%DVZ_Next(i, j, k) = 0

                                !DVZ is need for weighting
                                AuxDUVZ_Son = DVZ_Son(i_thick, j_thick, k)

    do17:                       do kfather = kfatherinic, KLBFather, -1 !!!! do18?                             
                                    !(layers from surface to bottom)

                                    if (Me%SubModel%Aux_DVZ(i, j, kfather)          & 
                                        < FillValueReal / 2.) then
                                        !if father values do not exist

                                        if (Me%SubModel%MissingNull)                &
                                            !son layers assumed null values
                                            exit do17

                                    endif

                                    AuxDUVZ_Father =                                &
                                        Me%SubModel%Aux_DVZ(i, j, kfather)
                                    !(since not exited from loop (i,j) value exists!)

                                    if (AuxDUVZ_Son .le.                            &
                                        RelativeThickness*AuxDUVZ_Father) then

                                        !son layer inside father layer part
                                        RelativeThickness = AuxDUVZ_Son*            &
                                            RelativeThickness / AuxDUVZ_Father

                                        Me%SubModel%DVZ_Next(i, j, k) =             &
                                            Me%SubModel%DVZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DVZ(i, j, kfather)      &
                                            * RelativeThickness

                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            AuxDUVZ_Son
                    
                                        if (Abs(AuxDUVZ_Son - AuxDUVZ_Father) .lt.  &
                                            AllmostZero) then
                                            !(AuxDUVZ_Son == AuxDUVZ_Father)

                                            !this father layer is already solved, solve next
                                            kfatherinic = kfatherinic -1
                                            RelativeThickness = 1
                                        else

                                            RelativeThickness = 1 - RelativeThickness
                                        endif

                                        AuxDUVZ_Son = 0.0

                                        exit do17
                                    else

                                        !son layer includes father layer part
                                        Me%SubModel%DVZ_Next(i, j, k) =             &
                                            Me%SubModel%DVZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DVZ(i, j, kfather)      &
                                            * RelativeThickness
                            
                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            RelativeThickness*AuxDUVZ_Father

                                        !get the remaing part of DVZ_Son
                                        AuxDUVZ_Son = AuxDUVZ_Son -                 &
                                            RelativeThickness*AuxDUVZ_Father

                                        !seek in the next father layer
                                        kfatherinic = kfatherinic - 1
                                        RelativeThickness = 1
                                    endif
                                enddo do17

                                !check if excess or deficit flux variable exists
                                if ((AuxDUVZ_Son /= 0.0) .and.                      &
                                    (kfather == KLBFather)) then 
                                    !last son layer was not fulfilled by father values
                                    !(all the next son layers are not fulfilled also)

                                    ExcessDUVZ_Son = AuxDUVZ_Son

                                    if (k-1 .ge. KLB) then
                                        !add DVZ of next son layers

                                        do k2 = k-1, KLB, -1
                                            !layers from surface to bottom

                                            ExcessDUVZ_Son = ExcessDUVZ_Son +       &
                                                DVZ_Son(i_thick, j_thick, k2)
                                        enddo
                                    endif
                                else if ((k == Kbottom) .and.                       &
                                    ((RelativeThickness /= 1) .or.                  &
                                    (kfather /= KLBFather))) then
                                    !all son layers are fulfilled with father values
                                    !but excedent father layer part exist
                        
                                    if (RelativeThickness /= 1)                     &
                                        ExcessValue_Father =                        &
                                                Me%SubModel%Aux_DVZ(i, j, kfather)* &
                                                RelativeThickness

                                    if (kfather - 1 .ge. KLBFather) then
                                        !add values of next father layers

    do18:                               do k2father = kfather - 1, KLBFather, - 1 !do19
                                            !layers from surface to bottom
                        
                                            if (Me%SubModel%Aux_DVZ(i, j,k2father)  & 
                                                < FillValueReal / 2.) then

                                                exit do18
                                            else

                                                ExcessValue_Father =                &
                                                ExcessValue_Father                  &
                                                + Me%SubModel%Aux_DVZ(i, j, k2father)
                                            endif
                                        enddo do18
                                    endif
                                endif
                            endif

                            if (InitialField) then

                                Me%SubModel%DVZ_Previous(i,j,k) =                   &
                                    Me%SubModel%DVZ_Next(i,j,k)  
                            endif
                        endif
                    endif 

                    Kbottom = KFloor_V(i_thick, j_thick)

                    !Time interpolation of variables (performed always!)
                    !(here just for velocity)
                    if (Me%SubModel%V_Next    (i, j, k) < FillValueReal / 2. .or.   &
                        Me%SubModel%V_Previous(i, j, k) < FillValueReal / 2.)  then

                        if (Me%SubModel%MissingNull) then 
                            
                            Me%SubModel%V_New(i, j, k)  =  0.

                        else
                            call SetError(FATAL_, INTERNAL_,                        &
                                 "ActualizeSon3DWithFather3D; Hydrodynamic. ERR26")
                        endif
                    else

                        Me%SubModel%V_New(i, j, k)  =                               &
                            Me%SubModel%V_Next    (i, j, k) * TimeCoef  +           &
                            Me%SubModel%V_Previous(i, j, k) * (1 - TimeCoef)
                    endif

                    if (InitialField .and. .not. Me%ComputeOptions%Continuous       &
                        .and. Me%SubModel%FatherHotStart)                           &
                        Me%Velocity%Horizontal%V%New(i, j, k) =                     &
                                   Me%SubModel%V_New(i, j, k)

                    !(for DVZ)
                    if (Me%SubModel%DVZ_Next    (i, j, k) < FillValueReal / 2.      &
                        .or. Me%SubModel%DVZ_Previous(i, j, k) < FillValueReal      &
                        / 2.) then

                        if (Me%SubModel%MissingNull) then 
                            
                            Me%SubModel%DVZ_New(i, j, k)  =  0.
                        else
                            call SetError(FATAL_, INTERNAL_,                        &
                                 "ActualizeSon3DWithFather3D; Hydrodynamic. ERR27") 
                        endif
                    else

                        Me%SubModel%DVZ_New(i, j, k)  =                             &
                                 Me%SubModel%DVZ_Next    (i, j, k) *                &
                                 TimeCoef +                                         &
                                 Me%SubModel%DVZ_Previous(i, j, k) *                &
                                 (1 - TimeCoef)
                    endif
                endif cd19

                if (k == Kbottom) exit do16
            enddo do16

            if (Me%SubModel%MomentConserv) then

                if ((ExcessDUVZ_Son /= 0.0) .or. (ExcessValue_Father /= 0.0)) then

do24:               do k = KUB, KLB, -1 

                        if (Me%SubModel%DeadZone) then

                            DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                        else

                            DeadZoneSon = .false.

                        endif
            
cd20:                   if ((ImposedTangFacesVSon(i, j, k) == Imposed  .or.         &
                         ImposedNormFacesVSon(i, j, k) == Imposed)  .and.           &
                         .not. DeadZoneSon) then
                
                            if (ImposedTangFacesVSon(i, j, k) == Imposed) then

                                i_thick = i
                                j_thick = j

                            else if (ImposedNormFacesVSon(i, j, k) == Imposed) then

                                if      (i == IUB + 1) then

                                    i_thick = i - 1

                                else if (i == ILB) then

                                    i_thick = i + 1

                                else

                                    i_thick = i + Faces3D_VSon(i + 1, j, k) -       &
                                              Faces3D_VSon(i - 1, j, k)

                                endif

                                j_thick = j 

                            endif

                            Kbottom = KFloor_V(i_thick, j_thick)

                            if ((((Me%CurrentTime == Me%SubModel%GetFatherTime)     &
                                .and. Me%SubModel%InterPolTime) .or.                &
                                (.not. Me%SubModel%InterPolTime) .or. InitialField) &
                                .and. (.not. NullValue)) then
                                !Check if layer values from father need to be corrected
                                !(capitalizing on the DO cycle)

                                if (ExcessDUVZ_Son /= 0.0) then
                                    !Correct son layer values for the deficit of father values

                                    SumDUVZ_Son = SumDUVZ_Son + DVZ_Son(i_thick, j_thick, k)

                                    if (SumDUVZ_Son .le. TotalDUVZ_Son) then
                                        !layers having father value
                            
                                        AuxDeficit = Me%SubModel%DVZ_Next(i,j,k)*   &
                                            ExcessDUVZ_Son*DVZ_Son(i_thick, j_thick, k) &
                                            /TotalDUVZ_Son

                                        !actualize the value of the father deficit
                                        DeficitValue_Father = DeficitValue_Father + &
                                            AuxDeficit

                                        !remove flux variable from layer
                                        Me%SubModel%DVZ_Next(i,j,k) =               &
                                                        Me%SubModel%DVZ_Next(i,j,k) &
                                                        - AuxDeficit

                                    elseif (AuxDUVZ_Son /= 0.0) then
                                        !son layer partially with father value
                                        AuxDeficit = Me%SubModel%DVZ_Next(i,j,k)*   &
                                            ExcessDUVZ_Son*(DVZ_Son(i_thick, j_thick, k) &
                                            - AuxDUVZ_Son)/TotalDUVZ_Son 

                                        !actualize the value of the father deficit
                                        DeficitValue_Father = DeficitValue_Father + &
                                            AuxDeficit

                                        !remove and add
                                        Me%SubModel%DVZ_Next(i,j,k) =               &
                                            Me%SubModel%DVZ_Next(i,j,k) - AuxDeficit + &
                                            DeficitValue_Father*AuxDUVZ_Son/        &
                                            (WaterColumnV(i_thick, j_thick) - TotalDUVZ_Son)

                                        AuxDUVZ_Son = 0.0
                                        !(layer completed)

                                    else
                                        !fill son layer without father value
                            
                                        !add collected value
                                        Me%SubModel%DVZ_Next(i,j,k) =               &
                                            DeficitValue_Father*                    &
                                            DVZ_Son(i_thick, j_thick,k)             &
                                            /(WaterColumnV(i_thick, j_thick) - TotalDUVZ_Son)

                                    endif

                                elseif (ExcessValue_Father /= 0.0) then
                                    !Correct son layer values for the excess of father values

                                    Me%SubModel%DVZ_Next(i,j,k) =                   &
                                        Me%SubModel%DVZ_Next(i,j,k) +               &
                                        ExcessValue_Father*DVZ_Son(i_thick, j_thick,k)/ &
                                        WaterColumnV(i_thick, j_thick)

                                endif

                                if (InitialField) then

                                    Me%SubModel%DVZ_Previous(i,j,k) =               &
                                        Me%SubModel%DVZ_Next(i,j,k)  

                                endif

                            endif

                            !Time interpolation of variables (performed always!)
                            !(here just for DUZ/DVZ)

                            if (Me%SubModel%DVZ_Next    (i, j, k) < FillValueReal / 2. &
                                .or. Me%SubModel%DVZ_Previous(i, j, k) < FillValueReal &
                                / 2.) then

                                if (Me%SubModel%MissingNull) then 
                            
                                    Me%SubModel%DVZ_New(i, j, k)  =  0.

                                else
                                    call SetError(FATAL_, INTERNAL_,                &
                                         "ActualizeSon3DWithFather3D; Hydrodynamic. ERR28") 
                                endif

                            else

                                Me%SubModel%DVZ_New(i, j, k)  =                     &
                                         Me%SubModel%DVZ_Next    (i, j, k) *        &
                                         TimeCoef +                                 &
                                         Me%SubModel%DVZ_Previous(i, j, k) *        &
                                         (1 - TimeCoef)

                            endif

                        endif cd20

                        if (k == Kbottom) exit do24

                    enddo do24

                endif

            endif

        enddo
        enddo

        !This is only done for graphical reasons
        if (InitialField .and. .not. Me%ComputeOptions%Continuous) then

            !U corners            
            Me%Velocity%Horizontal%U%New(ILB,JLB    , KLB:KUB)   =                  &
            Me%SubModel%U_New           (ILB,JLB    , KLB:KUB)

            Me%Velocity%Horizontal%U%New(ILB,JUB + 1, KLB:KUB)   =                  &
            Me%SubModel%U_New           (ILB,JUB + 1, KLB:KUB)

            Me%Velocity%Horizontal%U%New(IUB,JLB    , KLB:KUB)   =                  &
            Me%SubModel%U_New           (IUB,JLB    , KLB:KUB)

            Me%Velocity%Horizontal%U%New(IUB,JUB + 1, KLB:KUB)   =                  &
            Me%SubModel%U_New           (IUB,JUB + 1, KLB:KUB)

            
            !V corners
            Me%Velocity%Horizontal%V%New(ILB,JLB    , KLB:KUB)   =                  &
            Me%SubModel%V_New           (ILB,JLB    , KLB:KUB)

            Me%Velocity%Horizontal%V%New(ILB,JUB    , KLB:KUB)   =                  &
            Me%SubModel%V_New           (ILB,JUB    , KLB:KUB)

            Me%Velocity%Horizontal%V%New(IUB + 1,JLB, KLB:KUB)   =                  &
            Me%SubModel%V_New           (IUB + 1,JLB, KLB:KUB)

            Me%Velocity%Horizontal%V%New(IUB + 1,JUB, KLB:KUB)   =                  &
            Me%SubModel%V_New           (IUB + 1,JUB, KLB:KUB)

        endif

        Me%SubModel%Set      = .true.

        !UnGet son information 
        call ReadUnLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,              &
                           ImposedNormFacesUSon, ImposedNormFacesVSon,              &
                           Water3DSon, Boundary2DSon,                               &
                           Faces3D_USon, Faces3D_VSon,                              &
                           DUZ_Son, DVZ_Son,                                        &
                           DXX_Son, DYY_Son)

cd21:   if (InitialField .and. .not. Me%ComputeOptions%Continuous) then

            call SetMatrixValue(Me%WaterLevel%Old, Me%Size2D, Me%WaterLevel%New)
            call SetMatrixValue(Me%Velocity%Horizontal%V%Old, Me%Size,              &
                                 Me%Velocity%Horizontal%V%New)
            call SetMatrixValue(Me%Velocity%Horizontal%U%Old, Me%Size,              &
                                 Me%Velocity%Horizontal%U%New)
            call SetMatrixValue(Me%SubModel%DUZ_Old, Me%Size, Me%SubModel%DUZ_Next)
            call SetMatrixValue(Me%SubModel%DVZ_Old, Me%Size, Me%SubModel%DVZ_Next)

            !Me%WaterLevel%Old               (:,:  ) =                               &
                !Me%WaterLevel%New           (:,:  )

            !Me%Velocity%Horizontal%V%Old    (:,:,:) =                               &
                !Me%Velocity%Horizontal%V%New(:,:,:)

            !Me%Velocity%Horizontal%U%Old    (:,:,:) =                               &
                !Me%Velocity%Horizontal%U%New(:,:,:)

            !Me%SubModel%DUZ_Old(:,:,:)              =                               &
                !Me%SubModel%DUZ_Next(:,:,:)

            !Me%SubModel%DVZ_Old(:,:,:)              =                               &
                !Me%SubModel%DVZ_Next(:,:,:)

        endif cd21


        call UnGetGeometry(Me%ObjGeometry,                                          &
                           WaterColumnU, STAT = status)

        if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_,                    &
                                    "ActualizeSon3DWithFather3D; Hydrodynamic. ERR29") 


        call UnGetGeometry(Me%ObjGeometry,                                          &
                           WaterColumnV, STAT = status)

        if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR30") 


        call UnGetGeometry(Me%ObjGeometry,                                          &
                           KFloor_U, STAT = status)

        if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR31") 


        call UnGetGeometry(Me%ObjGeometry,                                          &
                           KFloor_V, STAT = status)

        if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR32") 

        !UnGets Bathymetry
        call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR33") 

        !Deallocates values and depths used to interpolate velocities
        if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.                    &
            Me%SubModel%InterPolTime) .or. (.not. Me%SubModel%InterPolTime)         &
            .or. InitialField) then

            deallocate(Depths)
            deallocate(Values)

            if (Me%SubModel%InterPolTime .and. .not. InitialField) then

                call null_Time(Me%CurrentTime)

            endif

        endif

    end subroutine ActualizeSon3DWithFather3D

    !--------------------------------------------------------------------------

    subroutine RemoveLowerSpikes (Values2D, WaterPoints, Bathymetry, MinWaterColumn,   &
                                  DeadZonePoints, DeadZoneON, ILB, IUB, JLB, JUB, KUB, &
                                  BoundaryPoints) 

    !Arguments-----------------------------------------------------------------
    real,    dimension(:,:  ), pointer            :: Values2D, Bathymetry
    integer, dimension(:,:,:), pointer            :: WaterPoints
    logical, dimension(:,:,:), pointer            :: DeadZonePoints
    integer, dimension(:,:  ), pointer, optional  :: BoundaryPoints
    real                                          :: MinWaterColumn
    integer                                       :: ILB, IUB, JLB, JUB, KUB
    logical                                       :: DeadZoneON
    !Local---------------------------------------------------------------------
    integer                                       :: i, j, Counter, ComputePoint
    real                                          :: Average, Deviation, Dif
    logical                                       :: BoundaryON
    integer                                       :: CHUNK
    
    !Begin---------------------------------------------------------------------

        if (present(BoundaryPoints)) then
            BoundaryON = .true.
        else
            BoundaryON = .false.
        endif

        Average   = 0.
        Deviation = 0.
        Counter   = 0
        
        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "RemoveLowerSpikes")
        
        !ACanas(2010): Parallelization of next two cycles removed as REDUCTION clause
        !ACanas(2010): causes rounding errors which cannot certified.
        
        ! !! $OMP PARALLEL SHARED(Average,Counter) PRIVATE(i,j,ComputePoint)
        !Compute Averages
        ! !! $OMP DO SCHEDULE(DYNAMIC, CHUNK) REDUCTION(+ : Average,Counter)
        do j= JLB, JUB
        do i= ILB, IUB

            ComputePoint = WaterPoints(i,j,KUB)
            if (BoundaryON) ComputePoint = ComputePoint * BoundaryPoints(i, j)
            if (DeadZoneON) then
                if (DeadZonePoints(i, j, KUB)) ComputePoint = 0
            endif
            !The uncovered points are not use to compute the average and the standard deviation
            if (Values2D(i, j) < -Bathymetry(i,j) + MinWaterColumn) &
                ComputePoint = 0

            if (ComputePoint == 1) then
                Counter = Counter + 1
                Average = Average + Values2D(i, j)

            endif

        enddo
        enddo
        ! !! $OMP END DO
        ! !! $OMP END PARALLEL

        Average = Average / real (Counter)

        ! !! $OMP PARALLEL SHARED(Deviation) PRIVATE(i,j,ComputePoint)
        !Standard Deviation
        ! !! $OMP DO SCHEDULE(DYNAMIC, CHUNK) REDUCTION(+ : Deviation)
        do j= JLB, JUB
        do i= ILB, IUB

            ComputePoint = WaterPoints(i,j,KUB)
            if (BoundaryON) ComputePoint = ComputePoint * BoundaryPoints(i, j)
            if (DeadZoneON) then
                if (DeadZonePoints(i, j, KUB)) ComputePoint = 0
            endif

            !The uncovered points are not use to compute the average and the standard deviation
            if (Values2D(i, j) < -Bathymetry(i,j) + MinWaterColumn) &
                ComputePoint = 0

            if (ComputePoint == 1) then
           
                Deviation = Deviation + abs(Values2D(i, j) - Average)

            endif

        enddo
        enddo
        ! !! $OMP END DO
        ! !! $OMP END PARALLEL
        
        Deviation = Deviation / real (Counter)

        !$OMP PARALLEL PRIVATE(i,j,ComputePoint,Dif)
        !Remove lower Spikes
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do j= JLB, JUB
        do i= ILB, IUB

            ComputePoint = WaterPoints(i,j,KUB)
            if (BoundaryON) ComputePoint = ComputePoint * BoundaryPoints(i, j)
            if (DeadZoneON) then
                if (DeadZonePoints(i, j, KUB)) ComputePoint = 0
            endif

            if (ComputePoint == 1) then

                Dif = Values2D(i, j) - Average

                if (Dif < 0 .and. abs(Dif) > 100. * Deviation) Values2D(i, j) = Average

            endif

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "RemoveLowerSpikes")

    end subroutine RemoveLowerSpikes

    !--------------------------------------------------------------------------

    subroutine ReadNextOrInitialField (UFather, VFather, DUZFather, DVZFather,           &
                                       FluxXFather, FluxYFather, ZFather, Open3DFather,  &
                                       Faces3D_UFather, Faces3D_VFather,                 &
                                       WetFaces_UFather, WetFaces_VFather, InitialField, &
                                       FatherHorizontalGrid)

        !Arguments-------------------------------------------------------------
        real,    dimension(:,:,:), pointer          :: UFather, VFather, DUZFather, DVZFather
        real(8), dimension(:,:,:), pointer          :: FluxXFather, FluxYFather
        real,    dimension(:,:  ), pointer          :: ZFather
        integer, dimension(:,:,:), pointer          :: Open3DFather
        integer, dimension(:,:,:), pointer          :: Open3DSon, Compute3DUSon, Compute3DVSon
        integer, dimension(:,:,:), pointer          :: Faces3D_UFather    
        integer, dimension(:,:,:), pointer          :: Faces3D_VFather      
        integer, dimension(:,:,:), pointer          :: WetFaces_UFather    
        integer, dimension(:,:,:), pointer          :: WetFaces_VFather  
        logical,           intent(IN )              :: InitialField
        integer                                     :: FatherHorizontalGrid

        !Local-----------------------------------------------------------------
        integer, dimension(:,:,:), pointer          :: Null_Mapping
        integer                                     :: ComputeZ, ComputeU, ComputeV
        integer                                     :: status
        integer                                     :: ILBSon, IUBSon, JLBSon, JUBSon, KLBSon, KUBSon
        integer                                     :: KLBFather, KUBFather
        
        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ReadNextOrInitialField")

        KUBSon    = Me%WorkSize%KUB
        KLBSon    = Me%WorkSize%KLB

        !Ang: new implementation father-son 3D connection
        KUBFather = Me%SubModel%FatherKUB
        KLBFather = Me%SubModel%FatherKLB
        
        ILBson    = Me%WorkSize%ILB
        IUBson    = Me%WorkSize%IUB
        JLBson    = Me%WorkSize%JLB
        JUBson    = Me%WorkSize%JUB
        
        nullify(Null_Mapping)

        call GetComputeZUV(Me%ObjHorizontalGrid, ComputeZ, ComputeU, ComputeV, STAT = status)
        if (status /= SUCCESS_)                                                     &
            call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR10") 

cd1:    if (Me%SubModel%InterPolTime .and. .not. InitialField) then

            call SetMatrixValue(Me%SubModel%Z_Previous, Me%Size2D, Me%SubModel%Z_Next)
            call SetMatrixValue(Me%SubModel%U_Previous, Me%Size, Me%SubModel%U_Next)
            call SetMatrixValue(Me%SubModel%V_Previous, Me%Size, Me%SubModel%V_Next)
            call SetMatrixValue(Me%SubModel%DUZ_Previous, Me%Size, Me%SubModel%DUZ_Next)
            call SetMatrixValue(Me%SubModel%DVZ_Previous, Me%Size, Me%SubModel%DVZ_Next)

            !Me%SubModel%Z_Previous  (:,:  ) = Me%SubModel%Z_Next  (:,:)
            !Me%SubModel%U_Previous  (:,:,:) = Me%SubModel%U_Next  (:,:,:)
            !Me%SubModel%V_Previous  (:,:,:) = Me%SubModel%V_Next  (:,:,:)
            !Me%SubModel%DUZ_Previous(:,:,:) = Me%SubModel%DUZ_Next(:,:,:)
            !Me%SubModel%DVZ_Previous(:,:,:) = Me%SubModel%DVZ_Next(:,:,:)

        endif cd1
        
        call InterpolRegularGrid   (Me%ObjHorizontalGrid,                           &
                                    FatherHorizontalGrid,                           &
                                    ZFather, Me%SubModel%Z_Next,                    &
                                    ComputeFather = Open3DFather,                   &
                                    Compute       = ComputeZ,                       &
                                    KUBFather     = KUBFather,                      &
                                    STAT          = status)

        if (status /= SUCCESS_)                                                     &
            call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR40") 
            
        if (Me%SubModel%Extrapolate) then
           
            call GetOpenPoints3D(Me%ObjMap, Open3DSon, STAT = status)
            if (status /= SUCCESS_) stop "ReadNextOrInitialField - Hydrodynamic - ERR30"

            call ExtraPol2DNearestCell (ILBson, IUBson, JLBson, JUBson, KUBson, Open3DSon, Me%SubModel%Z_Next)

            call UnGetMap(Me%ObjMap, Open3DSon, STAT = status)
            if (status /= SUCCESS_) stop "ReadNextOrInitialField - Hydrodynamic - ERR320"

        endif
            
        if (InitialField  .and. .not. Me%ComputeOptions%Continuous)                 &
            call Initial_Geometry(Me%SubModel%Z_Next)

            !The geometry is construct using the filed interpolated from the Father Water Level
            !The Mapping is also actualized by this subroutine
            
        if (Me%SubModel%Extrapolate) then
        
            call GetComputeFaces3D(Me%ObjMap, ComputeFacesU3D = Compute3DUSon, ComputeFacesV3D = Compute3DVSon, STAT = status)
            if (status /= SUCCESS_) stop "ReadNextOrInitialField - Hydrodynamic - ERR20"
           
        endif                  
        
        !Ang: new implementation
        if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.                       &
            (Me%SubModel%VertComunic == Father3DSon2D)) then

cd2:        if (InitialField) then  !.and. .not. Me%ComputeOptions%Continuous) then

                !Father values stored in aux variables with same vertical grid
                !(but horizontal grid as son's)
                call InterpolRegularGrid   (Me%ObjHorizontalGrid,                   &
                                            FatherHorizontalGrid,                   &
                                            FluxXFather, Me%SubModel%Aux_qX,        &
                                            WetFaces_UFather, ComputeU,             &
                                            KLBFather, KUBFather, KUBSon,           &
                                            FluxType = .true., STAT = status)
                if (status /= SUCCESS_)                                             &
                    call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR50") 
                    

                call InterpolRegularGrid   (Me%ObjHorizontalGrid,                   &
                                            FatherHorizontalGrid,                   &
                                            FluxYFather, Me%SubModel%Aux_qY,        &
                                            WetFaces_VFather, ComputeV,             &
                                            KLBFather, KUBFather, KUBSon,           &
                                            FluxType = .true., STAT = status)

                if (status /= SUCCESS_)                                             &
                    call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR60") 
                    
                if (Me%SubModel%Extrapolate) then
                
                    call ExtraPol3DNearestCell_8(ILBson, IUBson, JLBson, JUBson + 1,     &
                                                KLBFather, KUBFather, Null_Mapping, Me%SubModel%Aux_qX)

                    call ExtraPol3DNearestCell_8(ILBson, IUBson + 1 , JLBson, JUBson,    & 
                                                KLBFather, KUBFather, Null_Mapping, Me%SubModel%Aux_qY)
                               
                endif
                                

            endif cd2

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                    FatherHorizontalGrid,                           &
                                    UFather, Me%SubModel%Aux_U,                     &
                                    WetFaces_UFather, ComputeU,                     &
                                    KLBFather, KUBFather, KUBSon,                   &
                                    STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR70") 
                

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                    FatherHorizontalGrid,                           &
                                    DUZFather, Me%SubModel%Aux_DUZ,                 &
                                    Faces3D_UFather, ComputeU,                      &
                                    KLBFather, KUBFather, KUBSon,                   &
                                    STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR06") 

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                    FatherHorizontalGrid,                           &
                                    VFather, Me%SubModel%Aux_V,                     &
                                    WetFaces_VFather, ComputeV,                     &
                                    KLBFather, KUBFather, KUBSon,                   &
                                    STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR07") 
                
             

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                    FatherHorizontalGrid,                           &
                                    DVZFather, Me%SubModel%Aux_DVZ,                 &   
                                    Faces3D_VFather, ComputeV,                      &
                                    KLBFather, KUBFather, KUBSon,                   &
                                    STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR08") 
                
            if (Me%SubModel%Extrapolate) then
            
                call ExtraPol3DNearestCell(ILBson, IUBson, JLBson, JUBson + 1,     &
                                            KLBFather, KUBFather, Null_Mapping, Me%SubModel%Aux_U)

                call ExtraPol3DNearestCell(ILBson, IUBson + 1 , JLBson, JUBson,    & 
                                            KLBFather, KUBFather, Null_Mapping, Me%SubModel%Aux_V)

                call ExtraPol3DNearestCell(ILBson, IUBson, JLBson, JUBson + 1,     &
                                            KLBFather, KUBFather, Null_Mapping, Me%SubModel%Aux_DUZ)

                call ExtraPol3DNearestCell(ILBson, IUBson + 1 , JLBson, JUBson,    & 
                                            KLBFather, KUBFather, Null_Mapping, Me%SubModel%Aux_DVZ)
                           
            endif
                                          

       else

cd3:        if (InitialField .and. .not. Me%SubModel%HotStartData) then  !.and. .not. Me%ComputeOptions%Continuous) then

                call InterpolRegularGrid   (Me%ObjHorizontalGrid,                   &
                                            FatherHorizontalGrid,                   &
                                            FluxXFather, Me%SubModel%qX,            &
                                            WetFaces_UFather, ComputeU,             &
                                            KLBFather, KUBFather, KUBSon,           &
                                            FluxType = .true., STAT = status)
                if (status /= SUCCESS_)                                             &
                    call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR09") 


                call InterpolRegularGrid   (Me%ObjHorizontalGrid,                   &
                                            FatherHorizontalGrid,                   &
                                            FluxYFather, Me%SubModel%qY,            &
                                            WetFaces_VFather, ComputeV,             &
                                            KLBFather, KUBFather, KUBSon,           &
                                            FluxType = .true., STAT = status)

                if (status /= SUCCESS_)                                             &
                    call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR10") 
           
            endif cd3

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                        FatherHorizontalGrid,                       &
                                        UFather, Me%SubModel%U_Next,                &
                                        WetFaces_UFather, ComputeU,                 &
                                        KLBFather, KUBFather, KUBSon,               &
                                        STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR11") 

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                        FatherHorizontalGrid,                       &
                                        DUZFather, Me%SubModel%DUZ_Next,            &
                                        Faces3D_UFather, ComputeU,                  &
                                        KLBFather, KUBFather, KUBSon,               &
                                        STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR12") 

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                        FatherHorizontalGrid,                       &
                                        VFather, Me%SubModel%V_Next,                &
                                        WetFaces_VFather, ComputeV,                 &
                                        KLBFather, KUBFather, KUBSon,               &
                                        STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR13") 

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                        FatherHorizontalGrid,                       &
                                        DVZFather, Me%SubModel%DVZ_Next,            &   
                                        Faces3D_VFather, ComputeV,                  &
                                        KLBFather, KUBFather, KUBSon,               &
                                        STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR14") 

            if (Me%SubModel%Extrapolate) then

                call ExtraPol3DNearestCell_8(ILBson, IUBson, JLBson, JUBson + 1,     &
                                            KLBson, KUBson, Compute3DUSon, Me%SubModel%qX)

                call ExtraPol3DNearestCell_8(ILBson, IUBson + 1 , JLBson, JUBson,    & 
                                            KLBson, KUBson, Compute3DVSon, Me%SubModel%qY)
                                  
                call ExtraPol3DNearestCell(ILBson, IUBson, JLBson, JUBson + 1,     &
                                            KLBson, KUBson, Compute3DUSon, Me%SubModel%U_Next)

                call ExtraPol3DNearestCell(ILBson, IUBson + 1 , JLBson, JUBson,    & 
                                            KLBson, KUBson, Compute3DVSon, Me%SubModel%V_Next)

                call ExtraPol3DNearestCell(ILBson, IUBson, JLBson, JUBson + 1,     &
                                            KLBson, KUBson, Compute3DUSon, Me%SubModel%DUZ_Next)

                call ExtraPol3DNearestCell(ILBson, IUBson + 1 , JLBson, JUBson,    & 
                                            KLBson, KUBson, Compute3DVSon, Me%SubModel%DVZ_Next)
                           
            endif
        endif 

cd12:   if (Me%SubModel%InterPolTime .and. InitialField) then

            call SetMatrixValue(Me%SubModel%Z_Previous, Me%Size2D, Me%SubModel%Z_Next)

            !Me%SubModel%Z_Previous  (:,:  ) = Me%SubModel%Z_Next  (:,:)

            if ((Me%SubModel%VertComunic /= FatherSonDifDim) .or.                   &
                (Me%SubModel%VertComunic /= Father3DSon2D)) then

                call SetMatrixValue(Me%SubModel%U_Previous, Me%Size,               &
                                     Me%SubModel%U_Next)
                call SetMatrixValue(Me%SubModel%V_Previous, Me%Size,               &
                                     Me%SubModel%V_Next)
                call SetMatrixValue(Me%SubModel%DUZ_Previous, Me%Size,             &
                                     Me%SubModel%DUZ_Next)
                call SetMatrixValue(Me%SubModel%DVZ_Previous, Me%Size,             &
                                     Me%SubModel%DVZ_Next)

                !Me%SubModel%U_Previous  (:,:,:) = Me%SubModel%U_Next  (:,:,:)
                !Me%SubModel%V_Previous  (:,:,:) = Me%SubModel%V_Next  (:,:,:)
                !Me%SubModel%DUZ_Previous(:,:,:) = Me%SubModel%DUZ_Next(:,:,:)
                !Me%SubModel%DVZ_Previous(:,:,:) = Me%SubModel%DVZ_Next(:,:,:)

            endif

        endif cd12
        
        if (Me%SubModel%Extrapolate) then
        
            call UnGetMap(Me%ObjMap, Compute3DUSon, STAT = status)
            if (status /= SUCCESS_) stop "ReadNextOrInitialField - Hydrodynamic - ERR300"
                        
            call UnGetMap(Me%ObjMap, Compute3DVSon, STAT = status)
            if (status /= SUCCESS_) stop "ReadNextOrInitialField - Hydrodynamic - ERR310"

        endif        

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ReadNextOrInitialField")

    end subroutine ReadNextOrInitialField 

    !--------------------------------------------------------------------------


    subroutine ReadLockFather(ObjHydrodynamicFather,                                     &
                              FluxXFather, FluxYFather,                                  &
                              Open3DFather, Faces3D_UFather, Faces3D_VFather,            &
                              WetFaces_UFather, WetFaces_VFather,                        &
                              UFather, VFather, ZFather, DUZFather, DVZFather)

        !Arguments-------------------------------------------------------------
        type(T_Hydrodynamic),   pointer    :: ObjHydrodynamicFather
        real,    dimension(:,:,:), pointer :: UFather, VFather, DUZFather, DVZFather
        real(8), dimension(:,:,:), pointer :: FluxXFather, FluxYFather
        real,    dimension(:,:  ), pointer :: ZFather
        integer, dimension(:,:,:), pointer :: Open3DFather
        integer, dimension(:,:,:), pointer :: Faces3D_UFather
        integer, dimension(:,:,:), pointer :: Faces3D_VFather
        integer, dimension(:,:,:), pointer :: WetFaces_UFather
        integer, dimension(:,:,:), pointer :: WetFaces_VFather
   

        !Local---------------------------------------------------------------------
        integer :: status 


        !----------------------------------------------------------------------

        call GetOpenPoints3D(ObjHydrodynamicFather%ObjMap, Open3DFather, STAT = status)
        if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_, "ReadLockFather; Hydrodynamic. ERR01") 

        call GetComputeFaces3D(ObjHydrodynamicFather%ObjMap,                             &
                               ComputeFacesU3D = Faces3D_UFather,                        &
                               ComputeFacesV3D = Faces3D_VFather,                        &
                               STAT= status)
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadLockFather; Hydrodynamic. ERR02") 

        call GetWetFaces(ObjHydrodynamicFather%ObjMap,                                   &
                               WetFaceU = WetFaces_UFather,                              &
                               WetFaceV = WetFaces_VFather,                              &
                               STAT= status)
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadLockFather; Hydrodynamic. ERR03") 

        call GetGeometryDistances(ObjHydrodynamicFather%ObjGeometry, DUZ =  DUZFather,   &
                                  DVZ =  DVZFather, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadLockFather; Hydrodynamic. ERR04") 

        UFather     => ObjHydrodynamicFather%Velocity%Horizontal%U%New
        VFather     => ObjHydrodynamicFather%Velocity%Horizontal%V%New
        ZFather     => ObjHydrodynamicFather%WaterLevel%New
        FluxXFather => ObjHydrodynamicFather%WaterFluxes%X
        FluxYFather => ObjHydrodynamicFather%WaterFluxes%Y


    end subroutine ReadLockFather

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine ReadUnLockFather(ObjHydrodynamicFather,                                   &
                                FluxXFather, FluxYFather,                                &
                                Open3DFather, Faces3D_UFather, Faces3D_VFather,          &
                                WetFaces_UFather, WetFaces_VFather,                      &
                                UFather, VFather, ZFather, DUZFather, DVZFather)

        !Arguments-------------------------------------------------------------
        type(T_Hydrodynamic),   pointer    :: ObjHydrodynamicFather
        real,    dimension(:,:,:), pointer :: UFather, VFather, DUZFather, DVZFather
        real(8), dimension(:,:,:), pointer :: FluxXFather, FluxYFather
        real,    dimension(:,:  ), pointer :: ZFather
        integer, dimension(:,:,:), pointer :: Open3DFather
        integer, dimension(:,:,:), pointer :: Faces3D_UFather
        integer, dimension(:,:,:), pointer :: Faces3D_VFather
        integer, dimension(:,:,:), pointer :: WetFaces_UFather
        integer, dimension(:,:,:), pointer :: WetFaces_VFather
   

        !Local---------------------------------------------------------------------
        integer :: status 

   

        !----------------------------------------------------------------------

        call UnGetGeometry(ObjHydrodynamicFather%ObjGeometry, DUZFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR01"

        call UnGetGeometry(ObjHydrodynamicFather%ObjGeometry, DVZFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR02"

        call UnGetMap(ObjHydrodynamicFather%ObjMap, Open3DFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR03"

        call UnGetMap(ObjHydrodynamicFather%ObjMap, Faces3D_UFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR04"

        call UnGetMap(ObjHydrodynamicFather%ObjMap, Faces3D_VFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR05"

        call UnGetMap(ObjHydrodynamicFather%ObjMap, WetFaces_UFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR06"

        call UnGetMap(ObjHydrodynamicFather%ObjMap, WetFaces_VFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR07"

        nullify(UFather)
        nullify(VFather)
        nullify(ZFather)
        nullify(FluxXFather)
        nullify(FluxYFather)

    end subroutine ReadUnLockFather

    !--------------------------------------------------------------------------

    subroutine ReadLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,                   &
                           ImposedNormFacesUSon, ImposedNormFacesVSon,                   &
                           Water3DSon, Boundary2DSon,                                     &
                           Faces3D_USon, Faces3D_VSon,                                   &
                           DUZ_Son, DVZ_Son,                                             &
                           DXX_Son, DYY_Son)

        !Arguments-------------------------------------------------------------
        integer, dimension(:,:  ), pointer :: Boundary2DSon
        integer, dimension(:,:,:), pointer :: ImposedTangFacesUSon, ImposedTangFacesVSon
        integer, dimension(:,:,:), pointer :: ImposedNormFacesUSon, ImposedNormFacesVSon
        integer, dimension(:,:,:), pointer :: Water3DSon
        integer, dimension(:,:,:), pointer :: Faces3D_USon, Faces3D_VSon
        real   , dimension(:,:,:), pointer :: DUZ_Son, DVZ_Son
        real,    dimension(:,:  ), pointer :: DXX_Son, DYY_Son
   

        !Local---------------------------------------------------------------------
        integer                             :: status 


        !Module Horizontal Grid
        call GetHorizontalGrid(Me%ObjHorizontalGrid, DXX = DXX_Son, DYY = DYY_Son,       &
                               STAT = status)
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR01"

        !Module - ModuleHorizontalMap
        call GetImposedTangentialFaces(Me%ObjMap, ImposedTangFacesUSon,                  &
                                       ImposedTangFacesVSon, STAT = status)      
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR02"

        call GetImposedNormalFaces(Me%ObjMap, ImposedNormFacesUSon, ImposedNormFacesVSon,&
                                   STAT = status)      
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR03"


        call GetGeometryDistances(Me%ObjGeometry, DUZ =  DUZ_Son, DVZ =  DVZ_Son,        &
                                  STAT = status)
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR04"

        call GetWaterPoints3D(Me%ObjMap, Water3DSon, STAT = status)
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR05"

        call GetBoundaries(Me%ObjHorizontalMap, Boundary2DSon, STAT = status)
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR06"

        call GetComputeFaces3D(Me%ObjMap,                                                &
                               ComputeFacesU3D = Faces3D_USon,                           &
                               ComputeFacesV3D = Faces3D_VSon,                           & 
                               STAT= status)
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR07"

    end subroutine ReadLockSon

    !--------------------------------------------------------------------------

    subroutine ReadUnLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,                 &
                             ImposedNormFacesUSon, ImposedNormFacesVSon,                 &
                             Water3DSon, Boundary2DSon,                                   &
                             Faces3D_USon, Faces3D_VSon,                                 &
                             DUZ_Son, DVZ_Son,                                           &
                             DXX_Son, DYY_Son)

        !Arguments-------------------------------------------------------------
        integer, dimension(:,:  ), pointer :: Boundary2DSon
        integer, dimension(:,:,:), pointer :: ImposedTangFacesUSon, ImposedTangFacesVSon
        integer, dimension(:,:,:), pointer :: ImposedNormFacesUSon, ImposedNormFacesVSon
        integer, dimension(:,:,:), pointer :: Water3DSon
        integer, dimension(:,:,:), pointer :: Faces3D_USon, Faces3D_VSon
        real   , dimension(:,:,:), pointer :: DUZ_Son, DVZ_Son
        real,    dimension(:,:  ), pointer :: DXX_Son, DYY_Son
  

        !Local---------------------------------------------------------------------
        integer :: status 
        !----------------------------------------------------------------------

        !Get son information

        call UnGetMap(Me%ObjMap, ImposedTangFacesUSon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR01") 


        call UnGetMap(Me%ObjMap, ImposedTangFacesVSon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR02") 


        call UnGetMap(Me%ObjMap, ImposedNormFacesUSon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR03") 


        call UnGetMap(Me%ObjMap, ImposedNormFacesVSon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR04") 


        call UnGetGeometry(Me%ObjGeometry, DUZ_Son, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR07") 


        call UnGetGeometry(Me%ObjGeometry, DVZ_Son, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR08") 



        call UnGetMap(Me%ObjMap, Water3DSon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR09") 

        call UnGetHorizontalMap(Me%ObjHorizontalMap, Boundary2DSon, STAT = STATUS)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR09a") 

        call UnGetMap(Me%ObjMap, Faces3D_USon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR10") 

        call UnGetMap(Me%ObjMap, Faces3D_VSon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR11") 


        call UnGetHorizontalGrid(Me%ObjHorizontalGrid, DXX_Son, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR12") 

        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,                   &
                                 DYY_Son, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR13") 


    end subroutine ReadUnLockSon

    !--------------------------------------------------------------------------

    subroutine ConstructTimeInterpolation(DT_Father)

        !Arguments-------------------------------------------------------------
        real                                        :: DT_Father

        !Local---------------------------------------------------------------------
        real                                        :: DT_Son, Aux1, Aux2
        integer                                     :: status 
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB 
        integer                                     :: FatherLayers, SonLayers
        integer                                     :: FatherKLB, FatherKUB

        !----------------------------------------------------------------------
     
        !Begin - Shorten variables name 

        IUB       = Me%Size%IUB
        ILB       = Me%Size%ILB
        JUB       = Me%Size%JUB
        JLB       = Me%Size%JLB
        KUB       = Me%Size%KUB
        KLB       = Me%Size%KLB

        !Ang: new implementation
        FatherKLB = Me%SubModel%FatherKLB
        FatherKUB = Me%SubModel%FatherKUB

        FatherLayers = FatherKUB       - FatherKLB       + 1
        SonLayers    = Me%WorkSize%KUB - Me%WorkSize%KLB + 1

        call GetComputeTimeStep(Me%ObjTime, DT_Son, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ConstructTimeInterpolation; Hydrodynamic. ERR01") 

cd1:    if      (DT_Son <  DT_Father) then
        
            Aux1 = DT_Father / DT_Son
            Aux2 = real(int (Aux1))

            if (Aux1 /= Aux2)                                                            &
                call SetError(FATAL_, INTERNAL_, "ConstructTimeInterpolation; Hydrodynamic. ERR02") 


            Me%SubModel%InterpolTime  = .true.

        else if (DT_Son == DT_Father) then cd1

            Me%SubModel%InterpolTime  = .false.

        else  cd1

            call SetError(FATAL_, INTERNAL_, "ConstructTimeInterpolation; Hydrodynamic. ERR03") 

        endif cd1

        call Null_Time(Me%SubModel%PreviousTime)
        Me%SubModel%NextTime = Me%BeginTime


        if      ((FatherLayers == 1) .and. (SonLayers >  1)) then

            Me%SubModel%VertComunic = Father2DSon3D    

        else if ((FatherLayers >  1) .and. (SonLayers == 1)) then

            Me%SubModel%VertComunic = Father3DSon2D    

            !Ang: new implementation
            !Allocate auxiliary variables for father-son connection
            nullify(Me%SubModel%Aux_qX)
            nullify(Me%SubModel%Aux_qY)
            nullify(Me%SubModel%Aux_U)
            nullify(Me%SubModel%Aux_V)
            nullify(Me%SubModel%Aux_DUZ)
            nullify(Me%SubModel%Aux_DVZ)
        
            allocate(Me%SubModel%Aux_qX (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR04")
            Me%SubModel%Aux_qX (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_qY (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR05")
            Me%SubModel%Aux_qY (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_U  (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR06")
            Me%SubModel%Aux_U (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_V  (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR07")
            Me%SubModel%Aux_V (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_DUZ(ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR08")
            Me%SubModel%Aux_DUZ (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_DVZ(ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR09")
            Me%SubModel%Aux_DVZ (:,:,:) = FillValueReal

            call Null_Time(Me%SubModel%GetFatherTime)

        else if (FatherLayers         ==  SonLayers) then

            Me%SubModel%VertComunic = FatherSonEqualDim

        else

            Me%SubModel%VertComunic = FatherSonDifDim

            !Ang: new implementation
            !Allocate auxiliary variables for father-son connection
            nullify(Me%SubModel%Aux_qX)
            nullify(Me%SubModel%Aux_qY)
            nullify(Me%SubModel%Aux_U)
            nullify(Me%SubModel%Aux_V)
            nullify(Me%SubModel%Aux_DUZ)
            nullify(Me%SubModel%Aux_DVZ)
        
            allocate(Me%SubModel%Aux_qX (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR10")
            Me%SubModel%Aux_qX (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_qY (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR11")
            Me%SubModel%Aux_qY (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_U  (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR12")
            Me%SubModel%Aux_U (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_V  (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR13")
            Me%SubModel%Aux_V (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_DUZ(ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR14")
            Me%SubModel%Aux_DUZ (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_DVZ(ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR15")
            Me%SubModel%Aux_DVZ (:,:,:) = FillValueReal

            call Null_Time(Me%SubModel%GetFatherTime)

        endif

cd2:    if (Me%SubModel%InterpolTime) then

            allocate (Me%SubModel%Z_Previous(ILB:IUB, JLB:JUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR16")

            Me%SubModel%Z_Previous (:,:  ) = FillValueReal

            allocate (Me%SubModel%Z_Next(ILB:IUB, JLB:JUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR17")

            Me%SubModel%Z_Next (:,:  ) = FillValueReal

            allocate (Me%SubModel%U_Previous(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR18")

            Me%SubModel%U_Previous  (:,:,:) = FillValueReal

            allocate (Me%SubModel%U_Next(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR19")

            Me%SubModel%U_Next      (:,:,:) = FillValueReal


            allocate (Me%SubModel%V_Previous(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR20")

            Me%SubModel%V_Previous  (:,:,:) = FillValueReal

            allocate (Me%SubModel%V_Next    (ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR21")

            Me%SubModel%V_Next      (:,:,:) = FillValueReal


            allocate (Me%SubModel%DUZ_Previous(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR22")

            Me%SubModel%DUZ_Previous  (:,:,:) = FillValueReal

            allocate (Me%SubModel%DUZ_Next(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR23")

            Me%SubModel%DUZ_Next      (:,:,:) = FillValueReal


            allocate (Me%SubModel%DVZ_Previous(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR24")

            Me%SubModel%DVZ_Previous  (:,:,:) = FillValueReal

            allocate (Me%SubModel%DVZ_Next    (ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR25")

            Me%SubModel%DVZ_Next      (:,:,:) = FillValueReal

        else

            Me%SubModel%Z_Previous   => Me%SubModel%Z
            Me%SubModel%Z_Next       => Me%SubModel%Z

            Me%SubModel%U_Previous   => Me%SubModel%U_New
            Me%SubModel%U_Next       => Me%SubModel%U_New

            Me%SubModel%V_Previous   => Me%SubModel%V_New
            Me%SubModel%V_Next       => Me%SubModel%V_New

            Me%SubModel%DUZ_Previous => Me%SubModel%DUZ_New
            Me%SubModel%DUZ_Next     => Me%SubModel%DUZ_New

            Me%SubModel%DVZ_Previous => Me%SubModel%DVZ_New
            Me%SubModel%DVZ_Next     => Me%SubModel%DVZ_New

        endif cd2

    end subroutine ConstructTimeInterpolation


    Subroutine Actualises_Hydrodynamic


        !Arguments-------------------------------------------------------------------
        

        !Local 
        integer :: Num_Discretization, Previous_Direction

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Actualises_Hydrodynamic")

        !Update the moving boundary  (boundary of the tidal areas covered)
!        call UpdateComputeFaces3D(Me%ObjMap,                                &
!                                  Me%WaterLevel%New,                        &
!                                  Me%CurrentTime, STAT = STAT_CALL)      

!        if (STAT_CALL /= SUCCESS_)                                                       &
!            stop 'Actualises_Hydrodynamic; ModuleHydrodynamic. ERR01.'

        call SetMatrixValue(Me%WaterLevel%Old, Me%Size2D, Me%WaterLevel%New)
        !Me%WaterLevel%Old (:,:) = Me%WaterLevel%New(:,:)

        Num_Discretization = Me%ComputeOptions%Num_Discretization


cd2:    if (Num_Discretization == Abbott) then
            
            Previous_Direction = Me%Direction%XY
        
cd3:        if (Previous_Direction == DirectionY_) then
            
                call SetMatrixValue(Me%Velocity%Horizontal%U%Old, Me%Size, Me%Velocity%Horizontal%U%New)

                if (Me%SubModel%ON)then
                    call SetMatrixValue(Me%SubModel%U_Old, Me%Size, Me%SubModel%U_New)
                endif

            elseif (Previous_Direction == DirectionX_) then cd3
                
                call SetMatrixValue(Me%Velocity%Horizontal%V%Old, Me%Size, Me%Velocity%Horizontal%V%New)
                
                if (Me%SubModel%ON)then
                    call SetMatrixValue(Me%SubModel%V_Old, Me%Size, Me%SubModel%V_New)
                endif

            else

                Stop 'Sub. Actualises_Hydrodynamic - ModuleHydrodynamic - Err02.'

            endif cd3


        else if (Num_Discretization == Leendertse) then cd2
            
            call SetMatrixValue(Me%Velocity%Horizontal%U%Old, Me%Size, Me%Velocity%Horizontal%U%New)
            call SetMatrixValue(Me%Velocity%Horizontal%V%Old, Me%Size, Me%Velocity%Horizontal%V%New)

            !Me%Velocity%Horizontal%U%Old(:,:,:) =                           &
            !Me%Velocity%Horizontal%U%New(:,:,:)

            !Me%Velocity%Horizontal%V%Old(:,:,:) =                           & 
            !Me%Velocity%Horizontal%V%New(:,:,:)

            if (Me%SubModel%ON)   then
            
                call SetMatrixValue(Me%SubModel%U_Old, Me%Size, Me%SubModel%U_New)
                call SetMatrixValue(Me%SubModel%V_Old, Me%Size, Me%SubModel%V_New)
                
                !Me%SubModel%U_Old(:,:,:) =                                  &
                !Me%SubModel%U_New(:,:,:)

                !Me%SubModel%V_Old(:,:,:) =                                  &
                !Me%SubModel%V_New(:,:,:)

            endif


        else cd2

            Stop 'Sub. Actualises_Hydrodynamic - ModuleHydrodynamic - Err03.'

        endif cd2

        !NonHydrostatic
        if (Me%NonHydrostatic%ON) then
            call SetMatrixValue(Me%Velocity%Vertical%CartesianOld, Me%Size,             &
                                Me%Velocity%Vertical%Cartesian)
        endif

        !Actualize Generic 4D
        if (Me%Generic4D%ON)                                                            &
            Me%Generic4D%CurrentValue = TimeSerieValue(Me%Generic4D%ObjTimeSerie,       &
                                                       Me%CurrentTime,                  &
                                                       Me%Generic4D%TimeSerieColumn) 

        if (Me%ThinWalls%ON) then
            call ModifyThinWallsMapping
        endif
 
        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Actualises_Hydrodynamic")

    End Subroutine Actualises_Hydrodynamic


    !End------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine One_Iteration 


        !Arguments-------------------------------------------------------------------
        


        !Local----------------------------------------------------------------------
        real, dimension(:,:), pointer               :: GaugeElevation, GaugeVelocity    
        integer                                     :: Evolution, Grid
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB, k
        
        

        !Begin----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "One_Iteration")


        call Actualize_HydrodynamicTimeStep 

        !Initialize bottom boundary (Chezy coefficient is computed for the first time)
        if (Me%FirstIteration) then

#ifdef _USE_SEQASSIMILATION
            if (.not. Me%VirtualRun) then
#endif _USE_SEQASSIMILATION

#ifdef _USE_SEQASSIMILATION
            endif
#endif _USE_SEQASSIMILATION

            call MaintainDirection            
            call Bottom_Boundary
        endif


        Evolution = Me%ComputeOptions%Evolution

cd1:    if (Evolution == Solve_Equations_) then 

            call MomentumMassConservation 

#ifdef _USE_SEQASSIMILATION
            !(change direction to assure that only real runs change direction)
            if (Me%VirtualRun) call ChangeDirection
#endif _USE_SEQASSIMILATION

        else if (Evolution == Read_File_) then  cd1

            call ReadHydrodynamicFile 

            call Bottom_Boundary 

        else if (Evolution == No_hydrodynamic_ .or. Evolution == Residual_hydrodynamic_) then cd1

            !Don't make any hydrodynamic actualization
            !Update only the Geometry because the water properties evolution 
            !verifies always if the geometry is actualized 
            call New_Geometry

            call Bottom_Boundary 

        else if (Evolution == ImposedSolution_) then cd1

            call ReadImposedSolution

            call Modify_HorizontalWaterFlow
            
            call ChangeDirection    

            call Modify_HorizontalWaterFlow

            !Grid = Fix 
            !First prediction of the vertical fluxes and velocity for a fixed geometry
            !This is only important when one of the domains as vertical "Lagrangian" coordinate

            Grid = Fix

            call New_VerticalHydrodynamic( Grid)
            
            call New_Geometry

            !Grid = Variable
            !the vertical water flux is compute with the effect of variable volume
            Grid = Variable

            call New_VerticalHydrodynamic( Grid)  

            call Bottom_Boundary

#ifdef _USE_SEQASSIMILATION
            !(change direction to assure that only real runs change direction)
            if (Me%VirtualRun) call ChangeDirection
#endif _USE_SEQASSIMILATION

        else if (Evolution == Harmonics_)  then cd1
        
            ILB = Me%WorkSize%ILB
            IUB = Me%WorkSize%IUB
            JLB = Me%WorkSize%JLB
            JUB = Me%WorkSize%JUB   
            KLB = Me%WorkSize%KLB
            KUB = Me%WorkSize%KUB                      
        
            call Modify_AllDomain(Me%ObjOpenBoundary, Me%CurrentTime)            
            
            call GetImposedElevation(Me%ObjOpenBoundary, GaugeElevation)    
            
            Me%WaterLevel%New(:,:) = GaugeElevation(:,:)
            
            call UnGetOpenBoundary(Me%ObjOpenBoundary, GaugeElevation)                                     
            
            call GetImposedVelocity(Me%ObjOpenBoundary, GaugeVelocity, DirectionX_)  
            
            do k=KLB,KUB
                Me%Velocity%Horizontal%U%New(ILB:IUB,JLB:JUB,k) = GaugeVelocity(ILB:IUB,JLB:JUB) 
            enddo                                 
            
            call UnGetOpenBoundary(Me%ObjOpenBoundary, GaugeVelocity)                                                     
        
            call GetImposedVelocity(Me%ObjOpenBoundary, GaugeVelocity, DirectionY_)  
            
            do k=KLB,KUB
                Me%Velocity%Horizontal%V%New(ILB:IUB,JLB:JUB,k) = GaugeVelocity(ILB:IUB,JLB:JUB) 
            enddo  

            call UnGetOpenBoundary(Me%ObjOpenBoundary, GaugeVelocity)   
 
            call New_Geometry

            !call Bottom_Boundary
            


        else if (Evolution == Vertical1D_) then cd1
            
        !Guillaume
            call AssociateDirectionX
            call Bottom_Boundary
            call Explicit_Forces    
            call Compute_Velocity       
            call AssociateDirectionY 
            call Bottom_Boundary
            call Explicit_Forces    
            call Compute_Velocity

        else cd1 
            
            Stop 'Sub. One_Iteration - ModuleHydrodynamic - Err04'
                    
        endif cd1

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "One_Iteration")

    End Subroutine One_Iteration

    !End------------------------------------------------------------
   
    Subroutine ReadImposedSolution

        !Arguments-------------------------------------------------------------------
        


        !Local----------------------------------------------------------------------
        real,    dimension(:,:,:), pointer          :: Matrix3D
        integer, dimension(:,:,:), pointer          :: PointsToFill3D
        integer                                     :: STAT_CALL, i, j, k
        logical                                     :: RotateX, RotateY
        integer                                     :: CHUNK
        
        !Begin----------------------------------------------------------------------

        if (Me%WaterLevel%ID%SolutionFromFile) then
            call ModifyFillMatrix (FillMatrixID   = Me%WaterLevel%ID%ObjFillMatrix, &
                                   Matrix2D       = Me%WaterLevel%New,              &
                                   PointsToFill2D = Me%External_Var%WaterPoints2D,  &
                                   STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)  Stop 'ReadImposedSolution - ModuleHydrodynamic - ERR10'
        endif
        
        Me%WaterLevel%New (:,:) = Me%WaterLevel%New (:,:) / Me%OutPut%WaterLevelUnits 

        RotateX = .false. 
        RotateY = .false. 

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ReadImposedSolution")

        if (Me%Velocity%Horizontal%U%ID%SolutionFromFile) then

            if      (Me%Velocity%Horizontal%U%InTypeZUV == TypeU_) then
        
                PointsToFill3D => Me%External_Var%ComputeFaces3D_U
                Matrix3D       => Me%Velocity%Horizontal%U%New

            else if (Me%Velocity%Horizontal%U%InTypeZUV == TypeZ_) then

                PointsToFill3D => Me%External_Var%OpenPoints3D
            
                allocate (Matrix3D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB,Me%Size%KLB:Me%Size%KUB))

                Matrix3D(:,:,:) = FillValueReal

            endif

            call ModifyFillMatrix (FillMatrixID   = Me%Velocity%Horizontal%U%ID%ObjFillMatrix, &
                                   Matrix3D       = Matrix3D,                                  &
                                   PointsToFill3D = PointsToFill3D,                            &
                                   STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)  Stop 'ReadImposedSolution - ModuleHydrodynamic - ERR20'


            if (Me%Velocity%Horizontal%U%InTypeZUV == TypeZ_) then

                Me%Velocity%Horizontal%U%New(:,:,:) = 0.

                CHUNK = CHUNK_J(Me%WorkSize%JLB,Me%WorkSize%JUB)

                !$OMP PARALLEL PRIVATE(i,j,k)

                do k = Me%WorkSize%KLB,Me%WorkSize%KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = Me%WorkSize%JLB,Me%WorkSize%JUB
                do i = Me%WorkSize%ILB,Me%WorkSize%IUB
                
                    if (PointsToFill3D(i,j-1,k) == OpenPoint .and.                      &
                        PointsToFill3D(i,j  ,k) == OpenPoint) then
                        Me%Velocity%Horizontal%U%New(i,j,k) = (Matrix3D(i,j-1,k) + Matrix3D(i,j,k)) / 2.
                    endif

                enddo
                enddo
                !$OMP END DO NOWAIT
                enddo

                !$OMP END PARALLEL

                deallocate(Matrix3D)

            endif

            nullify   (PointsToFill3D)
            nullify   (Matrix3D)


            RotateX = .true. 

        endif

        if (Me%Velocity%Horizontal%V%ID%SolutionFromFile) then

            if      (Me%Velocity%Horizontal%V%InTypeZUV == TypeV_) then

                PointsToFill3D => Me%External_Var%ComputeFaces3D_V
                Matrix3D       => Me%Velocity%Horizontal%V%New

            else if (Me%Velocity%Horizontal%V%InTypeZUV == TypeZ_) then

                PointsToFill3D => Me%External_Var%OpenPoints3D
                allocate (Matrix3D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB,Me%Size%KLB:Me%Size%KUB))

                Matrix3D(:,:,:) = FillValueReal

            endif

            call ModifyFillMatrix (FillMatrixID   = Me%Velocity%Horizontal%V%ID%ObjFillMatrix, &
                                   Matrix3D       = Matrix3D,                                  &
                                   PointsToFill3D = PointsToFill3D,                            &
                                   STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)  Stop 'ReadImposedSolution - ModuleHydrodynamic - ERR30'

            if (Me%Velocity%Horizontal%V%InTypeZUV == TypeZ_) then

                Me%Velocity%Horizontal%V%New(:,:,:) = 0.

                CHUNK = CHUNK_J(Me%WorkSize%JLB,Me%WorkSize%JUB)

                !$OMP PARALLEL PRIVATE(i,j,k)

                do k = Me%WorkSize%KLB,Me%WorkSize%KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = Me%WorkSize%JLB,Me%WorkSize%JUB
                do i = Me%WorkSize%ILB,Me%WorkSize%IUB
                
                    if (PointsToFill3D(i-1,j,k) == OpenPoint .and.                  &
                        PointsToFill3D(i  ,j,k) == OpenPoint) then
                        Me%Velocity%Horizontal%V%New(i,j,k) = (Matrix3D(i-1,j,k) + Matrix3D(i,j,k)) / 2.
                    endif

                enddo
                enddo
                !$OMP END DO NOWAIT
                enddo

                !$OMP END PARALLEL

                deallocate(Matrix3D)

            endif

            nullify   (PointsToFill3D)
            nullify   (Matrix3D)

            RotateY = .true. 
        endif

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ReadImposedSolution")

        call RotateVectorFieldToGrid(HorizontalGridID  = Me%ObjHorizontalGrid,           &
                                     VectorInX         = Me%Velocity%Horizontal%U%New,   &
                                     VectorInY         = Me%Velocity%Horizontal%V%New,   &
                                     VectorOutX        = Me%Velocity%Horizontal%U%New,   &
                                     VectorOutY        = Me%Velocity%Horizontal%V%New,   &   
                                     WaterPoints3D     = Me%External_Var%WaterPoints3D,  &
                                     RotateX           = RotateX,                        &
                                     RotateY           = RotateY,                        &
                                     KLB               = Me%WorkSize%KLB,                &
                                     KUB               = Me%WorkSize%KUB,                &
                                     STAT              = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)  Stop 'ReadImposedSolution - ModuleHydrodynamic - ERR40'

    end subroutine ReadImposedSolution

    !End------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (03/1)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine MomentumMassConservation 

        !Arguments-------------------------------------------------------------------
        

        !Local----------------------------------------------------------------------

        integer                             :: Num_Discretization, Grid
        integer                             :: kbottomU, kbottomV
        integer                             :: ILB, IUB, JLB, JUB, WorkKUB, i, j, k
        integer                             :: STAT_CALL 
        real                                :: Depth
        integer                             :: CHUNK

        !Begin----------------------------------------------------------------------

        if (Me%FirstIteration .and. Me%ComputeOptions%Geost_Initialization) then

            call ComputeGeostrophicVelocity(Me%WaterLevel%New,                          &
                                            Me%External_Var%SigmaDens)
                                            
            if (Me%ComputeOptions%LocalSolution == AssimilationField_ .or.              &
                Me%ComputeOptions%LocalSolution == AssimilaPlusSubModel_ .or.           &
                Me%ComputeOptions%LocalSolution == AssimilaGaugeSubModel_) then 
                
                ! Compute batotropic part of geostrophic velocitiy
            
                ILB = Me%Size%ILB 
                IUB = Me%Size%IUB 
                JLB = Me%Size%JLB 
                JUB = Me%Size%JUB 

                WorkKUB = Me%WorkSize%KUB 

                CHUNK = CHUNK_J(JLB, JUB)
            
                if (MonitorPerformance) then
                    call StartWatch ("ModuleHydrodynamic", "MomentumMassConservation")
                endif
            
                !$OMP PARALLEL PRIVATE(i,j,k,kbottomU,Depth,kbottomV)
            
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    if(Me%External_Var%ComputeFaces3D_U (i ,j ,WorkKUB) == WaterPoint)  &
                    then 
                        kbottomU = Me%External_Var%KFloor_U(i, j)
                    
                        Depth = 0.
                        do k = WorkKUB, kbottomU, -1
                            Me%Geostroph%U_barotropic(i, j)=                            &
                                                      Me%Geostroph%U_barotropic(i, j)   &
                                                      +Me%Geostroph%U(i, j, k)*         &
                                                      Me%External_Var%DUZ(i, j, k)
                            Depth = Depth + Me%External_Var%DUZ(i, j, k)
                        enddo
                            Me%Geostroph%U_barotropic(i, j) =                           &
                                                  Me%Geostroph%U_barotropic(i, j)/ Depth
                    endif
                enddo
                enddo
                !$OMP END DO NOWAIT

                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    if(Me%External_Var%ComputeFaces3D_V (i ,j ,WorkKUB) == WaterPoint)  &
                    then 
                        kbottomV = Me%External_Var%KFloor_V(i, j)
                    
                        Depth = 0.
                        do k = WorkKUB, kbottomV, -1
                            Me%Geostroph%V_barotropic(i, j)=                            &
                                                    Me%Geostroph%V_barotropic(i, j)     &
                                                    +Me%Geostroph%V(i, j, k)*           &
                                                    Me%External_Var%DVZ(i, j, k)
                            Depth = Depth + Me%External_Var%DVZ(i, j, k)
                        enddo
                            Me%Geostroph%V_barotropic(i, j) =                           &
                                                 Me%Geostroph%V_barotropic(i, j) / Depth
                    endif
                enddo
                enddo
                !$OMP END DO
           
                !$OMP MASTER
                !Fetch the reference barotropic velocity field
                call GetAssimilationField(Me%ObjAssimilation,                           &
                                     ID      = BarotropicVelocityU_,                    &
                                     Field2D = Me%Geostroph%Reference_U_barotropic,     &
                                     STAT    = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR010'

                call GetAssimilationField(Me%ObjAssimilation,                           &
                                     ID      = BarotropicVelocityV_,                    &
                                     Field2D = Me%Geostroph%Reference_V_barotropic,     &
                                     STAT    = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR020'

                !Fetch the nudging coefficient for barotropic velocity
                call GetAssimilationCoef(Me%ObjAssimilation,                            &
                                     ID      = BarotropicVelocityU_,                    &
                                     CoefField2D = Me%Geostroph%Coef_U_barotropic,      &
                                     STAT            = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR030'

                call GetAssimilationCoef(Me%ObjAssimilation,                            &
                                     ID      = BarotropicVelocityV_,                    &
                                     CoefField2D = Me%Geostroph%Coef_V_barotropic,      &
                                     STAT            = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR040'
                !$OMP END MASTER
                !$OMP BARRIER
            
                !Initialize velocity with barotropic correction
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    if(Me%External_Var%ComputeFaces3D_U (i ,j ,WorkKUB) == WaterPoint)  &
                    then
                        kbottomU = Me%External_Var%KFloor_U(i, j)
                        do k = kbottomU, WorkKUB 
                        Me%Velocity%Horizontal%U%New (i,j,k) = Me%Geostroph%U(i,j,k) +  &
                                           Me%Geostroph%Coef_U_barotropic (i,j) *       &
                                           (Me%Geostroph%Reference_U_barotropic (i,j)   &
                                           - Me%Geostroph%U_barotropic(i, j))
                        enddo
                    endif
                enddo
                enddo
                !$OMP END DO NOWAIT

                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    if(Me%External_Var%ComputeFaces3D_V (i ,j ,WorkKUB) == WaterPoint)  &
                    then
                        kbottomV = Me%External_Var%KFloor_V(i, j)
                        do k = kbottomV, WorkKUB 
                        Me%Velocity%Horizontal%V%New (i,j,k) = Me%Geostroph%V(i,j,k) +  & 
                                           Me%Geostroph%Coef_V_barotropic (i,j) *       &
                                           (Me%Geostroph%Reference_V_barotropic (i,j)   &
                                           - Me%Geostroph%V_barotropic(i, j))
                        enddo
                    endif
                enddo
                enddo
                !$OMP END DO
                !$OMP END PARALLEL
                
                if (MonitorPerformance) then
                    call StopWatch ("ModuleHydrodynamic", "MomentumMassConservation")
                endif
                
                Me%Velocity%Horizontal%U%Old (:,:,:) = Me%Velocity%Horizontal%U%New (:,:,:)
                Me%Velocity%Horizontal%V%Old (:,:,:) = Me%Velocity%Horizontal%V%New (:,:,:)

                !Unfetch the reference variables
                call UnGetAssimilation( Me%ObjAssimilation,                             &
                                    Me%Geostroph%Reference_U_barotropic,                &
                                    STAT = STAT_CALL) 
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR050' 

                call UnGetAssimilation( Me%ObjAssimilation,                             &
                                    Me%Geostroph%Reference_V_barotropic,                &
                                    STAT = STAT_CALL) 
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR060' 

                call UnGetAssimilation( Me%ObjAssimilation,                             &
                                    Me%Geostroph%Coef_U_barotropic,                     &
                                    STAT = STAT_CALL) 
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR070' 

                call UnGetAssimilation( Me%ObjAssimilation,                             &
                                    Me%Geostroph%Coef_V_barotropic,                     &
                                    STAT = STAT_CALL) 
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR080' 


            else
            
            !Initialize velocity without barotropic correction
            
            Me%Velocity%Horizontal%U%New (:,:,:) = Me%Geostroph%U(:,:,:)
            Me%Velocity%Horizontal%V%New (:,:,:) = Me%Geostroph%V(:,:,:)
            Me%Velocity%Horizontal%U%Old (:,:,:) = Me%Velocity%Horizontal%U%New (:,:,:) 
            Me%Velocity%Horizontal%V%Old (:,:,:) = Me%Velocity%Horizontal%V%New (:,:,:)
            
            endif

                        
        endif

        
        call ModifyWaterDischarges 

        Num_Discretization = Me%ComputeOptions%Num_Discretization

i1:     if (Me%ComputeOptions%Vertical_AxiSymmetric_Model == 0) then

cd2:        if      (Num_Discretization == Abbott    ) then

                call Abbott_Scheme     

            else if (Num_Discretization == Leendertse) then cd2

                call Leendertse_Scheme 

            else cd2

                Stop 'Sub. MomentumMassConservation - ModuleHydrodynamic - Err01.'
 
            endif cd2

        else i1

            call Implicit_1DScheme

        endif i1


        !NonHydrostatic
        if (Me%NonHydrostatic%ON) then

            call VerticalMomentum

            call NonHydroStaticCorrection

            call Modify_HorizontalWaterFlow

            call NullifyAuxiliarPointers

        endif

        !Grid = Fix 
        !First prediction of the vertical fluxes and velocity for a fixed geometry
        !This is only important when one of the domains as vertical "Lagrangian" coordinate

        Grid = Fix

        call New_VerticalHydrodynamic( Grid)
        
        call New_Geometry

        !Grid = Variable
        !the vertical water flux is compute with the effect of variable volume
        Grid = Variable

        call New_VerticalHydrodynamic( Grid)  
        
    End Subroutine MomentumMassConservation
    !End------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                       
    ! Vertical Momentum                                                                    
    !
    ! Calculates the vertical velocity by resolving the momentum equation in z direction.  
    ! The routine computes a tri-diagonal system - that is coefficients and independent
    ! term - that is then solved using the Thomas algorithm.
    !
    ! 1) Pressure correction    
    ! 2) Diffusion
    ! 3) Advection
    ! 4) Boundary Condition
    ! 5) Solve by Thomas Algorithm
    !                                                                                      
    ! ----------------------------
    !
    ! author : Hernâni Theias
    ! last modified  : 06/2004 
    ! e-mail : hernanitheias@netcabo.pt                                                      
    !                                                                                      
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine VerticalMomentum
        !Local--------------------------------------------------
         real(8),    dimension(:,:,:), pointer  :: eCoef !coefficients
         real,    dimension(:,:,:), pointer     :: dCoef, fCoef, tiCoef !coefficients
         integer                                :: iub, ilb, jub, jlb, kub, klb
         integer                                :: i, j, k     !counters
         real(8),    dimension(:,:,:), pointer  :: fx, fy, fz
         real,       dimension(:,:,:), pointer  :: dz
         real,       dimension(:,:), pointer    :: dx, dy
         real                                   :: axy, az, kv
         real(8)                                :: aux
         ! integer                                :: CHUNK
         
        !Begin---------------------------------------------------
        !----Shorten names
        iub = Me%WorkSize%IUB
        ilb = Me%WorkSize%ILB
        jub = Me%WorkSize%JUB
        jlb = Me%WorkSize%JLB
        kub = Me%WorkSize%KUB
        klb = Me%WorkSize%KLB
        dCoef => Me%Coef%D3%D
        eCoef => Me%Coef%D3%E
        fCoef => Me%Coef%D3%F
        tiCoef => Me%Coef%D3%Ti
        !----Initialize values
        dCoef(:,:,:) = 0.0
        eCoef(:,:,:) = 1.0
        fCoef(:,:,:) = 0.0 
        tiCoef(:,:,:) = 0.0 !do not put FillValueReal here, please. Not healthy. 
        
        ! CHUNK = CHUNK_J(jlb,jub)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.
        
        !----Non-Hydrostatic correction, explicit part
        
        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "VerticalMomentum")

        ! !! $OMP PARALLEL PRIVATE(i,j,k)
        do k = klb, kub
        ! !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = jlb, jub
        do i = ilb, iub
            if(Me%External_Var%ComputeFaces3D_W(i, j, k) == Compute) then
                ![m/s]          =   [m/s]           + [] * [s] / [m] * [m^2/s^2]
                tiCoef(i, j, k) =   Me%Velocity%Vertical%CartesianOld(i, j, k)
            endif
        enddo !do i
        enddo !do j
        ! !! $OMP END DO
        enddo !do k
        ! !! $OMP END PARALLEL
        
        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "VerticalMomentum")
        
        !----Allocate...
        allocate(fx(ilb-1:iub+1,jlb-1:jub+1,klb-1:kub+1))
        allocate(fy(ilb-1:iub+1,jlb-1:jub+1,klb-1:kub+1))
        allocate(fz(ilb-1:iub+1,jlb-1:jub+1,klb-1:kub+1))
        allocate(dx(ilb-1:iub+1,jlb-1:jub+1))
        allocate(dy(ilb-1:iub+1,jlb-1:jub+1))
        allocate(dz(ilb-1:iub+1,jlb-1:jub+1,klb-1:kub+1))
        fx(:,:,:) = FillValueReal
        fy(:,:,:) = FillValueReal
        fz(:,:,:) = FillValueReal
        dx(:,:  ) = FillValueReal
        dy(:,:  ) = FillValueReal
        dz(:,:,:) = FillValueReal
        !----Calculate Diffusive Fluxes
        do j = jlb, jub
        do i = ilb, iub
            az = Me%External_Var%DXX(i,j) * Me%External_Var%DYY(i,j)
            do k = klb, kub
                !X
                if((Me%External_Var%WaterPoints3D(i,j,k)==OpenPoint).and.        &
                   (Me%External_Var%WaterPoints3D(i,j-1,k)==OpenPoint).and.       &
                   (Me%External_Var%WaterPoints3D(i,j,k-1)==OpenPoint).and.       &
                   (Me%External_Var%WaterPoints3D(i,j-1,k-1)==OpenPoint)) then
                    axy = Me%External_Var%DUZ(i,j,k) * Me%External_Var%DYY(i,j)
                    kv = interpolate3D(Me%External_Var%Visc_H_Center,            &  
                                       Me%External_Var%DUX, Me%External_Var%DVY, &
                                       Me%External_Var%DWZ, i, j, k, 0, -1, -1)
                    fx(i,j,k) = kv * axy
                else
                    fx(i,j,k) = 0.0
                endif
                
                dx(i,j) = Me%External_Var%DZX(i,j-1)                
                
                !Y
                if((Me%External_Var%WaterPoints3D(i,j,k)==OpenPoint).and.         &
                   (Me%External_Var%WaterPoints3D(i-1,j,k)==OpenPoint).and.       &
                   (Me%External_Var%WaterPoints3D(i,j,k-1)==OpenPoint).and.       &
                   (Me%External_Var%WaterPoints3D(i-1,j,k-1)==OpenPoint)) then
                    axy = Me%External_Var%DVZ(i,j,k) * Me%External_Var%DXX(i,j)
                    kv = interpolate3D(Me%External_Var%Visc_H_Center,            &  
                                       Me%External_Var%DUX, Me%External_Var%DVY, &
                                       Me%External_Var%DWZ, i, j, k, -1, 0, -1)
                    fy(i,j,k) = kv * axy
                else
                    fy(i,j,k) = 0.0
                endif
                
                dy(i,j) = Me%External_Var%DZY(i,j-1)
                
                !Z
                if((Me%External_Var%ComputeFaces3D_W(i,j,k)==Compute).and. &
                   (Me%External_Var%ComputeFaces3D_W(i,j,k-1)==Compute)) then
                    kv = ( Me%External_Var%Vertical_Viscosity(i, j, k-1) +             &
                           Me%External_Var%Vertical_Viscosity(i, j, k  ) ) / 2.
                    fz(i,j,k) = kv * az
                else
                    fz(i,j,k) = 0.0
                endif
                
                dz(i,j,k) = Me%External_Var%DWZ(i,j,k)                
                
            enddo !do k 
        enddo !do i
        enddo !do j
        !----Diffusion          
         call ComputeDiffusion3D (ilb, iub, jlb, jub, klb, kub,                          &
                dx, dy, dz,                                                              &
                Me%External_Var%ComputeFaces3D_W,                                        &
                fx, fy, fz,                                                              &
                Me%WaterLevel%DT, Me%Velocity%Vertical%Cartesian,                        &
                Me%External_Var%Volume_W,                                                &
                Ticoef, Ecoef, DCoef, Fcoef,                                             &
                0.,                                                                      &
                0.,                                                                      &
                Me%ComputeOptions%ImplicitVertDiffusion,                                 &
                Me%ComputeOptions%HorizontalDiffusion,                                   &
                Me%ComputeOptions%HorizontalDiffusion,                                   &
                Me%ComputeOptions%VerticalDiffusion)
        !----Interpolate Fluxes to W-Grid
        do k = klb, kub
        do j = jlb, jub + 1
        do i = ilb, iub + 1
!            fx(i,j,k) = interpolate3D(Me%WaterFluxes%X,                                  &  
!                                   Me%External_Var%DUX, Me%External_Var%DVY,             &
!                                   Me%External_Var%DWZ, i, j, k, 0, 0, -1)

            aux = Me%External_Var%DUZ(i, j, k-1) /(Me%External_Var%DUZ(i, j, k-1) + Me%External_Var%DUZ(i, j, k))

            fx(i,j,k) =             Me%External_Var%ComputeFaces3D_U(i,j,k  ) * Me%WaterFluxes%X(i,j,k  ) * aux  
            fx(i,j,k) = fx(i,j,k) + Me%External_Var%ComputeFaces3D_U(i,j,k-1) * Me%WaterFluxes%X(i,j,k-1) * (1.-aux)

!            fy(i,j,k) = interpolate3D(Me%WaterFluxes%Y,                                  &  
!                                   Me%External_Var%DUX, Me%External_Var%DVY,             &
!                                   Me%External_Var%DWZ, i, j, k, 0, 0, -1)

            aux = Me%External_Var%DVZ(i, j, k-1) /(Me%External_Var%DVZ(i, j, k-1) + Me%External_Var%DVZ(i, j, k))

            fy(i,j,k) =             Me%External_Var%ComputeFaces3D_V(i,j,k  ) * Me%WaterFluxes%Y(i,j,k  ) * aux  
            fy(i,j,k) = fy(i,j,k) + Me%External_Var%ComputeFaces3D_V(i,j,k-1) * Me%WaterFluxes%Y(i,j,k-1) * (1.-aux)

            !fz(i,j,k) = interpolate3D(Me%WaterFluxes%Z,                                  &  
            !                       Me%External_Var%DUX, Me%External_Var%DVY,             &
            !                       Me%External_Var%DWZ, i, j, k, 0, 0, -1)
            
            fz(i,j,k) =             Me%External_Var%ComputeFaces3D_W(i,j,k  ) * Me%WaterFluxes%Z(i,j,k  ) * 0.5
            fz(i,j,k) = fz(i,j,k) + Me%External_Var%ComputeFaces3D_W(i,j,k-1) * Me%WaterFluxes%Z(i,j,k-1) * 0.5
            
        enddo !do k 
        enddo !do i
        enddo !do j
        !----Advection
        call ComputeAdvection3D(ilb, iub, jlb, jub, klb, kub,                            &
                    dx, dy, dz,                                                          &
                    Me%External_Var%ComputeFaces3D_W,                                    &
                    fx, fy, fz,                                                          &
                    Me%WaterLevel%DT, Me%Velocity%Vertical%Cartesian,                    &
                    Me%External_Var%Volume_W,                                            &
                    Ticoef, Ecoef, DCoef, Fcoef,                                         &
                    0.0,                                                                 &
                    0.0,                                                                 &
                    Me%ComputeOptions%ImplicitVertAdvection,                             &
                    Me%ComputeOptions%HorizontalAdvection,                               &
                    Me%ComputeOptions%HorizontalAdvection,                               &
                    Me%ComputeOptions%VerticalAdvection,                                 &
                    Me%ComputeOptions%AdvectionMethodH,                                  &
                    Me%ComputeOptions%AdvectionMethodV,                                  &
                    Me%ComputeOptions%TVD_LimH,                                          &
                    Me%ComputeOptions%TVD_LimV,                                          &
                    Me%ComputeOptions%VolumeRelMax,                                      &
                    Me%ComputeOptions%Upwind2H,                                          &
                     Me%ComputeOptions%Upwind2V) 

        !Compute the momentum discharge 
        if (Me%ComputeOptions%MomentumDischarge)                            &
            call ModifyMomentumDischargeVert 

       !----Boundary condition
        call VerticalMomentumBoundary
        
        !Adds a force that relax the velocity field to a reference field
        if (Me%Relaxation%Force)                                                &
            call ModifyRelaxAcelerationVert        
        !----Solve
        !griflet: old call
        !call THOMASZ(ilb, iub, jlb, jub, klb, kub, dCoef, eCoef, fCoef, tiCoef,        &
        !              Me%Velocity%Vertical%Cartesian, Me%VECG_3D, Me%VECW_3D)
        !griflet: new call
        call THOMASZ(ilb, iub, jlb, jub, klb, kub, Me%THOMAS,       &
                      Me%Velocity%Vertical%Cartesian                &
#ifdef _ENABLE_CUDA
        ! Use CUDA to solve the Thomas algorithm, ID of ModuleCuda is needed
                         , Me%ObjCuda,                              &
                         .FALSE.                                    &
#endif _ENABLE_CUDA
                         )

        !----DeAllocate...
        deallocate(fx)
        deallocate(fy)
        deallocate(fz)
        deallocate(dx)
        deallocate(dy)
        deallocate(dz)
    End Subroutine VerticalMomentum
    !End------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                       
    ! Vertical Momentum Boundary Condition                                                                      
    !                                                                           
    ! ----------------------------
    !
    ! author : Hernâni Theias
    ! last modified  : 06/2004 
    ! e-mail : hernanitheias@netcabo.pt                                                      
    !                                                                                      
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine VerticalMomentumBoundary
        !Arguments-------------------------------------------------------------------
        real,    dimension(:,:,:), pointer     :: ti, s, n          
        real(8), dimension(:,:,:), pointer     :: p
        integer                                :: ilb, iub, jlb, jub, k_up !bounds
        integer,    dimension(:,:), pointer    :: k_bottom
        !Local----------------------------------------------------------------------
        integer                                 :: i, j !counters
        ! integer                                 :: CHUNK
        
        !Begin----------------------------------------------------------------------
        ilb = Me%WorkSize%ILB
        iub = Me%WorkSize%IUB
        jlb = Me%WorkSize%JLB
        jub = Me%WorkSize%JUB
        K_UP = Me%WorkSize%KUB + 1
        
        nullify(ti, s, p, n)
        
        ti => Me%Coef%D3%TI
        s  => Me%Coef%D3%D
        p  => Me%Coef%D3%E
        n  => Me%Coef%D3%F
        k_bottom => Me%External_Var%KFloor_Z
        
        ! CHUNK = CHUNK_I(ilb,iub)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "VerticalMomentumBoundary")
        
        ! !! $OMP PARALLEL PRIVATE(i,j,k)
        do i = ilb, iub
        do j = jlb, jub
        !--------Impose w_bottom = 0.0
            if(k_bottom(i,j)>0) then
                ti(i, j, k_bottom(i,j)) = 0.0
                s (i, j, k_bottom(i,j)) = 0.0
                p (i, j, k_bottom(i,j)) = 1.0
                n (i, j, k_bottom(i,j)) = 0.0                
            endif
        !--------Impose w_up = d(eta)/dt
            ti(i, j, k_up) =  (Me%WaterLevel%New(i, j) - Me%WaterLevel%Old(i, j)) & 
                             / Me%WaterLevel%DT
            s (i, j, k_up) = 0.0
            p (i, j, k_up) = 1.0
            n (i, j, k_up) = 0.0                
        enddo    
        enddo
        ! !! $OMP END DO
        ! !! $OMP END PARALLEL
        
        nullify(ti, s, p, n)        
        
        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "VerticalMomentumBoundary")
        
    endsubroutine VerticalMomentumBoundary
    !End----------------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      
    ! Non-HydroStatic Correction
    ! --------------------------                                                        
    !                                                                                      
    ! This routine calculates pressure correction due to non-hydrostatic effects.          
    ! It gives a correction that is then applied to velocity and water level.              
    ! This procedure is based on an article by V. Casulli and P. Zanolli                   
    ! "Semi-Implicit Numerical Modeling of Nonhydrostatic Free-Surface Flows for           
    ! environmental problems" applied to Mohid.
    ! This correction is calculated via a set of equations that yields a 
    ! linear system of equations.
    ! The resulting pentadiagonal system is solved using either:
    ! i)    Pre-Conditionned Conjugate Gradient Method
    ! ii)   Stone's Method (LU decomposition for sparse matrices)
    ! iii)  LiSolve
    ! Values of matrix coefficient for the system are stored in 'p', 'e', 'w', 'n', 's' 
    ! vectors, 'p' being the diagonal. 'q' is the independent term.
    ! The solution of the system is stored in 'pc', which is previsional pressure correction.
    ! There is no correction on w. The continuity equation is used to to determine it, so
    ! model is conservative.
    !
    ! ----------------------------
    !
    ! author : Hernâni Theias
    ! last modified  : 06/2004 
    ! e-mail : hernanitheias@netcabo.pt                                      
    !                                                                                      
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine NonHydroStaticCorrection
        !Local----------------------------------------------------------------------
        real,    dimension (:,:,:), pointer  :: e,w,s,n   ! coefficient matrix (non-diagonals elements)
        real,    dimension (:,:,:), pointer  :: DecayTimeW
        real(8), dimension (:,:,:), pointer  :: p         ! coefficient matrix (diagonal elements)
        real,    dimension (:,:,:), pointer  :: q         ! independdent term
        real,    dimension (:,:,:), pointer  :: pc        ! previsional pressure correction
        integer                              :: di, dj    ! index change due to calculation direction
        real                                 :: dt        ! time step
        real                                 :: az        ! cell face area in Z direction
        real(8)                              :: aux       ! auxiliary coefficient 
        real(8)                              :: fluxZ     ! flux in Z-dir for the upper (free surface) cell
        real                                 :: pcl       ! local value for pressure correction
        integer                              :: i, j, k   ! counters
        integer                              :: ILB, IUB, JLB, JUB, KLB, KUB !bounds
        integer                              :: status 
        ! integer                              :: CHUNK
        
        !Begin----------------------------------------------------------------------
        !----Shorten variables names
        w => Me%NonHydroStatic%CCoef
        s => Me%Coef%D3%D
        p => Me%Coef%D3%E
        n => Me%Coef%D3%F
        e => Me%NonHydroStatic%GCoef
        q => Me%Coef%D3%TI
        pc => Me%NonHydroStatic%PrevisionalQ
        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB
        dt = Me%WaterLevel%DT

        if (Me%Relaxation%Force) then        

            call GetAssimilationCoef (Me%ObjAssimilation,                               &
                                      ID              = VelocityW_,                     &
                                      CoefField3D     = DecayTimeW,                     &
                                      STAT            = status)

            if (status /= SUCCESS_)                                                         &
                call SetError (FATAL_, INTERNAL_, "ModifyRelaxAcelerationVert - Hydrodynamic - ERR20")        
        
        endif                                  
                                  

        
        !----Initialize coefficient matrices 
        
        call SetMatrixValue(n, Me%WorkSize,      0.0 )
        call SetMatrixValue(s, Me%WorkSize,      0.0 )
        call SetMatrixValue(w, Me%WorkSize,      0.0 )
        call SetMatrixValue(e, Me%WorkSize,      0.0 )
        call SetMatrixValue(p, Me%WorkSize, dble(0.0))
        call SetMatrixValue(q, Me%WorkSize,      0.0 )
        
        n(:,:,:) = 0.0 
        s(:,:,:) = 0.0 
        w(:,:,:) = 0.0
        e(:,:,:) = 0.0 
        p(:,:,:) = 0.0
        q(:,:,:) = 0.0
        di = Me%Direction%di
        dj = Me%Direction%dj
        !----Calculate matrix coefficient and independent term of the system
        do i = ILB, IUB
        do j = JLB, JUB
        !--------Calculate z-area of cell
            az = Me%External_Var%DUX(i,j) * Me%External_Var%DVY(i,j)
            do k = KLB, KUB
                if(Me%External_Var%OpenPoints3D(i, j, k) /= OpenPoint) then !cell must not be calculated
                    p(i, j, k)  = 1.0
                    q(i, j ,k ) = 0.0 !pc(i, j, k)
                    cycle
                endif
        !-------------Fluxes in the implicit direction
                if(Me%External_Var%ComputeFaces3D_UV(i, j, k) == Compute) then
                    ![s*m] = [s*m^4/m^3]
                    aux = dt * Me%External_Var%Area_UV(i, j, k) ** 2 / Me%External_Var%Volume_UV(i, j, k)
                    
                    !if (associated(DecayTimeUV)) then
                    !    if (DecayTimeUV(i,j,k)< 1000) aux = aux*0.1
                    !endif 
                    
                    p(i     , j     , k) = p(i     , j     , k) + aux
                    s(i     , j     , k) = s(i     , j     , k) - aux
                    ![m3/s]              =  [m3/s] + [m3/s]
                    q(i     , j     , k) = q(i     , j     , k) + Me%WaterFluxes%XY(i, j, k)
                    p(i - di, j - dj, k) = p(i - di, j - dj, k) + aux
                    n(i - di, j - dj, k) = n(i - di, j - dj, k) - aux
                    q(i - di, j - dj, k) = q(i - di, j - dj, k) - Me%WaterFluxes%XY(i, j, k)
                endif
        !-------------Fluxes in the explicit direction
                if(Me%External_Var%ComputeFaces3D_VU(i, j, k) == Compute) then
                    q(i     , j     , k) = q(i     , j     , k) + Me%WaterFluxes%YX(i, j, k)
                    q(i - dj, j - di, k) = q(i - dj, j - di, k) - Me%WaterFluxes%YX(i, j, k) !note here di and dj are switched
                endif
        !------------Fluxes in Z direction
                if(Me%External_Var%ComputeFaces3D_W (i, j, k) == Compute) then
                
               
                
                    ![s*m]        = ![s] * [m^4] / [m^3]
                    aux            = dt * az ** 2 / Me%External_Var%Volume_W(i, j, k)

                    if (associated(DecayTimeW)) then
                        if (DecayTimeW(i,j,k)< 1000) aux = 0.01 * aux
                    endif                     
                    
                    ![m3/s]        = ![m^2] * [m/s]
                    fluxZ          = az * Me%Velocity%Vertical%Cartesian(i, j, k)

                    p(i, j, k) = p(i, j, k    ) +  aux   
                    w(i, j, k) = w(i, j, k    ) -  aux
                    ![m3/s]    = [m3/s] + []*[m3/s] + [ ]* [m^2] * [m/s]
                    q(i, j, k) = q(i, j, k    ) + fluxZ 

                    p(i, j, k - 1) = p(i, j, k - 1) + aux
                    e(i, j, k - 1) = e(i, j, k - 1) - aux
                    q(i, j, k - 1) = q(i, j, k - 1) - fluxZ

        !----------------Free-Surface Layer - boundary condition (pressure correction = 0)
                    if (k == KUB) then
                        ![m3/s]    = [m3/s]         + [m]/[s]*[m^2] 
                        q(i, j, k) = q(i, j, k    ) + (Me%WaterLevel%Old(i, j) - Me%WaterLevel%New(i, j)) / dt * az
                        ![s*m]     = [s*m]          + [m^2]/[m/s^2]/[s] 
                        p(i, j, k) = p(i, j, k    ) + az / Gravity / dt
                    endif

                endif
            enddo ! do k
            enddo ! do j
        enddo ! do i
        !
        !----Boundary Condition - Before Solving System
        !call NonHydroOpenBoundary(.True.)

        if (Me%ComputeOptions%WaterDischarges) call NonHydroDischarges
        
        !call NonHydroWallBoundary(      )        

        !
        !----Solve the syste
        call BICGSTAB2D(pc, p, s, n, w, e, q,               &
                          ilb, iub, jlb, jub, klb, kub,     &
                          dj,                               &
                          Me%NonHydroStatic%MaxIt,          &
                          Me%NonHydroStatic%Residual,       &
                          Me%External_Var%OpenPoints3D,     &
                          Me%NonHydroStatic%AlphaLU,        &
                          Me%NonHydroStatic%NormalizedResidual)
        !
        !----Correction (of velocity and water level accordingly to 'pc')
        !
        !----Boundary Condition - After Solving System
        !call NonHydroOpenBoundary(.False.)
        !
        ! CHUNK = CHUNK_J(JLB, JUB)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "NonHydroStaticCorrection")
        
        ! !! $OMP PARALLEL PRIVATE(i,j,k,az,pc1)
        ! !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            ![m^2] = [m]*[m]
            az = Me%External_Var%DUX(i,j) * Me%External_Var%DVY(i,j)
        !--------Correct water level
            if((.not.Me%ComputeOptions%Compute_Tide).or. &
              (Me%External_Var%BoundaryPoints(i, j)/=Boundary)) then
                ![m]= [m^2/s^2]     / [m/s^2]
                pcl = pc(i, j, KUB) / Gravity
                if(abs(pcl)<AllmostZero) pcl = 0. ! only correct after level if pc is something
                ![m]                   = [m]´+ [m]
                Me%WaterLevel%New(i,j) = Me%WaterLevel%New(i,j) + pcl
            end if
            do k = KLB,KUB
        !------------Correct NH pressure correction (itself!)
                Me%NonHydroStatic%PressureCorrect(i,j,k) = pc(i, j, k) - pc(i, j, KUB) 
            enddo !do k             
        enddo !do i
        enddo !do j
        ! !!$OMP END DO
        ! !!$OMP END PARALLEL
        

        ! !!$OMP PARALLEL PRIVATE(i,j,k,pcl)
        ! !!$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            do k = KLB,KUB
        !------------Correct UV - only the direction taken implicit is corrected
                if(Me%External_Var%ComputeFaces3D_UV(i,j,k) == Compute) then 
                    pcl = pc(i - di, j - dj, k) - pc(i     , j     , k)

                    if(abs(pcl)<AllmostZero) pcl = 0. ! only correct velocity if grdient important          
                    ![m/s]                               =  [m/s] + [s]*[m^2/s^2]/[m]
                    Me%Velocity%Horizontal%UV%New(i,j,k) =   Me%Velocity%Horizontal%UV%New(i,j,k)       & 
                                                           + dt * pcl /Me%External_Var%DZX_ZY(i, j) 
                endif
            enddo !do k             
        enddo !do i
        enddo !do j
        ! !! $OMP END DO
        ! !! $OMP END PARALLEL
        
        if (Me%Relaxation%Force) then        

            call UnGetAssimilation (Me%ObjAssimilation, DecayTimeW,  status)

        endif              

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "NonHydroStaticCorrection")
        
        !----restore values on p (avoid divisions by zero at later stages of calculation)
        call SetMatrixValue(p, Me%WorkSize, dble(1.0))

    End Subroutine NonHydroStaticCorrection
    !End------------------------------------------------------------
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !
    ! NonHydroOpenBoundary (null gradient)     
    ! 
    ! ----------------------------
    !
    ! author : Hernâni Theias
    ! last modified  : 06/2004 
    ! e-mail : hernanitheias@netcabo.pt                                                       !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine NonHydroOpenBoundary(PreSolve)
        !Local----------------------------------------------------------------------
        real,    dimension (:,:,:), pointer  :: e,w,s,n   ! coefficient matrix (non-diagonals elements)
        real,    dimension (:,:,:), pointer  :: pc        ! previsional pressure correction
        real(8), dimension (:,:,:), pointer  :: p         ! coefficient matrix (diagonal elements)
        real,    dimension (:,:,:), pointer  :: q         ! independdent term
        integer                              :: i, j, k   ! counters
        integer                              :: ILB, IUB, JLB, JUB, KUB ! bounds
        logical                              :: PreSolve
        ! integer                              :: CHUNK
        
        !Begin----------------------------------------------------------------------
        !----Shorten variables names
        s => Me%Coef%D3%D
        p => Me%Coef%D3%E
        n => Me%Coef%D3%F
        q => Me%Coef%D3%TI
        w => Me%NonHydroStatic%CCoef
        e => Me%NonHydroStatic%GCoef
        pc => Me%NonHydroStatic%PrevisionalQ
        
        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        !Null gradient

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "NonHydroOpenBoundary")

        ! !! $OMP PARALLEL PRIVATE(i,j,k)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        do i = ILB, IUB
        do j = JLB, JUB
            !Y boundary faces
Y1:         if (Me%External_Var%BoundaryFacesV(i, j) == Boundary) then

                ! !! $OMP MASTER
                ! CHUNK = CHUNK_K(Me%External_Var%KFloor_V(i, j), KUB)
                ! !! $OMP END MASTER
                ! !! $OMP BARRIER
                
                ! !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = Me%External_Var%KFloor_V(i, j), KUB

                    if      (Me%External_Var%BoundaryPoints(i-1, j) == Boundary) then
                        
                        if      ((Me%Direction%XY == DirectionY_).and.(PreSolve)) then
                            
                            e(i-1, j, k) =  0.
                            w(i-1, j, k) =  0.
                            p(i-1, j, k) =  1.  
                            s(i-1, j, k) =  0.
                            n(i-1, j, k) = -1.
                            q(i-1, j, k) =  0.
                        
                        else if (Me%Direction%XY == DirectionX_) then
                             
                            if(PreSolve) then ! keep previous value
                              
                                e(i-1, j, k) =  0.
                                w(i-1, j, k) =  0.
                                p(i-1, j, k) =  1.
                                s(i-1, j, k) =  0.
                                n(i-1, j, k) =  0.
                                q(i-1, j, k) =  pc(i - 1, j, k)
                            else ! equal to current neighbour
                                pc(i - 1, j, k) = pc(i, j, k)
                            endif

                        endif

                    else if (Me%External_Var%BoundaryPoints(i, j) == Boundary) then
                  

                        if      ((Me%Direction%XY == DirectionY_).and.(PreSolve))  then
                        
                            e(i, j, k) =  0.
                            w(i, j, k) =  0.
                            p(i, j, k) =  1.
                            s(i, j, k) = -1.
                            n(i, j, k) =  0.
                            q(i, j, k) =  0.

                        else if (Me%Direction%XY == DirectionX_) then
        
                            if(PreSolve) then
                                
                                e(i, j, k) =  0.
                                w(i, j, k) =  0.
                                p(i, j, k) =  1.
                                s(i, j, k) =  0.
                                n(i, j, k) =  0.
                                q(i, j, k) =  pc(i, j, k)
                            else
                                pc(i, j, k) = pc(i - 1, j, k)
                            endif

                        endif
                    
                    endif

                enddo ! do k
                ! !! $OMP END DO 
            endif Y1

            !X boundary faces
X1:         if (Me%External_Var%BoundaryFacesU(i, j) == Boundary) then
                ! !! $OMP MASTER
                ! CHUNK = CHUNK_K(Me%External_Var%KFloor_U(i, j), KUB)
                ! !! $OMP END MASTER
                ! !! $OMP BARRIER
                
                ! !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = Me%External_Var%KFloor_U(i, j), KUB

                    if      (Me%External_Var%BoundaryPoints(i, j - 1) == Boundary) then

                        if((Me%Direction%XY == DirectionX_).and.PreSolve) then
                            e(i, j-1, k) =  0.
                            w(i, j-1, k) =  0.
                            p(i, j-1, k) =  1.
                            s(i, j-1, k) =  0.
                            n(i, j-1, k) = -1.
                            q(i, j-1, k) =  0.
                        else if (Me%Direction%XY == DirectionY_) then
                            if(PreSolve) then
                                e(i, j-1, k) =  0.
                                w(i, j-1, k) =  0.
                                p(i, j-1, k) =  1.
                                s(i, j-1, k) =  0.
                                n(i, j-1, k) =  0.
                                q(i, j-1, k) =  pc(i, j-1, k)
                            else
                                pc(i, j-1, k) = pc(i, j, k)
                            endif
                        endif
                    else if (Me%External_Var%BoundaryPoints(i, j) == Boundary) then
                        if((Me%Direction%XY == DirectionX_).and.PreSolve) then
                            e(i, j, k) =  0.
                            w(i, j, k) =  0.
                            p(i, j, k) =  1.
                            s(i, j, k) = -1.
                            n(i, j, k) =  0.
                            q(i, j, k) =  0.
                        else if (Me%Direction%XY == DirectionY_) then
                            if(PreSolve) then
                                e(i, j, k) =  0.
                                w(i, j, k) =  0.
                                p(i, j, k) =  1.
                                s(i, j, k) =  0.
                                n(i, j, k) =  0.
                                q(i, j, k) =  pc(i, j, k)
                            else
                                pc(i, j, k) = pc(i, j-1, k)
                            endif
                        endif
                    endif

                enddo ! do k
                ! !! $OMP END DO
                
            endif X1
        enddo ! do j
        enddo ! do i
        ! !! $OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "NonHydroOpenBoundary")

        nullify(p)
        nullify(pc)
        nullify(q)
        nullify(e)
        nullify(w)
        nullify(s)
        nullify(n)
    end subroutine NonHydroOpenBoundary
    !End------------------------------------------------------------
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !
    ! NonHydroWallBoundary (null gradient)     
    ! 
    ! ----------------------------
    !
    ! author : Paulo Leitão
    ! last modified  : 04/2012 
    ! e-mail : paulo.chambel@hidromod.com
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine NonHydroWallBoundary()
        !Local----------------------------------------------------------------------
        real,    dimension (:,:,:), pointer  :: e,w,s,n   ! coefficient matrix (non-diagonals elements)
        real,    dimension (:,:,:), pointer  :: pc        ! previsional pressure correction
        real(8), dimension (:,:,:), pointer  :: p         ! coefficient matrix (diagonal elements)
        real,    dimension (:,:,:), pointer  :: q         ! independdent term
        integer                              :: i, j, k, nb   ! counters
        integer                              :: ILB, IUB, JLB, JUB, KUB ! bounds
        ! integer                              :: CHUNK
        
        !Begin----------------------------------------------------------------------
        !----Shorten variables names
        s => Me%Coef%D3%D
        p => Me%Coef%D3%E
        n => Me%Coef%D3%F
        q => Me%Coef%D3%TI
        w => Me%NonHydroStatic%CCoef
        e => Me%NonHydroStatic%GCoef
        pc => Me%NonHydroStatic%PrevisionalQ
        
        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        !Null gradient

        !if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "NonHydroWallBoundary")

        ! !!$OMP PARALLEL PRIVATE(i,j,k,nb)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        do i = ILB, IUB
        do j = JLB, JUB
            !check all open points
X1:         if (Me%External_Var%OpenPoints3D(i, j,KUB) == OpenPoint) then

                ! !!$OMP MASTER
                ! CHUNK = CHUNK_K(Me%External_Var%KFloor_V(i, j), KUB)
                ! !!$OMP END MASTER
                ! !!$OMP BARRIER
                
                ! !!$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = Me%External_Var%KFloor_Z(i, j), KUB
                
                    nb = Me%External_Var%OpenPoints3D(i-1,  j,k  ) + Me%External_Var%OpenPoints3D(i+1,  j,k  ) + &
                         Me%External_Var%OpenPoints3D(i  ,j-1,k  ) + Me%External_Var%OpenPoints3D(i  ,j+1,k  ) + &
                         Me%External_Var%OpenPoints3D(i  ,j  ,k-1) 
                         
                    if (nb == 5) cycle
                    
                    if (Me%ComputeOptions%WaterDischarges) then
                    
                        if (abs(Me%WaterFluxes%Discharges(i, j, k))>1e-15) then
                            cycle
                        endif
                        
                    endif                    
                    
                    !by default pressure correction is nule
                    e(i, j, k) =  0.
                    w(i, j, k) =  0.
                    p(i, j, k) =  1.
                    s(i, j, k) =  0.
                    n(i, j, k) =  0.
                    q(i, j, k) =  0.                    

                    !South wall boundary
                    if      (Me%External_Var%OpenPoints3D(i-1, j,k) /=OpenPoint .and.   &
                             Me%External_Var%OpenPoints3D(i+1, j,k) ==OpenPoint) then
                    
                        if      (Me%Direction%XY == DirectionY_) then
                            n(i, j, k) =  -1.
                        else if (Me%Direction%XY == DirectionX_) then
                            q(i, j, k) =  q(i+1, j, k)
                        endif
                    
                    !North wall boundary
                    elseif  (Me%External_Var%OpenPoints3D(i-1, j,k) ==OpenPoint .and.   &
                             Me%External_Var%OpenPoints3D(i+1, j,k) /=OpenPoint) then
                    
                        if      (Me%Direction%XY == DirectionY_) then
                            s(i, j, k) =  -1.
                        else if (Me%Direction%XY == DirectionX_) then
                            q(i, j, k) =  q(i-1, j, k)
                        endif
                    
                    !West wall boundary
                    elseif  (Me%External_Var%OpenPoints3D(i,j-1,k) /=OpenPoint .and.   &
                             Me%External_Var%OpenPoints3D(i,j+1,k) ==OpenPoint) then
                    
                        if      (Me%Direction%XY == DirectionX_) then
                            n(i, j, k) =  -1.
                        else if (Me%Direction%XY == DirectionY_) then
                            q(i, j, k) =  q(i,j+1, k)
                        endif
                    
                    !East wall boundary
                    elseif  (Me%External_Var%OpenPoints3D(i,j-1,k) ==OpenPoint .and.   &
                             Me%External_Var%OpenPoints3D(i,j+1,k) /=OpenPoint) then
                    
                        if      (Me%Direction%XY == DirectionX_) then
                            s(i, j, k) =  -1.
                        else if (Me%Direction%XY == DirectionY_) then
                            q(i, j, k) =  q(i,j-1, k)
                        endif

                    !bottom wall boundary
                    elseif  (k == Me%External_Var%KFloor_Z(i, j)) then
                        
                        e(i, j, k) =  -1.
                    
                    endif

                                    
                enddo ! do k
                ! !!$OMP END DO
                
            endif X1
        enddo ! do j
        enddo ! do i
        ! !!$OMP END PARALLEL

        !if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "NonHydroWallBoundary")

        nullify(p)
        nullify(pc)
        nullify(q)
        nullify(e)
        nullify(w)
        nullify(s)
        nullify(n)
    end subroutine NonHydroWallBoundary
    !End------------------------------------------------------------

     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !
    ! NonHydroDischarges ()     
    ! 
    ! ----------------------------
    !
    ! author : Paulo Leitão
    ! last modified  : 04/2012 
    ! e-mail : paulo.chambel@hidromod.com
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine NonHydroDischarges()
        !Local----------------------------------------------------------------------
        real,    dimension (:,:,:), pointer  :: e,w,s,n   ! coefficient matrix (non-diagonals elements)
        real,    dimension (:,:,:), pointer  :: pc        ! previsional pressure correction
        real(8), dimension (:,:,:), pointer  :: p         ! coefficient matrix (diagonal elements)
        real,    dimension (:,:,:), pointer  :: q         ! independdent term
        integer                              :: i, j, k   ! counters
        integer                              :: ILB, IUB, JLB, JUB, KUB ! bounds
        ! integer                              :: CHUNK
        
        !Begin----------------------------------------------------------------------
        !----Shorten variables names
        s => Me%Coef%D3%D
        p => Me%Coef%D3%E
        n => Me%Coef%D3%F
        q => Me%Coef%D3%TI
        w => Me%NonHydroStatic%CCoef
        e => Me%NonHydroStatic%GCoef
        pc => Me%NonHydroStatic%PrevisionalQ
        
        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        !if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "NonHydroWallBoundary")

        ! !!$OMP PARALLEL PRIVATE(i,j,k,nb)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        !-------------Discharges

        do i = ILB, IUB
        do j = JLB, JUB
            !check all open points
X1:         if (Me%External_Var%OpenPoints3D(i, j,KUB) == OpenPoint) then

                ! !!$OMP MASTER
                ! CHUNK = CHUNK_K(Me%External_Var%KFloor_V(i, j), KUB)
                ! !!$OMP END MASTER
                ! !!$OMP BARRIER
                
                ! !!$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = Me%External_Var%KFloor_Z(i, j), KUB

                    q(i, j, k) = q(i, j, k) + Me%WaterFluxes%Discharges(i, j, k)
                    
                    !if the flow is positive and the discharge velocity was defined the pressure correction is imposed
!                    if (Me%WaterFluxes%Discharges(i, j, k) > 0. .and. Me%ComputeOptions%MomentumDischarge) then
            
!                        q(i, j, k) = 0.5* (Me%WaterFluxes%DischargesVelU(i, j, k)**2 + Me%WaterFluxes%DischargesVelV(i, j, k)**2)

!                        e(i, j, k) =  0.
!                        w(i, j, k) =  0.
!                        p(i, j, k) =  1.
!                        s(i, j, k) =  0.
!                        n(i, j, k) =  0.

!                    endif
                
                enddo ! do k
                ! !!$OMP END DO
                
            endif X1
        enddo ! do j
        enddo ! do i
        ! !!$OMP END PARALLEL

        !if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "NonHydroDischarges")

        nullify(p)
        nullify(pc)
        nullify(q)
        nullify(e)
        nullify(w)
        nullify(s)
        nullify(n)
    end subroutine NonHydroDischarges
    !End------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !
    ! ComputeCartesianNH
    ! 
    ! ----------------------------
    !
    ! This routine calculates the vertical velocity based divergence equation :
    ! div(V) = 0
    ! The vertical velocity is given by the flux balance at each cell and assuming
    ! that at bottom w = 0, so we can calculate w from bottom to top.
    ! This routine is only used in non-hydrostatic calculations, to match the numerical
    ! scheme followed.
    !
    ! ----------------------------
    !
    ! author : Hernâni Theias
    ! last modified  : 06/2004 
    ! e-mail : hernanitheias@netcabo.pt                                                     
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ComputeCartesianNH
        !Local----------------------------------------------------------------------          
        integer                              :: i, j, k   ! counters
        integer                              :: kbottom   ! cell index at bottom
        real(8)                              :: az        ! cell horizontal area
        real(8)                              :: df        ! horizontal flux balance
        real(8)                              :: db        ! velocity of the lower cell
        real(8)                              :: discharge ! discharge flux
        integer                              :: kub       ! upper cell index
        ! integer                              :: CHUNK
        
        !Begin----------------------------------------------------------------------

        ! CHUNK = CHUNK_I(Me%WorkSize%ILB, Me%WorkSize%IUB)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ComputeCartesianNH")
        
        ! !! $OMP PARALLEL PRIVATE(i,j,k,kbottom,kub,az,df,discharge)
        ! !! $OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            if(Me%External_Var%OpenPoints3d(i,j, Me%WorkSize%KUB) == OpenPoint) then
                kbottom = Me%External_Var%KFloor_Z(i,j)
                if((Me%ComputeOptions%Compute_Tide).and. &
                   (Me%External_Var%BoundaryPoints(i, j)==Boundary)) then
                    kub = Me%WorkSize%KUB
                else
                    kub = Me%WorkSize%KUB + 1
                endif
                Me%Velocity%Vertical%Cartesian(i,j,kbottom) = 0.
                az = Me%External_Var%DUX(i,j) * Me%External_Var%DVY(i,j)
                do k = kbottom + 1, kub
                    discharge = 0.
                    if(Me%ComputeOptions%WaterDischarges) &
                        discharge = Me%WaterFluxes%Discharges(i, j, k-1)
                    df =   Me%WaterFluxes%X(i    , j    , k - 1)                        &
                         - Me%WaterFluxes%X(i    , j + 1, k - 1)                        &
                         + Me%WaterFluxes%Y(i    , j    , k - 1)                        &
                         - Me%WaterFluxes%Y(i + 1, j    , k - 1)                        &
                         + discharge                     
                    !dw = Me%Velocity%Vertical%CartesianOld(i,j,k-1) - Me%Velocity%Vertical%CartesianOld(i,j,k)                         
                    db = Me%Velocity%Vertical%Cartesian   (i,j,k - 1)
                    Me%Velocity%Vertical%Cartesian(i,j,k) =  db + df / az
                enddo
            endif
        enddo
        enddo
        ! !! $OMP END DO
        ! !! $OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ComputeCartesianNH")
        
        if (Me%CyclicBoundary%ON) then !in case of cyclic boundary
            call CyclicBoundVertical (Vector = Me%Velocity%Vertical%Cartesian)
        endif
    
    End Subroutine
    !End------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ReadHydrodynamicFile 


        !Arguments-------------------------------------------------------------------
        


        !Local----------------------------------------------------------------------
        real,    dimension(:,:),   pointer :: WaterLevel
        real(8), dimension(:,:,:), pointer :: WaterFluxX, WaterFluxY, Discharges
        integer, dimension(:,:,:), pointer :: ComputeFaces3DU, ComputeFaces3DV

        integer :: STAT_CALL


        !Begin----------------------------------------------------------------------


        !Reads new Instant
        call ModifyHydrodynamicFile(Me%ObjHydrodynamicFileIn, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR01' 


        !Gets actual WaterLevel
        call GetFileWaterLevel(Me%ObjHydrodynamicFileIn, WaterLevel, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR02' 


        !Actualizes Hydrodynamic
        Me%WaterLevel%New = WaterLevel


        !With the new WaterLevel, recalculate Geometry
        !Notice: This wont work if the coordinate is of the type Lagrangian
        call New_Geometry


        !Gets Horizontal Fluxes from file
        call GetFileFluxes(Me%ObjHydrodynamicFileIn,                        &
                           WaterFluxX = WaterFluxX,                                      &
                           WaterFluxY = WaterFluxY,                                      &
                           Discharges = Discharges,                                      &
                           STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR03' 

        call SetMatrixValue(Me%WaterFluxes%X,          Me%Size, WaterFluxX) 
        call SetMatrixValue(Me%WaterFluxes%Y,          Me%Size, WaterFluxY) 
        call SetMatrixValue(Me%WaterFluxes%Discharges, Me%Size, Discharges) 

        !Calculates horizontal velocities, given the fluxes
        call Compute_VelocityFromFluxes


        !Gets the Mapping from the file
        call GetFileMapping(Me%ObjHydrodynamicFileIn,                       &
                            ComputeFaces3DU,                                             &
                            ComputeFaces3DV,                                             &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR04' 


        !Modifies Mapping, acording to the one in the file
        call ReadUnLock_ModuleMap
        call SetComputesFaces3D(Me%ObjMap,                                  &
                                ComputeFaces3DU,                                         &
                                ComputeFaces3DV,                                         &
                                Me%CurrentTime,                             &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR05' 
        call ReadLock_ModuleMap


        !Calculates the vertical hydrodynamic
        call New_VerticalHydrodynamic( Grid = Variable)

        !WaterLevel
        call UnGetHydrodynamicFile (Me%ObjHydrodynamicFileIn,               &
                                    WaterLevel, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR06' 


        !WaterFluxX
        call UnGetHydrodynamicFile (Me%ObjHydrodynamicFileIn,               &
                                    WaterFluxX, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR07' 

        !WaterFluxY
        call UnGetHydrodynamicFile (Me%ObjHydrodynamicFileIn,               &
                                    WaterFluxY, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR08' 

        !Discharges
        call UnGetHydrodynamicFile (Me%ObjHydrodynamicFileIn,               &
                                    Discharges, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR09' 

        !ComputeFaces3DU
        call UnGetHydrodynamicFile (Me%ObjHydrodynamicFileIn,               &
                                    ComputeFaces3DU, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR10' 

        !ComputeFaces3DV
        call UnGetHydrodynamicFile (Me%ObjHydrodynamicFileIn,               &
                                    ComputeFaces3DU, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR11' 


    end subroutine ReadHydrodynamicFile
    
    !End----------------------------------------------------------------------


    subroutine New_Geometry

        !Arguments------------------------------------------------------------

        !Local----------------------------------------------------------------
        integer, dimension(:,:,:), pointer  :: WaterPoints3D
        real,    dimension(:,:  ), pointer  :: SurfaceElevation
        real,    dimension(:,:,:), pointer  :: Velocity_Z, DecayTime
        real                                :: DT_WaterLevel
        real                                :: ColdPeriod, ColdOrder, DT_RunPeriod, CoefCold
        integer                             :: i, j, k, kbottom, STAT_CALL
        integer                             :: CHUNK

        !Begin----------------------------------------------------------------
        
        WaterPoints3D    => Me%External_Var%WaterPoints3D

        SurfaceElevation => Me%WaterLevel%New

        Velocity_Z       => Me%Velocity%Vertical%Across

        DT_WaterLevel    =  Me%WaterLevel%DT

        if (Me%Relaxation%Geometry) then 

            call GetAssimilationCoef (Me%ObjAssimilation,                               &
                                      ID              = VerticalZ_,                     &
                                      CoefField3D     = DecayTime,                      &
                                      ColdRelaxPeriod = ColdPeriod,                     &
                                      ColdOrder       = ColdOrder,                      &
                                      STAT            = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                 stop 'Subroutine New_Geometry; Module ModuleHydrodynamic. ERR10' 


            DT_RunPeriod = Me%CurrentTime - Me%BeginTime

            if (ColdPeriod > (Me%EndTime - Me%BeginTime))                               &
                stop 'Subroutine New_Geometry; Module ModuleHydrodynamic. ERR20' 

cd4:        if (ColdPeriod <= DT_RunPeriod) then
                CoefCold = 1
            else  cd4
                CoefCold = (DT_RunPeriod / ColdPeriod) ** ColdOrder
                if (CoefCold < 1.e-32) CoefCold = 1.e-32
            endif cd4

            CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
        
            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "New_Geometry")
            endif
        
            !$OMP PARALLEL PRIVATE(i,j,k,kbottom)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            
            kbottom = Me%External_Var%KFloor_Z(i, j)

                if (WaterPoints3D(i, j, Me%WorkSize%KUB) == WaterPoint) then
                    do k = kbottom, Me%WorkSize%KUB
                        Me%Relaxation%DecayTimeGeo(i, j, k) = CoefCold * DecayTime(i, j, k)
                    enddo
                endif

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "New_Geometry")
            endif

        endif



        !call ReadUnLock_ModuleHorizontalGrid 


        !call ReadUnLock_ModuleHorizontalMap 


        !call ReadUnLock_ModuleGeometry 

        
        call ReadUnLock_External_Modules 

        if (Me%Relaxation%Geometry) then 

            !Compute new volume 
            call ComputeVerticalGeometry(Me%ObjGeometry, WaterPoints3D,                     &
                                         SurfaceElevation, Me%CurrentTime,                  &
                                         Velocity_Z, DT_WaterLevel,                         &
                                         DecayTime = DecayTime, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                      &
                 stop 'Subroutine New_Geometry; Module ModuleHydrodynamic. ERR30' 
        else
        
            call ComputeVerticalGeometry(Me%ObjGeometry, WaterPoints3D,                     &
                                         SurfaceElevation, Me%CurrentTime,                  &
                                         Velocity_Z, DT_WaterLevel,                         &
                                         STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                      &
                 stop 'Subroutine New_Geometry; Module ModuleHydrodynamic. ERR40' 
        
        endif

        !Nullify auxliar pointers
        nullify(SurfaceElevation, WaterPoints3D, Velocity_Z)


!        call ReadUnLock_ModuleMap 


        !Update the moving boundary  (boundary of the tidal areas covered)
!        call UpdateComputeFaces3D(Me%ObjMap, &
!             Me%CurrentTime, STAT = STAT_CALL)      

!        if (STAT_CALL /= SUCCESS_)                                           &
!            stop 'Subroutine New_Geometry; module ModuleHydrodynamic. ERR02.'


        call ReadLock_External_Modules 

        if (Me%Relaxation%Geometry) then 

            call UnGetAssimilation   (Me%ObjAssimilation,                               &
                                      DecayTime,                                        &
                                      STAT        = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine New_Geometry; Module ModuleHydrodynamic. ERR50' 


        endif




    end subroutine New_Geometry
    
    !End----------------------------------------------------------------------

    subroutine New_VerticalHydrodynamic( Grid)

        !Arguments------------------------------------------------------------

        integer                          :: Grid

        !Local----------------------------------------------------------------

        !Begin----------------------------------------------------------------
        
        !Grid = Fix = 1
        !First prediction of the vertical fluxes and velocity for a fixed geometry
        !This is only important when one of the domains as vertical "Lagrangian" coordinate

        !Grid = Variable = 2 
        !the vertical water flux is compute with the effect of variable volume
        call Modify_VerticalWaterFlow (Grid)

        call Filter_3D_Fluxes         
    
        call Compute_VerticalVelocity 

        if(Me%NonHydroStatic%ON) then
            call ComputeCartesianNH
        else
            call ComputeCartesianVertVelocity(Grid = Grid)
        endif

        call Boundary_VerticalFlow (Grid)

        if (Me%CyclicBoundary%ON) then

            call CyclicBoundVertical (VectorD = Me%WaterFluxes%Z)

        endif

    
    end subroutine New_VerticalHydrodynamic
    
    !End----------------------------------------------------------------------



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Leendertse_Scheme

        !Arguments------------------------------------------------------------
         

        !Local----------------------------------------------------------------

        !Begin----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Leendertse_Scheme")

        call MaintainDirection   
        
        call Explicit_Forces  

        call Compute_Velocity 
        ! Water Flux must be consistent with the water level equation 
        Me%WaterFluxes%New_Old = 0.

        call Modify_HorizontalWaterFlow


        !Same direction of the water level direction 

        call ChangeDirection  
        
        call Bottom_Boundary    

        call Explicit_Forces    

        call Compute_WaterLevel 
        
        call Compute_Velocity   

        ! Water Flux must be consistent with the water level equation 
        Me%WaterFluxes%New_Old = 1.

        call Modify_HorizontalWaterFlow


!        !Modify the Background velocity if the boundary relaxation scheme is ON
!        if (Me%Relaxation%Velocity)                                  &
!            call ModifyBackgroundVelocity 

        if (.not. Me%NonHydrostatic%ON) call NullifyAuxiliarPointers

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Leendertse_Scheme")

    End Subroutine Leendertse_Scheme

    !End------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Abbott_Scheme

        !Arguments------------------------------------------------------------
         

        !Local----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Abbott_Scheme")

        call ChangeDirection
        
        call Bottom_Boundary    

        call Explicit_Forces    

        call Compute_WaterLevel 

        call Compute_Velocity   


        ! Water Flux must be consistent with the water level equation 
        Me%WaterFluxes%New_Old = 0.5

        call Modify_HorizontalWaterFlow


!        !Modify the Background velocity if the boundary relaxation scheme is ON
!        if (Me%Relaxation%Velocity)                                  &
!            call ModifyBackgroundVelocity 
        
        if (.not. Me%NonHydrostatic%ON) call NullifyAuxiliarPointers


        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Abbott_Scheme")

    
    End Subroutine Abbott_Scheme

    !End---------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (2006/1)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Implicit_1DScheme

        !Arguments------------------------------------------------------------
         

        !Local----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Implicit_1DScheme")
        
        call Bottom_Boundary    

        call Explicit_Forces    

        call Compute_WaterLevel 

        call Compute_Velocity   


        ! Water Flux must be consistent with the water level equation 
        Me%WaterFluxes%New_Old = 1.

        call Modify_HorizontalWaterFlow

        if (.not. Me%NonHydrostatic%ON) call NullifyAuxiliarPointers


        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Implicit_1DScheme")

    
    End Subroutine Implicit_1DScheme

    !End---------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Direction                                                                    !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine  ChangeDirection

        !Arguments------------------------------------------------------------


        !Local----------------------------------------------------------------
        integer :: Previous_Direction 

        !Begin----------------------------------------------------------------

        Previous_Direction = Me%Direction%XY

        if (Previous_Direction == DirectionX_) then

             call AssociateDirectionY

        else if (Previous_Direction == DirectionY_) then
             
             call AssociateDirectionX

        endif 

        Me%NonHydrostatic%ThetaUV = 1 


    End Subroutine  ChangeDirection

    !End------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Direction                                                                    !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine  MaintainDirection

        !Arguments------------------------------------------------------------


        !Local----------------------------------------------------------------
        integer :: Previous_Direction 

        !Begin----------------------------------------------------------------

        Previous_Direction = Me%Direction%XY

        if (Previous_Direction == DirectionX_) then

             call AssociateDirectionX

        else if (Previous_Direction == DirectionY_) then
             
             call AssociateDirectionY

        endif 

        !NonHydrostatic
        Me%NonHydrostatic%ThetaUV = 0

    End Subroutine  MaintainDirection

    !End------------------------------------------------------------



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Direction                                                                    !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine  AssociateDirectionY

        !Arguments------------------------------------------------------------



        !Begin----------------------------------------------------------------
         nullify(Me%External_Var%ComputeFaces3D_UV)         
         nullify(Me%External_Var%ComputeFaces3D_VU)
         Me%Direction%XY   =  DirectionY_
         Me%Direction%YX   =  DirectionX_
         Me%Direction%di   =  1
         Me%Direction%dj   =  0    

         !Baroclinic 
         Me%Forces%Rox3XY  => Me%Forces%Rox3Y

         !Flow
         Me%Velocity%Horizontal%UV%Old  => &
         Me%Velocity%Horizontal%V%Old

         Me%Velocity%Horizontal%UV%New  => &
         Me%Velocity%Horizontal%V%New


         Me%Velocity%Horizontal%VU%Old  => &
         Me%Velocity%Horizontal%U%Old

         Me%Velocity%Horizontal%VU%New  => &
         Me%Velocity%Horizontal%U%New

         if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then
         
             Me%VelBaroclinic%UV%Old  => &
             Me%VelBaroclinic%V%Old

             Me%VelBaroclinic%UV%New  => &
             Me%VelBaroclinic%V%New


             Me%VelBaroclinic%VU%Old  => &
             Me%VelBaroclinic%U%Old

             Me%VelBaroclinic%VU%New  => &
             Me%VelBaroclinic%U%New

             Me%VelBaroclinic%ImposedNormXY  => &
             Me%VelBaroclinic%ImposedNormY

             Me%VelBaroclinic%ImposedTangXY  => &
             Me%VelBaroclinic%ImposedTangY

             Me%VelBaroclinic%UV2D  => &
             Me%VelBaroclinic%V2D
         
         
         endif   


         Me%WaterFluxes%XY              => &
         Me%WaterFluxes%Y

         Me%WaterFluxes%YX              => &
         Me%WaterFluxes%X
         
         if (Me%ComputeOptions%MomentumDischarge) then
            Me%WaterFluxes%DischargesVelUV => &
            Me%WaterFluxes%DischargesVelV  
         endif

         !3D geometry
         Me%External_Var%Volume_UV => &
         Me%External_Var%Volume_V  

         Me%External_Var%Area_UV   => &
         Me%External_Var%Area_V

         Me%External_Var%Area_VU   => &
         Me%External_Var%Area_U

         Me%External_Var%KFloor_UV => &
         Me%External_Var%KFloor_V

         Me%External_Var%KFloor_VU => &
         Me%External_Var%KFloor_U

         Me%External_Var%WaterColumnUV => &
         Me%External_Var%WaterColumnV

         Me%External_Var%WaterColumnVU => &
         Me%External_Var%WaterColumnU

         Me%External_Var%DUZ_VZ        => &
         Me%External_Var%DVZ

         !Horizontal grid
         Me%External_Var%DZX_ZY    => &
         Me%External_Var%DZY

         Me%External_Var%DZY_ZX    => &
         Me%External_Var%DZX

         Me%External_Var%DXX_YY    => &
         Me%External_Var%DYY

         Me%External_Var%DUX_VY    => &
         Me%External_Var%DVY

         Me%External_Var%DVY_UX    => &
         Me%External_Var%DUX

         Me%External_Var%DYY_XX    => &
         Me%External_Var%DXX

         !3D Mapping
         Me%External_Var%ComputeFaces3D_UV   => &
         Me%External_Var%ComputeFaces3D_V

         Me%External_Var%ComputeFaces3D_VU   => &
         Me%External_Var%ComputeFaces3D_U

         Me%External_Var%LandBoundaryFacesUV => &
         Me%External_Var%LandBoundaryFacesV

         Me%External_Var%LandBoundaryFacesVU => &
         Me%External_Var%LandBoundaryFacesU

!         Me%External_Var%UnCoveredFaces3D_UV   => &
!         Me%External_Var%UnCoveredFaces3D_V



         Me%External_Var%BoundaryFacesUV     => &
         Me%External_Var%BoundaryFacesV


         Me%External_Var%BoundaryFacesVU     => &
         Me%External_Var%BoundaryFacesU

         Me%External_Var%ImposedTangentialFacesUV  => &
         Me%External_Var%ImposedTangentialFacesV

         Me%External_Var%ImposedTangentialFacesVU  => &
         Me%External_Var%ImposedTangentialFacesU


         Me%External_Var%ImposedNormalFacesUV  => &
         Me%External_Var%ImposedNormalFacesV


         !Wind
         if (Me%ComputeOptions%Wind /= NoWind_) &
            Me%External_Var%TauWind_UV       => &
            Me%External_Var%TauWindV

         !if (Me%Relaxation%Velocity)         then
            
            !Me%Relaxation%ReferenceVelUV  => &
            !Me%Relaxation%ReferenceVelV
            
            !Me%Relaxation%BackgroundVelUV  => &
            !Me%Relaxation%BackgroundVelV

         !endif
        
        if (Me%SubModel%ON)   then

            Me%SubModel%UV_New   => Me%SubModel%V_New
            Me%SubModel%UV_Old   => Me%SubModel%V_Old
            Me%SubModel%DUVZ_Old => Me%SubModel%DVZ_Old
            Me%SubModel%qXY      => Me%SubModel%qY
            Me%SubModel%qYX      => Me%SubModel%qX
                    
        endif


         !Waves
         if (Me%ComputeOptions%WaveStress) then
            Me%External_Var%TauWaves_UV => Me%External_Var%TauWavesV
         endif


        if( Me%Geostroph%ON)  then
            Me%Geostroph%UV  => Me%Geostroph%V
            Me%Geostroph%VU  => Me%Geostroph%U
        endif


    End Subroutine  AssociateDirectionY

    !End------------------------------------------------------------



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Direction                                                                    !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine  AssociateDirectionX

        !Arguments------------------------------------------------------------




        !Begin----------------------------------------------------------------
         nullify(Me%External_Var%ComputeFaces3D_UV)
         nullify(Me%External_Var%ComputeFaces3D_VU)        
         Me%Direction%XY   =  DirectionX_
         Me%Direction%YX   =  DirectionY_
         Me%Direction%di   =  0
         Me%Direction%dj   =  1   

         !Baroclinic 
         Me%Forces%Rox3XY  => Me%Forces%Rox3X

         !Flow
         Me%Velocity%Horizontal%UV%Old  => &
         Me%Velocity%Horizontal%U%Old

         Me%Velocity%Horizontal%UV%New  => &
         Me%Velocity%Horizontal%U%New


         Me%Velocity%Horizontal%VU%Old  => &
         Me%Velocity%Horizontal%V%Old

         Me%Velocity%Horizontal%VU%New  => &
         Me%Velocity%Horizontal%V%New

         if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then
         
             Me%VelBaroclinic%UV%Old  => &
             Me%VelBaroclinic%U%Old

             Me%VelBaroclinic%UV%New  => &
             Me%VelBaroclinic%U%New


             Me%VelBaroclinic%VU%Old  => &
             Me%VelBaroclinic%V%Old

             Me%VelBaroclinic%VU%New  => &
             Me%VelBaroclinic%V%New


             Me%VelBaroclinic%ImposedNormXY  => &
             Me%VelBaroclinic%ImposedNormX

             Me%VelBaroclinic%ImposedTangXY  => &
             Me%VelBaroclinic%ImposedTangX

             Me%VelBaroclinic%UV2D  => &
             Me%VelBaroclinic%U2D
      
         
         endif   

         Me%WaterFluxes%XY              => &
         Me%WaterFluxes%X
         
         Me%WaterFluxes%YX              => &
         Me%WaterFluxes%Y
         
         if (Me%ComputeOptions%MomentumDischarge) then
            Me%WaterFluxes%DischargesVelUV => &
            Me%WaterFluxes%DischargesVelU  
         endif
         

         !3D Geometry
         Me%External_Var%Volume_UV => &
         Me%External_Var%Volume_U  

         Me%External_Var%Area_UV   => &
         Me%External_Var%Area_U

         Me%External_Var%Area_VU   => &
         Me%External_Var%Area_V

         Me%External_Var%WaterColumnUV => &
         Me%External_Var%WaterColumnU

         Me%External_Var%WaterColumnVU => &
         Me%External_Var%WaterColumnV

         Me%External_Var%DUZ_VZ        => &
         Me%External_Var%DUZ


         Me%External_Var%KFloor_UV => &
         Me%External_Var%KFloor_U

         Me%External_Var%KFloor_VU => &
         Me%External_Var%KFloor_V

         !Horizontal Grid
         Me%External_Var%DZX_ZY    => &
         Me%External_Var%DZX

         Me%External_Var%DZY_ZX    => &
         Me%External_Var%DZY


         Me%External_Var%DXX_YY    => &
         Me%External_Var%DXX

         Me%External_Var%DUX_VY    => &
         Me%External_Var%DUX

         Me%External_Var%DVY_UX    => &
         Me%External_Var%DVY

         Me%External_Var%DYY_XX    => &
         Me%External_Var%DYY


         !3D Mapping
         Me%External_Var%ComputeFaces3D_UV   => &
         Me%External_Var%ComputeFaces3D_U

         Me%External_Var%ComputeFaces3D_VU   => &
         Me%External_Var%ComputeFaces3D_V

         Me%External_Var%LandBoundaryFacesUV => &
         Me%External_Var%LandBoundaryFacesU

         Me%External_Var%LandBoundaryFacesVU => &
         Me%External_Var%LandBoundaryFacesV

!         Me%External_Var%UnCoveredFaces3D_UV   => &
!         Me%External_Var%UnCoveredFaces3D_U

         !Horizontal Mapping

         Me%External_Var%BoundaryFacesUV     => &
         Me%External_Var%BoundaryFacesU

         Me%External_Var%BoundaryFacesVU     => &
         Me%External_Var%BoundaryFacesV


         Me%External_Var%ImposedTangentialFacesUV  => &
         Me%External_Var%ImposedTangentialFacesU

         Me%External_Var%ImposedTangentialFacesVU  => &
         Me%External_Var%ImposedTangentialFacesV

         Me%External_Var%ImposedNormalFacesUV      => &
         Me%External_Var%ImposedNormalFacesU


         !Wind
         if (Me%ComputeOptions%Wind /= NoWind_) &
            Me%External_Var%TauWind_UV       => &
            Me%External_Var%TauWindU


!         if (Me%Relaxation%Velocity)         then

!            Me%Relaxation%ReferenceVelUV  => &
!            Me%Relaxation%ReferenceVelU

!            Me%Relaxation%BackgroundVelUV  => &
!            Me%Relaxation%BackgroundVelU      

!         endif

        if (Me%SubModel%ON)   then

            Me%SubModel%UV_New   => Me%SubModel%U_New
            Me%SubModel%UV_Old   => Me%SubModel%U_Old
            Me%SubModel%DUVZ_Old => Me%SubModel%DUZ_Old
            Me%SubModel%qXY      => Me%SubModel%qX
            Me%SubModel%qYX      => Me%SubModel%qY
                    
        endif

        
        !Waves
        if (Me%ComputeOptions%WaveStress) then
            Me%External_Var%TauWaves_UV => Me%External_Var%TauWavesU
        endif
        


        if( Me%Geostroph%ON)  then
            Me%Geostroph%UV  => Me%Geostroph%U
            Me%Geostroph%VU  => Me%Geostroph%V
        endif

    End Subroutine  AssociateDirectionX

    !End------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Direction                                                                    !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine  NullifyAuxiliarPointers

        !Arguments------------------------------------------------------------




        !Begin----------------------------------------------------------------


         nullify(Me%Forces%Rox3XY)

         !Flow
         nullify(Me%Velocity%Horizontal%UV%Old)

         nullify(Me%Velocity%Horizontal%UV%New)

         nullify(Me%Velocity%Horizontal%VU%Old)

         nullify(Me%Velocity%Horizontal%VU%New)

         nullify(Me%WaterFluxes%XY)

         nullify(Me%WaterFluxes%YX)
         
         nullify(Me%WaterFluxes%DischargesVelUV)
         
         !3D Geometry
         nullify(Me%External_Var%Volume_UV)

         nullify(Me%External_Var%Area_UV)

         nullify(Me%External_Var%Area_VU)

         nullify(Me%External_Var%KFloor_UV)

         nullify(Me%External_Var%KFloor_VU)

         nullify(Me%External_Var%WaterColumnUV)

         nullify(Me%External_Var%WaterColumnVU)

         !Horizontal Grid
         nullify(Me%External_Var%DZX_ZY)

         nullify(Me%External_Var%DZY_ZX)

         nullify(Me%External_Var%DXX_YY)

         nullify(Me%External_Var%DUX_VY)

         nullify(Me%External_Var%DVY_UX)

         nullify(Me%External_Var%DYY_XX)


         !3D Mapping
         nullify(Me%External_Var%ComputeFaces3D_UV)

         nullify(Me%External_Var%ComputeFaces3D_VU)

         nullify(Me%External_Var%LandBoundaryFacesUV)

!         nullify(Me%External_Var%UnCoveredFaces3D_UV)

         !Horizontal Mapping

         nullify(Me%External_Var%BoundaryFacesUV)

         nullify(Me%External_Var%BoundaryFacesVU)

         !Wind
         if (Me%ComputeOptions%Wind /= NoWind_) &
            nullify(Me%External_Var%TauWind_UV)

      
         !Reference velocities
!         if (Me%Relaxation%Velocity)         then

!            nullify(Me%Relaxation%ReferenceVelUV)

!            nullify(Me%Relaxation%BackgroundVelUV)      

!         endif


         !Waves
         if (Me%ComputeOptions%WaveStress) then
            nullify(Me%External_Var%TauWaves_UV)
        endif



    End Subroutine  NullifyAuxiliarPointers

    !End------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the effect of all the explicit forces ( Baroclinic and      !
    !  barotropic water pressure, Coriolis, Atmospheric pressure,                          !
    !  Horizontal transport - covection + diffusion)                                       !
    !  in the velocity evolution                                                           !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping, Forces                                              !
    ! OutPut: TiCoef_3D                                                                      !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Compute_Velocity 

        !Variables Categories  
            !Geometry  : WaterLevel_New, DUX_VY, DZX_ZY 
            !WaterProp : Density
            !Forces    : Inertial_Aceleration, Horizontal_Transport, ROX3, AtmPressure 
            !Time      : DT_Velocity
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : TiCoef_3D

         
        !Variables Direction Dependent
            !DUX_VY, DZX_ZY, ComputeFaces3D_UV, KFloor_UV, Direction


        !Arguments------------------------------------------------------------


        !Local----------------------------------------------------------------
        real(8), dimension(:,:,:), pointer  :: ECoef_3D
        real,    dimension(:,:,:), pointer  :: DCoef_3D, FCoef_3D, TiCoef_3D, &
                                               Velocity_UV_Old, Velocity_UV_New
        integer, dimension(:,:,:), pointer  :: ComputeFaces3D_UV, LandBoundaryFacesUV, &
                                               WaterPoints3D

        integer                             :: IJmin, IJmax, JImin, JImax, di, dj
        
        integer                             :: i, j, k, IUB, ILB, JUB, JLB, KUB, KLB

        integer                             :: FaceAdjacentToWater, Coef
        
        integer                             :: CHUNK
        !Begin----------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di          =  Me%Direction%di
        dj          =  Me%Direction%dj


        DCoef_3D  => Me%Coef%D3%D
        ECoef_3D  => Me%Coef%D3%E
        FCoef_3D  => Me%Coef%D3%F
        TiCoef_3D => Me%Coef%D3%Ti

        ComputeFaces3D_UV   => Me%External_Var%ComputeFaces3D_UV
        LandBoundaryFacesUV => Me%External_Var%LandBoundaryFacesUV

        Velocity_UV_Old => Me%Velocity%Horizontal%UV%Old
        Velocity_UV_New => Me%Velocity%Horizontal%UV%New

        WaterPoints3D   => Me%External_Var%WaterPoints3D


        !End   - Shorten variables name

        call SetMatrixValue(DCoef_3D,  Me%WorkSize,      0.0       )
        call SetMatrixValue(ECoef_3D,  Me%WorkSize, dble(1.0)      )
        call SetMatrixValue(FCoef_3D,  Me%WorkSize,      0.0       )
        call SetMatrixValue(TICoef_3D, Me%WorkSize, Velocity_UV_Old)


        call Velocity_ExplicitForces  


        call VelVerticalDiffusionBoundaries 


        if (KUB > 1) then

            if (Me%ComputeOptions%VerticalDiffusion)                        &
                call Velocity_VerticalDiffusion  

            if (Me%ComputeOptions%VerticalAdvection)                        &
                call Velocity_VerticalAdvection 

        endif

        if (Me%ComputeOptions%WaveStress) then

            call Velocity_WaveStress

        endif

        CHUNK = CHUNK_J(JLB,JUB)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Compute_Velocity")

        !$OMP PARALLEL PRIVATE(i,j,k,Coef,FaceAdjacentToWater)

        do  k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB
            ! Large values (FillReal_Value) in non covered faces  
            TiCoef_3D (i, j, k) = TiCoef_3D (i, j, k) * ComputeFaces3D_UV(i, j, k) +     &
                                  (1. - ComputeFaces3D_UV(i, j, k)) * FillValueReal                     

            ! Land boundary condition - velocity zero in faces that 
            ! have water in one side and land in another 
            TiCoef_3D (i, j, k) = TiCoef_3D (i, j, k) * (1. - LandBoundaryFacesUV(i, j, k))

            ! UnCovered faces condition - velocity zero in faces that 
            ! are uncovered
            !The UncoveredFaces disapaered from the module map

!            TiCoef_3D (i, j, k) = TiCoef_3D (i, j, k) * (1. - UnCoveredFacesUV(i, j, k))

            Coef = WaterPoints3D(i, j, k) + WaterPoints3D(i-di, j-dj, k)

            if (Coef > 0) Coef = 1

            FaceAdjacentToWater = (1. - ComputeFaces3D_UV(i, j, k)) * Coef
                            
            TiCoef_3D (i, j, k) = TiCoef_3D (i, j, k) * (1 - FaceAdjacentToWater)

            
        enddo
        enddo
        !$OMP END DO
        enddo
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Compute_Velocity")

cd2D:   if (KUB == 1) then !If the model is 2D then the implicit direction is in the horizontal

            IJmin = ILB * dj + JLB * di
            IJmax = IUB * dj + JUB * di

            JImin = ILB * di + JLB * dj
            JImax = IUB * di + JUB * dj


            !griflet: olds call
            !call THOMAS_3D(IJmin, IJmax, JImin, JImax, KLB, KUB, di, dj,                 &
            !               DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D, Velocity_UV_New,     &
            !               Me%VECG_3D, Me%VECW_3D)
            !griflet: new call
            call THOMAS_3D(IJmin, IJmax, JImin, JImax, KLB, KUB, di, dj,                &
                           Me%THOMAS, Velocity_UV_New                                   &
#ifdef _ENABLE_CUDA
                           , Me%ObjCuda,                                                &
                           .FALSE.                                                      &
#endif _ENABLE_CUDA
                           )
        else cd2D ! The implicit direction is in the vertical


            ! Vertical direction implicit
            !griflet: old call
            !call THOMASZ(ILB, IUB, JLB, JUB, KLB, KUB, DCoef_3D, ECoef_3D,               &
            !             FCoef_3D, TiCoef_3D, Velocity_UV_New,                           &
            !             Me%VECG_3D, Me%VECW_3D)
            !griflet: new call

            ! Use CUDA to solve the Thomas algorithm, ID of ModuleCuda is needed
            ! Save results while computing velocity in X direction
            call THOMASZ(ILB, IUB, JLB, JUB, KLB, KUB, Me%THOMAS, Velocity_UV_New       &
#ifdef _ENABLE_CUDA
                         , Me%ObjCuda,                                                  &
                         .FALSE.                                                        &
#endif _ENABLE_CUDA
                        )

        endif cd2D

        call InstantMixingSmallDepths

        call Velocity_OpenBoundary 

        if (Me%CyclicBoundary%ON)  then

            if (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                Me%CyclicBoundary%Direction == DirectionXY_)  then
                call CyclicBoundVectNormal    ( Vector = Velocity_UV_New)
            endif

            if (Me%CyclicBoundary%Direction == Me%Direction%YX .or. &
                Me%CyclicBoundary%Direction == DirectionXY_)  then
                call CyclicBoundVectTangential( Vector = Velocity_UV_New)
            endif

        endif


        !PCL
        if (Me%Relaxation%Velocity)                                         &
            call VelocityRelaxation 


        !Nullify auxiliar variables
        nullify (DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D)

        nullify (WaterPoints3D, LandBoundaryFacesUV)

        nullify (Velocity_UV_Old, Velocity_UV_New)

    end Subroutine Compute_Velocity

    !------------------------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine mixes instantaniously the watercolumn in small depths               ! 
    !                                                                                      !
    ! Input : Flow, Geometry                                                               !
    ! OutPut: VelocityU, V                                                                 !
    ! Author: Frank (00/10)                                                                !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine InstantMixingSmallDepths
        
        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        real,    dimension(:, :, :), pointer        :: Area_UV
        real,    dimension(:, :, :), pointer        :: Velocity_UV_New
        real,    dimension(:, :   ), pointer        :: WaterColumnUV
        integer, dimension(:, :, :), pointer        :: ComputeFaces3D_UV
        integer, dimension(:, :   ), pointer        :: KFloor_UV
        real(8)                                     :: TotalArea, TotalFlux
        real                                        :: WaterColumn2D
        integer                                     :: ILB, IUB, i
        integer                                     :: JLB, JUB, j
        integer                                     :: Kbottom, KUB, k
        integer                                     :: CHUNK
        
        !Begin-----------------------------------------------------------------
        ILB                  =  Me%WorkSize%ILB
        IUB                  =  Me%WorkSize%IUB
        JLB                  =  Me%WorkSize%JLB
        JUB                  =  Me%WorkSize%JUB
        KUB                  =  Me%WorkSize%KUB
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D
        
        Velocity_UV_New      => Me%Velocity%Horizontal%UV%New
        Area_UV              => Me%External_Var%Area_UV
        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        WaterColumnUV        => Me%External_Var%WaterColumnUV
        KFloor_UV            => Me%External_Var%KFloor_UV

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "InstantMixingSmallDepths")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,kbottom,TotalArea,TotalFlux)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doi:    do j=JLB, JUB
doj:    do i=ILB, IUB
            
            
cd1:        if (ComputeFaces3D_UV(i, j, KUB) == Covered  .and.                           &
                WaterColumnUV(i, j) <= WaterColumn2D) then 

                Kbottom = KFloor_UV(i, j)

                TotalArea = 0.
                TotalFlux = 0.

dok1:           do  k = Kbottom, KUB            

                    TotalArea = TotalArea + dble(Area_UV        (i, j, k))
                    TotalFlux = TotalFlux + dble(Area_UV        (i, j, k)) *             &
                                            dble(Velocity_UV_New(i, j, k))

                enddo dok1

                Velocity_UV_New(i, j, Kbottom:KUB) = real(TotalFlux/TotalArea)

            endif cd1

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "InstantMixingSmallDepths")
        endif

        nullify(Velocity_UV_New  )
        nullify(Area_UV          )
        nullify(ComputeFaces3D_UV) 
        nullify(WaterColumnUV    )
        nullify(KFloor_UV        )
        
    end subroutine InstantMixingSmallDepths
         

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal velocity from the horizontal fluxes.         ! 
    !                                                                                      !
    ! Input : Flow, Geometry                                                               !
    ! OutPut: VelocityU, V                                                                 !
    ! Author: Frank (00/10)                                                                !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine Compute_VelocityFromFluxes

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k
        integer                                     :: CHUNK        
        
        !Begin-----------------------------------------------------------------

        CHUNK = CHUNK_J(Me%WorkSize%JLB,Me%WorkSize%JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Compute_VelocityFromFluxes")
        endif
        
        !$OMP PARALLEL PRIVATE(i,j,k)

        !openMP here
        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB + 1
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            Me%Velocity%Horizontal%U%New(i, j, k) = Me%WaterFluxes%X(i, j, k) / Me%External_Var%Area_U(i, j, k)
        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo
        
        !openMP here
        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB + 1
            Me%Velocity%Horizontal%V%New(i, j, k) = Me%WaterFluxes%Y(i, j, k) / Me%External_Var%Area_V(i, j, k)
        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Compute_VelocityFromFluxes")
        endif

    end subroutine Compute_VelocityFromFluxes



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This suborutine compute the water level elevation                                    !
    !                                                                                      !
    ! Input : Geomtry, Flow, Mapping, Time steps                                           !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Compute_WaterLevel 
        
        !Variables Categories  
            !Geometry  : Volume_UV, Area_UV, DUX_VY, DVY_UX, DXX_YY, DYY_XX, DZX_ZY  
            !Flow      : Velocity_UV_Old, Velocity_VU_New, Velocity_VU_Old, Vert_Viscosity
            !WaterProp : Density
            !Boundary  : AtmPressure, Chezy
            !Forces    : Horizontal_Transport, Rox3, 
            !Time      : DT_Elevation, DT_Velocity
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D

        !Variables Direction Dependent
           !Volume_UV, Area_UV, DUX_VY, DVY_UX, DXX_YY, DYY_XX, DZX_ZY
           !Velocity_UV_Old, Velocity_VU_New, Velocity_VU_Old, ComputeFaces3D_UV, KFloor_UV, Direction 

        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------

        real(8), dimension(:,:),   pointer  :: ECoef_2D, ECoef_2D_Aux
        real,    dimension(:,:),   pointer  :: DCoef_2D, FCoef_2D, TiCoef_2D,  &
                                               WaterLevel_Old, WaterLevel_New, &
                                               RadCoef_2D, TiRadCoef_2D, TiCoef_2D_Aux
         
        real,    dimension(:,:),   pointer  :: WaterLevel_Max, WaterLevel_Min

        integer                             :: IUB, ILB, JUB, JLB
        integer                             :: IJmin, IJmax, JImin, JImax 
        integer                             :: di, dj, DirectionXY

        !Begin----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Compute_WaterLevel")

        !Begin - Shorten variables name 

        DirectionXY =  Me%Direction%XY


        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB

        di          =  Me%Direction%di
        dj          =  Me%Direction%dj

        DCoef_2D  => Me%Coef%D2%D
        ECoef_2D  => Me%Coef%D2%E
        FCoef_2D  => Me%Coef%D2%F
        TiCoef_2D => Me%Coef%D2%Ti

        ECoef_2D_Aux    => Me%Coef%D2%Eaux
        TiCoef_2D_Aux   => Me%Coef%D2%Tiaux

        RadCoef_2D   => Me%Coef%D2%Rad
        TiRadCoef_2D => Me%Coef%D2%TiRad

        WaterLevel_Old => Me%WaterLevel%Old
        WaterLevel_New => Me%WaterLevel%New
        WaterLevel_Max => Me%WaterLevel%Maxi
        WaterLevel_Min => Me%WaterLevel%Mini

        !End   - Shorten variables name

        !Begin - Compute

        call SetMatrixValue(DCoef_2D,   Me%WorkSize2D,           0.0 )
        call SetMatrixValue(ECoef_2D,   Me%WorkSize2D,      dble(1.0))
        call SetMatrixValue(FCoef_2D,   Me%WorkSize2D,           0.0 )
        call SetMatrixValue(TiCoef_2D,  Me%WorkSize2D, WaterLevel_Old)

cd1:    if (Me%ComputeOptions%BarotropicRadia == FlatherWindWave_ .or.      &
            Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then 

            call SetMatrixValue(RadCoef_2D,    Me%WorkSize2D, 0.0)
            call SetMatrixValue(TiRadCoef_2D,  Me%WorkSize2D, 0.0)

        end if cd1

        !Implicit bottom friction
        call WaterLevel_BottomFriction     
        call WaterLevel_BarotropicPressure 
        call WaterLevel_ExplicitForces     
        call WaterLevel_WaterFluxes        

        call WaterLevel_OpenBoundary       

        call WaterLevelDischarges          

        IJmin = ILB * dj + JLB * di
        IJmax = IUB * dj + JUB * di

        JImin = ILB * di + JLB * dj
        JImax = IUB * di + JUB * dj

        if (.not. Me%CyclicBoundary%ON .or.                                              &
                 (Me%CyclicBoundary%ON .and. Me%CyclicBoundary%Direction == Me%Direction%YX))  then


            if (Me%DomainDecomposition%ON) then
                call THOMAS_2D_DomainDecomposition
            else
                !griflet: old call
                !call THOMAS_2D(IJmin, IJmax, JImin, JImax, di, dj, DCoef_2D, ECoef_2D,       &
                !               FCoef_2D, TiCoef_2D, WaterLevel_New,                          &
                !               Me%VECG_2D, Me%VECW_2D)
                !griflet: new call
                call THOMAS_2D(IJmin, IJmax, JImin, JImax, di, dj, Me%THOMAS2D, WaterLevel_New, Me%ModelName)
            endif
        else

            call WaterLevel_CyclicBoundary

        endif

        if (Me%Relaxation%WaterLevel)                                               &
            call WaterLevelRelaxation

        ! aqui relaxa-se o nivel com altimetria
        if (Me%ComputeOptions%AltimetryAssimilation%Yes)                            &
            call WaterLevelRelaxationAltimetry

        !In this subroutine model verifies if the level is below a critical level 
        !This is critical level is a warning that says below this level there is a very 
        !by probability of negative volumes
        call WaterLevelCorrection
        
        if (Me%ComputeOptions%WaterLevelMaxMin)                                 &
            call WaterLevelMaxMin(WaterLevel_Max, WaterLevel_Min)

        !Nullify auxiliar variables
        nullify (DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D)

        nullify(ECoef_2D_Aux, TiCoef_2D_Aux)

        nullify (WaterLevel_Old, WaterLevel_New)


        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Compute_WaterLevel")

   end Subroutine Compute_WaterLevel


    !------------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine computes the thomaz 2D in parallel following a                       ! 
    ! domain decomposition approach                                                        !
    !                                                                                      !
    ! Input : Coefficients of the  linear system equation                                  !
    ! OutPut: Water level                                                                  !
    ! Author: Paulo Chambel (2013/2)                                                       !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine THOMAS_2D_DomainDecomposition     
    
#ifdef _USE_MPI

        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------
        real,    dimension(:,:), pointer :: DCoef_2D, FCoef_2D, TiCoef_2D
        real(8), dimension(:,:), pointer :: ECoef_2D
        real,    dimension(:,:), pointer :: WaterLevel_New
        real(8), dimension(:  ), pointer :: VECG, VECW        
        integer                          :: STAT_CALL, IUB, ILB, JUB, JLB
        integer                          :: IJmin, IJmax
        integer                          :: JImin, JImax
        integer                          :: di,    dj
        
        
        !Begin---------------------------------------------------------------
        write(*,*) 'start THOMAS_2D_DomainDecomposition' 
        call AggregatesThomasCoefs
        
        write(*,*) 'End AggregatesThomasCoefs DD ', Me%DomainDecomposition%MPI_ID        

        !Waits for all processes
        call MPI_Barrier  (MPI_COMM_WORLD, STAT_CALL)
        
        if (Me%DomainDecomposition%Master) then
        
            IUB = Me%DomainDecomposition%Global%IUB
            ILB = Me%DomainDecomposition%Global%ILB
            JUB = Me%DomainDecomposition%Global%JUB
            JLB = Me%DomainDecomposition%Global%JLB

            di          =  Me%Direction%di
            dj          =  Me%Direction%dj
            
            DCoef_2D  => Me%DomainDecomposition%Coef%D
            ECoef_2D  => Me%DomainDecomposition%Coef%E
            FCoef_2D  => Me%DomainDecomposition%Coef%F
            TiCoef_2D => Me%DomainDecomposition%Coef%Ti
            
            VECG      => Me%DomainDecomposition%VECG
            VECW      => Me%DomainDecomposition%VECW
            
            WaterLevel_New  => Me%DomainDecomposition%WaterLevel_New
            
        
            IJmin = ILB * dj + JLB * di
            IJmax = IUB * dj + JUB * di

            JImin = ILB * di + JLB * dj
            JImax = IUB * di + JUB * dj        
            
            write(*,*) 'Start Thomas DD ', Me%DomainDecomposition%MPI_ID 
            !write(*,*) 'IJmin, IJmax, JImin, JImax, di,    dj', IJmin, IJmax, JImin, JImax, di,    dj
            !write(*,*) 'DCoef_2D(120,146), ECoef_2D(120,146), FCoef_2D(120,146), TiCoef_2D(120,146),                     &
            !               WaterLevel_New(120,146), VECG(1), VECW(1)', &
            !               DCoef_2D(120,146), ECoef_2D(120,146), FCoef_2D(120,146), TiCoef_2D(120,146),                     &
            !               WaterLevel_New(120,146), VECG(1), VECW(1)
            !PCL - Retirar - testes
            call THOMAS_2D(IJmin, IJmax, JImin, JImax, di,    dj,                       &
                           DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D,                     &
                           WaterLevel_New, VECG, VECW)                           
        
            write(*,*) 'End Thomas DD ', Me%DomainDecomposition%MPI_ID                    
            
        endif
        
        !Waits for all processes
        call MPI_Barrier  (MPI_COMM_WORLD, STAT_CALL)
        
        write(*,*) 'Start Thomas DD ', Me%DomainDecomposition%MPI_ID                            
        
        call BroadcastThomasResult()
        
        !Waits for all processes
        call MPI_Barrier  (MPI_COMM_WORLD, STAT_CALL)

        write(*,*) 'End Thomas DD ', Me%DomainDecomposition%MPI_ID                            
        
#endif _USE_MPI

    end subroutine THOMAS_2D_DomainDecomposition         

    !------------------------------------------------------------------------------
    
#ifdef _USE_MPI    

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine aggregates in one global domain the thomas                           !
    ! coefficients of all domains                                                          !
    !                                                                                      !
    ! Input : Coefficients of the linear system equation for each domain                   !
    ! OutPut: Coefficients of the linear system equation for the global domain             !
    ! Author: Paulo Chambel (2013/2)                                                       !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine AggregatesThomasCoefs     
    

        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------
        real,    dimension(:,:), pointer :: D, F, Ti
        real(8), dimension(:,:), pointer :: E

        integer                          :: STAT_CALL, IUB, ILB, JUB, JLB
        integer                          :: di,    dj, i
        
        integer                          :: Source, Destination         
        integer                          :: iSize
        integer, save                    :: Precision
        integer                          :: status(MPI_STATUS_SIZE)       
        
        integer, pointer, dimension(:)   :: Aux1D
        type(T_Size2D)                   :: Inner, Mapping
        
        
        !Begin---------------------------------------------------------------
        
        if (Me%FirstIteration) then
        
            !PCL - Master slave mapping
            write(*,*) 'Start master slave mapping', Me%DomainDecomposition%MPI_ID
            iSize = 16
            allocate(Aux1D(iSize))
                    
            if (Me%DomainDecomposition%Master) then
            
                do i=1, Me%DomainDecomposition%Nslaves

                    Precision = MPI_INTEGER
                    Source    = i
                    
                    write(*,*) 'Start receive slave mapping', Me%DomainDecomposition%MPI_ID
                    
                    call MPI_Recv (Aux1D(1:iSize), iSize, Precision,   Source, 30001, MPI_COMM_WORLD, status, STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'
                
                    write(*,*) 'End receive slave mapping', Me%DomainDecomposition%MPI_ID                
                
                    Me%DomainDecomposition%Slaves_Inner  (i)%ILB = Aux1D(1)
                    Me%DomainDecomposition%Slaves_Inner  (i)%IUB = Aux1D(2)
                    Me%DomainDecomposition%Slaves_Inner  (i)%JLB = Aux1D(3)
                    Me%DomainDecomposition%Slaves_Inner  (i)%JUB = Aux1D(4)

                    Me%DomainDecomposition%Slaves_HaloMap(i)%ILB = Aux1D(5)
                    Me%DomainDecomposition%Slaves_HaloMap(i)%IUB = Aux1D(6)
                    Me%DomainDecomposition%Slaves_HaloMap(i)%JLB = Aux1D(7)
                    Me%DomainDecomposition%Slaves_HaloMap(i)%JUB = Aux1D(8)

                    Me%DomainDecomposition%Slaves_Size   (i)%ILB = Aux1D(9)
                    Me%DomainDecomposition%Slaves_Size   (i)%IUB = Aux1D(10)
                    Me%DomainDecomposition%Slaves_Size   (i)%JLB = Aux1D(11)
                    Me%DomainDecomposition%Slaves_Size   (i)%JUB = Aux1D(12)

                    Me%DomainDecomposition%Slaves_Mapping(i)%ILB = Aux1D(13)
                    Me%DomainDecomposition%Slaves_Mapping(i)%IUB = Aux1D(14)
                    Me%DomainDecomposition%Slaves_Mapping(i)%JLB = Aux1D(15)
                    Me%DomainDecomposition%Slaves_Mapping(i)%JUB = Aux1D(16)

                enddo

            else
            
                Aux1D(1) = Me%DomainDecomposition%Inner%ILB
                Aux1D(2) = Me%DomainDecomposition%Inner%IUB
                Aux1D(3) = Me%DomainDecomposition%Inner%JLB
                Aux1D(4) = Me%DomainDecomposition%Inner%JUB
                
                Aux1D(5) = Me%DomainDecomposition%HaloMap%ILB
                Aux1D(6) = Me%DomainDecomposition%HaloMap%IUB
                Aux1D(7) = Me%DomainDecomposition%HaloMap%JLB
                Aux1D(8) = Me%DomainDecomposition%HaloMap%JUB

                Aux1D(9) = Me%WorkSize2D%ILB
                Aux1D(10)= Me%WorkSize2D%IUB
                Aux1D(11)= Me%WorkSize2D%JLB
                Aux1D(12)= Me%WorkSize2D%JUB            

                Aux1D(13) = Me%DomainDecomposition%Mapping%ILB
                Aux1D(14) = Me%DomainDecomposition%Mapping%IUB
                Aux1D(15) = Me%DomainDecomposition%Mapping%JLB
                Aux1D(16) = Me%DomainDecomposition%Mapping%JUB
           
                Precision   = MPI_INTEGER
                Destination = Me%DomainDecomposition%Master_MPI_ID
                
                write(*,*) 'Start send slave mapping', Me%DomainDecomposition%MPI_ID
        
                call MPI_Send (Aux1D(1:iSize), iSize, Precision, Destination, 30001, MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'

                write(*,*) 'End send slave mapping', Me%DomainDecomposition%MPI_ID
            
            endif
            
            deallocate(Aux1d)        
            
        endif            

        IUB = Me%DomainDecomposition%Global%IUB
        ILB = Me%DomainDecomposition%Global%ILB
        JUB = Me%DomainDecomposition%Global%JUB
        JLB = Me%DomainDecomposition%Global%JLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj
 
        if (Me%DomainDecomposition%Master) then
        
            write(*,*) 'Start copy thomas coefs', Me%DomainDecomposition%MPI_ID

            call CopyThomasCoefs(D = Me%Coef%D2%D, E  = Me%Coef%D2%E,                   &
                                 F = Me%Coef%D2%F, Ti = Me%Coef%D2%Ti,                  &
                                 Inner   = Me%DomainDecomposition%Inner,                &
                                 Mapping = Me%DomainDecomposition%Mapping)
                                 
            write(*,*) 'End copy thomas coefs', Me%DomainDecomposition%MPI_ID                                 
            
            do i=1, Me%DomainDecomposition%Nslaves
            
                Inner   = Me%DomainDecomposition%Slaves_Inner  (i)
                
                Mapping = Me%DomainDecomposition%Slaves_Mapping(i)

                allocate(D (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
                allocate(E (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
                allocate(F (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
                allocate(Ti(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
                
                iSize     = (Inner%IUB-Inner%ILB+1) * (Inner%JUB-Inner%JLB+1)
                
                Precision = MPIKind(D)
                
                Source    =  Me%DomainDecomposition%Slaves_MPI_ID(i)
                
                write(*,*) 'Start receive thomas coefs', Me%DomainDecomposition%MPI_ID                
                write(*,*) 'Recv D'
                call MPI_Recv (D(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                               Source, 20001, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'
                
                write(*,*) 'Recv F'
                call MPI_Recv (F(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                               Source, 20002, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'

                write(*,*) 'Recv Ti'
                call MPI_Recv (Ti(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                               Source, 20003, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'
                
                Precision = MPI_DOUBLE_PRECISION

                write(*,*) 'Recv E'
                call MPI_Recv (E(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                               Source, 20004, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'
                
                write(*,*) 'End receive thomas coefs', Me%DomainDecomposition%MPI_ID                
                
                write(*,*) 'Start copy thomas coefs', Me%DomainDecomposition%MPI_ID                

                call CopyThomasCoefs(D = D, E  = E, F = F, Ti = Ti, Inner = Inner, Mapping = Mapping)
                
                write(*,*) 'End copy thomas coefs', Me%DomainDecomposition%MPI_ID
                
                deallocate(D )
                deallocate(E )
                deallocate(F )
                deallocate(Ti)

                nullify(D)
                nullify(E)
                nullify(F)
                nullify(Ti)

            enddo
            
        else

            Inner       = Me%DomainDecomposition%Inner   
            
            allocate(D (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
            allocate(E (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
            allocate(F (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
            allocate(Ti(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
                 
        
            D   (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB) = Me%Coef%D2%D   (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB)
            E   (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB) = Me%Coef%D2%E   (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB)
            F   (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB) = Me%Coef%D2%F   (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB)
            Ti  (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB) = Me%Coef%D2%Ti  (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB)
            
            iSize       = (Inner%IUB-Inner%ILB+1) * (Inner%JUB-Inner%JLB+1)
            Precision   = MPIKind(D)
            Destination = Me%DomainDecomposition%Master_MPI_ID
            
            write(*,*) 'Start send thomas coefs', Me%DomainDecomposition%MPI_ID                
    
            write(*,*) 'Send D'
            call MPI_Send (D(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                           Destination, 20001, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'

            write(*,*) 'Send F'
            call MPI_Send (F(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                           Destination, 20002, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'

            write(*,*) 'Send Ti'
            call MPI_Send (Ti(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                           Destination, 20003, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'
            
            Precision = MPI_DOUBLE_PRECISION

            write(*,*) 'Send E'
            call MPI_Send (E(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                           Destination, 20004, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'
            
            write(*,*) 'End send thomas coefs', Me%DomainDecomposition%MPI_ID    
            
            deallocate(D )
            deallocate(E )
            deallocate(F )
            deallocate(Ti)

            nullify(D)
            nullify(E)
            nullify(F)
            nullify(Ti)
            
        
        endif

        

    end subroutine AggregatesThomasCoefs         

    !------------------------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine broadcast for each domain the thomas algorithm results               !
    ! (new water level)                                                                    !
    !                                                                                      !
    ! Input : water level for the global domain                                            !
    ! OutPut: water level for each domain                                                  !
    ! Author: Paulo Chambel (2013/2)                                                       !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine BroadcastThomasResult()     
    

        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------
        real,    dimension(:,:), pointer :: WL

        integer                          :: STAT_CALL, IUB, ILB, JUB, JLB
        integer                          :: di,    dj, i
        
        integer                          :: Source, Destination         
        integer                          :: iSize
        integer, save                    :: Precision
        integer                          :: status(MPI_STATUS_SIZE)        
        
        type(T_Size2D)                   :: WorkSize, HaloMap
        
        
        !Begin---------------------------------------------------------------

        IUB = Me%DomainDecomposition%Global%IUB
        ILB = Me%DomainDecomposition%Global%ILB
        JUB = Me%DomainDecomposition%Global%JUB
        JLB = Me%DomainDecomposition%Global%JLB

        di  =  Me%Direction%di
        dj  =  Me%Direction%dj
 
        if (Me%DomainDecomposition%Master) then
        
            WorkSize = Me%WorkSize2D
            HaloMap  = Me%DomainDecomposition%HaloMap
        
            Me%WaterLevel%New(WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB) =   &
                Me%DomainDecomposition%WaterLevel_New(HaloMap%ILB:HaloMap%IUB,          &
                                                      HaloMap%JLB:HaloMap%JUB)

            do i=1, Me%DomainDecomposition%Nslaves
            
                WorkSize =  Me%DomainDecomposition%Slaves_Size   (i)
                HaloMap  =  Me%DomainDecomposition%Slaves_HaloMap(i)
                
                allocate(WL (WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB))
                
                WL(WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB) =               &
                    Me%DomainDecomposition%WaterLevel_New(HaloMap%ILB:HaloMap%IUB, HaloMap%JLB:HaloMap%JUB)
                    
                iSize       = (WorkSize%IUB-WorkSize%ILB+1) * (WorkSize%JUB-WorkSize%JLB+1)
                
                Precision   = MPIKind(WL)
                
                Destination =  Me%DomainDecomposition%Slaves_MPI_ID(i)

                call MPI_Send (WL(WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB), iSize, Precision,   &
                               Destination, 20006, MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'BroadcastThomasResult - ModuleHydrodynamic - ERR10'

                deallocate(WL)
                nullify   (WL)

            enddo
            
        else
            WorkSize    = Me%WorkSize2D        
        
            allocate(WL (WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB))     
            
       
            iSize       = (WorkSize%IUB-WorkSize%ILB+1) * (WorkSize%JUB-WorkSize%JLB+1)
            Precision   = MPIKind(WL)
            Source      = Me%DomainDecomposition%Master_MPI_ID
            
            call MPI_Recv (WL(WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB), iSize, Precision,   &
                           Source, 20006, MPI_COMM_WORLD, status, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BroadcastThomasResult - ModuleHydrodynamic - ERR20'

            Me%WaterLevel%New(WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB) = &
                WL(WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB)

            deallocate(WL )
            nullify   (WL)                

        endif


    end subroutine BroadcastThomasResult         

    !------------------------------------------------------------------------------
    
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine copys  the thomas coefficients from one domain to the global one     !
    !                                                                                      !
    ! Input : Coefficients of the linear system equation for each domain                   !
    ! OutPut: Coefficients of the linear system equation for the global domain             !
    ! Author: Paulo Chambel (2013/2)                                                       !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine CopyThomasCoefs(D, F, Ti, E, Inner, Mapping)
    

        !Arguments------------------------------------------------------------
        real,    dimension(:,:), pointer :: D, F, Ti
        real(8), dimension(:,:), pointer :: E
        type (T_Size2D)                  :: Inner, Mapping        
        
        !Local---------------------------------------------------------------
        real,    dimension(:,:), pointer :: DCoef_2D, FCoef_2D, TiCoef_2D
        real(8), dimension(:,:), pointer :: ECoef_2D

        
        !Begin---------------------------------------------------------------
        
        nullify(DCoef_2D )
        nullify(ECoef_2D )
        nullify(FCoef_2D )
        nullify(TiCoef_2D)        
 
        DCoef_2D  => Me%DomainDecomposition%Coef%D
        ECoef_2D  => Me%DomainDecomposition%Coef%E
        FCoef_2D  => Me%DomainDecomposition%Coef%F
        TiCoef_2D => Me%DomainDecomposition%Coef%Ti

        
        Dcoef_2D(Mapping%ILB:Mapping%IUB, Mapping%JLB:Mapping%JUB) =                    &
               D(Inner%ILB  :Inner%IUB  , Inner%JLB  :Inner%JUB  )                

        Ecoef_2D(Mapping%ILB:Mapping%IUB, Mapping%JLB:Mapping%JUB) =                    &
               E(Inner%ILB  :Inner%IUB  , Inner%JLB  :Inner%JUB  )                
    

        Fcoef_2D(Mapping%ILB:Mapping%IUB, Mapping%JLB:Mapping%JUB) =                    &
               F(Inner%ILB  :Inner%IUB  , Inner%JLB  :Inner%JUB  )                

        Ticoef_2D(Mapping%ILB:Mapping%IUB, Mapping%JLB:Mapping%JUB) =                   &
               Ti(Inner%ILB  :Inner%IUB  , Inner%JLB  :Inner%JUB  ) 
               
        nullify(DCoef_2D )
        nullify(ECoef_2D )
        nullify(FCoef_2D )
        nullify(TiCoef_2D)
               
    end subroutine CopyThomasCoefs                       

#endif _USE_MPI

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !In this subroutine model verifies if the level is below a critical level              !
    !This is critical level is a warning that says below this level there is a very        !
    !big probability of negative volumes                                                   !
    !To avoid this problem the water level is corrected and put equal to this              !
    !critical                                                                              !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevelCorrection 

        !Arguments--------------------------------------------------------------
         

        !External---------------------------------------------------------------

!        character(LEN = StringLength) :: string

!        integer :: WARNING_, INTERNAL_

        !Local------------------------------------------------------------------

        integer                             :: i, j, STAT_CALL
!        integer                             :: M
        integer                             :: IUB, ILB, JUB, JLB, KUB
        integer, pointer, dimension (:,:,:) :: WaterPoints3D

        real,    dimension(:,:), pointer    :: WaterLevel_New, Bathymetry, VolumeCreated, &
                                               DUX, DVY 
        real                                :: MinWaterColumn, WaterLevelMin, dh

!        character(LEN = StringLength)       :: auxi,  auxj
!        character(LEN = 5           )       :: auxii, auxjj
        logical                             :: OKWarnning, CorrectWaterLevel 

        integer                             :: CHUNK

        !Begin------------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        WaterLevel_New    => Me%WaterLevel%New
        WaterPoints3D     => Me%External_Var%WaterPoints3D
        VolumeCreated     => Me%WaterLevel%VolumeCreated

        DUX            => Me%External_Var%DUX
        DVY            => Me%External_Var%DVY

        WaterLevelMin     =  Me%ComputeOptions%WaterLevelMin
        CorrectWaterLevel =  Me%ComputeOptions%CorrectWaterLevel
       
        !End   - Shorten variables name

       !Gets Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'WaterLevelCorrection - ModuleHydrodynamic - ERR01'

        call GetGeometryMinWaterColumn(Me%ObjGeometry, &
                                       MinWaterColumn, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'WaterLevelCorrection - ModuleHydrodynamic - ERR02'

        OKWarnning = .false.
         
        CHUNK = CHUNK_J(JLB, JUB) 
         
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevelCorrection")
        endif
         
        !$OMP PARALLEL PRIVATE(i,j,dh,OKWarnning)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK) 
do1:    do  j = JLB, JUB
do2:    do  i = ILB, IUB
                        
cd1:        if (WaterPoints3D(i, j, KUB) == OpenPoint) then

                !By defaul this first correction is always made because the water level can not
                !be located below the bottom

cd2:            if (WaterLevel_New(i, j) < (- Bathymetry(i, j) + MinWaterColumn / 2.)) then

                    dh = (- WaterLevel_New(i, j) - Bathymetry(i, j) + MinWaterColumn / 2.)

                    VolumeCreated (i, j) = VolumeCreated(i, j)  + dh * DUX(i, j) * DVY(i, j)

                    WaterLevel_New(i, j) = - Bathymetry(i, j) + MinWaterColumn / 2.

                    OKWarnning = .true.

                endif cd2


                !This second correction is optional and is used when the user wants to 
                !define a reference level below which the water level is corrected.
cd3:            if (CorrectWaterLevel .and. WaterLevel_New(i, j) < (WaterLevelMin + MinWaterColumn / 2.)) then

                    WaterLevel_New(i, j) = WaterLevelMin + MinWaterColumn / 2.

                    OKWarnning = .true.

                endif cd3
        
!cd4:            if (OKWarnning) then

                    !Disables warnings in the corners
!                    if ((i==ILB .and. j == JLB) .or.  &
!                        (i==ILB .and. j == JUB) .or.  &
!                        (i==IUB .and. j == JLB) .or.  &
!                        (i==IUB .and. j == JUB)) Cyclic do2


!do3 :               do M = 1, StringLength
!                        auxi(M:M) = space
!                        auxj(M:M) = space
!                    end do do3

             
!                    write(auxi,*) i
!                    auxi = adjustl(trim(auxi))

             
!                    write(auxj,*) j
!                    auxj = adjustl(trim(auxj))
!

!do4 :               do M = 1, 5
!                        auxii(M:M) = auxi(M:M)
!                        auxjj(M:M) = auxj(M:M)
!                    end do do4


!                    string = adjustl(trim('In point I='//auxii//' and J='//auxjj//' was created water.'))

!                    call SetError (WARNING_, INTERNAL_, String)

!                    OKWarnning = .false.

!                endif cd4
            endif cd1

        enddo do2
        enddo do1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevelCorrection")
        endif

       !UnGets Bathymetry
        call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'WaterLevelCorrection - ModuleHydrodynamic - ERR03'

        nullify (WaterLevel_New, VolumeCreated, DUX, DVY)
        nullify (WaterPoints3D )

        !----------------------------------------------------------------------

    End Subroutine WaterLevelCorrection

    !--------------------------------------------------------------------------


    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine computes the maximum and the minimum water elevation of each cell    !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level Max and Min values                                               !
    ! Author: Guillaume Riflet (2010/9)                                                    !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevelMaxMin(WaterLevel_Max, WaterLevel_Min)

        !Arguments--------------------------------------------------------------
        real, dimension(:,:), pointer       :: WaterLevel_Max, WaterLevel_Min

        !External---------------------------------------------------------------

        !Local------------------------------------------------------------------

        integer                             :: i, j
        integer                             :: IUB, ILB, JUB, JLB, KUB
        integer, pointer, dimension (:,:,:) :: WaterPoints3D

        real,    dimension(:,:), pointer    :: WaterLevel_New

        integer                             :: CHUNK

        !Begin------------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        WaterLevel_New    => Me%WaterLevel%New
        WaterPoints3D     => Me%External_Var%WaterPoints3D

        !End   - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB) 

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevelMaxMin")
        endif

        !$OMP PARALLEL PRIVATE(i,j)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  j = JLB, JUB
do2:    do  i = ILB, IUB

cd1:        if (WaterPoints3D(i, j, KUB) == OpenPoint) then

                !Do we have a new record water level?
                if (WaterLevel_Max(i,j) < WaterLevel_New(i,j)) then
                    WaterLevel_Max(i,j) = WaterLevel_New(i,j)
                end if

                !Do we have a new minimum water level?
                if (WaterLevel_Min(i,j) > WaterLevel_New(i,j)) then
                    WaterLevel_Min(i,j) = WaterLevel_New(i,j)
                end if

            endif cd1

        enddo do2
        enddo do1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevelMaxMin")
        endif

        nullify (WaterLevel_New)
        nullify (WaterPoints3D )

        !----------------------------------------------------------------------

    End Subroutine WaterLevelMaxMin

    !--------------------------------------------------------------------------
    
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine compute the water level in the open boundary                         !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_OpenBoundary 

        !Arguments------------------------------------------------------------
         


        !Local---------------------------------------------------------------------
        integer :: i, j
        integer, pointer, dimension (:,:,:) :: WaterPoints3D

        real,    dimension(:,:), pointer    :: TiCoef_2D
        logical                             :: Imposed_BoundaryWave

        integer                             :: IUB, ILB, JUB, JLB, KUB, BarotropicRadia

        integer                             :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        TiCoef_2D     => Me%Coef%D2%Ti
        WaterPoints3D => Me%External_Var%WaterPoints3D

        Imposed_BoundaryWave =  Me%ComputeOptions%Imposed_BoundaryWave
        BarotropicRadia      =  Me%ComputeOptions%BarotropicRadia

        
        !End   - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)
          
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_OpenBoundary")
        endif  
          
        !$OMP PARALLEL PRIVATE(i,j)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)  
        do  j = JLB, JUB
        do  i = ILB, IUB

            !A large negative water level (FillReal_Value) is imposed in non waterpoints
            TiCoef_2D(i, j) = TiCoef_2D(i, j) * WaterPoints3D(i, j, KUB) + &
                               (1. - WaterPoints3D(i, j, KUB)) * FillValueReal

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_OpenBoundary")
        endif 

        if (Imposed_BoundaryWave) then 
           
            call WaterLevel_ImposedWave 

        else if (BarotropicRadia == FlatherWindWave_) then 
 
            !Extrapolate in the implicit direction using a radiation condition the water level 
            !for the boundary points
            call WaterLevel_FlatherWindWave (                                              &
                                       WaterFlux_XY      = Me%WaterFluxes%XY,                 &
                                       WaterFlux_YX      = Me%WaterFluxes%YX,                 &
                                       WaterColumnUV     = Me%External_Var%WaterColumnUV,     &
                                       DUX_VY            = Me%External_Var%DUX_VY,            &
                                       DVY_UX            = Me%External_Var%DVY_UX,            &
                                       DYY_XX            = Me%External_Var%DYY_XX,            &
                                       ComputeFaces3D_UV = Me%External_Var%ComputeFaces3D_UV, &
                                       ComputeFaces3D_VU = Me%External_Var%ComputeFaces3D_VU, &
                                       BoundaryFacesUV   = Me%External_Var%BoundaryFacesUV,   &
                                       Kfloor_UV         = Me%External_Var%Kfloor_UV,         &
                                       Kfloor_VU         = Me%External_Var%Kfloor_VU,         &
                                       di                = Me%Direction%di,                   &
                                       dj                = Me%Direction%dj,                   &
                                       ImplicitFaces     = .true.)

            !Extrapolate in the explicit direction using a radiation condition the water level 
            !for the boundary points
            call WaterLevel_FlatherWindWave (                                              &
                                       WaterFlux_XY      = Me%WaterFluxes%YX,                 &
                                       WaterFlux_YX      = Me%WaterFluxes%XY,                 &
                                       WaterColumnUV     = Me%External_Var%WaterColumnVU,     &
                                       DUX_VY            = Me%External_Var%DVY_UX,            &
                                       DVY_UX            = Me%External_Var%DUX_VY,            &
                                       DYY_XX            = Me%External_Var%DXX_YY,            &
                                       ComputeFaces3D_UV = Me%External_Var%ComputeFaces3D_VU, &
                                       ComputeFaces3D_VU = Me%External_Var%ComputeFaces3D_UV, &
                                       BoundaryFacesUV   = Me%External_Var%BoundaryFacesVU,   &
                                       Kfloor_UV         = Me%External_Var%Kfloor_VU,         &
                                       Kfloor_VU         = Me%External_Var%Kfloor_UV,         &
                                       di                = Me%Direction%dj,                   &
                                       dj                = Me%Direction%di,                   &
                                       ImplicitFaces     = .false.)


        else if  (BarotropicRadia == FlatherLocalSolution_) then 
        
            call WaterLevel_FlatherLocalSolution 
 
        else if (BarotropicRadia  == BlumbergKantha_      ) then !MRV

            call WaterLevel_BlumbergKantha 

        endif                  

        
        
        !Nullify auxiliar variables
        nullify (TiCoef_2D)
        nullify (WaterPoints3D)

        !----------------------------------------------------------------------

    End Subroutine WaterLevel_OpenBoundary

    !--------------------------------------------------------------------------


    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine imposed a specific wave in the open boundary                         !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_ImposedWave 

        !Arguments------------------------------------------------------------
         


        !Local---------------------------------------------------------------------
        integer :: i, j, STAT_CALL

        integer, pointer, dimension (:,:)   :: BoundaryPoints

        real(8), dimension(:,:), pointer    :: ECoef_2D
        real,    dimension(:,:), pointer    :: DCoef_2D, FCoef_2D, TiCoef_2D, &
                                               ImposedElevation
        integer                             :: IUB, ILB, JUB, JLB

        integer                             :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB

        DCoef_2D  => Me%Coef%D2%D
        ECoef_2D  => Me%Coef%D2%E
        FCoef_2D  => Me%Coef%D2%F
        TiCoef_2D => Me%Coef%D2%Ti

        BoundaryPoints   => Me%External_Var%BoundaryPoints

cd1:    if (Me%SubModel%ON) then

            ImposedElevation => Me%SubModel%Z

       
    !End   - Shorten variables name

cd3:        if (.not. Me%SubModel%Set) then 
            
                Stop 'Sub. WaterLevel_ImposedWave - ModuleHydrodynamic - ERR01a.'

            endif cd3
       
        !End   - Shorten variables name

        else cd1 

            call Modify_OpenBoundary(Me%ObjOpenBoundary,                                 &
                                     Me%CurrentTime,                                     &
                                     Me%External_Var%AtmosphericPressure,                &
                                     Me%ComputeOptions%AtmosphereCoef,                   & 
                                     STAT        = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                   &
                Stop 'Sub. WaterLevel_ImposedWave - ModuleHydrodynamic - ERR01.'
            
cd2:        if (Me%ComputeOptions%Compute_Tide .or. Me%ComputeOptions%InvertBarometer) then
                
                call GetImposedElevation(Me%ObjOpenBoundary,                &
                                      ImposedElevation, STAT = STAT_CALL)


                if (STAT_CALL /= SUCCESS_) &
                    Stop 'Sub. WaterLevel_ImposedWave - ModuleHydrodynamic - ERR03.'

            else cd2

                ImposedElevation => Me%WaterLevel%New

            endif cd2

        endif cd1

        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_ImposedWave")
        endif 
        
        !$OMP PARALLEL PRIVATE(i,j)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB

           !The water level values imposed in the open boundary points are maintained
            TiCoef_2D(i, j) = TiCoef_2D(i, j) * (1. - BoundaryPoints(i, j)) +            &
                              ImposedElevation(i, j) * BoundaryPoints(i, j) 

            DCoef_2D(i, j)  = DCoef_2D(i, j)  * (1. - BoundaryPoints(i, j))

            ECoef_2D(i, j)  = ECoef_2D(i, j)  * (1. - BoundaryPoints(i, j)) +            &
                              1. * BoundaryPoints(i, j)

            FCoef_2D(i, j)  = FCoef_2D(i, j)  * (1. - BoundaryPoints(i, j))
               
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_ImposedWave")
        endif 

cd4:    if (.not. Me%SubModel%ON .and. (Me%ComputeOptions%Compute_Tide .or. Me%ComputeOptions%InvertBarometer)) then

    
            call UnGetOpenBoundary(Me%ObjOpenBoundary, ImposedElevation, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                Stop 'Sub. WaterLevel_ImposedWave - ModuleHydrodynamic - ERR04.'

        else  cd4

            nullify(ImposedElevation)

        endif cd4


        !Nullify auxiliar variables
        nullify (DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D)
        nullify (BoundaryPoints)

        !----------------------------------------------------------------------

    End Subroutine WaterLevel_ImposedWave


    !------------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine imposed a Cyclic boundary condition for the water level               !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_CyclicBoundary 

        !Arguments------------------------------------------------------------
         


        !Local---------------------------------------------------------------------
        integer :: i, j

        integer, pointer, dimension (:,:)   :: BoundaryPoints

        real(8), dimension(:,:),   pointer  :: ECoef_2D
        real,    dimension(:,:),   pointer  :: DCoef_2D, FCoef_2D, TiCoef_2D, WaterLevel_New
        real(8), dimension(:),     pointer  :: b, bb, gam
        real,    dimension(:),     pointer  :: a, c, r, x, u, z

        real                                :: alpha,beta

        integer                             :: IUB, ILB, JUB, JLB !, status

        !AT integer                                :: CHUNK
        
        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB

        BoundaryPoints   => Me%External_Var%BoundaryPoints
        WaterLevel_New   => Me%WaterLevel%New

        DCoef_2D  => Me%Coef%D2%D
        ECoef_2D  => Me%Coef%D2%E
        FCoef_2D  => Me%Coef%D2%F
        TiCoef_2D => Me%Coef%D2%Ti

        a  => Me%Coef%D1%a
        b  => Me%Coef%D1%b
        bb => Me%Coef%D1%bb
        c  => Me%Coef%D1%c
        r  => Me%Coef%D1%r
        u  => Me%Coef%D1%u
        x  => Me%Coef%D1%x
        z  => Me%Coef%D1%z
        gam=> Me%Coef%D1%gam

        a  (:) = 0
        b  (:) = 0
        bb (:) = 0
        c  (:) = 0
        r  (:) = 0
        u  (:) = 0
        x  (:) = 0
        z  (:) = 0
        gam(:) = 0
       
       
        !End   - Shorten variables name

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_CyclicBoundary")
        endif 

XY:     if (Me%Direction%XY == DirectionY_) then

            !AT CHUNK = CHUNK_J(JLB + 1, JUB - 1)

            !AT !! $OMP PARALLEL PRIVATE(j,beta,alpha) &
            !AT !! $OMP FIRSTPRIVATE(a,b,bb,c,r,u,x,z,gam)
            !AT !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:        do  j = JLB + 1, JUB - 1
                  
cd2:            if   (BoundaryPoints(ILB, j) == Boundary .and. BoundaryPoints(IUB, j) == Boundary) then

                    !beta                  = DCoef_2D (IUB-1, j)
                    !alpha                 = FCoef_2D (ILB+1, j)

                    beta                  = DCoef_2D (ILB+1, j)
                    alpha                 = FCoef_2D (IUB-1, j)


                    DCoef_2D (ILB + 1, j) = 0.
                    FCoef_2D (IUB - 1, j) = 0.

                    a(ILB : IUB)      = DCoef_2D  (ILB:IUB, j)
                    b(ILB : IUB)      = ECoef_2D  (ILB:IUB, j)
                    c(ILB : IUB)      = FCoef_2D  (ILB:IUB, j)
                    r(ILB : IUB)      = TiCoef_2D (ILB:IUB, j)

                    call Tridag_cyclic(a, b, c, alpha, beta, r, x, gam, bb, u, z, ILB + 1, IUB - 1)

                    x(ILB) = x(IUB - 1)
                    x(IUB) = x(ILB + 1)

                
                else if (BoundaryPoints(ILB, j) /= Boundary .or. BoundaryPoints(IUB, j) /= Boundary ) then

                    a(ILB : IUB)      = DCoef_2D  (ILB:IUB, j)
                    b(ILB : IUB)      = ECoef_2D  (ILB:IUB, j)
                    c(ILB : IUB)      = FCoef_2D  (ILB:IUB, j)
                    r(ILB : IUB)      = TiCoef_2D (ILB:IUB, j)

                    call tridag(a,b,c,r,x,gam, ILB + 1, IUB - 1)

                    if (Me%CyclicBoundary%Direction == DirectionY_ .or. &
                        Me%CyclicBoundary%Direction == DirectionXY_) then

                        if (BoundaryPoints(ILB, j) == Boundary) x(ILB) = x(IUB - 1)
                        if (BoundaryPoints(IUB, j) == Boundary) x(IUB) = x(ILB + 1)

                    endif

                endif cd2

                WaterLevel_New(ILB:IUB, j) = x(ILB:IUB)


            enddo do1
            !AT !! $OMP END DO
            !AT !! $OMP END PARALLEL

            if (Me%CyclicBoundary%Direction == DirectionX_ .or. &
                Me%CyclicBoundary%Direction == DirectionXY_) then

                WaterLevel_New(ILB:IUB, JLB) = WaterLevel_New(ILB:IUB, JUB - 1)
                WaterLevel_New(ILB:IUB, JUB) = WaterLevel_New(ILB:IUB, JLB + 1)

            endif


        else if (Me%Direction%XY == DirectionX_) then XY

            !AT CHUNK = CHUNK_I(ILB + 1, IUB - 1)
        
            !AT !! $OMP PARALLEL PRIVATE(i,beta,alpha)
            !AT !! $OMP FIRSTPRIVATE(a,b,bb,c,r,u,x,z,gam)
            !AT !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
do2:        do  i = ILB + 1, IUB - 1
                  
cd3:            if   (BoundaryPoints(i, JLB) == Boundary .and. BoundaryPoints(i, JUB) == Boundary) then

                    !beta                  = DCoef_2D (i, JUB-1)
                    !alpha                 = FCoef_2D (i, JLB+1)

                    beta                  = DCoef_2D (i, JLB+1)
                    alpha                 = FCoef_2D (i, JUB-1)

                    DCoef_2D (i, JLB + 1) = 0.
                    FCoef_2D (i, JUB - 1) = 0.

                    a(JLB : JUB)      = DCoef_2D  (i, JLB:JUB)
                    b(JLB : JUB)      = ECoef_2D  (i, JLB:JUB)
                    c(JLB : JUB)      = FCoef_2D  (i, JLB:JUB)
                    r(JLB : JUB)      = TiCoef_2D (i, JLB:JUB)


                    call Tridag_cyclic(a, b, c, alpha, beta, r, x, gam, bb, u, z, JLB + 1, JUB - 1)

                    x(JLB) = x(JUB - 1)
                    x(JUB) = x(JLB + 1)
                
                else if (BoundaryPoints(i, JLB) /= Boundary .or. BoundaryPoints(i, JUB) /= Boundary ) then cd3

                    a(JLB : JUB)      = DCoef_2D  (i, JLB:JUB)
                    b(JLB : JUB)      = ECoef_2D  (i, JLB:JUB)
                    c(JLB : JUB)      = FCoef_2D  (i, JLB:JUB)
                    r(JLB : JUB)      = TiCoef_2D (i, JLB:JUB)

                    call tridag(a,b,c,r,x,gam, JLB + 1, JUB - 1)

                    if (Me%CyclicBoundary%Direction == DirectionX_ .or. &
                        Me%CyclicBoundary%Direction == DirectionXY_) then

                        if (BoundaryPoints(i, JLB) == Boundary) x(JLB) = x(JUB - 1)
                        if (BoundaryPoints(i, JUB) == Boundary) x(JUB) = x(JLB + 1)

                    endif

                endif cd3

                WaterLevel_New(i, JLB:JUB) = x(JLB:JUB)


            enddo do2
            !AT !! $OMP END DO
            !AT !! $OMP END PARALLEL

            if (Me%CyclicBoundary%Direction == DirectionY_ .or. &
                Me%CyclicBoundary%Direction == DirectionXY_) then

                WaterLevel_New(ILB, JLB:JUB) = WaterLevel_New(IUB-1, JLB:JUB)
                WaterLevel_New(IUB, JLB:JUB) = WaterLevel_New(ILB+1, JLB:JUB)

            endif

        endif XY

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_CyclicBoundary")
        endif 

        !Nullify auxiliar variables
        nullify (ECoef_2D, DCoef_2D, FCoef_2D, TiCoef_2D, BoundaryPoints, WaterLevel_New)

        nullify (a, b, bb, c, r, u, x, z, gam)


        !----------------------------------------------------------------------

    End Subroutine WaterLevel_CyclicBoundary


    subroutine CyclicCoef2D ( TiCoef_2D, TiCoef_2D_Aux, AuxExplicit, DT_AreaCell1,                      &
                             DT_AreaCell2, I, J, iSouth, jWest,                          &
                             Dcoef_2D, ECoef_2D, ECoef_2D_Aux, FCoef_2D, AuxImplicit, Direction)

        !Arguments------------------------------------------------------------
        real,    dimension(:,:),             pointer  :: TiCoef_2D, TiCoef_2D_Aux
        real   , intent (IN)                          :: AuxExplicit,                    &
                                                         DT_AreaCell1, DT_AreaCell2
        integer, intent (IN)                          :: I, J, iSouth, jWest


        real(8), dimension(:,:),   optional, pointer  :: ECoef_2D, ECoef_2D_Aux
        real,    dimension(:,:),   optional, pointer  :: DCoef_2D, FCoef_2D 
        real   , intent (IN),      optional           :: AuxImplicit
        integer, intent (IN),      optional           :: Direction
        !Local---------------------------------------------------------------------


        integer, pointer, dimension (:,:)   :: BoundaryPoints

        integer                             :: IUB, ILB, JUB, JLB, I_Down, J_Down
        integer                             :: Direction_
        logical                             :: ComputeFace

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB

        BoundaryPoints   => Me%External_Var%BoundaryPoints
       
        !End   - Shorten variables name

        ComputeFace = .true.
        I_Down      = iSouth
        J_Down      = jWest

        if (Present(Direction)) then

            Direction_ = Direction

        else

            Direction_ = Me%Direction%XY

        endif
        
        
ixy:    if (Direction_ == DirectionY_ ) then
                 
iby:        if   (BoundaryPoints(ILB, j) == Boundary .and. BoundaryPoints(IUB, j) == Boundary &
                  .and. (I ==ILB + 1 .or. I== IUB)) then

                if (I == ILB + 1) then 

                    I_Down = IUB - 1
                                
                endif

                if (I == IUB) then

                    ComputeFace = .false.

                endif

            endif iby

        else if (Direction_ == DirectionX_) then ixy

                  
ibx:        if   (BoundaryPoints(i, JLB) == Boundary .and. BoundaryPoints(i, JUB) == Boundary &
                  .and. (J ==JLB + 1 .or. J == JUB)) then

                if (J == JLB + 1) then 

                    J_Down = JUB - 1
                                
                endif

                if (J == JUB) then

                    ComputeFace = .false.

                endif

            endif ibx

        endif ixy

        if (ComputeFace) then


            !Compute the coeficients of linear system equations for the I,J Z cell
            ![ ]                   = [ ]         + [m^2/s] * [s/m^2]
            if (present(DCoef_2D))                                                       &
                DCoef_2D(I,J)         = DCoef_2D(I,J)  - AuxImplicit * DT_AreaCell2
        
            ![ ]                   = [ ]         + [m^2/s] * [s/m^2]
            if (present(ECoef_2D))                                                       &
                ECoef_2D (I,J)        = ECoef_2D(I,J)  + AuxImplicit * DT_AreaCell2

            ![m]                   = [m]         + [m^3/s] * [s/m^2] 
            TiCoef_2D(I,J)            = TiCoef_2D(I,J) + AuxExplicit * DT_AreaCell2

            !Compute the coeficients of linear system equations for the iSouth, jWest Z cell

            ![ ]                   = [ ]                     + [m^2/s] * [s/m^2] 
            if (present(FCoef_2D))                                                       &
                FCoef_2D(I_Down, J_Down) = FCoef_2D(I_Down, J_Down)  - AuxImplicit * DT_AreaCell1

            ![ ]                   = [ ]                     + [m^2/s] * [s/m^2] 
            if (present(ECoef_2D_Aux))                                                       &   
                ECoef_2D_Aux(I_Down, J_Down) = AuxImplicit * DT_AreaCell1

            ![m]                   = [m]                     + [m^3/s] * [s/m^2] 
            TiCoef_2D_Aux(I_Down, J_Down)    = - AuxExplicit * DT_AreaCell1

        endif    

        !Nullify auxiliar variables
        nullify (BoundaryPoints)


        !----------------------------------------------------------------------

    End Subroutine CyclicCoef2D



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine imposed a Cyclic boundary condition for a vectorial property          !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine CyclicBoundVectNormal ( Vector, VectorD)

        !Arguments------------------------------------------------------------
        
        real,    dimension (:,:,:), pointer, optional :: Vector
        real(8), dimension (:,:,:), pointer, optional :: VectorD

        !Local---------------------------------------------------------------------
        integer, dimension (:,:  ), pointer :: BoundaryPoints
        integer                             :: IUB, ILB, JUB, JLB, KLB, KUB
        integer                             :: i, j, k

        integer                             :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB

        BoundaryPoints => Me%External_Var%BoundaryPoints

        !End   - Shorten variables name
        

        !Normal boundary faces --------------------------------------------------------------------------
            
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "CyclicBoundVectNormal")
        endif 
            
cd1:    if (Me%Direction%XY == DirectionX_) then

            CHUNK = CHUNK_I(ILB, IUB)

            !$OMP PARALLEL PRIVATE(i,k)
do1:        do k = KLB, KUB 
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do2:        do i = ILB, IUB

                if (BoundaryPoints(i, JUB) == Boundary .or.                              &
                    BoundaryPoints(i, JLB) == Boundary) then

                    if (present(Vector )) Vector  (i, JUB + 1, k) = Vector (i, JLB + 2, k)
                    if (present(VectorD)) VectorD (i, JUB + 1, k) = VectorD(i, JLB + 2, k)

           
                    if (present(Vector )) Vector  (i, JLB, k) = Vector (i, JUB - 1, k)
                    if (present(VectorD)) VectorD (i, JLB, k) = VectorD(i, JUB - 1, k)


                    if (present(Vector )) Vector  (i, JUB, k) = Vector (i, JLB + 1, k)
                    if (present(VectorD)) VectorD (i, JUB, k) = VectorD(i, JLB + 1, k)

                endif

            enddo do2
            !$OMP END DO NOWAIT           
            enddo do1
            !$OMP END PARALLEL


        endif cd1


cd2:    if (Me%Direction%XY == DirectionY_) then
            
            CHUNK = CHUNK_J(JLB, JUB)
            
            !$OMP PARALLEL PRIVATE(j,k)
do3:        do k = KLB, KUB 
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do4:        do j = JLB, JUB

                if (BoundaryPoints(IUB, j) == Boundary .or.                              &
                    BoundaryPoints(ILB, j) == Boundary) then                    
                    if (present(Vector )) Vector  (IUB+1, j, k) = Vector (ILB + 2, j, k)
                    if (present(VectorD)) VectorD (IUB+1, j, k) = VectorD(ILB + 2, j, k)

                
                    if (present(Vector )) Vector  (ILB  , j, k) = Vector (IUB - 1, j, k)
                    if (present(VectorD)) VectorD (ILB  , j, k) = VectorD(IUB - 1, j, k)

                    if (present(Vector )) Vector  (IUB  , j, k) = Vector (ILB + 1, j, k)
                    if (present(VectorD)) VectorD (IUB  , j, k) = VectorD(ILB + 1, j, k)

                endif

            enddo do4
            !$OMP END DO NOWAIT
            enddo do3
            !$OMP END PARALLEL
        
        endif cd2

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "CyclicBoundVectNormal")
        endif 

        nullify(BoundaryPoints)


        !----------------------------------------------------------------------

    End Subroutine CyclicBoundVectNormal

    !--------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine imposed a Cyclic boundary condition for a vectorial property          !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine CyclicBoundVectTangential ( Vector, VectorD)

        !Arguments------------------------------------------------------------
        
        real,    dimension (:,:,:), pointer, optional :: Vector
        real(8), dimension (:,:,:), pointer, optional :: VectorD

        !Local---------------------------------------------------------------------
        integer, dimension (:,:  ), pointer :: BoundaryPoints
        integer                             :: IUB, ILB, JUB, JLB, KLB, KUB
        integer                             :: i, j, k

        integer                             :: CHUNK
        
        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB

        BoundaryPoints => Me%External_Var%BoundaryPoints

        !End   - Shorten variables name
        
        !Tangential boundary faces --------------------------------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "CyclicBoundVectTangential")
        endif  
                    
cd1:    if (Me%Direction%XY == DirectionY_) then

            CHUNK = CHUNK_I(ILB, IUB)
            !$OMP PARALLEL PRIVATE(i,k)

do1:        do k = KLB, KUB 
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do2:        do i = ILB, IUB

                if (BoundaryPoints(i, JUB) == Boundary) then

                    if (present(Vector )) Vector  (i, JUB, k) = Vector (i, JLB + 1, k)
                    if (present(VectorD)) VectorD (i, JUB, k) = VectorD(i, JLB + 1, k)

                endif

                if (BoundaryPoints(i, JLB) == Boundary) then       
                        
                    if (present(Vector )) Vector  (i, JLB, k) = Vector (i, JUB - 1, k)
                    if (present(VectorD)) VectorD (i, JLB, k) = VectorD(i, JUB - 1, k)

                endif

            enddo do2
            !$OMP END DO NOWAIT
            enddo do1
            !$OMP END PARALLEL

        endif cd1


cd2:    if (Me%Direction%XY == DirectionX_) then

            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP PARALLEL PRIVATE(j,k)
do3:        do k = KLB, KUB 
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do4:        do j = JLB, JUB

                if (BoundaryPoints(IUB, j) == Boundary) then                   
                    if (present(Vector )) Vector  (IUB, j, k) = Vector (ILB + 1, j, k)
                    if (present(VectorD)) VectorD (IUB, j, k) = VectorD(ILB + 1, j, k)
                endif
               
                if (BoundaryPoints(ILB, j) == Boundary) then
                    if (present(Vector )) Vector  (ILB, j, k) = Vector (IUB - 1, j, k)
                    if (present(VectorD)) VectorD (ILB, j, k) = VectorD(IUB - 1, j, k)
                endif

            enddo do4
            !$OMP END DO NOWAIT
            enddo do3
            !$OMP END PARALLEL

        endif cd2

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "CyclicBoundVectTangential")
        endif  

        nullify(BoundaryPoints)

        !----------------------------------------------------------------------

    End Subroutine CyclicBoundVectTangential

    !--------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine imposed a Cyclic boundary condition for vertical velocity or flux    !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine CyclicBoundVertical (Vector, VectorD)

        !Arguments------------------------------------------------------------
        
        real,    dimension (:,:,:), pointer, optional :: Vector
        real(8), dimension (:,:,:), pointer, optional :: VectorD

        !Local---------------------------------------------------------------------
        integer, dimension (:,:  ), pointer :: BoundaryPoints
        integer                             :: IUB, ILB, JUB, JLB, KLB, KUB
        integer                             :: i, j, k

        integer                             :: CHUNK

        !Begin----------------------------------------------------------------

        !Begin - Shorten variables name 

        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB

        BoundaryPoints => Me%External_Var%BoundaryPoints

        !End   - Shorten variables name
        
        !Tangential boundary faces --------------------------------------------------------------------------
 
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "CyclicBoundVertical")
        endif                      

f1:     if (Me%CyclicBoundary%Direction == DirectionX_ .or. &
            Me%CyclicBoundary%Direction == DirectionXY_)  then

            CHUNK = CHUNK_I(ILB, IUB)
            
            !$OMP PARALLEL PRIVATE(i,k)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do1:        do i = ILB, IUB

                if (BoundaryPoints(i, JUB) == Boundary) then

do2:               do k = KLB, KUB + 1

                        if (present(Vector )) Vector  (i, JUB, k) = Vector (i, JLB + 1, k)
                        if (present(VectorD)) VectorD (i, JUB, k) = VectorD(i, JLB + 1, k)

                    enddo do2

                endif

                if (BoundaryPoints(i, JLB) == Boundary) then       

do3:                do k = KLB, KUB + 1
                    
                        if (present(Vector )) Vector  (i, JLB, k) = Vector (i, JUB - 1, k)
                        if (present(VectorD)) VectorD (i, JLB, k) = VectorD(i, JUB - 1, k)

                    enddo do3

                endif

            enddo do1
            !$OMP END DO
            !$OMP END PARALLEL

        endif f1


f2:     if (Me%CyclicBoundary%Direction == DirectionY_ .or. &
            Me%CyclicBoundary%Direction == DirectionXY_)  then

            CHUNK = CHUNK_J(JLB, JUB)
            
            !$OMP PARALLEL PRIVATE(j,k)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do4:        do j = JLB, JUB

                if (BoundaryPoints(IUB, j) == Boundary) then                   

do5:                do k = KLB, KUB + 1
                    
                        if (present(Vector )) Vector  (IUB, j, k) = Vector (ILB + 1, j, k)
                        if (present(VectorD)) VectorD (IUB, j, k) = VectorD(ILB + 1, j, k)

                    enddo do5

                endif
           
                if (BoundaryPoints(ILB, j) == Boundary) then

do6:               do k = KLB, KUB + 1
                
                        if (present(Vector )) Vector  (ILB, j, k) = Vector (IUB - 1, j, k)
                        if (present(VectorD)) VectorD (ILB, j, k) = VectorD(IUB - 1, j, k)

                    enddo do6

                endif

            enddo do4
            !$OMP END DO
            !$OMP END PARALLEL

        endif f2

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "CyclicBoundVertical")
        endif      

        nullify(BoundaryPoints)

        !----------------------------------------------------------------------

    End Subroutine CyclicBoundVertical

    !--------------------------------------------------------------------------




    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine compute the Sommerfeld radition condition for the open boundary      !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_FlatherWindWave ( WaterFlux_XY, WaterFlux_YX,  &
                                     WaterColumnUV, DUX_VY, DVY_UX, DYY_XX,              &
                                     ComputeFaces3D_UV, ComputeFaces3D_VU,               &
                                     BoundaryFacesUV, kfloor_UV, kfloor_VU,              &
                                     di, dj, ImplicitFaces)

        !Arguments------------------------------------------------------------
        
        real(8), dimension (:,:,:), pointer :: WaterFlux_XY, WaterFlux_YX
        real,    dimension (:,:  ), pointer :: WaterColumnUV, DUX_VY, DVY_UX, DYY_XX 
        integer, dimension (:,:,:), pointer :: ComputeFaces3D_UV, ComputeFaces3D_VU
        integer, dimension (:,:  ), pointer :: BoundaryFacesUV, kfloor_UV, kfloor_VU
        integer                             :: di, dj
        logical                             :: ImplicitFaces


        !Local---------------------------------------------------------------------
        integer                             :: i, j, k 
        integer, pointer, dimension (:,:)   :: BoundaryPoints


        real(8), dimension(:,:), pointer    :: ECoef_2D
        real,    dimension(:,:), pointer    :: DCoef_2D, FCoef_2D, TiCoef_2D,         &
                                               ImposedElevation, OldImposedElevation, &
                                               ImposedVelocity,                       &
                                               WaterLevel_New, BoundaryReferenceLevel,&
                                               RadCoef_2D, TiRadCoef_2D, WaterLevel_Old


        real,    dimension(:,:,:), pointer  :: SZZ  
                   

        real                                :: D1, D2, E1, E2, E3, E4, F1, F2,  &
                                               T1, T2, T3, T4, A_Aux, B_Aux,    &
                                               HT_boundary, Wave_Celerity,      &
                                               DT_Elevation, WaveEntering,      &
                                               OldWaveEntering, ReferenceLevel

        real(8)                             :: FluxXY_L, FluxYX_L, FluxMod_L,   &  
                                               FluxXY_E, FluxYX_E,              &
                                               FluxXY_T, FluxYX_T,              &
                                               Flux_WestSouth, Flux_EastNorth,  &
                                               Flux_SouthWest, Flux_NorthEast,  &
                                               XY_Component_L, XY_Component_E,  &
                                               XY_Component_Cart_E,             &
                                               YX_Component_Cart_E,             &
                                               WaterFluxBoundary,               &
                                               EnteringWaveDirection,           &
                                               LeavingVelocity !, LeavingVelocityXY
        
        real                                :: MinLeavingComponent,  MinLeavingVelocity 


        integer                             :: IUB, ILB, JUB, JLB, KUB,         &
                                               i1, i2, i3, i4, j1, j2, j3, j4,  &
                                               db, kbottom,                     &
                                               ib, jb, i_int, j_int

                                               
        !In the future this values will be read from the hydrodynamic data file 
        real, parameter                     :: WaveReflection_Coef = 1.

        logical                             :: Compute_Tide

        integer                             :: status

        integer                             :: DirX, DirY, DirBound

        integer                             :: CHUNK
        
        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        DT_Elevation  =  Me%WaterLevel%DT

        DCoef_2D      => Me%Coef%D2%D
        ECoef_2D      => Me%Coef%D2%E
        FCoef_2D      => Me%Coef%D2%F
        TiCoef_2D     => Me%Coef%D2%Ti

        RadCoef_2D    => Me%Coef%D2%Rad
        TiRadCoef_2D  => Me%Coef%D2%TiRad

        SZZ                  => Me%External_Var%SZZ

        !Geometry
!        WaterColumnUV        => Me%External_Var%WaterColumnUV
!        DUX_VY               => Me%External_Var%DUX_VY
!        DVY_UX               => Me%External_Var%DVY_UX
!        DYY_XX               => Me%External_Var%DYY_XX

!        kfloor_UV            => Me%External_Var%kfloor_UV
!        kfloor_VU            => Me%External_Var%kfloor_VU



        !Flow
!        WaterFlux_XY    => Me%WaterFluxes%XY
!        WaterFlux_YX    => Me%WaterFluxes%YX
        WaterLevel_New  => Me%WaterLevel%New
        WaterLevel_Old  => Me%WaterLevel%Old


!        BoundaryFacesUV   => Me%External_Var%BoundaryFacesUV
        BoundaryPoints    => Me%External_Var%BoundaryPoints

!        ComputeFaces3D_UV =>  Me%External_Var%ComputeFaces3D_UV
!        ComputeFaces3D_VU =>  Me%External_Var%ComputeFaces3D_VU

        EnteringWaveDirection =  Me%ComputeOptions%EnteringWaveDirection
        
        MinLeavingComponent   =  Me%ComputeOptions%MinLeavingComponent
        MinLeavingVelocity    =  Me%ComputeOptions%MinLeavingVelocity


        Compute_Tide          = Me%ComputeOptions%Compute_Tide
        
        !End   - Shorten variables name


        call Modify_OpenBoundary(Me%ObjOpenBoundary,                                    &
                                 Me%CurrentTime,                                        &
                                 Me%External_Var%AtmosphericPressure,                   &                                 
                                 Me%ComputeOptions%AtmosphereCoef,                      &
                                 STAT        = status)
        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR01")


        call GetImposedElevation(Me%ObjOpenBoundary,                        &
                                  ImposedElevation, STAT = status)


        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR02")


        call GetOldImposedElevation(Me%ObjOpenBoundary, &
                                    OldImposedElevation, STAT = status)


        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR03")


        call GetOpenBoundParameter(Me%ObjOpenBoundary, DirectionX = DirX,   &
                                                                    DirectionY = DirY, STAT= status)

        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR03a")


        if      (Me%Direction%XY == DirectionX_) then

            DirBound = DirX

        else if (Me%Direction%XY == DirectionY_) then

            DirBound = DirY

        endif


        call GetImposedVelocity   (Me%ObjOpenBoundary, ImposedVelocity,     &
                                   DirBound, STAT= status)

        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR03b")

        !PCL

cd23:   if (Me%Relaxation%RefBoundWaterLevel) then
        
            !call GetAssimilationList(WaterLevel = PropertyID)

            call GetAssimilationField(Me%ObjAssimilation,                   &
!                                      ID              = PropertyID,                      &
                                      ID              = WaterLevel_,                     &
                                      Field2D         = BoundaryReferenceLevel,          &
                                      STAT            = status)

            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR04")


        else   cd23

            call GetBoundaryReferenceLevel(Me%ObjOpenBoundary,              &
                                           BoundaryReferenceLevel, STAT = status)

            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR05")


        endif cd23

        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "WaterLevel_FlatherWindWave")
        
        !$OMP PARALLEL PRIVATE(i,j,kbottom,HT_Boundary,db,i1,i2,i3,i4,j1,j2,j3,j4,Flux_WestSouth) &
        !$OMP PRIVATE(Flux_EastNorth,Flux_SouthWest,Flux_NorthEast,ib,jb,ReferenceLevel) &
        !$OMP PRIVATE(WaveEntering,OldWaveEntering,i_int,j_int,Wave_Celerity,XY_Component_Cart_E) &
        !$OMP PRIVATE(YX_Component_Cart_E,FluxXY_E,FluxYX_E,FluxXY_T,FluxYX_T,FluxXY_L,FluxYX_L) &
        !$OMP PRIVATE(FluxMod_L,LeavingVelocity,XY_Component_L,XY_Component_E,WaterFluxBoundary) &
        !$OMP PRIVATE(A_aux,T3,B_aux,D1,D2,E1,E2,E3,E4,F1,F2,T1,T2,T4)
  
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB

            
            !In this way if in a boundary point the elevation is not change 
            !due to the radiation condition then 
            !the old elevation is maintain 
!cd9:        if (BoundaryPoints(i, j) == Boundary) then

                !TiCoef_2D(i, j) = WaterLevel_New(i, j)

                !DCoef_2D (i, j) = 0. 

                !ECoef_2D (i, j) = 1.

                !FCoef_2D (i, j) = 0. 


            !endif cd9
            
cd1:        if  (BoundaryFacesUV  (i, j     )  == Boundary     .and.                     &
                 ComputeFaces3D_UV(i, j, KUB)  == Covered      .and.                     & 
                (BoundaryPoints   (i, j)       == Not_Boundary .or.                      &
                 BoundaryPoints   (i-di, j-dj) == Not_Boundary)) then


                kbottom = kfloor_UV(i, j) 

               ![m] = [m^2]/[m] 
                HT_boundary = WaterColumnUV(i, j)


                !Direction - Leaving wave
                if (BoundaryPoints(i, j) == Boundary) then 

                    !West or South cell is interior and
                    !the East or North cell is boundary
                    db = 1

                    i1 = i - di
                    i2 = i       
                    i3 = i - di
                    i4 = i + dj - di
                    j1 = j - dj
                    j2 = j       
                    j3 = j - dj
                    j4 = j - dj + di


                else 

                    !West or South cell is boundary and
                    !the East or North cell is interior
                    db = 0

                    i1 = i
                    i2 = i + di
                    i3 = i
                    i4 = i + dj 
                    j1 = j
                    j2 = j + dj 
                    j3 = j
                    j4 = j + di


                endif

                !total West or South face water flux
                Flux_WestSouth = 0.    

cd2:            if (ComputeFaces3D_UV(i1, j1, KUB) == Covered) then 

                    kbottom = kfloor_UV(i1, j1) 

                    do  k = kbottom, KUB
                    
                        Flux_WestSouth = Flux_WestSouth + WaterFlux_XY(i1, j1, k)

                    enddo
                
                endif cd2


                !total East or North face water flux
                Flux_EastNorth = 0.    

cd3:            if (ComputeFaces3D_UV(i2, j2, KUB) == Covered) then 

                    kbottom = kfloor_UV(i2, j2) 

                    do  k = kbottom, KUB
                    
                        Flux_EastNorth = Flux_EastNorth + WaterFlux_XY(i2, j2, k)

                    enddo

                endif cd3


                !total South or West face water flux
                Flux_SouthWest = 0.    

cd4:            if (ComputeFaces3D_VU(i3, j3, KUB) == Covered) then 

                    kbottom = kfloor_VU(i3, j3) 

                    do  k = kbottom, KUB
                        
                        Flux_SouthWest = Flux_SouthWest + WaterFlux_YX(i3, j3, k) 

                    enddo

                endif cd4


                !total North or East face water flux

                Flux_NorthEast = 0.    

cd5:            if (ComputeFaces3D_VU(i4, j4, KUB) == Covered) then 

                    kbottom = kfloor_VU(i4, j4) 

                    do  k = kbottom, KUB
                    
                        Flux_NorthEast = Flux_NorthEast + WaterFlux_YX(i4, j4, k)

                    enddo

                endif cd5

                !Boundary cell
                !X direction (di=0,dj=1) - boundary West  cell (db=0) => (ib,jb)=(i, j-1)
                !X direction (di=0,dj=1) - boundary East  cell (db=1) => (ib,jb)=(i, j)
                !Y direction (di=1,dj=0) - boundary South cell (db=0) => (ib,jb)=(i-1, j)
                !Y direction (di=1,dj=0) - boundary North cell (db=1) => (ib,jb)=(i, j)

                ib    = i - di * (1 - db)
                jb    = j - dj * (1 - db)

                ReferenceLevel   = BoundaryReferenceLevel (ib, jb) 
                WaveEntering     = ImposedElevation       (ib, jb) - ReferenceLevel
                OldWaveEntering  = OldImposedElevation    (ib, jb) - ReferenceLevel

                !Interior cell next to a boundary face
                !X direction (di=0,dj=1) - Interior East  cell (db=0) => (ib,jb)=(i, j)
                !X direction (di=0,dj=1) - Interior West  cell (db=1) => (ib,jb)=(i, j-1)
                !Y direction (di=1,dj=0) - Interior North cell (db=0) => (ib,jb)=(i, j)
                !Y direction (di=1,dj=0) - Interior South cell (db=1) => (ib,jb)=(i-1, j)

                i_int = i - di * db
                j_int = j - dj * db

                !The wave Celerity compute in the boundary face 
                ![m/s] = [m/s^2*m]^.5 = [m/s]
                Wave_Celerity = sqrt(Gravity * HT_Boundary) 
                

                !If was defined a entering wave then 
cd15:           if (Me%ComputeOptions%ComputeEnteringWave) then

                    !Direction - Entering wave - Cartesian referencial
                    XY_Component_Cart_E  = dj * cos(EnteringWaveDirection) +  &
                                           di * sin(EnteringWaveDirection)
                    YX_Component_Cart_E  = dj * sin(EnteringWaveDirection) +  &
                                           di * cos(EnteringWaveDirection)

                    if (abs(XY_Component_Cart_E) < MinLeavingComponent) XY_Component_Cart_E = 0.
                    if (abs(YX_Component_Cart_E) < MinLeavingComponent) YX_Component_Cart_E = 0.



                    !If the flow of the entering wave is going from the inside the domain to the 
                    !outside then the entering flow is consider be zero

                    if ((XY_Component_Cart_E <= 0 .and. db == 0) .or.  &  !West or South cell boundary
                        (XY_Component_Cart_E >= 0 .and. db == 1)) then    !East or North cell boundary

                        XY_Component_Cart_E  = 0.

                        WaveEntering         = 0.
                        OldWaveEntering      = 0.

                    endif


                    !Flow - Entering wave - Cartesian referencial. In necessary to compute 
                    !the entering fluxes in cartesian referencial to be consistent witht the 
                    !total fluxes

                    ![m^3/s] = [m] * [m/s] * [ ] * [m]
                    FluxXY_E = WaveEntering * Wave_Celerity *  &
                               XY_Component_Cart_E * DVY_UX(i, j) 

                    ![m^3/s] = [m] * [m/s] * [ ] * [m]
                    FluxYX_E = WaveEntering * Wave_Celerity *  &
                               YX_Component_Cart_E * DUX_VY(i, j)
                                    
                else cd15

                    XY_Component_Cart_E  = 0.

                    WaveEntering         = 0.
                    OldWaveEntering      = 0.

                    FluxXY_E             = 0.
                    FluxYX_E             = 0.

                endif cd15


                !The leaving wave direction is compute in the center of the 
                !first interior cell 
                FluxXY_T = (Flux_WestSouth + Flux_EastNorth) / 2. 


                FluxYX_T = (Flux_SouthWest + Flux_NorthEast) / 2. 


                !Flow - Leaving wave - Cartesian referencial
                FluxXY_L = FluxXY_T - FluxXY_E
                FluxYX_L = FluxYX_T - FluxYX_E

                FluxMod_L = pythag (FluxXY_L, FluxYX_L)

                LeavingVelocity   = FluxMod_L      / DYY_XX(i, j)  / HT_Boundary


                if (LeavingVelocity < MinLeavingVelocity)    then 

                    XY_Component_L = 1.

                else

                    XY_Component_L = abs(FluxXY_L) / FluxMod_L

                endif
                !If the flow of the leaving wave is going from inside the domain to the 
                !outside then the flow must be positive in the oposite condition it must 
                !be negative
                if (db == 0) then  !West or South cell boundary
                    ![ ] = [m^3/s] / [m^3/s]
                    XY_Component_E  =   abs(XY_Component_Cart_E)

                    XY_Component_L  = - abs(XY_Component_L)

                    !The total OLD water flux in the boundary face
                    WaterFluxBoundary = Flux_WestSouth 


                else if (db == 1) then !East or North cell boundary

                    ![ ] = [m^3/s] / [m^3/s]
                    XY_Component_E  = - abs(XY_Component_Cart_E)

                    XY_Component_L  = + abs(XY_Component_L)

                    !The total OLD water flux in the boundary face
                    WaterFluxBoundary = Flux_EastNorth


                endif


                if (abs(XY_Component_L)  > 1. )  then
                    !!!! $OMP CRITICAL (WLFWW1_STOP01)
                    Stop 'XY_Component_L = 1'
                    !!!! $OMP END CRITICAL (WLFWW1_STOP01)
                endif

                if (ImplicitFaces) then


                    ![s^-1] = [m^2/s] / [m] / [m]
                    A_aux = RadCoef_2D(I, J) / DYY_XX(i, j) / HT_Boundary

                    ![m/s]    = [m^3/s] / [m] / [m]
                    T3        = + TiRadCoef_2D(I, J) / DYY_XX(i, j) / HT_Boundary
                

                else

                    ![s^-1]   = [m^2/s] / [m] / [m]
                    A_aux     = 0. 

                    ![m/s]    = [m^3/s] / [m] / [m]
                    T3        = WaterFluxBoundary / DYY_XX(i, j) / HT_Boundary


                endif

               
                T3            = T3 - ImposedVelocity(ib, jb) * XY_Component_Cart_E

                
                ![m^-1*s^-1] = [m/s] * [ ] * [ ] / [m] / [m]
                B_aux =  Wave_Celerity * XY_Component_L * WaveReflection_Coef &
                           / (DUX_VY(i - di, j - dj) + DUX_VY(i, j)) / HT_Boundary


                ![s^-1]   = [ ] * [s^-1] + [m^-1*s^-1] * [m]
                D1        = - db * A_aux
                D2        = + db * B_aux * DUX_VY(i, j)

                E1        = + db * A_Aux 
                E2        = + db * B_aux * DUX_VY(i - di, j - dj)
                E3        = - (1 - db) * A_aux
                E4        = + (1 - db) * B_aux * DUX_VY(i, j) 

                F1        = + (1 - db) * A_aux
                F2        = + (1 - db) * B_aux * DUX_VY(i - di, j - dj)

                ! [s^-1] = ([m/s] / [m] )
                T1        = - Wave_Celerity * XY_Component_E / HT_Boundary

                T2        = + Wave_Celerity * XY_Component_L * WaveReflection_Coef / &
                              HT_Boundary

                    
                T4        = WaveEntering * T1 + T3 + (WaveEntering + ReferenceLevel) * T2 

cd7:            if (ImplicitFaces) then

                    DCoef_2D (ib, jb) = D1 + D2 

                    ECoef_2D (ib, jb) = E1 + E2 + E3 + E4

                    FCoef_2D (ib, jb) = F1 + F2

                    TiCoef_2D(ib, jb) = T4

                else cd7


                    DCoef_2D (ib, jb) = 0. 

                    ECoef_2D (ib, jb) = 1.

                    FCoef_2D (ib, jb) = 0.

                    TiCoef_2D(ib, jb) =   (T4 - (D2     ) * WaterLevel_New(ib - di, jb - dj)   &
                                        - (F2           ) * WaterLevel_New(ib + di, jb + dj))/ &
                                          (E2 + E4)

                endif cd7



            endif cd1

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "WaterLevel_FlatherWindWave")
        
        call UnGetOpenBoundary(Me%ObjOpenBoundary, ImposedElevation, STAT = status)
        if (status /= SUCCESS_) &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR08")


        call UnGetOpenBoundary(Me%ObjOpenBoundary, OldImposedElevation, STAT = status)
        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR09")

        call UnGetOpenBoundary(Me%ObjOpenBoundary, ImposedVelocity, STAT = status)
        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR09a")



cd24:   if (Me%Relaxation%RefBoundWaterLevel) then
        
            call UnGetAssimilation(Me%ObjAssimilation,                      &
                                    BoundaryReferenceLevel, STAT = status)

            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR10")


        else   cd24

            call UnGetOpenBoundary(Me%ObjOpenBoundary, BoundaryReferenceLevel, STAT = status)

            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR11")

        
        endif cd24

        !Nullify auxiliar variables
            
        !Linear system equation
        nullify (DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D, RadCoef_2D, TiRadCoef_2D)

        !Mapping
        nullify (BoundaryPoints)

        !Geometry
        nullify(SZZ)

        !Hydrodynamic
        nullify(WaterLevel_New)
        nullify(WaterLevel_Old)

        !----------------------------------------------------------------------

    End Subroutine WaterLevel_FlatherWindWave

    !--------------------------------------------------------------------------


      !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine compute the Sommerfeld radition condition for the open boundary      !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_FlatherLocalSolution

        !Arguments------------------------------------------------------------
        

        !Local---------------------------------------------------------------------
        real(8), dimension (:,:,:), pointer :: WaterFlux_XY, WaterFlux_YX,               &
                                               LocalFlux3D_XY, LocalFlux3D_YX
        real,    dimension (:,:,:), pointer :: LocalVel3D_X , LocalVel3D_Y
        real,    dimension (:,:  ), pointer :: LocalVel2D_XY, LocalVel2D_YX,             &
                                               LocalVel2D_X , LocalVel2D_Y
        real,    dimension (:,:  ), pointer :: WaterColumnUV, DUX_VY, DYY_XX, DXX_YY 
        
        integer, dimension (:,:,:), pointer :: ComputeFaces3D_UV, ComputeFaces3D_VU
        integer, dimension (:,:  ), pointer :: BoundaryFacesUV, kfloor_UV, kfloor_VU
        integer                             :: di, dj
        integer                             :: i, j, k 
        integer, pointer, dimension (:,:)   :: BoundaryPoints


        real(8), dimension(:,:), pointer    :: ECoef_2D
        real,    dimension(:,:), pointer    :: DCoef_2D, FCoef_2D, TiCoef_2D,            &
                                               WaterLevel_New,  GaugeWaterLevel,         &
                                               AssimilaWaterLevel, SubModelWaterLevel,   &
                                               RadCoef_2D, TiRadCoef_2D, Bathymetry 
        real,    dimension(:,:,:), pointer  :: SZZ  
                   
        real                                :: D1, D2, E1, E2, E3, E4, F1, F2,           &
                                               T1, T3, T4, A_Aux, B_Aux,                 &
                                               HT_boundary, Wave_Celerity,               &
                                               DT_Elevation, LocalWave, DT_RunPeriod, SlowCoef

        real(8)                             :: FluxXY_L, FluxYX_L, FluxMod_L,            &  
                                               FluxXY_E, FluxYX_E,                       &
                                               FluxXY_T, FluxYX_T,                       &
                                               Flux_WestSouth, Flux_EastNorth,           &
                                               Flux_SouthWest, Flux_NorthEast,           &
                                               LocalFlux_WestSouth, LocalFlux_EastNorth, &
                                               LocalFlux_SouthWest, LocalFlux_NorthEast, &
                                               XY_Component_L,                           &
                                               WaterFluxBoundary, LocalBoundaryFlux,     &
                                               LeavingVelocity, Aux1, Aux2
        
        real                                :: MinLeavingComponent,  MinLeavingVelocity, LocalWLa, LocalWLb

        integer                             :: IUB, ILB, JUB, JLB, KUB,         &
                                               i1, i2, i3, i4, j1, j2, j3, j4,  &
                                               db, kbottom,                     &
                                               ib, jb, i_int, j_int


        integer                             :: status

        integer                             :: DirX, DirY, DirBoundXY, DirBoundYX
        
        logical                             :: LocalSolution, LocalAssimila, LocalSubModel, LocalGauge

                                               
        !In the future this values will be read from the hydrodynamic data file 
        real,    parameter                  :: WaveReflection_Coef = 1.

        integer                             :: CHUNK
        
        !Begin----------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        
        di  = Me%Direction%di
        dj  = Me%Direction%dj


        DT_Elevation  =  Me%WaterLevel%DT

        DCoef_2D          => Me%Coef%D2%D
        ECoef_2D          => Me%Coef%D2%E
        FCoef_2D          => Me%Coef%D2%F
        TiCoef_2D         => Me%Coef%D2%Ti

        RadCoef_2D        => Me%Coef%D2%Rad
        TiRadCoef_2D      => Me%Coef%D2%TiRad

        SZZ               => Me%External_Var%SZZ

        WaterLevel_New    => Me%WaterLevel%New

        WaterFlux_XY      => Me%WaterFluxes%XY 
        WaterFlux_YX      => Me%WaterFluxes%YX 

        WaterColumnUV     => Me%External_Var%WaterColumnUV
        DUX_VY            => Me%External_Var%DUX_VY
        DYY_XX            => Me%External_Var%DYY_XX
        DXX_YY            => Me%External_Var%DXX_YY
        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV
        ComputeFaces3D_VU => Me%External_Var%ComputeFaces3D_VU
        BoundaryFacesUV   => Me%External_Var%BoundaryFacesUV
        Kfloor_UV         => Me%External_Var%Kfloor_UV
        Kfloor_VU         => Me%External_Var%Kfloor_VU
                           
        BoundaryPoints    => Me%External_Var%BoundaryPoints

       
        MinLeavingComponent   =  Me%ComputeOptions%MinLeavingComponent
        MinLeavingVelocity    =  Me%ComputeOptions%MinLeavingVelocity

       
        !End   - Shorten variables name

        LocalSolution = .true.

        LocalAssimila = .false.

        LocalGauge    = .false.

        LocalSubModel = .false.


        !Gets Bathymetry
        call GetGridData(Me%ObjGridData,                                                &
                           Bathymetry, STAT = status)
        
        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR010")


cd0:    if (Me%ComputeOptions%LocalSolution == Gauge_             .or.                  &
            Me%ComputeOptions%LocalSolution == GaugePlusSubModel_ .or.                  &
            Me%ComputeOptions%LocalSolution == AssimilaGaugeSubModel_) then


            call Modify_OpenBoundary(Me%ObjOpenBoundary,                                &
                                     Me%CurrentTime,                                    &
                                     Me%External_Var%AtmosphericPressure,               &
                                     Me%ComputeOptions%AtmosphereCoef,                  &
                                     STAT        = status)
            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR020")


            call GetImposedElevation(Me%ObjOpenBoundary,                                &
                                      GaugeWaterLevel, STAT = status)


            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR030")



            call GetOpenBoundParameter(Me%ObjOpenBoundary, DirectionX = DirX,           &
                                                           DirectionY = DirY, STAT= status)

            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR040")


            if      (Me%Direction%XY == DirectionX_) then

                DirBoundXY = DirX
                DirBoundYX = DirY


            else if (Me%Direction%XY == DirectionY_) then

                DirBoundXY = DirY
                DirBoundYX = DirX

            endif

            LocalGauge = .true.

        endif cd0 


ifa:    if (Me%ComputeOptions%LocalSolution == AssimilationField_ .or.                  & 
            Me%ComputeOptions%LocalSolution == AssimilaPlusSubModel_ .or.               &
            Me%ComputeOptions%LocalSolution == AssimilaGaugeSubModel_) then 

            !call GetAssimilationList(WaterLevel = PropertyID)
            call GetAssimilationField(Me%ObjAssimilation,                               &
                                      ID              = WaterLevel_,                    &
                                      Field2D         = AssimilaWaterLevel,             &
                                      STAT            = status)

            if (status /= SUCCESS_) call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR050")
            
            if (Me%ComputeOptions%ExternalBarotropicVel2D) then            

                    call GetAssimilationField(Me%ObjAssimilation,                       &
                                              ID              = BarotropicVelocityU_,   &
                                              Field2D         = LocalVel2D_X,           &
                                              STAT            = status)

                    if (status /= SUCCESS_) call SetError (FATAL_, INTERNAL_,           &
                        "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR060")


                    call GetAssimilationField(Me%ObjAssimilation,                       &
                                              ID              = BarotropicVelocityV_,   &
                                              Field2D         = LocalVel2D_Y,           &
                                              STAT            = status)

                    if (status /= SUCCESS_) call SetError (FATAL_, INTERNAL_,           &
                        "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR070")

            else

                    call GetAssimilationField(Me%ObjAssimilation,                       &
                                              ID              = VelocityU_,             &
                                              Field3D         = LocalVel3D_X,           &
                                              STAT            = status)

                    if (status /= SUCCESS_) call SetError (FATAL_, INTERNAL_,           &
                        "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR080")


                    call GetAssimilationField(Me%ObjAssimilation,                       &
                                              ID              = VelocityV_,             &
                                              Field3D         = LocalVel3D_Y,           &
                                              STAT            = status)

                    if (status /= SUCCESS_) call SetError (FATAL_, INTERNAL_,           &
                        "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR090")
                    
                    nullify (LocalVel2D_X, LocalVel2D_Y)
                    allocate(LocalVel2D_X(Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB))
                    allocate(LocalVel2D_Y(Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB))

                    LocalVel2D_X(:,:) = 0.
                    LocalVel2D_Y(:,:) = 0.

                    do  j = JLB, JUB
                    do  i = ILB, IUB                    
i34:                    if (Me%External_Var%ComputeFaces3D_U(i, j, KUB) == Covered) then                     
                            kbottom = Me%External_Var%kfloor_U(i, j) 
                            do  k = kbottom, KUB
                                LocalVel2D_X(i, j) = LocalVel2D_X(i, j) + LocalVel3D_X(i, j, k) * &
                                                     Me%External_Var%DUZ(i, j, k) / Me%External_Var%WaterColumnU(i, j)
                            enddo 
                        endif i34
                    enddo
                    enddo
                    
                    do  j = JLB, JUB
                    do  i = ILB, IUB                    
i35:                    if (Me%External_Var%ComputeFaces3D_V(i, j, KUB) == Covered) then                     
                            kbottom = Me%External_Var%kfloor_V(i, j) 
                            do  k = kbottom, KUB
                                LocalVel2D_Y(i, j) = LocalVel2D_Y(i, j) + LocalVel3D_Y(i, j, k) * &
                                                     Me%External_Var%DVZ(i, j, k) / Me%External_Var%WaterColumnV(i, j)
                            enddo 
                        endif i35
                    enddo
                    enddo                    

            endif

            DT_RunPeriod = Me%CurrentTime - Me%BeginTime
            
            SlowCoef = 1.            

            if (Me%ComputeOptions%FlatherColdPeriod > DT_RunPeriod) then
                SlowCoef = (DT_RunPeriod / Me%ComputeOptions%FlatherColdPeriod) 
            endif

            if      (Me%Direction%XY == DirectionX_) then

                LocalVel2D_XY => LocalVel2D_X
                LocalVel2D_YX => LocalVel2D_Y

            else if (Me%Direction%XY == DirectionY_) then

                LocalVel2D_XY => LocalVel2D_Y
                LocalVel2D_YX => LocalVel2D_X

            endif

            LocalAssimila = .true.


        endif ifa

ifb:    if  (Me%ComputeOptions%LocalSolution == SubModel_            .or.               &
             Me%ComputeOptions%LocalSolution == AssimilaPlusSubModel_.or.               &
             Me%ComputeOptions%LocalSolution == GaugePlusSubModel_   .or.               &
             Me%ComputeOptions%LocalSolution == AssimilaGaugeSubmodel_) then 


            SubModelWaterLevel => Me%SubModel%Z 

            LocalFlux3D_XY     => Me%SubModel%qXY
             
            LocalFlux3D_YX     => Me%SubModel%qYX 


            LocalSubModel = .true.

        endif ifb

ifc:    if  (Me%ComputeOptions%LocalSolution == NoLocalSolution_) then 

            LocalSolution = .false.

        endif ifc

        CHUNK = CHUNK_J(JLB, JUB)
       
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_FlatherLocalSolution")
        endif
       
        !$OMP PARALLEL PRIVATE(i,j,kbottom,HT_boundary,db,i1,i2,i3,i4,j1,j2,j3,j4,ib) &
        !$OMP PRIVATE(jb,i_int,j_int,Aux1,Flux_WestSouth,LocalFlux_WestSouth,Aux2) &
        !$OMP PRIVATE(Flux_EastNorth,LocalFlux_EastNorth,Flux_SouthWest) &
        !$OMP PRIVATE(LocalFlux_SouthWest,Flux_NorthEast,LocalFlux_NorthEast) &
        !$OMP PRIVATE(Wave_Celerity,FluxXY_E,FluxYX_E,LocalWLa,LocalWLb,LocalWave) &
        !$OMP PRIVATE(FluxXY_T,FluxYX_T,FluxXY_L,FluxYX_L,FluxMod_L,LeavingVelocity) &
        !$OMP PRIVATE(XY_Component_L,WaterFluxBoundary,LocalBoundaryFlux,A_aux,T3) &
        !$OMP PRIVATE(B_aux,D1,D2,E1,E2,E3,E4,F1,F2,T1,T4)
        
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB

            
            !In this way if in a boundary point the elevation is not change 
            !due to the radiation condition then 
            !the old elevation is maintain 
cd9:        if (BoundaryPoints(i, j) == Boundary) then

                TiCoef_2D(i, j) = WaterLevel_New(i, j)

                DCoef_2D (i, j) = 0. 

                ECoef_2D (i, j) = 1.

                FCoef_2D (i, j) = 0. 


            endif cd9
            
cd1:        if  (BoundaryFacesUV  (i, j     )  == Boundary     .and.                     &
                 ComputeFaces3D_UV(i, j, KUB)  == Covered      .and.                     & 
                (BoundaryPoints   (i, j)       == Not_Boundary .or.                      &
                 BoundaryPoints   (i-di, j-dj) == Not_Boundary)) then


                kbottom = kfloor_UV(i, j) 

               ![m] = [m^2]/[m] 
                HT_boundary = WaterColumnUV(i, j)


                !Direction - Leaving wave
                if (BoundaryPoints(i, j) == Boundary) then 

                    !West or South cell is interior and
                    !the East or North cell is boundary
                    db = 1

                    i1 = i - di
                    i2 = i       
                    i3 = i - di
                    i4 = i + dj - di
                    j1 = j - dj
                    j2 = j       
                    j3 = j - dj
                    j4 = j - dj + di


                else 

                    !West or South cell is boundary and
                    !the East or North cell is interior
                    db = 0

                    i1 = i
                    i2 = i + di
                    i3 = i
                    i4 = i + dj 
                    j1 = j
                    j2 = j + dj 
                    j3 = j
                    j4 = j + di


                endif


                !Boundary cell
                !X direction (di=0,dj=1) - boundary West  cell (db=0) => (ib,jb)=(i, j-1)
                !X direction (di=0,dj=1) - boundary East  cell (db=1) => (ib,jb)=(i, j)
                !Y direction (di=1,dj=0) - boundary South cell (db=0) => (ib,jb)=(i-1, j)
                !Y direction (di=1,dj=0) - boundary North cell (db=1) => (ib,jb)=(i, j)

                ib    = i - di * (1 - db)
                jb    = j - dj * (1 - db)

                !Interior cell next to a boundary face
                !X direction (di=0,dj=1) - Interior East  cell (db=0) => (ib,jb)=(i, j)
                !X direction (di=0,dj=1) - Interior West  cell (db=1) => (ib,jb)=(i, j-1)
                !Y direction (di=1,dj=0) - Interior North cell (db=0) => (ib,jb)=(i, j)
                !Y direction (di=1,dj=0) - Interior South cell (db=1) => (ib,jb)=(i-1, j)

                i_int = i - di * db
                j_int = j - dj * db


                if (LocalSolution) then

                    if (LocalAssimila) then

                        Aux1 = dble(Bathymetry(i_int, j_int) + SlowCoef * AssimilaWaterLevel(i_int, j_int))

                    else

                        Aux1 = FillValueReal

                    endif


                else

                    Aux1 = 0.

                endif


                !total West or South face water flux
                Flux_WestSouth      = 0.    
                LocalFlux_WestSouth = 0.

cd2:            if (ComputeFaces3D_UV(i1, j1, KUB) == Covered) then 
                    
                    Aux2 = dble(DYY_XX(i1, j1)) 
                    
                    if (LocalSolution .and. LocalAssimila)                              &
                        LocalFlux_WestSouth = Aux1 * Aux2 * dble(SlowCoef * LocalVel2D_XY(i1, j1))

                    kbottom = kfloor_UV(i1, j1) 

                    do  k = kbottom, KUB
                    
                        Flux_WestSouth = Flux_WestSouth + WaterFlux_XY(i1, j1, k)

                        if (LocalSolution .and. LocalSubModel)                          &
                            LocalFlux_WestSouth = LocalFlux_WestSouth + LocalFlux3D_XY(i1, j1, k) * Aux2

                    enddo

                
                endif cd2


                !total East or North face water flux
                Flux_EastNorth      = 0.    
                LocalFlux_EastNorth = 0

cd3:            if (ComputeFaces3D_UV(i2, j2, KUB) == Covered) then 

                    Aux2 = dble(DYY_XX(i2, j2))

                    if (LocalSolution .and. LocalAssimila)                              &
                        LocalFlux_EastNorth = Aux1 * Aux2 * dble(SlowCoef * LocalVel2D_XY(i2, j2))

                    kbottom = kfloor_UV(i2, j2) 

                    do  k = kbottom, KUB
                    
                        Flux_EastNorth = Flux_EastNorth + WaterFlux_XY(i2, j2, k)

                        if (LocalSolution .and. LocalSubModel)                          &
                            LocalFlux_EastNorth = LocalFlux_EastNorth + LocalFlux3D_XY(i2, j2, k) * Aux2

                    enddo

                endif cd3


                !total South or West face water flux
                Flux_SouthWest      = 0.    
                LocalFlux_SouthWest = 0.

cd4:            if (ComputeFaces3D_VU(i3, j3, KUB) == Covered) then 

                    Aux2  = dble(DXX_YY(i3, j3))

                    if (LocalSolution .and. LocalAssimila)                              &
                        LocalFlux_SouthWest = Aux1 * Aux2 * dble(SlowCoef * LocalVel2D_YX(i3, j3))

                    kbottom = kfloor_VU(i3, j3) 

                    do  k = kbottom, KUB
                        
                        Flux_SouthWest = Flux_SouthWest + WaterFlux_YX(i3, j3, k) 

                        if (LocalSolution .and. LocalSubModel)                          &
                            LocalFlux_SouthWest = LocalFlux_SouthWest + LocalFlux3D_YX(i3, j3, k) * Aux2

                    enddo

                endif cd4


                !total North or East face water flux

                Flux_NorthEast      = 0.    
                LocalFlux_NorthEast = 0.

cd5:            if (ComputeFaces3D_VU(i4, j4, KUB) == Covered) then 

                    Aux2 = dble(DXX_YY(i4, j4))

                    if (LocalSolution .and. LocalAssimila)                              &
                        LocalFlux_NorthEast = Aux1 * Aux2 * dble(SlowCoef * LocalVel2D_YX(i4, j4))

                    kbottom = kfloor_VU(i4, j4) 

                    do  k = kbottom, KUB
                    
                        Flux_NorthEast = Flux_NorthEast + WaterFlux_YX(i4, j4, k)

                        if (LocalSolution .and. LocalSubModel)                          &
                            LocalFlux_NorthEast = LocalFlux_NorthEast + LocalFlux3D_YX(i4, j4, k) * Aux2

                    enddo

                endif cd5

                !The wave Celerity compute in the boundary face 
                ![m/s] = [m/s^2*m]^.5 = [m/s]
                
                Wave_Celerity = sqrt(Gravity * HT_Boundary) 
                !Wave_Celerity = 2.123163734


                !If was defined a entering wave then 
cd15:           if (LocalSolution) then

                    FluxXY_E = (LocalFlux_WestSouth + LocalFlux_EastNorth) / 2. 
                    FluxYX_E = (LocalFlux_SouthWest + LocalFlux_NorthEast) / 2. 

                    LocalWLa = 0.
                    LocalWLb = 0.

                    if (LocalGauge) then
                        LocalWLa = LocalWLa + GaugeWaterLevel(ib   , jb   )
                        LocalWLb = LocalWLb + GaugeWaterLevel(i_int, j_int)
                    endif

                    if (LocalSubModel) then
                        LocalWLa = LocalWLa + SubModelWaterLevel(ib   , jb   )
                        LocalWLb = LocalWLb + SubModelWaterLevel(i_int, j_int)
                    endif

                    if (LocalAssimila) then
                        LocalWLa = LocalWLa + SlowCoef * AssimilaWaterLevel(ib   , jb   )
                        LocalWLb = LocalWLb + SlowCoef * AssimilaWaterLevel(i_int, j_int)
                    endif


                    LocalWave = (LocalWLa * DUX_VY(i_int, j_int) +  &
                                 LocalWLb * DUX_VY(ib   , jb   ))/  &
                                (DUX_VY(i_int, j_int) + DUX_VY(ib   , jb))

                else cd15

                    LocalWave = 0.

                    FluxXY_E  = 0.
                    FluxYX_E  = 0.

                endif cd15


                !The leaving wave direction is compute in the center of the 
                !first interior cell 
                FluxXY_T = (Flux_WestSouth + Flux_EastNorth) / 2. 
                FluxYX_T = (Flux_SouthWest + Flux_NorthEast) / 2. 


                !Flow - Leaving wave - Cartesian referencial
                FluxXY_L = FluxXY_T - FluxXY_E
                FluxYX_L = FluxYX_T - FluxYX_E

                FluxMod_L = pythag (FluxXY_L, FluxYX_L)

                LeavingVelocity   = FluxMod_L / DYY_XX(i, j) / HT_Boundary

                if (LeavingVelocity < MinLeavingVelocity)    then 

                    XY_Component_L = 1.

                else

                    XY_Component_L = abs(FluxXY_L) / FluxMod_L

                endif
                !If the flow of the leaving wave is going from inside the domain to the 
                !outside then the flow must be positive in the oposite condition it must 
                !be negative
                if (db == 0) then  !West or South cell boundary
                    ![ ] = [m^3/s] / [m^3/s]
                    XY_Component_L  = - abs(XY_Component_L)

                    !The total OLD water flux in the boundary face
                    WaterFluxBoundary = Flux_WestSouth 

                    LocalBoundaryFlux = LocalFlux_WestSouth 


                else if (db == 1) then !East or North cell boundary

                    ![ ] = [m^3/s] / [m^3/s]
                    XY_Component_L  = + abs(XY_Component_L)

                    !The total OLD water flux in the boundary face
                    WaterFluxBoundary = Flux_EastNorth

                    LocalBoundaryFlux = LocalFlux_EastNorth

                endif


                if (abs(XY_Component_L)  > 1. )   Stop 'XY_Component_L = 1'

                ![s^-1] = [m^2/s] / [m] / [m]
                A_aux = RadCoef_2D(I, J) / DYY_XX(i, j) / HT_Boundary

                ![m^3/s]    = [m^3/s] 
                T3        = + TiRadCoef_2D(I, J) 
                
                ![m/s]    = [m^3/s]                
                T3            = (T3 - LocalBoundaryFlux) / DYY_XX(i, j) / HT_Boundary 

              
                
                ![m^-1*s^-1] = [m/s] * [ ] * [ ] / [m] / [m]
                B_aux =  Wave_Celerity * XY_Component_L * WaveReflection_Coef &
                           / (DUX_VY(i - di, j - dj) + DUX_VY(i, j)) / HT_Boundary


                ![s^-1]   = [ ] * [s^-1] + [m^-1*s^-1] * [m]
                D1        = - db * A_aux
                D2        = + db * B_aux * DUX_VY(i, j)

                E1        = + db * A_Aux 
                E2        = + db * B_aux * DUX_VY(i - di, j - dj)
                E3        = - (1 - db) * A_aux
                E4        = + (1 - db) * B_aux * DUX_VY(i, j) 

                F1        = + (1 - db) * A_aux
                F2        = + (1 - db) * B_aux * DUX_VY(i - di, j - dj)

                ! [m/s] = ([m] * [m/s] / [m] )
                T1        = + LocalWave * Wave_Celerity * XY_Component_L / HT_Boundary

                    
                T4        =  T1 + T3  


                DCoef_2D (ib, jb) = D1 + D2 

                ECoef_2D (ib, jb) = E1 + E2 + E3 + E4

                FCoef_2D (ib, jb) = F1 + F2

                TiCoef_2D(ib, jb) = T4 


            endif cd1

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_FlatherLocalSolution")
        endif

        !Gets Bathymetry
        call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = status)
        
        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR100")

        

cd24:   if (Me%ComputeOptions%LocalSolution == Gauge_             .or.                  &
            Me%ComputeOptions%LocalSolution == GaugePlusSubmodel_ .or.                  &
            Me%ComputeOptions%LocalSolution == AssimilaGaugeSubmodel_) then

            call UnGetOpenBoundary(Me%ObjOpenBoundary, GaugeWaterLevel, STAT = status)
            if (status /= SUCCESS_) &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR110")


        endif cd24



cd25:   if (Me%ComputeOptions%LocalSolution == AssimilationField_    .or.               &
            Me%ComputeOptions%LocalSolution == AssimilaPlusSubModel_ .or.               &
            Me%ComputeOptions%LocalSolution == AssimilaGaugeSubmodel_) then 


            call UnGetAssimilation(Me%ObjAssimilation,                                  &
                                    AssimilaWaterLevel, STAT = status)

            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR120")

            if (Me%ComputeOptions%ExternalBarotropicVel2D) then  

                call UnGetAssimilation(Me%ObjAssimilation,                                  &
                                        LocalVel2D_X, STAT = status)

                if (status /= SUCCESS_)                                                     &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR130")



                call UnGetAssimilation(Me%ObjAssimilation,                                  &
                                        LocalVel2D_Y, STAT = status)

                if (status /= SUCCESS_)                                                     &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR140")
            else
            
            
                if (associated(LocalVel2D_X )) deallocate(LocalVel2D_X)
                if (associated(LocalVel2D_Y )) deallocate(LocalVel2D_Y)            

                call UnGetAssimilation(Me%ObjAssimilation,                                  &
                                        LocalVel3D_X, STAT = status)
                if (status /= SUCCESS_)                                                     &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR150")



                call UnGetAssimilation(Me%ObjAssimilation,                                  &
                                        LocalVel3D_Y, STAT = status)
                if (status /= SUCCESS_)                                                     &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR160")

                
            endif
        
        endif cd25
            

        !Nullify auxiliar variables
            
        !Linear system equation
        nullify (DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D, RadCoef_2D, TiRadCoef_2D)

        !Mapping
        nullify(BoundaryPoints   )
        nullify(ComputeFaces3D_UV)
        nullify(ComputeFaces3D_VU)
        nullify(BoundaryFacesUV  )
        nullify(Kfloor_UV        )
        nullify(Kfloor_VU        )


        !Geometry
        nullify(SZZ              )
        nullify(WaterColumnUV    )
        nullify(DUX_VY           )
        nullify(DXX_YY           )
        nullify(DYY_XX           )
        nullify(Bathymetry       )


        !Hydrodynamic
        nullify(WaterLevel_New   )

        nullify(WaterFlux_XY     )
        nullify(WaterFlux_YX     )

        nullify(LocalFlux3D_XY)
        nullify(LocalFlux3D_YX)

        nullify(SubModelWaterLevel)

        nullify(LocalVel2D_XY)
        nullify(LocalVel2D_YX)


        nullify(LocalVel2D_X )
        nullify(LocalVel2D_Y )


        !----------------------------------------------------------------------

    End Subroutine WaterLevel_FlatherLocalSolution

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------


      !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                        !
    ! This subroutine computes the implicit Blumberg and Kantha condition for elevation at OB !
    ! This condition is a combination of clamped and radiation conditions                    !
    !                                                                                        !
    ! Input : Mapping                                                                        !
    ! OutPut: Water Level at the open boundary                                               !
    ! Author: Manuel Ruiz Villarreal and Paulo Chambel, 2001                                 !
    !                                                                                        !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_BlumbergKantha 

        !Arguments------------------------------------------------------------
         


        !Local---------------------------------------------------------------------
        integer                             :: i, j, STAT_CALL, STAT
        integer, pointer, dimension (:,:)   :: BoundaryPoints, BoundaryFacesV, BoundaryFacesU, BoundaryFacesUV

        real(8), dimension(:,:), pointer    :: ECoef_2D
        real,    dimension(:,:), pointer    :: DCoef_2D, FCoef_2D, TiCoef_2D,         &
                                               ImposedElevation, WaterLevel_Old

        real,    dimension(:,:), pointer    :: DZX, DZY

        real,    dimension(:,:), pointer    :: Tlag

        real                                :: HT_boundary, DT_Elevation,                &
                                               Wave_Celerity, CoefRelax, DZX_ZY, CelAdim          

        integer                             :: IUB, ILB, JUB, JLB, KUB, db
        integer                             :: di,dj, i_normal, j_normal

        integer                             :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        DT_Elevation  =  Me%WaterLevel%DT

        DCoef_2D      => Me%Coef%D2%D
        ECoef_2D      => Me%Coef%D2%E
        FCoef_2D      => Me%Coef%D2%F
        TiCoef_2D     => Me%Coef%D2%Ti

        !Geometry
        DZX               => Me%External_Var%DZX
        DZY               => Me%External_Var%DZY
        
        !Map
        BoundaryFacesU   => Me%External_Var%BoundaryFacesU
        BoundaryFacesV   => Me%External_Var%BoundaryFacesV
        BoundaryFacesUV  => Me%External_Var%BoundaryFacesUV
        BoundaryPoints   => Me%External_Var%BoundaryPoints

        WaterLevel_Old   => Me%WaterLevel%Old
        Tlag             => Me%ComputeOptions%Tlag

        di  = Me%Direction%di
        dj  = Me%Direction%dj
        
        !End   - Shorten variables name


        call Modify_OpenBoundary(Me%ObjOpenBoundary,                                    &
                                 Me%CurrentTime,                                        &
                                 Me%External_Var%AtmosphericPressure,                   &
                                 Me%ComputeOptions%AtmosphereCoef,                      & 
                                 STAT        = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            Stop 'Sub. WaterLevel_BlumbergKantha - ModuleHydrodynamic - ERR01.'


        call GetImposedElevation(Me%ObjOpenBoundary, &
                                  ImposedElevation, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            Stop 'Sub. WaterLevel_BlumbergKantha - ModuleHydrodynamic - ERR02.'

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_BlumbergKantha")
        endif

        !$OMP PARALLEL PRIVATE(i,j,db, i_normal, j_normal, DZX_ZY, HT_Boundary)  &
        !$OMP PRIVATE(Wave_Celerity, CoefRelax, CelAdim, STAT)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)  
        do  j = JLB, JUB
        do  i = ILB, IUB
                        
cd1:        if (BoundaryPoints(i, j) == Boundary) then
            
                !Depending on where boundaryfaces are found:
                ! - db= 0, interior point contributes to DCoef; db= 1, interior point contributes to FCoef
                ! - The sign of the normal direction to the boundary
                ! - If the normal direction is X or Y. DZX(i-1,j) == Distance between elevation points i-1,j and i,j
                ! - The depth at the boundary face i,j, needed for computing wave_celerity
                ! In the case of generalised boundaries (i.e. boundary points with several open boundary faces),
                ! the first boundaryface found determines everything. For this purpose we use STAT
                ! Also for avoiding to impose elevation from BK in the explicit direction


                STAT = Unknown_
                
                ! 
                if (BoundaryFacesU(i,j) == Boundary) then

                   db = 0

                   i_normal =  0
                   j_normal = -1

                   DZX_ZY = DZX(i,j-1)

                   !Wave Celerity is computed at the boundary face                 
                   HT_boundary = Me%External_Var%WaterColumnU(i, j)

                   STAT = SUCCESS_

                end if

                if ((BoundaryFacesU(i,j+1) == Boundary).and.(STAT /= SUCCESS_)) then

                   db = 1

                   i_normal = 0
                   j_normal = 1

                   DZX_ZY = DZX(i,j)

                   !Wave Celerity is computed at the boundary face                 
                   HT_boundary = Me%External_Var%WaterColumnU(i, j+1)
                   

                   STAT = SUCCESS_

                end if

                if ((BoundaryFacesV(i,j) == Boundary).and.(STAT /= SUCCESS_)) then

                   db = 0

                   i_normal = -1
                   j_normal = 0

                   DZX_ZY = DZY(i-1,j)

                   !Wave Celerity is computed at the boundary face                 
                   HT_boundary = Me%External_Var%WaterColumnV(i, j)
                   
                   STAT = SUCCESS_

                end if

                if ((BoundaryFacesV(i+1,j) == Boundary).and.(STAT /= SUCCESS_) ) then

                   db = 1

                   i_normal = 1
                   j_normal = 0

                   DZX_ZY = DZY(i,j)

                   !Wave Celerity is computed at the boundary face                 
                   HT_boundary = Me%External_Var%WaterColumnV(i+1, j)


                   STAT = SUCCESS_

                end if    
                    
                if (STAT == SUCCESS_) then

                    ! Wave celerity of a barotropic wave
                    ![m/s] = [m/s^2*m]^.5 = [m/s]
                    Wave_Celerity     = sqrt (Gravity * HT_Boundary) 

                    CoefRelax         = DT_Elevation / Tlag(i, j)

                    CelAdim           = DT_Elevation * Wave_Celerity / DZX_ZY

                    if ((BoundaryFacesUV(i   ,j   ) == Boundary) .or.                    &
                        (BoundaryFacesUV(i+di,j+dj) == Boundary) ) then

                        !Note that the BK condition is discretized implicitly (but only in the implicit direction)!
                        TiCoef_2D(i, j)   = WaterLevel_Old(i,j) + ImposedElevation(i, j) * CoefRelax

                        ECoef_2D (i, j)   = 1. + CoefRelax + CelAdim

                        DCoef_2D (i, j)   = (-1) * (1-db)  * CelAdim

                        FCoef_2D (i, j)   = (-1) *    db   * CelAdim

                    else

                        TiCoef_2D(i, j)   = (1 - CelAdim)  * WaterLevel_Old  (i,         j)             + &
                                               CoefRelax   * ImposedElevation(i         ,j)             + &
                                         (1-db)  * CelAdim * WaterLevel_Old  (i+i_normal,j+j_normal)    + &
                                          db     * CelAdim * WaterLevel_Old  (i+i_normal,j+j_normal)

                        DCoef_2D (i, j)   = 0. 

                        ECoef_2D (i, j)   = 1. + CoefRelax

                        FCoef_2D (i, j)   = 0. 

                    end if

               
                else ! The boundary point has no faces with interior points 
                  
                  TiCoef_2D(i, j) = ImposedElevation(i, j)

                  DCoef_2D (i, j) = 0. 

                  ECoef_2D (i, j) = 1.

                  FCoef_2D (i, j) = 0. 
                                
                end if

            endif cd1

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL
        
        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_BlumbergKantha")
        endif
        
        call UnGetOpenBoundary(Me%ObjOpenBoundary, ImposedElevation, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            Stop 'Sub. WaterLevel_BlumbergKantha - ModuleHydrodynamic - ERR05.'

        !Nullify auxiliar variables

        !Linear system equation
        nullify (DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D)
        
        !Mapping
        nullify (BoundaryPoints, BoundaryFacesUV)

        !Geometry
        nullify(DZY, DZX)

        !Flow
        nullify(ImposedElevation, WaterLevel_Old)

        nullify (Tlag)

        !----------------------------------------------------------------------

    End Subroutine WaterLevel_BlumbergKantha

      !------------------------------------------------------------------------------


    FUNCTION spythag(a,b)
        REAL(4) :: a,b,spythag
        REAL(4) :: absa,absb

        absa = abs(a)
        absb = abs(b)
        if(absa.gt.absb)then
            spythag=absa*sqrt(1.+(absb/absa)**2)
        else
            if(absb.eq.0.)then
                spythag=0.
            else
                spythag=absb*sqrt(1.+(absa/absb)**2)
            endif
        endif
    END FUNCTION spythag


    FUNCTION dpythag(a,b)

        REAL(8) :: a,b,dpythag
        REAL(8) :: absa,absb

        absa = abs(a)
        absb = abs(b)
        if(absa.gt.absb)then
            dpythag=absa*sqrt(1.+(absb/absa)**2)
        else
            if(absb.eq.0.)then
                dpythag=0.
            else
                dpythag=absb*sqrt(1.+(absa/absb)**2)
            endif
        endif
    END FUNCTION dpythag




    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces equal to the closes covered face
    ! This is only needed to compute the velocity modulus in faces adjecent to the       
    ! exterior zone                                                                        
    !                                                                                     
    ! Input : Flow, Mapping                                                                 
    ! OutPut: Velocity                                                                     
    ! Author: Paulo Chambel (99/6) 
    ! Last modification MRV 2001: Possible separation of OB conditions for barotropic and baroclinic
    !                              components of velocity                                                        

    Subroutine Velocity_OpenBoundary 
    

        !Arguments-------------------------------------------------------------
        

        !Local-----------------------------------------------------------------
        real, pointer, dimension(:,:,:) :: Velocity_UV_New


        !Begin - Shorten variables name 


        !Begin-----------------------------------------------------------------

        Velocity_UV_New   => Me%Velocity%Horizontal%UV%New

        if( Me%ComputeOptions%BaroclinicRadia == Horizontal_) then
  
           call Compute_BaroclinicHorVelocity   

        end if

        !PCL - temporary
cdsub: if (Me%SubModel%ON                                           .and.               &
           Me%ComputeOptions%LocalSolution /= AssimilaPlusSubModel_ .and.               &
           Me%ComputeOptions%LocalSolution /= AssimilationField_    .and.               &
           Me%ComputeOptions%LocalSolution /= AssimilaGaugeSubModel_) then

            call VelSubModelNormalOB       ( Velocity_UV_New)


            call VelSubModelTangentialOB   ( Velocity_UV_New)

        else cdsub     

!PCL
!            if( Me%ComputeOptions%BaroclinicRadia == Horizontal_ ) then                                                

!                call VelNormalRadiaOpenBoundary    ( Velocity_UV_New,    &
!                                                    Me%VelBaroclinic%UV%New,&
!                                                    Me%VelBaroclinic%UV2D)



!                call VelTangentialRadiaOpenBoundary( Velocity_UV_New,    &
!                                                    Me%VelBaroclinic%UV%New,&
!                                                    Me%VelBaroclinic%UV2D)

!            else

                call VelNormalOpenBoundary     ( Velocity_UV_New)


                call VelTangentialOpenBoundary ( Velocity_UV_New)

!PCL
!            endif
            

        endif cdsub


        call MaskNonUsedFaces ( Velocity_UV_New)

        nullify(Velocity_UV_New)

    end Subroutine Velocity_OpenBoundary

    !------------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces equal to the sum
    ! of baroclinic component compute using a radiation equation plus 
    ! a barotropic component equal to zero (option : NULL_VALUE ) or equal
    ! to the adjcent compute face barotropic component (option : NULL_GRADIENT)
    !
    !                                                                                     
    ! Input : Flow, Mapping                                                                 
    ! OutPut: Velocity                                                                     
    ! Author: Paulo Chambel (99/6)                                                         

    Subroutine VelTangentialRadiaOpenBoundary ( Velocity_UV_New,         &
                                               BaroclinicUV, BarotropicUV)
    

        !Arguments-------------------------------------------------------------
        
        real,    dimension(:,:,:), pointer :: Velocity_UV_New, BaroclinicUV
        real,    dimension(:,:  ), pointer :: BarotropicUV
                                                
        !Local-----------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: SZZ
        real,    dimension(:,:  ), pointer :: DUX_VY
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: BoundaryPoints, KFloor_UV

        real                               :: Coef, Aux
        real                               :: DT_Velocity
        integer                            :: VelTangentialBoundary
        integer                            :: I, J, K, di, dj
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 


        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB


        BoundaryPoints           => Me%External_Var%BoundaryPoints

        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV         => Me%External_Var%KFloor_UV

        DUX_VY            => Me%External_Var%DUX_VY
        SZZ               => Me%External_Var%SZZ

        DT_Velocity           = Me%Velocity%DT

        VelTangentialBoundary =  Me%ComputeOptions%VelTangentialBoundary


        di  = Me%Direction%di
        dj  = Me%Direction%dj


        !End   - Shorten variables name
        


cd1:    if (VelTangentialBoundary == NULL_VALUE) then


            dok: do k = KLB, KUB 
            doj: do j = JLB, JUB
            doi: do i = ILB, IUB

                if (ImposedTangentialFacesUV(i, j, k) == Imposed) then

                    Velocity_UV_New(i, j, k)   = BaroclinicUV(i, j, k)

                endif
                                  
            enddo doi
            enddo doj
            enddo dok


        else if (VelTangentialBoundary == NULL_GRADIENT) then cd1

            dok1: do k = KLB, KUB 
            doj1: do j = JLB, JUB
            doi1: do i = ILB, IUB


cd2:            if (ImposedTangentialFacesUV(i, j, k) == Imposed) then 


                    Aux = ComputeFaces3D_UV(i + dj, j + di, k) *  &
                          ComputeFaces3D_UV(i - dj, j - di, k)
        
                    if (Aux == 1) then ! both faces are compute points
                        Coef = 0.5 ! average between the two velocities
                    else
                        Coef = 1.
                    endif

               !In the exterior faces the 
                !velocity is imposed equal to the nearst compute face
                    Velocity_UV_New(i, j, k) = Coef                                * &
                                           (BarotropicUV     (i + dj, j + di   )   * &
                                            ComputeFaces3D_UV(i + dj, j + di, k)   + &
                                            BarotropicUV     (i - dj, j - di   )   * &
                                            ComputeFaces3D_UV(i - dj, j - di, k))  + &
                                            BaroclinicUV(i, j, k)
                                 
                endif cd2

            enddo doi1
            enddo doj1
            enddo dok1


        endif cd1

        !Nullify auxiliar pointers
        nullify(ComputeFaces3D_UV       )
        nullify(ImposedTangentialFacesUV)
        nullify(BoundaryPoints          )
        nullify(KFloor_UV)

        nullify(DUX_VY)
        nullify(SZZ)

        

    end Subroutine VelTangentialRadiaOpenBoundary



    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces (faces normal to the open boundary)                                
    !                                                                                     
    ! Input : Flow, Mapping                                                                 
    ! OutPut: Velocity                                                                     
    ! Author: Paulo Chambel (99/6)                                                         

    Subroutine VelNormalRadiaOpenBoundary ( Velocity_UV_New,             &
                                           BaroclinicUV, BarotropicUV)
    

        !Arguments-------------------------------------------------------------
        
        real,    dimension(:,:,:), pointer :: Velocity_UV_New, BaroclinicUV
        real,    dimension(:,:  ), pointer :: BarotropicUV
                                                
        !Local-----------------------------------------------------------------
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV


        real                               :: Vel_Right, Vel_Left
        
        integer                            :: VelNormalBoundary, imax, jmax, imin, jmin

        integer                            :: I, J, K, di, dj     
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB


        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB


        ImposedNormalFacesUV   => Me%External_Var%ImposedNormalFacesUV

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV


        VelNormalBoundary =  Me%ComputeOptions%VelNormalBoundary

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !End   - Shorten variables name
        

        !--------------------------------------------------------------------------


cd1:    if (VelNormalBoundary == NULL_VALUE) then

            dok: do k = KLB, KUB 
            doj: do j = JLB, JUB + dj
            doi: do i = ILB, IUB + di

                if (ImposedNormalFacesUV(i, j, k) == Imposed) then

                    !In the exterior faces the 
                    !velocity is imposed equal to zero
                    Velocity_UV_New(i, j, k)   = BaroclinicUV(i, j, k) 

                endif
                                     
            enddo doi
            enddo doj
            enddo dok

        else if (VelNormalBoundary == NULL_GRADIENT) then  cd1

            dok1: do k = KLB, KUB 
            doj1: do j = JLB, JUB
            doi1: do i = ILB, IUB

cd2:            if (ImposedNormalFacesUV(i, j, k) == Imposed) then 


                     Vel_Left  = BarotropicUV     (i - di, j - dj)      *  &
                                 ComputeFaces3D_UV(i - di, j - dj, k)

                     Vel_Right = BarotropicUV     (i + di, j + dj   )   *  &
                                 ComputeFaces3D_UV(i + di, j + dj, k)

                    !In the exterior faces the 
                    !the barotropic velocity component is imposed equal to the nearest computed face
                    Velocity_UV_New(i, j, k)   =  Vel_Left + Vel_Right
                    !the baroclinic velocity component compute using a radiation equation is add                     
                    Velocity_UV_New(i, j, k)   =  Velocity_UV_New(i, j, k) + BaroclinicUV(i, j, k)
                                                 
                endif  cd2
                                   
            enddo doi1
            enddo doj1
            enddo dok1  

            !This is to avoid the error : arrays out of bounds

            imin = di * (IUB + di) + dj * ILB
            imax = di * (IUB + di) + dj * IUB
            
            jmin = dj * (JUB + dj) + di * JLB
            jmax = dj * (JUB + dj) + di * JUB

            dok2: do k = KLB, KUB 
            doi2: do i= imin, imax
            doj2: do j= jmin, jmax

cd3:            if (ImposedNormalFacesUV(i, j, k) == Imposed) then 

                         Vel_Left  = Velocity_UV_New  (i - di, j - dj, k) * &
                                     ComputeFaces3D_UV(i - di, j - dj, k)

                        !In the exterior faces the 
                        !velocity is imposed equal to the nearest computed face
                        Velocity_UV_New(i, j, k)   =  Vel_Left
                                                     
                
                endif  cd3

            enddo doj2
            enddo doi2
            enddo dok2

        endif cd1


        !Nullify auxiliar pointers
        nullify(ComputeFaces3D_UV)
        nullify(ImposedNormalFacesUV)

    end Subroutine VelNormalRadiaOpenBoundary

    !------------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces (faces normal to the open boundary)                                
    !                                                                                     
    ! Input : Flow, Mapping                                                                 
    ! OutPut: Velocity                                                                     
    ! Author: Paulo Chambel (99/6)                                                         

    Subroutine MaskNonUsedFaces ( Velocity_UV_New)
    

        !Arguments-------------------------------------------------------------
        
        real,    dimension(:,:,:), pointer :: Velocity_UV_New
                                                
        !Local-----------------------------------------------------------------

        integer, dimension(:,:  ), pointer :: BoundaryPoints, BoundaryFacesUV, ExteriorFacesUV


        integer                            :: I, J, K, di, dj     
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: status 
 
        integer                            :: CHUNK
        
        !Begin----------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB



        BoundaryFacesUV => Me%External_Var%BoundaryFacesUV
        BoundaryPoints  => Me%External_Var%BoundaryPoints

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !End   - Shorten variables name
        
cd0:    if      (Me%Direction%XY == DirectionX_) then

            call GetExteriorBoundaryFaces(Me%ObjHorizontalMap,              &
                                          BoundaryPointsFaceU = ExteriorFacesUV, STAT = status) 

            if (status /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, "MaskNonUsedFaces; Hydrodynamic. ERR01")     

        else if (Me%Direction%XY == DirectionY_) then cd0

            call GetExteriorBoundaryFaces(Me%ObjHorizontalMap,              &
                                      BoundaryPointsFaceV = ExteriorFacesUV, STAT = status) 

            if (status /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, "MaskNonUsedFaces; Hydrodynamic. ERR02")     

        endif cd0
        !--------------------------------------------------------------------------

        CHUNK = CHUNK_K(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "MaskNonUsedFaces")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k)  
doj:    do j = JLB, JUB
doi:    do i = ILB, IUB
                
cd1:        if (BoundaryPoints(i, j) == Boundary) then

                
cd2:            if(BoundaryFacesUV(i     , j     ) == Not_Boundary .and.                 &
                   BoundaryFacesUV(i + di, j + dj) == Not_Boundary) then 
                                                
cd3:                if (ExteriorFacesUV(i, j) == Exterior) then
                    
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                   dok: do k = KLB, KUB 

                            Velocity_UV_New(i, j, k) = Velocity_UV_New(i + di, j + dj, k)        

                        enddo dok
                    !$OMP END DO
                        
                    else if (ExteriorFacesUV(i + di, j + dj) == Exterior) then cd3
                              
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                   dol: do k = KLB, KUB 

                            Velocity_UV_New(i + di, j + dj, k) = Velocity_UV_New(i, j, k)

                        enddo dol
                    !$OMP END DO
 
                    endif cd3

                endif cd2

            endif cd1
                                 
        enddo doi
        enddo doj
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "MaskNonUsedFaces")
        endif

        call UnGetHorizontalMap (Me%ObjHorizontalMap,                       &
                                 ExteriorFacesUV, STAT = status) 

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "MaskNonUsedFaces; Hydrodynamic. ERR03")     


        !Nullify auxiliar pointers
        nullify(BoundaryFacesUV)
        nullify(BoundaryPoints )




    end Subroutine MaskNonUsedFaces

    !------------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces (faces normal to the open boundary)                                
    !                                                                                     
    ! Input : Flow, Mapping                                                                 
    ! OutPut: Velocity                                                                     
    ! Author: Paulo Chambel (99/6)                                                         

    Subroutine VelNormalOpenBoundary ( Velocity_UV_New)
    

        !Arguments-------------------------------------------------------------
        
        real,    dimension(:,:,:), pointer :: Velocity_UV_New
                                                
        !Local-----------------------------------------------------------------

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV


        real                               :: Vel_Right, Vel_Left
        
        integer                            :: VelNormalBoundary, imax, jmax, imin, jmin

        integer                            :: I, J, K, di, dj     
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB


        ImposedNormalFacesUV   => Me%External_Var%ImposedNormalFacesUV

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV


        VelNormalBoundary =  Me%ComputeOptions%VelNormalBoundary

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !End   - Shorten variables name
        

        !--------------------------------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "VelNormalOpenBoundary")
        endif

cd1:    if (VelNormalBoundary == NULL_VALUE) then

            CHUNK = CHUNK_J(JLB, JUB + dj)

            !$OMP PARALLEL PRIVATE(i,j,k)
            dok: do k = KLB, KUB 
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            doj: do j = JLB, JUB + dj
            doi: do i = ILB, IUB + di


                !In the exterior faces the 
                !velocity is imposed equal to zero
                Velocity_UV_New(i, j, k)   = Velocity_UV_New(i, j, k)         * &
                                             (1. - ImposedNormalFacesUV(i, j, k))  
                                     
            enddo doi
            enddo doj
            !$OMP END DO NOWAIT
            enddo dok
            !$OMP END PARALLEL

        else if (VelNormalBoundary == NULL_GRADIENT) then  cd1

            CHUNK = CHUNK_K(KLB, KUB)
        
            !$OMP PARALLEL PRIVATE(i,j,k,Vel_Left,Vel_Right)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            dok1: do k = KLB, KUB 
            doj1: do j = JLB, JUB
            doi1: do i = ILB, IUB

cd2:            if (ImposedNormalFacesUV(i, j, k) == Imposed) then 


                     Vel_Left  = Velocity_UV_New  (i - di, j - dj, k)   *  &
                                 ComputeFaces3D_UV(i - di, j - dj, k)

                     Vel_Right = Velocity_UV_New  (i + di, j + dj, k)   *  &
                                 ComputeFaces3D_UV(i + di, j + dj, k)

                    !In the exterior faces the 
                    !velocity is imposed equal to the nearest computed face
                    Velocity_UV_New(i, j, k)   =  Vel_Left + Vel_Right
                                                 
                endif  cd2
                                   
            enddo doi1
            enddo doj1
            enddo dok1
            !$OMP END DO NOWAIT

            !$OMP MASTER
            !This is to avoid the error : arrays out of bounds

            imin = di * (IUB + di) + dj * ILB
            imax = di * (IUB + di) + dj * IUB
            
            jmin = dj * (JUB + dj) + di * JLB
            jmax = dj * (JUB + dj) + di * JUB
            !$OMP END MASTER
            !$OMP BARRIER
            
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            dok2: do k = KLB, KUB 
            doi2: do i= imin, imax
            doj2: do j= jmin, jmax

cd3:            if (ImposedNormalFacesUV(i, j, k) == Imposed) then 

                         Vel_Left  = Velocity_UV_New  (i - di, j - dj, k) * &
                                     ComputeFaces3D_UV(i - di, j - dj, k)

                        !In the exterior faces the 
                        !velocity is imposed equal to the nearest computed face
                        Velocity_UV_New(i, j, k)   =  Vel_Left
                                                     
                
                endif  cd3

            enddo doj2
            enddo doi2
            enddo dok2
            !$OMP END DO
            !$OMP END PARALLEL

        endif cd1

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "VelNormalOpenBoundary")
        endif

        !Nullify auxiliar pointers
        nullify(ComputeFaces3D_UV)
        nullify(ImposedNormalFacesUV)

    end Subroutine VelNormalOpenBoundary

    !------------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces equal to the closes covered face
    ! This is only needed to compute the velocity modulus in faces adjecent to the       
    ! exterior zone                                                                        
    !                                                                                     
    ! Input : Flow, Mapping                                                                 
    ! OutPut: Velocity                                                                     
    ! Author: Paulo Chambel (99/6)                                                         

    Subroutine VelTangentialOpenBoundary ( Velocity_UV_New)
    

        !Arguments-------------------------------------------------------------
        
        real,    dimension(:,:,:), pointer :: Velocity_UV_New
                                                
        !Local-----------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: SZZ
        real,    dimension(:,:  ), pointer :: DUX_VY
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: BoundaryPoints, KFloor_UV

        real                               :: Coef, Aux
        real                               :: DT_Velocity
        integer                            :: VelTangentialBoundary
        integer                            :: I, J, K, di, dj
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        
        integer                            :: CHUNK
        
        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 


        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB


        BoundaryPoints           => Me%External_Var%BoundaryPoints

        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV         => Me%External_Var%KFloor_UV

        DUX_VY            => Me%External_Var%DUX_VY
        SZZ               => Me%External_Var%SZZ

        DT_Velocity           = Me%Velocity%DT

        VelTangentialBoundary =  Me%ComputeOptions%VelTangentialBoundary


        di  = Me%Direction%di
        dj  = Me%Direction%dj


        !End   - Shorten variables name
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "VelTangentialOpenBoundary")
        endif

cd1:    if (VelTangentialBoundary == NULL_VALUE) then

            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP PARALLEL PRIVATE(i,j,k)

            dok: do k = KLB, KUB 
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            doj: do j = JLB, JUB
            doi: do i = ILB, IUB

                !iSouth  = i - di
                !jWest   = j - dj


                !In the faces that have boundary points in both sides  
                !velocity is imposed equal to zero
                Velocity_UV_New(i, j, k)   = Velocity_UV_New(i, j, k)         *          &
                                             (1- ImposedTangentialFacesUV(i, j, k)) 
!                                             (1. - BoundaryPoints(i, j)       *          &
!                                             BoundaryPoints(iSouth, jWest))  

                                  
            enddo doi
            enddo doj
            !$OMP END DO
            enddo dok
            !$OMP END PARALLEL

        else if (VelTangentialBoundary == NULL_GRADIENT) then cd1

            CHUNK = CHUNK_K(KLB, KUB)
        
            !$OMP PARALLEL PRIVATE(i,j,k,Aux,Coef)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            dok1: do k = KLB, KUB 
            doj1: do j = JLB, JUB
            doi1: do i = ILB, IUB

!                iSouth  = i - di
!                jWest   = j - dj

!cd2:            if (BoundaryPoints(i      , j     ) == Boundary .and. &
!                    BoundaryPoints(iSouth, jWest) == Boundary) then 

cd2:            if (ImposedTangentialFacesUV(i, j, k) == Imposed) then 


                    Aux = ComputeFaces3D_UV(i + dj, j + di, k) *  &
                          ComputeFaces3D_UV(i - dj, j - di, k)
        
                    if (Aux == 1) then ! both faces are compute points
                        Coef = 0.5 ! average between the two velocities
                    else
                        Coef = 1.
                    endif

               !In the exterior faces the 
                !velocity is imposed equal to the nearst compute face
                    Velocity_UV_New(i, j, k) = Coef                                * &
                                           (Velocity_UV_New  (i + dj, j + di, k)   * &
                                            ComputeFaces3D_UV(i + dj, j + di, k)   + &
                                            Velocity_UV_New  (i - dj, j - di, k)   * &
                                            ComputeFaces3D_UV(i - dj, j - di, k))
                                 
                endif cd2

            enddo doi1
            enddo doj1
            enddo dok1
            !$OMP END DO
            !$OMP END PARALLEL

        endif cd1

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "VelTangentialOpenBoundary")
        endif

        !Nullify auxiliar pointers
        nullify(ComputeFaces3D_UV       )
        nullify(ImposedTangentialFacesUV)
        nullify(BoundaryPoints          )
        nullify(KFloor_UV)

        nullify(DUX_VY)
        nullify(SZZ)

        

    end Subroutine VelTangentialOpenBoundary


    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces                                 
    !                                                                                     
    ! Input : Flow, Mapping                                                                 
    ! OutPut: Velocity                                                                     
    ! Author: Paulo Chambel (99/6)                                                         

    Subroutine VelSubModelNormalOB ( Velocity_UV_New)
    


        !Arguments-------------------------------------------------------------
        
        real,    dimension(:,:,:), pointer :: Velocity_UV_New
                                                
        !Local-----------------------------------------------------------------

        integer, dimension(:,:,:), pointer :: ImposedNormalFacesUV

        integer                            :: I, J, K, di, dj
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 


        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB


        ImposedNormalFacesUV   => Me%External_Var%ImposedNormalFacesUV

        di  = Me%Direction%di
        dj  = Me%Direction%dj


        !End   - Shorten variables name
        


        !--------------------------------------------------------------------------

cd5:     if (Me%SubModel%Set) then 

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "VelSubModelNormalOB")
            endif

            CHUNK = CHUNK_J(JLB, JUB + dj)
            !$OMP PARALLEL PRIVATE(i,j,k)
            dok2: do k = KLB, KUB 
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            doj2: do j = JLB, JUB + dj
            doi2: do i = ILB, IUB + di

                !The faces that are exterior are put equal to the father model

cd4:            if (Me%External_Var%ImposedNormalFacesUV(i, j, k) == Imposed) then                  
                
                    Velocity_UV_New(i, j, k)   =  Me%SubModel%UV_New(i, j, k) 

                endif cd4

            enddo doi2
            enddo doj2
            !$OMP END DO NOWAIT
            enddo dok2
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "VelSubModelNormalOB")
            endif

        else cd5

            call SetError (FATAL_, INTERNAL_, "VelSubModelNormalOB - Hydrodynamic - ERR01")        
            

        endif cd5



        !Nullify auxiliar pointers
        nullify(ImposedNormalFacesUV)

    end Subroutine VelSubModelNormalOB

    !------------------------------------------------------------------------------
    !------------------------------------------------------------------------------

    ! Author: Paulo Chambel (99/6)                                                         

    Subroutine VelSubModelTangentialOB ( Velocity_UV_New)
    

        !Arguments-------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_New
                                                
        !Local-----------------------------------------------------------------

        integer, dimension(:,:,:), pointer :: ImposedTangentialFacesUV

        integer                            :: I, J, K, di, dj    
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 


        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB


        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV


        di  = Me%Direction%di
        dj  = Me%Direction%dj


        !End   - Shorten variables name
        


        !--------------------------------------------------------------------------

cd5:     if (Me%SubModel%Set) then 

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "VelSubModelTangentialOB")
            endif 

            CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(i,j,k)
            dok2: do k = KLB, KUB 
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            doj2: do j = JLB, JUB
            doi2: do i = ILB, IUB

                !In the faces that have boundary points in both sides  
                !velocity is imposed equal to the father velocity

cd4:            if (ImposedTangentialFacesUV(i, j, k) == Imposed) then                  
                
                    Velocity_UV_New(i, j, k)   =  Me%SubModel%UV_New(i, j, k) 

                endif cd4

            enddo doi2
            enddo doj2
            !$OMP END DO NOWAIT
            enddo dok2
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "VelSubModelTangentialOB")
            endif 

        else cd5

            call SetError (FATAL_, INTERNAL_, "VelSubModelTangentialOB - Hydrodynamic - ERR01")        
            

        endif cd5



        !Nullify auxiliar pointers
        nullify(ImposedTangentialFacesUV)


        

    end Subroutine VelSubModelTangentialOB

    !------------------------------------------------------------------------------

           !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Computes barotropic velocities by vertically integrating velocities                  !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Barotropic velocities                                                        !
    ! Author: Manuel Ruiz Villarreal (01/4)                                                !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine Compute_BaroclinicHorVelocity  
        
        !Arguments-------------------------------------------------------------
        

                                                
        !Local-----------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_XY       
        real,    dimension(:,:,:), pointer :: Baroclinic_UV_New, Baroclinic_UV_Old,      &
                                              Velocity_UV_New, Area_UV, DWZ, Baroclinic_VU_New
        real,    dimension(:,:  ), pointer :: WaterColumnUV, WaterColumnZ, DYY_XX,       &
                                              DUX_VY, BarotropicUV
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV,   &
                                              ImposedTangentialFacesUV

        real                               :: DT_Velocity, WaveCelerityX, InternalCelerity
        real                               :: VelNormal, VelTang, VelMod, NormalDirection, TangDirection, LimitMax
        real(8)                            :: BarotropicVelocity

        integer                            :: I, J, K, kbottom, di, dj, ib , jb
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB,              &
                                              IUBSize, ILBSize, JUBSize, JLBSize

        integer                            :: i0, j0, i1, j1, i2, j2, i3, j3, i4, j4 

        integer                            :: NP, NT

        logical                            :: EastNorthBoundary, ConstantCelerity, ExplDiscrt

        integer                            :: CHUNK
        
        !Begin----------------------------------------------------------------
         
        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KLB = Me%WorkSize%KLB      
        KUB = Me%WorkSize%KUB        

        IUBSize = Me%Size%IUB
        ILBSize = Me%Size%ILB
        JUBSize = Me%Size%JUB
        JLBSize = Me%Size%JLB

        
        DT_Velocity  = Me%Velocity%DT

        NP = 1
        NT = 1

        if (Me%VelBaroclinic%BaroclinicOBCDiscret  == Explicit_) then 

            ExplDiscrt = .true.

        else

            ExplDiscrt = .false.

        endif 
                    
        WaterColumnUV            => Me%External_Var%WaterColumnUV    
        WaterColumnZ             => Me%External_Var%WaterColumn    
        DWZ                      => Me%External_Var%DWZ
        Area_UV                  => Me%External_Var%Area_UV
        DYY_XX                   => Me%External_Var%DYY_XX
        DUX_VY                   => Me%External_Var%DUX_VY

        !Flow
        WaterFlux_XY             => Me%WaterFluxes%XY
        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        ImposedNormalFacesUV     => Me%External_Var%ImposedNormalFacesUV
        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV
        Baroclinic_UV_New        => Me%VelBaroclinic%UV%New
        Baroclinic_VU_New        => Me%VelBaroclinic%VU%New
        Baroclinic_UV_Old        => Me%VelBaroclinic%UV%Old
        BarotropicUV             => Me%VelBaroclinic%UV2D

        Velocity_UV_New          => Me%Velocity%Horizontal%UV%New


        !End - Shorten


        di                = Me%Direction%di
        dj                = Me%Direction%dj

        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Compute_BaroclinicHorVelocity")
        endif 
        
        !$OMP PARALLEL PRIVATE(i,j,k,kbottom,BarotropicVelocity)
        
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        !Baroclinic velocities are computed in every point of the domain. 
        !In principle, it only needs to be computed at boundaryfaces if we don't want to do output of barotropic velocities
        doj1: do j = JLB, JUB
        doi1: do i = ILB, IUB 

       
          !Compute internal baroclinic velocity
cd1:      if (ComputeFaces3D_UV(i, j, KUB) == Covered) then 

              kbottom            = Me%External_Var%kfloor_UV(i, j) 
              
              BarotropicVelocity = 0.

              do  k = kbottom, KUB
                  ![m^3/s]           = [m^3/s] + [m/s] * [m^2]
                  BarotropicVelocity = BarotropicVelocity + dble(Velocity_UV_New(i, j, k)) * &
                                                            dble(Area_UV(i, j, k))
        
              enddo
        
              BarotropicVelocity = BarotropicVelocity / dble(WaterColumnUV(i,j)) / dble(DYY_XX (i,j))

              BarotropicUV(i, j) = real(BarotropicVelocity)

              do  k = kbottom, KUB

                  Baroclinic_UV_Old (i, j, k) = Baroclinic_UV_New (i, j, k)
                    
                  Baroclinic_UV_New (i, j, k) = Velocity_UV_New(i, j, k) - BarotropicUV(i, j)

        
              enddo

        
           endif cd1

        end do doi1
        end do doj1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Compute_BaroclinicHorVelocity")
        endif 

doj2:   do j = JLB, JUB + dj
doi2:   do i = ILB, IUB + di 


dok2:       do k = KLB, KUB            
cd2:            if (ImposedNormalFacesUV(i, j, k) == Imposed) then 


                    if (ComputeFaces3D_UV(i - di, j - dj, k) == Covered) then
                
                        ib  = i - di
                        jb  = j - dj

                        EastNorthBoundary = .true.

                        i0  = i -     di
                        j0  = j -     dj

                        i1  = i - 2 * di
                        j1  = j - 2 * dj

                        i2  = i - 2 * di + dj
                        j2  = j - 2 * dj + di

                        i3  = i - 2 * di
                        j3  = j - 2 * dj




                    else if (ComputeFaces3D_UV(i + di, j + dj, k) == Covered) then

                        ib  = i
                        jb  = j
                        EastNorthBoundary = .false.

                        i0  = i + di
                        j0  = j + dj

                        i1  = i + 2 * di
                        j1  = j + 2 * dj

                        i2  = i + di + dj
                        j2  = j + dj + di

                        i3  = i + di
                        j3  = j + dj


                    else

                        call SetError (FATAL_, INTERNAL_, "Compute_BaroclinicHorVelocity - Hydrodynamic - ERR01")

                    endif

                    ConstantCelerity = .false.

                    if (Me%VelBaroclinic%CelerityType /= Orlanski_) then

                        ConstantCelerity = .true.

                        if (Me%VelBaroclinic%CelerityType == Constant_) then

                            InternalCelerity = Me%VelBaroclinic%InternalCelerity &
                                               * DT_Velocity / DUX_VY(ib, jb)                 
                                               
                        else if (Me%VelBaroclinic%CelerityType == OeyAndChen_) then 

                            InternalCelerity = sqrt(1e-3 * Gravity * WaterColumnUV(i0, j0)) &
                                               * DT_Velocity / DUX_VY(ib, jb) 

                        endif


                        VelNormal        = (Baroclinic_UV_New(i0, j0, k) + Baroclinic_UV_New(i1, j1, k)) / 2.
                        VelTang          = (Baroclinic_VU_New(i2, j2, k) + Baroclinic_VU_New(i3, j3, k)) / 2.
                        VelMod           = sqrt(VelNormal ** 2 + VelTang ** 2)

                        if (VelMod < Me%VelBaroclinic%MinLeavingBaroclincVel) then
                        
                            NormalDirection  = 1.
                            TangDirection    = 0.

                        else

                            NormalDirection  = abs (VelNormal) / VelMod
                            TangDirection    = abs (VelTang  ) / VelMod

                            if (EastNorthBoundary) then

                                if ((VelTang * VelNormal) < 0) TangDirection = - TangDirection

                            else

                                if ((VelTang * VelNormal) > 0) TangDirection = - TangDirection

                            endif

                        endif

                    else

                        !Maximum internal velocity allowed (MaxInternalCelerity = 10 m/s)
                        LimitMax = MaxInternalCelerity * DT_Velocity / DUX_VY(ib, jb)

                    endif

                    if (Me%VelBaroclinic%BaroclinicOBCDiscret  == StoreWave_) then 

                        !PCL begin

                        WaveCelerityX = NormalDirection * InternalCelerity

                        call BoundaryInstantList (Me%VelBaroclinic%ImposedNormXY(NP), &
                                                  Me%CurrentTime, Baroclinic_UV_New,  &
                                                  Baroclinic_UV_Old, DT_Velocity,                  &
                                                  Me%VelBaroclinic%DTWave,            &
                                                  WaveCelerityX, i, j, k, i0, j0)
                        
                        NP = NP + 1
                                    
                        !PCL end

                    else

                        call OrlanskiCelerity2D(NewField          = Baroclinic_UV_New,       &
                                                OldField          = Baroclinic_UV_Old,       &
                                                ComputePoints     = ComputeFaces3D_UV,       &
                                                Imin              = ILBSize,                 &
                                                Imax              = IUBSize,                 &
                                                Jmin              = JLBSize,                 &
                                                Jmax              = JUBSize,                 &
                                                di                = di,                      &
                                                dj                = dj,                      &
                                                i                 =  i,                      &
                                                j                 =  j,                      &
                                                k                 =  k,                      &
                                                EastNorthBoundary = EastNorthBoundary,       &
                                                DT                = DT_Velocity,           &
                                                LimitMax          = LimitMax,                &
                                                TrelaxIn          = Me%VelBaroclinic%TRelaxIn,          &
                                                TrelaxOut         = Me%VelBaroclinic%TRelaxOut,        &
                                                InternalCelerity  = InternalCelerity,        &
                                                WaveDirectionX    = NormalDirection,         &
                                                WaveDirectionY    = TangDirection,           & 
                                                ConstantCelerity  = ConstantCelerity,        &
                                                NormalRadiation   = Me%VelBaroclinic%BaroclinicNormalRadiation,   &
                                                Explicit          = ExplDiscrt,              &
                                                WaveCelerityX     = WaveCelerityX)

                    endif



                endif cd2

cd3:            if (ImposedTangentialFacesUV(i, j, k) == Imposed) then 


                    if (ComputeFaces3D_UV(i - dj, j - di, k) == Covered) then

                        EastNorthBoundary = .true.

                        i0  = i -     dj
                        j0  = j -     di

                        i1  = i -     di
                        j1  = j -     dj

                        i2  = i
                        j2  = j

                        i3  = i - di - dj
                        j3  = j - dj - di 

                        i4  = i - dj 
                        j4  = j - di 



                    else if (ComputeFaces3D_UV(i + dj, j + di, k) == Covered) then


                        EastNorthBoundary = .false.

                        i0  = i + dj
                        j0  = j + di

                        i1  = i + dj
                        j1  = j + di

                        i2  = i - di + dj
                        j2  = j - dj + di

                        i3  = i + 2 * dj
                        j3  = j + 2 * di 

                        i4  = i - di + 2 * dj
                        j4  = j - dj + 2 * di 

                    else

!                       call SetError (FATAL_, INTERNAL_, "Compute_BaroclinicHorVelocity - Hydrodynamic - ERR02")
                        Cycle


                    endif

                    ConstantCelerity = .false.

                    if (Me%VelBaroclinic%CelerityType /= Orlanski_) then

                        ConstantCelerity = .true.

                        if (Me%VelBaroclinic%CelerityType == Constant_) then

                            InternalCelerity = Me%VelBaroclinic%InternalCelerity &
                                               * DT_Velocity / (DYY_XX(i, j) + DYY_XX(i0, j0)) * 2.                 
                                               
                        else if (Me%VelBaroclinic%CelerityType == OeyAndChen_) then 

                            InternalCelerity = sqrt(1e-3 * Gravity * WaterColumnUV(i0, j0)) &
                                               * DT_Velocity / (DYY_XX(i, j) + DYY_XX(i0, j0)) * 2.                 

                        endif



                        VelNormal        = (Baroclinic_VU_New(i1, j1, k) + Baroclinic_VU_New(i2, j2, k) + &
                                            Baroclinic_VU_New(i3, j3, k) + Baroclinic_VU_New(i4, j4, k)) / 4.
                        VelTang          =  Baroclinic_UV_New(i0, j0, k)
                        VelMod           = sqrt(VelNormal ** 2 + VelTang ** 2)

                        if (VelMod < Me%VelBaroclinic%MinLeavingBaroclincVel) then
                        
                            NormalDirection  = 1.
                            TangDirection    = 0.

                        else

                            NormalDirection  = abs (VelNormal) / VelMod
                            TangDirection    = abs (VelTang  ) / VelMod

                            if (EastNorthBoundary) then

                                if ((VelTang * VelNormal) < 0) TangDirection = - TangDirection

                            else

                                if ((VelTang * VelNormal) > 0) TangDirection = - TangDirection

                            endif

                        endif

                    else

                        !Maximum internal velocity allowed (MaxInternalCelerity = 10 m/s)
                        LimitMax = MaxInternalCelerity * DT_Velocity / (DYY_XX(i, j) + DYY_XX(i0, j0)) * 2.

                    endif

                    if (Me%VelBaroclinic%BaroclinicOBCDiscret  == StoreWave_) then 

                        !PCL begin
                        WaveCelerityX = NormalDirection * InternalCelerity

                        call BoundaryInstantList (Me%VelBaroclinic%ImposedTangXY(NT), &
                                                  Me%CurrentTime, Baroclinic_UV_New,  &
                                                  Baroclinic_UV_Old, DT_Velocity,                  &
                                                  Me%VelBaroclinic%DTWave,            &
                                                  WaveCelerityX, i, j, k, i0, j0)

                        NT = NT + 1
                                    
                        !PCL end

                    else

                        call OrlanskiCelerity2D(NewField          = Baroclinic_UV_New,       &
                                                OldField          = Baroclinic_UV_Old,       &
                                                ComputePoints     = ComputeFaces3D_UV,       &
                                                Imin              = ILBSize,                 &
                                                Imax              = IUBSize,                 &
                                                Jmin              = JLBSize,                 &
                                                Jmax              = JUBSize,                 &
                                                di                = dj,                      &
                                                dj                = di,                      &
                                                i                 =  i,                      &
                                                j                 =  j,                      &
                                                k                 =  k,                      &
                                                EastNorthBoundary = EastNorthBoundary,       &
                                                DT                = DT_Velocity,             &
                                                LimitMax          = LimitMax,                &
                                                TrelaxIn          = Me%VelBaroclinic%TRelaxIn,          &
                                                TrelaxOut         = Me%VelBaroclinic%TRelaxOut,        &
                                                InternalCelerity  = InternalCelerity,        &
                                                WaveDirectionX    = NormalDirection,         &
                                                WaveDirectionY    = TangDirection,           & 
                                                ConstantCelerity  = ConstantCelerity,        &
                                                NormalRadiation   = Me%VelBaroclinic%BaroclinicNormalRadiation, &
                                                Explicit          = ExplDiscrt,              &
                                                WaveCelerityX     = WaveCelerityX)

                    endif 

                endif cd3


            end do dok2



        end do doi2
        end do doj2

        nullify (WaterFlux_XY            )
        nullify (WaterColumnUV           )
        nullify (Area_UV                 )
        nullify (DYY_XX                  )
        nullify (DUX_VY                  )
        nullify (ComputeFaces3D_UV       )
        nullify (ImposedNormalFacesUV    )
        nullify (ImposedTangentialFacesUV)
        nullify (Baroclinic_UV_New       )
        nullify (Baroclinic_VU_New       )
        nullify (Baroclinic_UV_Old       )
        nullify (Velocity_UV_New         )
        nullify (WaterColumnZ            )
        nullify (DWZ                     )
        nullify (BarotropicUV            )

         
    end subroutine Compute_BaroclinicHorVelocity


    Subroutine BoundaryInstantList (ImposedXY, CurrentTime, Prop_New, Prop_Old, DT_Prop, &
                                    DTWave, WaveCelerityX, i, j, k, ib, jb)


        !Arguments----------------------------------------------------------------------------
        type (T_Imposed)                :: ImposedXY
        type (T_Time)                   :: CurrentTime
        real, dimension(:,:,:), pointer :: Prop_New, Prop_Old
        real                            :: DT_Prop, DTWave, WaveCelerityX
        integer                         :: i, j, k, ib, jb

        !Local--------------------------------------------------------------------------------
        type (T_InstantBound), pointer  :: InstantXY, AuxXY
        type (T_Time)                   :: NextInstant, NewInstant
        real(8)                         :: DT1, DT2
        integer                         :: status
        logical                         :: Found

        !Begin--------------------------------------------------------------------------------


        !Add Instant

cd1:    if (abs(WaveCelerityX) < 1e-4) then
        
            NewInstant  = CurrentTime  + DT_Prop / 1e-4

        else  cd1
            
            NewInstant  = CurrentTime  + DT_Prop / WaveCelerityX 

        endif cd1

cd2:    if (associated(ImposedXY%FirstInstant)) then

            NextInstant = ImposedXY%LastInstant%TimeB + DTWave

        else  cd2

            call null_time(NextInstant)

        endif cd2

        nullify (InstantXY)

        allocate(InstantXY, STAT = status)

        if (status /= SUCCESS_)                                                      &
            call SetError (FATAL_, INTERNAL_, "BoundaryInstantList - Hydrodynamic - ERR01")

        nullify (InstantXY%Next)
        nullify (InstantXY%Prev)

        InstantXY%TimeB    = NewInstant
        InstantXY%BaroclVel= Prop_New(ib, jb, k)

cd3:    if (.not.associated(ImposedXY%FirstInstant)) then
            ImposedXY%Number           =  1
            ImposedXY%FirstInstant     => InstantXY
            ImposedXY%LastInstant      => InstantXY
        else  cd3
                
cd4:        if (.not.associated(ImposedXY%FirstInstant%Next)) then
                
cd5:            if (NewInstant >= NextInstant) then

                    InstantXY%Prev             => ImposedXY%LastInstant
                    ImposedXY%LastInstant%Next => InstantXY
                    ImposedXY%LastInstant      => InstantXY
                    ImposedXY%Number           =  ImposedXY%Number + 1

                endif cd5

            else  cd4
                            
cd6:            if (NewInstant >= NextInstant) then
                    
                    InstantXY%Prev             => ImposedXY%LastInstant
                    ImposedXY%LastInstant%Next => InstantXY
                    ImposedXY%LastInstant      => InstantXY
                    ImposedXY%Number           =  ImposedXY%Number + 1

                else  cd6

                    AuxXY => ImposedXY%FirstInstant

                    Found = .false. 

                    do While(associated(AuxXY) .and. associated(AuxXY%Next)) 
        
                        if (AuxXY%TimeB <= CurrentTime .and. AuxXY%Next%TimeB >= CurrentTime) then
                            if ((CurrentTime      - AuxXY%TimeB) >  DTWave) Found = .true. 
                            if ((AuxXY%Next%TimeB - CurrentTime) >  DTWave) Found = .true. 
                            exit

                        endif

                        AuxXY => AuxXY%Next 

                    enddo 

                    if (Found) then

                        InstantXY%Prev        => AuxXY
                        InstantXY%Next        => AuxXY%Next
                        AuxXY%Next            => InstantXY
                        ImposedXY%Number      =  ImposedXY%Number + 1

                    endif

                endif cd6

            endif  cd4

        endif cd3

        !Delete obsolete instants

        nullify(InstantXY)

        nullify(AuxXY) 

        if (associated(ImposedXY%FirstInstant%Next)) then
            
            do while (ImposedXY%FirstInstant%Next%TimeB < CurrentTime) 

                AuxXY                  => ImposedXY%FirstInstant
                ImposedXY%FirstInstant => ImposedXY%FirstInstant%Next
                ImposedXY%Number       =  ImposedXY%Number - 1

                deallocate (AuxXY, STAT = status)

                if (status /= SUCCESS_)                                                      &
                    call SetError (FATAL_, INTERNAL_, "BoundaryInstantList - Hydrodynamic - ERR02")
            
                nullify(AuxXY) 

            enddo 

        endif

        nullify(AuxXY) 

        AuxXY => ImposedXY%FirstInstant

        Found = .false. 

        do While(associated(AuxXY) .and. associated(AuxXY%Next)) 
        
            if (AuxXY%TimeB <= CurrentTime .and. AuxXY%Next%TimeB >= CurrentTime) then

                Found = .true. 
                exit

            endif


            AuxXY => AuxXY%Next 

        enddo 

        if (Found) then

            DT1 = AuxXY%Next%TimeB - CurrentTime
            DT2 = CurrentTime      - AuxXY%TimeB

            Prop_Old(i, j, k) =  Prop_New(i, j, k)

            Prop_New(i, j, k) = (real(DT1) * AuxXY%BaroclVel + real(DT2) * AuxXY%Next%BaroclVel) /       &
                                 real(DT1 + DT2)

        else

            Prop_New(i, j, k) = 0.

        endif

        nullify(AuxXY) 

    end subroutine BoundaryInstantList



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Actualizes variables needed to impose boundary conditions                            !
    ! at the bottom and at the surface                                                     ! 
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Chezy                                                                        !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Bottom_Boundary
    

        !Arguments-----------------------------------------------------------------

         !Categories  
            !Bottom    : Chezy, Rugosity, HMIN_ATR
            !Flow      : WaterFlux_XY, Me%WaterFluxes%New_Old, Velocity_UV_New, Velocity_UV_Old
            !Mapping   : KFloor_Z

                                            
        !Arguments------------------------------------------------------------
         

        !Local-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Bottom_Boundary")

       !Bottom boundary
        call Modify_ChezyZ 

        call Modify_ChezyVelUV 


        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Bottom_Boundary")

    !------------------------------------------------------------------------------

    End Subroutine Bottom_Boundary

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Compute the Chezy bottom friction coeficient                                         !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Chezy                                                                        !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_ChezyZ 

        !Variables Categories  
            !Geometry  : DWZ
            !Bottom    : Chezy, Rugosity, HMIN_ATR
            !Flow      : WaterFlux_XY, Me%WaterFluxes%New_Old, Velocity_UV_New, Velocity_UV_Old
            !Mapping   : KFloor_Z

        !Arguments------------------------------------------------------------
         

                                            
        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: DWZ
        real,    dimension(:,:),   pointer :: ChezyZ, RugosityMatrix
        integer, dimension(:,:,:), pointer :: WaterPoints3D
        integer, dimension(:,:),   pointer :: KFloor_Z
        real                               :: AuxZ, Hmin_Chezy, EP, WallDistance, Rugosity
        logical                            :: Manning

        integer                            :: IUB, ILB, JUB, JLB, KUB
        integer                            :: I, J, kbottom

        integer                            :: CHUNK

        !Begin--------------------------------------------------------------------------

        !Begin - Shorten variables name 
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        Hmin_Chezy     =  Me%External_Var%Hmin_Chezy

        Manning        =  Me%External_Var%Manning

        RugosityMatrix => Me%External_Var%RugosityMatrix

        ChezyZ         => Me%External_Var%ChezyZ

        KFloor_Z       => Me%External_Var%KFloor_Z

        WaterPoints3D  => Me%External_Var%WaterPoints3D
        DWZ            => Me%External_Var%DWZ

        !End - Shorten variables name 


        if (KUB > 1 .and. Manning) then 

            call SetError (FATAL_, INTERNAL_, "Modify_ChezyZ - Hydrodynamic - ERR03")        

        endif

        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_ChezyZ")
        endif 
            
        !$OMP PARALLEL PRIVATE(i,j,AuxZ,Kbottom,EP,Rugosity,WallDistance)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)    
doj:    do  j = JLB, JUB
doi:    do  i = ILB, IUB
                    
cd2:        if (WaterPoints3D(i, j, KUB) == WaterPoint) then 
                ! For a non water point Kfloor_Z = -999999
                Kbottom     = KFloor_Z(i, j)

                AUXZ        = MAX(DWZ(I, J, Kbottom), Hmin_Chezy)

                EP          = 1./3.


cd0:            if (Me%External_Var%Chezy) then

                    ChezyZ(i, j) = Me%External_Var%ChezyCoef

                else cd0

                    Rugosity    = RugosityMatrix(i, j)

cd1:                if (Rugosity == 0.) then
                
                        ChezyZ(i, j) = 0.
                
                    else cd1
                 
cd3:                    if (Manning) then
                
                             ![]          =  [m/s2] *   [m-1/3 * s]**2         / [m1/3] 
                             ChezyZ(i, j) = Gravity * Rugosity**2 / AUXZ**EP
                 
                         else cd3
                
                             !To avoid wall distance values lower than rugosity
                             WallDistance = AuxZ/2. + Rugosity
                
                             if (WallDistance <= Rugosity) then                                    
                                 !!!! $OMP CRITICAL (MCZ1_ERR04)
                                 call SetError (FATAL_, INTERNAL_, "Modify_ChezyZ - Hydrodynamic - ERR04")        
                                 !!!! $OMP END CRITICAL (MCZ1_ERR04)
                             endif    
                
                             ! [] = [] / log ([m]/[m])
                             ChezyZ(i, j) = (Const_VonKarman / LOG(WallDistance / Rugosity))**2.
                
                         endif cd3
                
                    endif cd1
                
                endif cd0

            endif cd2

        enddo doi
        enddo doj
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_ChezyZ")
        endif 

        !Nullify auxiliar variables
        nullify (KFloor_Z)
        nullify (DWZ)
        nullify (ChezyZ)
        nullify (WaterPoints3D)
        nullify (RugosityMatrix)

    end Subroutine Modify_ChezyZ

    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Compute the Chezy bottom friction coeficient                                         !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Chezy                                                                        !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_ChezyVelUV 

        !Variables Categories  
            !Bottom    : ChezyVelUV, Rugosity, HMIN_ATR
            !Flow      : WaterFlux_XY, Me%WaterFluxes%New_Old, Velocity_UV_New, Velocity_UV_Old
            !Mapping   : KFloor_Z

        !Arguments------------------------------------------------------------
         

                                            
        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV
        real,    dimension(:,:,:), pointer :: DUZ_VZ, Velocity_UV_New, Velocity_VU_New
        real,    dimension(:,:),   pointer :: ChezyVelUV, RugosityMatrix, DUX_VY,        &
                                              DYY_XX, DZX_ZY, DXX_YY
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV
        real                               :: AuxZ, Hmin_Chezy, EP, WallDistance,        &
                                              Rugosity, Vmin_Chezy, Chezy, DT_Z,         &
                                              VelMod_UV, DT_Velocity, ChezyWave
        logical                            :: Manning 

        integer                            :: iSouth, jWest, di, dj, i_North, j_East
        integer                            :: IUB, ILB, JUB, JLB, KUB
        integer                            :: I, J, kbottom
    
        !$ integer                            :: CHUNK

        !Begin--------------------------------------------------------------------------

        !Begin - Shorten variables name 
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB


        di                = Me%Direction%di
        dj                = Me%Direction%dj

        Hmin_Chezy        =  Me%External_Var%Hmin_Chezy

        Vmin_Chezy        =  Me%External_Var%Vmin_Chezy

        Manning           =  Me%External_Var%Manning

        DT_Velocity       =  Me%Velocity%DT

        RugosityMatrix    => Me%External_Var%RugosityMatrix

        KFloor_UV         => Me%External_Var%KFloor_UV
        Volume_UV         => Me%External_Var%Volume_UV

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV
        DUZ_VZ            => Me%External_Var%DUZ_VZ
        DUX_VY            => Me%External_Var%DUX_VY
        DXX_YY            => Me%External_Var%DXX_YY
        DYY_XX            => Me%External_Var%DYY_XX
        DZX_ZY            => Me%External_Var%DZX_ZY

        Velocity_UV_New   => Me%Velocity%Horizontal%UV%New
        Velocity_VU_New   => Me%Velocity%Horizontal%VU%New

        !End - Shorten variables name 


        if (KUB > 1 .and. Manning) then 
            
            call SetError (FATAL_, INTERNAL_, "Modify_ChezyVelUV - Hydrodynamic - ERR03")        

        endif

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !$OMP PARALLEL PRIVATE( AuxZ, EP, WallDistance,         &
        !$OMP                   Rugosity, Chezy, DT_Z,          &
        !$OMP                   VelMod_UV, ChezyWave,          &
        !$OMP                   iSouth, jWest, i_North, j_East,    &
        !$OMP                   I, J, kbottom, ChezyVelUV)

        ChezyVelUV        => Me%External_Var%ChezyVelUV

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)    
doj:    do  j = JLB, JUB
doi:    do  i = ILB, IUB
                    
cd2:        if (ComputeFaces3D_UV(i, j, KUB) == Covered) then 
                ! For a non water point Kfloor_UV = -999999
                Kbottom     = KFloor_UV(i, j)

                iSouth     = i - di
                jWest      = j - dj
                ! This values (i_North and j_east) can only be use to compute the velocity modulus in a face
                i_North = i + dj
                j_East  = j + di

cd0:            if (Me%External_Var%Chezy) then

                    Chezy = Me%External_Var%ChezyCoef

                else cd0

cd4:                if (abs(Velocity_UV_New(i, j, Kbottom)) < Vmin_Chezy) then
                    
                        AUXZ        = MAX(DUZ_VZ(i, j, Kbottom), Hmin_Chezy)

                    else  cd4

                        AUXZ        = DUZ_VZ(i, j, Kbottom)

                    endif cd4

                    EP          = 1./3.



                    Rugosity = (RugosityMatrix(i      , j     ) * DUX_VY(iSouth, jWest) +  &
                                RugosityMatrix(iSouth, jWest) * DUX_VY(i      , j     ))/  &
                               (DUX_VY        (iSouth, jWest) + DUX_VY(i      , j     ))

cd1:                if (Rugosity == 0.) then

                        Chezy = 0.

                    else cd1
                
cd3:                   if (Manning) then 

                            ![]         =  [m/s2] * [m-1/3 * s]**2/ [m1/3] 
                            Chezy = Gravity * Rugosity**2 / AUXZ**EP
                
                        else cd3

                            !To avoid wall distance values lower than rugosity
                            WallDistance = AuxZ/2. + Rugosity

                            if (WallDistance <= Rugosity)  then

                                write(*,*) 'AuxZ, IUB ,JUB, X, Y, I, J=', AuxZ, IUB ,JUB, dj, di, I, J

                                call SetError (FATAL_, INTERNAL_, "Modify_ChezyVelUV - Hydrodynamic - ERR04")        

                            endif



                            ! [] = [] / log ([m]/[m])
                            Chezy = (Const_VonKarman / LOG(WallDistance / Rugosity))**2.


                        endif cd3

                    endif cd1

                endif cd0

                ![s/m]                    = [s] / [m^3] * [m] * [m]
                DT_Z                      = DT_Velocity / Volume_UV(i, j, Kbottom)     &
                                            * DZX_ZY(iSouth, jWest) * DYY_XX(I, J)

                VelMod_UV                 = Face_Velocity_Modulus(                     &
                                            Velocity_VU_New(I_North, jWest, kbottom),  &
                                            Velocity_VU_New(I_North, J_East, kbottom), &
                                            Velocity_VU_New(iSouth, jWest, kbottom),   &
                                            Velocity_VU_New(iSouth, J_East, kbottom),  &
                                            DXX_YY(I_North, jWest),                    &
                                            DXX_YY(I_North, J_East),                   &
                                            DXX_YY(iSouth, jWest),                     &
                                            DXX_YY(iSouth, J_East),                    &
                                            Velocity_UV_New(I,J,kbottom))                

                ![]              = []       [s/m] * [m/s]
                !ChezyVelUV(i, j) = Chezy  * DT_Z * VelMod_UV
                
                !To avoid chezyUV null. This way the bottom shear stress is not null when the water cover for the first time 
                !an uncovered cell. Need to be double check is schematic models
                
                if (.not. Me%FirstIteration .and. .not. Me%ComputeOptions%Continuous) then
                    if (VelMod_UV == 0.) VelMod_UV = 0.1
                endif
                
                ChezyVelUV(i, j) = Chezy  * DT_Z * VelMod_UV


                if (Me%ComputeOptions%WaveStress) then

                    ChezyWave = Face_Interpolation(Me%External_Var%WaveChezyVel(i, j), &
                                                   Me%External_Var%WaveChezyVel(iSouth, jWest), &
                                                   DUX_VY(I, J), DUX_VY(iSouth, jWest))

                    ![]       = [m/s] * [s/m] 
                    ChezyWave = ChezyWave * DT_Z

                    ChezyVelUV(i, j) = ChezyVelUV(i, j) + ChezyWave

                endif

            else  cd2

                ChezyVelUV(i, j) = FillValueReal

            endif cd2

        enddo doi
        enddo doj
        !$OMP END DO NOWAIT
        
        !$OMP END PARALLEL

        !Nullify auxiliar variables
        nullify (KFloor_UV         )
        nullify (DUZ_VZ            )
        nullify (DUX_VY            ) 
        nullify (DUZ_VZ            )
        nullify (DUX_VY            )
        nullify (DXX_YY            )
        nullify (DYY_XX            )
        nullify (DZX_ZY            )
        nullify (ChezyVelUV        )
        nullify (ComputeFaces3D_UV )
        nullify (RugosityMatrix    )
        nullify (Velocity_UV_New   )
        nullify (Velocity_VU_New   )
        nullify (Volume_UV         )
  
    end Subroutine Modify_ChezyVelUV

    !------------------------------------------------------------------------------


    !Compute all the variables common to the velocities and elevation computing 
    Subroutine Explicit_Forces  

        !Variables Categories
        ! Geometry   : Volume_Z, Area_VU, DWZ, DZX_ZY, DXX_YY, DUX_VY, DYY_XX, Coriolis_Freq
        ! Flow       : Visc_H_Center, Visc_H_Corner, Velocity_UV, Velocity_VU_Old,                          
        !              WaterFlux_XY, WaterFlux_YX
        ! Forces     : Rox3, Horizontal_Transport, Inertial_Aceleration
        ! WaterProp  : Density
        ! Options    : Baroclinic, UpStream_CenterDif, UpStream, Direction
        ! Mapping    : KFloor_UV, ComputeFaces3D_UV
        ! Domain     : ILB, IUB, JLB, JUB, KLB, KUB

        !Variables direction dependent:
        !  Velocity_UV, Velocity_VU_Old, WaterFlux_XY, WaterFlux_YX,
        !  Area_VU, DZX_ZY, DXX_YY, DUX_VY, DYY_XX, KFloor_UV, ComputeFaces3D_UV


        !Arguments------------------------------------------------------------
         


        !Local---------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Explicit_Forces")


        
        !Inertial aceleration 
        if (Me%ComputeOptions%InertiaForces)                                    &
            call Modify_InertiaForces

        !Obstacle drag
        if (Me%ComputeOptions%Obstacle)                                         &
            call Modify_ObstacleDrag
            
        !Effect of a scraper in a settling tank
        if (Me%ComputeOptions%Scraper)                                          &
            call Modify_ScraperEffect 
            
        !Controlling the flow adding dissipation if a thinwall is open
        if (Me%ThinWalls%ON) then
            call ModifyThinWallsDissipation
        endif                              

        !Adds a force that relax the velocity field to a reference field
        if (Me%Relaxation%Force)                                                &
            call ModifyRelaxAceleration 

        !Baroclinic density gradient integral
        if (Me%ComputeOptions%Baroclinic)                                      &
            call Modify_ROX3  (Me%External_Var%SigmaDens, Me%Forces%Rox3XY)
            
        !griflet: still needs to be parallelized
        call Modify_Horizontal_Transport  

        !Compute the tide potential as a tide elevation
        !griflet: tide potential still needs to be correctly parallelized
        if (Me%TidePotential%Compute)                                           &
            call ModifyTidePotential 

        !Adds a force that relax the velocity field to Geostrophic velocity from 
        !Altimetric Assimilation
        if( Me%ComputeOptions%AltimetryAssimilation%flag .and.                                  &
            Me%CurrentTime .ge. Me%ComputeOptions%AltimetryAssimilation%NextCompute)            &
            call ModifyAltimAceleration

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Explicit_Forces")

    End Subroutine Explicit_Forces

    !End-----------------------------------------------------------------------



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the total horizontal inertia =                              !
    !  Hor. Advection + Hor. Diffusion + Coriolis Force                                    !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_Horizontal_Transport 
    

        !Variables Categories-----------------------------------------------------------------

        !Categories  
           !Geometry  : Volume_Z, Area_VU, DYY_XX, DUX_VY
           !Flow      : Velocity_UV_Old, Velocity_VU_Old, WaterFlux_XY, WaterFlux_YX, 
           !            Visc_H_Center, Visc_H_Corner
           !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction


         
        !Variables Direction Dependent
           !Area_VU, DYY_XX, DUX_VY
           !Velocity_UV_Old, Velocity_VU_Old, WaterFlux_XY, WaterFlux_YX, 
           !Visc_H_Center, Visc_H_Corner
           !ComputeFaces3D_UV, KFloor_UV, Direction

        !Arguments--------------------------------------------------------------------------


        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport
        real,    dimension(:,:,:), pointer :: Aux_UX_VY, Aux_UY_VX, Velocity_UV_Old
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, LandBoundaryFacesUV

        integer                            :: I, J, K
                          
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !$ integer                            :: CHUNK

        !--------------------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
       
        Horizontal_Transport => Me%Forces%Horizontal_Transport

        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        LandBoundaryFacesUV  => Me%External_Var%LandBoundaryFacesUV
        !End - Shorten variables name 

        call SetMatrixValue(Horizontal_Transport, Me%WorkSize, dble(0.0))

cd1:    if (Me%ComputeOptions%HorizontalAdvection) then

            call Modify_Advection_UY_VX 

            call Modify_Advection_UX_VY 

            if (.not. Me%CyclicBoundary%ON .or.                             &
                     (Me%CyclicBoundary%ON .and.                            &
                      Me%CyclicBoundary%Direction == Me%Direction%YX))      &
                call Modify_Advection_Bound  

            call AdvectionInSmallDepths 

            if (Me%Relaxation%HorizAdv)                                     &
                call ModifyRelaxHorizAdv


        endif cd1


cd2:    if (Me%ComputeOptions%HorizontalDiffusion) then
            !Biharmonic filter is able to dissipate the high frequency variabiliy (1dx,4dx and 6dx) 
            !without dissipating energy associated with the big spatial scales
cd3:        if (Me%ComputeOptions%BiHarmonic) then

                !If the BiHarmonic option is true then is compute the laplacian
                !of the velocity in the velocity direction (Aux_UX_VY) and perpendiculary
                !to the velocity (Aux_UX_VY),

                Me%ComputeOptions%BiHarmonicUX_VY(:,:,:) = 0

                Me%ComputeOptions%BiHarmonicUY_VX(:,:,:) = 0

                Aux_UX_VY => Me%ComputeOptions%BiHarmonicUX_VY
                
                Aux_UY_VX => Me%ComputeOptions%BiHarmonicUY_VX

                call LaplacianXY( Velocity_UV_Old, Aux_UX_VY)          
                      
                !For Aux_UX_VY are admitted the same normal open 
                !boundary conditions of the velocities
                if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then

                    call CyclicBoundVectNormal  (Aux_UX_VY)                                                

                else

                    call VelNormalOpenBoundary  (Aux_UX_VY)

                endif

                call LaplacianYX( Velocity_UV_Old, Aux_UY_VX)                

                !For Aux_UY_VX are admitted the same tangential open 
                !boundary conditions of the velocities
                if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%YX .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then
    
                    call CyclicBoundVectTangential   (Aux_UY_VX)

                else

                    call VelTangentialOpenBoundary   (Aux_UY_VX)

                endif


                call Modify_Diffusion_UY_VX  ( Aux_UY_VX, Biharmonic = .true.)

                call Modify_Diffusion_UX_VY  ( Aux_UX_VY, Biharmonic = .true.)

cd44:           if (Me%SubModel%ON) then

                    call ModifyDiffSub_UY_VX ( Aux_UY_VX, Biharmonic = .true.)                

                    call ModifyDiffSub_UX_VY ( Aux_UX_VY, Biharmonic = .true.)

                endif cd44


                nullify(Aux_UX_VY)
                nullify(Aux_UY_VX)

            endif cd3
            !Turbulent diffusion
            Aux_UY_VX => Me%Velocity%Horizontal%UV%Old    
                        
            Aux_UX_VY => Me%Velocity%Horizontal%UV%Old

            call Modify_Diffusion_UY_VX  ( Aux_UY_VX, Biharmonic = .false.)

            call Modify_Diffusion_UX_VY  ( Aux_UX_VY, Biharmonic = .false.)

cd4:        if (Me%SubModel%ON) then

                call ModifyDiffSub_UY_VX ( Aux_UY_VX, Biharmonic = .false.)                

                call ModifyDiffSub_UX_VY ( Aux_UX_VY, Biharmonic = .false.)

            endif cd4


            nullify(Aux_UX_VY)
            nullify(Aux_UY_VX)

        endif cd2


        if (Me%ComputeOptions%VolumeVariation)                              &
            call ModifyVolumeVariation 

        !Compute the momentum discharge 
        if (Me%ComputeOptions%MomentumDischarge)                            &
            call ModifyMomentumDischarge 

        !$ CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_Horizontal_Transport")
        endif 

        !$OMP PARALLEL PRIVATE(i,j,k)
        do  k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB

            ! Large values (FillReal_Value) in non covered faces  
            Horizontal_Transport (i, j, k) = Horizontal_Transport (i, j, k)    * &
                                             ComputeFaces3D_UV(i, j, k)        + &
                                             (1. - ComputeFaces3D_UV(i, j, k)) * &
                                             FillValueReal

            ! Land boundary condition - horizontal transport zero in faces that 
            ! have water in one side and land in another 
            Horizontal_Transport (i, j, k) = Horizontal_Transport (i, j, k) * &
                                             (1. - LandBoundaryFacesUV(i, j, k))
            
        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_Horizontal_Transport")
        endif 

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (ComputeFaces3D_UV   )
        nullify (LandBoundaryFacesUV )
        nullify (Velocity_UV_Old     )


    end Subroutine Modify_Horizontal_Transport

    !------------------------------------------------------------------------------
    Subroutine Modify_Advection_Bound

        !Arguments--------------------------------------------------------------------------


        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport
        integer, dimension(:,:),   pointer :: BoundaryFacesUV
        integer                            :: I, J, K
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        integer                            :: CHUNK

        !--------------------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        Horizontal_Transport => Me%Forces%Horizontal_Transport
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV


cd1:    if (Me%Submodel%ON) then

            call Modify_UX_VY_SubModel   

            call Modify_UY_VX_SubModel   
        
        else cd1

            call Modify_UX_VY_Boundary   

            call Modify_UY_VX_Boundary   

cd2:        if (Me%ComputeOptions%NullBoundaryHorAdv) then

                CHUNK = CHUNK_J(JLB, JUB)
                
                if (MonitorPerformance) then
                    call StartWatch ("ModuleHydrodynamic", "Modify_Advection_Bound")
                endif
                 
                !$OMP PARALLEL PRIVATE(i,j,k)
do4 :           do  k = KLB, KUB
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do5 :           do  j = JLB, JUB
do6 :           do  i = ILB, IUB
                    !Horizontal Advection null in the boundary faces  
                    Horizontal_Transport (i, j, k) = Horizontal_Transport (i, j, k) * &
                                                     (1. - BoundaryFacesUV(i, j)) 

                end do do6
                end do do5
                !$OMP END DO
                end do do4
                !$OMP END PARALLEL
                
                if (MonitorPerformance) then
                    call StopWatch ("ModuleHydrodynamic", "Modify_Advection_Bound")
                endif
                
            endif cd2

            nullify(Horizontal_Transport)
            nullify(BoundaryFacesUV     )


        endif cd1
        
                    

    end Subroutine Modify_Advection_Bound

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal advection with the same direction of the    !
    !  velocity. For the U velocity compute the advection with the X direction            !       
    !  for the V velocity compute the advection with the Y direction                      !
    !                                                                                      !
    ! Input : Flow, Mapping,                                                               !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_Advection_UX_VY  


        !Variables Categories----------------------------------------------------------------
        ! Flow     : WaterFlux_XY (Horizontal water fluxes), Velocity_UV_Old (U or V velocity)
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces) 
        ! Options  : UpStream_CenterDif (1-Upwind and 0-Centered differences),ImplicitVertAdvection (1 - implict, 0 - explicit)
        ! Direction: Direction (DirectionX=1,DirectionY_=2)
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)
        ! OutPut   : Horizontal_Transport 

        !Variables direction dependent: 
        !Velocity_UV_Old, WaterFlux_XY, Horizontal_Transport, ComputeFaces3D_UV, Direction, KFloor_UV


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_XY, Horizontal_Transport, Volume_UV
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        real,    dimension(:,:),   pointer :: DZX_ZY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4
         
!        real                               :: UpStream_CenterDif, Aux

!        real                               :: Coef1_Up, Coef2_Up, Coef3_Up, Coef_Centered

        real(8)                            :: FaceFlux_WestSouth !, MomentumFlux

!        real                               :: Coef1_WestSouth, Coef2_WestSouth, Coef3_WestSouth, Coef4_WestSouth
 
 !       real                               :: Cell1_FaceWestSouth, Cell2_FaceWestSouth, Cell3_FaceWestSouth, Cell4_FaceWestSouth

 !       real                               :: Cell_1, Cell_2, Cell_3, Cell_4

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_North, j_East, iSouth2, &
                                              jWest2, iSouth3, jWest3

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        logical                            :: ComputeFlux, NearBoundary

        !$ integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

!        UpStream_CenterDif   =  Me%ComputeOptions%UpStream_CenterDif

!        Coef1_Up             =  Me%HorAdvection%Coef1_Up
!        Coef2_Up             =  Me%HorAdvection%Coef2_Up
!        Coef3_Up             =  Me%HorAdvection%Coef3_Up

        WaterFlux_XY         => Me%WaterFluxes%XY
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        DZX_ZY               => Me%External_Var%DZX_ZY
        Volume_UV            => Me%External_Var%Volume_UV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ImposedNormalFacesUV => Me%External_Var%ImposedNormalFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV

        !End - Shorten variables name 

        !Centered difference coefficient equal for both faces (West/South = East/North)
!        Coef_Centered = 0.5

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_Advection_UX_VY")
        endif

        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !griflet: Avoid inner parallel zones, avoid all barriers and critical sections...
        !and you'll be fine.
        !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, &
        !$OMP                   iSouth,jWest,j_East,i_North,jWest2,iSouth2,jWest3,iSouth3, &
        !$OMP                   ComputeFlux, FaceFlux_WestSouth, &
        !$OMP                   NearBoundary,Vel4,du4, &
        !$OMP                   V4,CFace)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)               
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj
            i_North = i +   di
            j_East  = j +   dj
            iSouth2 = i - 2*di
            jWest2  = j - 2*dj
            iSouth3 = i - 3*di
            jWest3  = j - 3*dj


            ComputeFlux = .false.

            !This condition impose in the open boundary gradient null for the horizontal advection 
            if (ComputeFaces3D_UV(i, j, KUB)            == Covered .and. &
                ComputeFaces3D_UV(iSouth, jWest, KUB) == Covered ) ComputeFlux = .true.
            
            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                            Me%CyclicBoundary%Direction == DirectionXY_)) then
            
                if ((ComputeFaces3D_UV   (i     , j    , KUB) == Covered .and.           &
                     ImposedNormalFacesUV(iSouth, jWest, KUB) == Imposed).or.            &
                    (ComputeFaces3D_UV   (iSouth, jWest, KUB) == Covered .and.           &
                     ImposedNormalFacesUV(i     , j    , KUB) == Imposed)) ComputeFlux = .true.

            endif
 
cd0:        if (ComputeFlux) then


                Kbottom = max(KFloor_UV(i, j), KFloor_UV(iSouth, jWest))

        dok1:   do k = Kbottom, KUB

                    FaceFlux_WestSouth = (WaterFlux_XY(iSouth, jWest, k) + &
                                         WaterFlux_XY(i, j, k))/2.            ![m^3/s]

                    NearBoundary = .false.


                    Vel4(1) = Velocity_UV_Old(iSouth2, jWest2, k);
                    Vel4(2) = Velocity_UV_Old(iSouth,  jWest,  k);
                    Vel4(3) = Velocity_UV_Old(i,       j,      k);
                    Vel4(4) = Velocity_UV_Old(i_North, j_East, k);


                    if (FaceFlux_WestSouth > 0) then
                        if (ComputeFaces3D_UV(iSouth2, jWest2, k) /= Compute) then
                            NearBoundary = .true.
                            du4(1) = FillValueReal;
                        else
                            du4(1) = DZX_ZY(iSouth3, jWest3);
                        endif
                    else
                        if (ComputeFaces3D_UV(i_North,  j_East,  k) /= Compute) NearBoundary = .true.
                    endif

                    du4(2) = DZX_ZY(iSouth2, jWest2);
                    du4(3) = DZX_ZY(iSouth,  jWest );
                    du4(4) = DZX_ZY(i,       j     );


                    !du4  (1) = DZX_ZY  (i-2);du4  (2) = du  (i-1);du4  (3) = du  (i);du4  (4) = du  (i+1);
                    V4   (1) = Volume_UV  (iSouth2, jWest2, k);
                    V4   (2) = Volume_UV  (iSouth,  jWest,  k);
                    V4   (3) = Volume_UV  (i,       j,      k);
                    V4   (4) = Volume_UV  (i_North, j_East, k);
                    
                    call ComputeAdvectionFace(Vel4, V4, du4, Me%Velocity%DT,            &
                                              FaceFlux_WestSouth,                       &
                                              Me%ComputeOptions%VolumeRelMax,           &
                                              Me%ComputeOptions%AdvectionMethodH,       &
                                              Me%ComputeOptions%TVD_LimH,               &
                                              NearBoundary,                             &
                                              Me%ComputeOptions%Upwind2H, CFace)

                    Me%Aux3DFlux(i, j, k) = dble(Vel4(1) * CFace(1)  + Vel4(2) * CFace(2)  +     &
                                        Vel4(3) * CFace(3)  + Vel4(4) * CFace(4)) *     &
                                        FaceFlux_WestSouth ![m/s*m^3/s]


                    Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) +  Me%Aux3DFlux(i, j, k) 
           
                enddo dok1
                
            endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
         
        do k=KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB        
                
            iSouth  = i -   di
            jWest   = j -   dj   

            Horizontal_Transport(iSouth, jWest, k) = Horizontal_Transport(iSouth, jWest, k) - Me%Aux3DFlux(i, j, k) 

        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        !$OMP END PARALLEL                

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_Advection_UX_VY")
        endif

        !Nullify auxiliar pointers
        nullify (WaterFlux_XY        )
        nullify (Horizontal_Transport)
        nullify (Velocity_UV_Old     )
        nullify (ComputeFaces3D_UV   )
        nullify (KFloor_UV           )
        nullify (ImposedNormalFacesUV)

        nullify (DZX_ZY              )
        nullify (Volume_UV           )


    End Subroutine Modify_Advection_UX_VY

    
    !End ----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal advection with the perpendicular direction  !
    !  in the horizontal plane of the velocity. For the U velocity compute the             !
    !  advection with the Y direction for the V velocity compute the advection with the  !
    !  X direction                                                                         !
    !                                                                                      !
    ! Input : Flow, Mapping, Geometry, Time steps                                          !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_Advection_UY_VX 

      

        !Variables categories
        ! Geometry : DYY_XX  (U or V Control Volume width) 
        ! Flow     : WaterFlux_YX (Water flux perpendicular to the velocity direction), Velocity_UV_Old (U or V velocity)
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces) 
        ! Options  : UpStream_CenterDif (1-Upwind and 0-Centered differences), ImplicitVertAdvection (1-implict, 0- explicit)
        ! Direction: Direction (DirectionX=1,DirectionY_=2)
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)
        ! OutPut   : Horizontal_Transport

        !Arguments dependent from the direction: 
        ! DYY_XX, Velocity_UV_Old, Horizontal_Transport, WaterFlux_YX, ComputeFaces3D_UV, 
        ! Direction, Kfloor_UV, WaterFlux_YX


        !Arguments------------------------------------------------------------
         


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_YX, Horizontal_Transport, Volume_UV
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old 
        real,    dimension(:,:),   pointer :: DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        !real                               :: UpStream_CenterDif, Aux

!        real                               :: Coef1_Up, Coef2_Up, Coef3_Up, Coef2_Centered_SW, &
!                                              Coef3_Centered_SW

        real(8)                            :: FaceFlux_SouthWest !,MomentumFlux

!        real                               :: Coef1_SouthWest, Coef2_SouthWest, Coef3_SouthWest, Coef4_SouthWest

!        real                               :: Cell1_FaceSouthWest, Cell2_FaceSouthWest, Cell3_FaceSouthWest, Cell4_FaceSouthWest

!        real                               :: Cell_1, Cell_2, Cell_3, Cell_4
    
        integer                            :: di, dj, i, j, k, Kbottom
        integer                            :: iSouth, jWest, i_West, j_South, i_East, j_North, &
                                              i_West2, j_South2

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        logical                            :: NotBoundary, FaceLeftOK, FaceRightOK, NearBoundary

        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4
        
        !$ integer                            :: CHUNK

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

!        UpStream_CenterDif   =  Me%ComputeOptions%UpStream_CenterDif

!        Coef1_Up             =  Me%HorAdvection%Coef1_Up
!        Coef2_Up             =  Me%HorAdvection%Coef2_Up
!        Coef3_Up             =  Me%HorAdvection%Coef3_Up

        WaterFlux_YX         => Me%WaterFluxes%YX
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        Volume_UV            => Me%External_Var%Volume_UV

        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV
        BoundaryFacesUV          => Me%External_Var%BoundaryFacesUV
        KFloor_UV                => Me%External_Var%KFloor_UV
        DYY_XX                   => Me%External_Var%DYY_XX


        !End - Shorten variables name

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_Advection_UY_VX")
        endif
        
        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))        
        
        !$ CHUNK = CHUNK_J(JLB,JUB)

        !griflet: Avoid inner parallel zones, avoid all barriers and critical sections...
        !and you'll be fine.
        !ACanas(2010): Parallelization is commented because overheads are
        !ACanas(2010): found very large due to cycle is inner and in index k.
        !ACanas(2010): Since MOHID Water typical applications have horizontal
        !ACanas(2010): grid much larger than vertical grid it is not 
        !ACanas(2010): expected that performance could improve in other
        !Acanas(2010): applications than the one used for test.

        !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, &
        !$OMP                   iSouth,jWest,i_West,j_South,i_East,j_North,i_West2,j_South2, &
        !$OMP                   NotBoundary, FaceRightOK, FaceLeftOK, FaceFlux_SouthWest, &
        !$OMP                   NearBoundary,Vel4,du4, &
        !$OMP                   V4,CFace)        

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj:    do j=JLB, JUB
doi:    do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj

            i_West   = i -   dj
            j_South  = j -   di

            i_East   = i +   dj
            j_North  = j +   di

            i_West2  = i - 2*dj
            j_South2 = j - 2*di

cd1:        if (BoundaryFacesUV  (i     , j      ) == Not_Boundary .and.                 &
                BoundaryFacesUV  (i_West, j_South) == Not_Boundary) then
                
                NotBoundary = .true.

            else  cd1

                NotBoundary = .false.

            endif cd1

            !When the boundary is Cyclic the momentum advection flux is also compute for the boundary faces
            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                            Me%CyclicBoundary%Direction == DirectionXY_)) NotBoundary = .true.

cd2:        if (ComputeFaces3D_UV       (i, j, KUB) == Covered .or.                      &
                ImposedTangentialFacesUV(i, j, KUB) == Imposed) then

                FaceRightOK = .true.

            else  cd2

                FaceRightOK = .false.

            endif cd2

cd3:        if (ComputeFaces3D_UV       (i_West, j_South, KUB) == Covered .or.           &
                ImposedTangentialFacesUV(i_West, j_South, KUB) == Imposed) then

                FaceLeftOK = .true.

            else  cd3

                FaceLeftOK = .false.

            endif cd3
            
cd4:       if (NotBoundary .and. FaceRightOK .and. FaceLeftOK) then

                Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_West, j_South))

dok1:           do k = Kbottom, KUB

                    !South or West Face
                    FaceFlux_SouthWest = (WaterFlux_YX(iSouth  , jWest, k) + &
                                          WaterFlux_YX(i, j, k))/2.  
                    
                    NearBoundary = .false.


                    if (FaceFlux_SouthWest > 0) then
                        if (ComputeFaces3D_UV(i_West2, j_South2, k) /= Compute) NearBoundary = .true.
                    else
                        if (ComputeFaces3D_UV(i_East,  j_North,  k) /= Compute) NearBoundary = .true.
                    endif

                    Vel4(1) = Velocity_UV_Old(i_West2, j_South2, k);
                    Vel4(2) = Velocity_UV_Old(i_West, j_South,   k);
                    Vel4(3) = Velocity_UV_Old(i     , j,         k);
                    Vel4(4) = Velocity_UV_Old(i_East, j_North,   k);

                    du4(1) = DYY_XX(i_West2, j_South2)
                    du4(2) = DYY_XX(i_West, j_South  )
                    du4(3) = DYY_XX(i     , j        )
                    du4(4) = DYY_XX(i_East, j_North  )

                    !du4  (1) = DZX_ZY  (i-2);du4  (2) = du  (i-1);du4  (3) = du  (i);du4  (4) = du  (i+1);
                    V4   (1) = Volume_UV  (i_West2, j_South2, k);
                    V4   (2) = Volume_UV  (i_West, j_South,   k);
                    V4   (3) = Volume_UV  (i     , j,         k);
                    V4   (4) = Volume_UV  (i_East, j_North,   k);
                                       
                    call ComputeAdvectionFace(Vel4, V4, du4, Me%Velocity%DT,            &
                                              FaceFlux_SouthWest,                       &
                                              Me%ComputeOptions%VolumeRelMax,           &
                                              Me%ComputeOptions%AdvectionMethodH,       &
                                              Me%ComputeOptions%TVD_LimH,               &
                                              NearBoundary,                             &
                                              Me%ComputeOptions%Upwind2H, CFace)

                    Me%Aux3DFlux(i, j, k) = dble(Vel4(1) * CFace(1)  + Vel4(2) * CFace(2)  +     &
                                        Vel4(3) * CFace(3)  + Vel4(4) * CFace(4)) *     &
                                        FaceFlux_SouthWest ![m/s*m^3/s]
                    
                           
                    Horizontal_Transport(i, j, k)           = Horizontal_Transport(i, j, k) + &
                                                              Me%Aux3DFlux(i, j, k)


                enddo dok1
            endif cd4

        enddo doi
        enddo doj
        !$OMP END DO

        do k=KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB        
                
            i_West   = i -   dj
            j_South  = j -   di 

            Horizontal_Transport(i_West, j_South, k)= Horizontal_Transport(i_West, j_South, k) - &
                                                      Me%Aux3DFlux(i, j, k) 

        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo        

        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_Advection_UY_VX")
        endif

        !Nullify auxiliar pointers
        nullify (WaterFlux_YX            )
        nullify (Horizontal_Transport    )
        nullify (Velocity_UV_Old         )
        nullify (ComputeFaces3D_UV       )
        nullify (ImposedTangentialFacesUV)
        nullify (KFloor_UV               )
        nullify (DYY_XX                  )
        nullify (BoundaryFacesUV         )
        nullify (Volume_UV           )



    End Subroutine Modify_Advection_UY_VX
    
        !End ----------------------------------------------------------------------


    !------------------------------------------------------------------------------

    Subroutine Modify_UX_VY_Boundary  
      


        !Arguments------------------------------------------------------------
         


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_XY, Horizontal_Transport
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old 
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        real                               :: VelAux
         
        real(8)                            :: MomentumFlux

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_North, j_East

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
   
        integer                            :: CHUNK
        
        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        WaterFlux_XY         => Me%WaterFluxes%XY
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ImposedNormalFacesUV => Me%External_Var%ImposedNormalFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV

        !End - Shorten variables name 

        CHUNK = CHUNK_J(JLB, JUB)
 
         if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_UX_VY_Boundary")
        endif
 
        !$OMP PARALLEL PRIVATE(i,j,k,Kbottom,iSouth,jWest,i_North)    &
        !$OMP PRIVATE(j_East,VelAux,MomentumFlux)
 
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj
            i_North  = i +   di
            j_East   = j +   dj

 
cd0:        if (BoundaryFacesUV  (i, j     ) == Boundary .and.                                  &
                ComputeFaces3D_UV(i, j, KUB) == Covered) then

                Kbottom = KFloor_UV(i, j)


                    ! West or South Face
                               
!cd1:            if (BoundaryFacesUV   (i_North, j_East)      == Not_Boundary .and.       &
!                    ComputeFaces3D_UV (i_North, j_East, KUB) == Not_Covered) then

cd1:            if (ImposedNormalFacesUV (i_North, j_East, KUB)  == Imposed) then
 
            dok1:   do k = Kbottom, KUB

                        if (WaterFlux_XY(i, j, k) > 0.) then

                            VelAux = Velocity_UV_Old(i, j, k)

                        else

                            VelAux = Velocity_UV_Old(i_North, j_East, k)

                        endif
                        
                        ![m^3/s*m/s]  = [m/s*m^3/s]
                        MomentumFlux = dble(VelAux) * WaterFlux_XY(i, j, k) ![m/s*m^3/s]


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) - &
                                                         MomentumFlux

                    enddo dok1
                                                        
!                else if (BoundaryFacesUV   (iSouth, jWest)      == Not_Boundary .and.  &
!                         ComputeFaces3D_UV (iSouth, jWest, KUB) == Not_Covered ) then cd1
                
                else if (ImposedNormalFacesUV (iSouth, jWest, KUB)  == Imposed) then cd1

            dok2:   do k = Kbottom, KUB

                        if (WaterFlux_XY(i, j, k) > 0.) then

                            VelAux = Velocity_UV_Old(iSouth, jWest, k)

                        else

                            VelAux = Velocity_UV_Old(i, j, k)

                        endif


                        ![m^3/s*m/s]  = [m/s*m^3/s]
                        MomentumFlux = dble(VelAux) * WaterFlux_XY(i, j, k) ![m/s*m^3/s]


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) + &
                                                         MomentumFlux                       


                    enddo dok2

                endif cd1
         

            endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL
 
        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_UX_VY_Boundary")
        endif
 
        !Nullify auxiliar pointers
        nullify (WaterFlux_XY        )
        nullify (Horizontal_Transport)
        nullify (Velocity_UV_Old     )
        nullify (KFloor_UV           )
        nullify (BoundaryFacesUV     )
        nullify (ComputeFaces3D_UV   )
        nullify (ImposedNormalFacesUV)

    End Subroutine Modify_UX_VY_Boundary

    
    !End ----------------------------------------------------------------------


    !------------------------------------------------------------------------------

    Subroutine Modify_UX_VY_SubModel 
      


        !Arguments------------------------------------------------------------
         


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_XY, Horizontal_Transport, Sub_qXY
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old !,Sub_UV
        real,    dimension(:,:  ), pointer :: DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV
         
        real(8)                            :: MomentumFlux, FatherFlux, SonFlux, AverageFlux

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_North, j_East

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK
        
        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        WaterFlux_XY         => Me%WaterFluxes%XY
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        !Sub_UV               => Me%SubModel%UV
        Sub_qXY              => Me%SubModel%qXY

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ImposedNormalFacesUV => Me%External_Var%ImposedNormalFacesUV
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV
        DYY_XX               => Me%External_Var%DYY_XX

        !End - Shorten variables name 

        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_UX_VY_SubModel")
        endif
        
        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,i_North,j_East,Kbottom,SonFLux) &
        !$OMP PRIVATE(FatherFlux,MomentumFlux,AverageFlux)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj
            i_North  = i +   di
            j_East   = j +   dj

 
cd0:        if (BoundaryFacesUV  (i, j)      == Boundary .and.                           &
                ComputeFaces3D_UV(i, j, KUB) == Covered) then
                
                Kbottom = KFloor_UV(i, j)

                ! East or North Face          

!cd1:            if (BoundaryFacesUV   (i_North, j_East)      == Not_Boundary .and.       &
!                    ComputeFaces3D_UV (i_North, j_East, KUB) == Not_Covered) then

cd1:            if (ImposedNormalFacesUV (i_North, j_East, KUB) == Imposed) then

            dok1:   do k = Kbottom, KUB

            
                       ![m^3/s]  = [m^3/s]
                        SonFlux    =  WaterFlux_XY(i, j, k) ![m/s*m^3/s]


                        ![m^3/s]   = [m^2/s]*[m]

                        FatherFlux =      Sub_qXY (i_North, j_East, k)  *                &
                                     dble(DYY_XX  (i_North, j_East)   )
                    
                        AverageFlux  = (FatherFlux + SonFlux) / 2.

                        if (AverageFlux > 0 ) then

                            ![m^3/s*m/s] = [m/s*m^3/s]
                            MomentumFlux = dble(Velocity_UV_Old(i,  j,  k))          * AverageFlux

                        else

                            ![m^3/s*m/s] = [m/s*m^3/s]
                            MomentumFlux = dble(Velocity_UV_Old(i_North, j_East, k)) * AverageFlux

                        endif


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) - &
                                                         MomentumFlux

                    enddo dok1

                ! West or South Face

!                else if (BoundaryFacesUV   (iSouth, jWest)      == Not_Boundary .and.  &
!                         ComputeFaces3D_UV (iSouth, jWest, KUB) == Not_Covered ) then cd1

                else if (ImposedNormalFacesUV (iSouth, jWest, KUB) == Imposed) then cd1

            dok2:   do k = Kbottom, KUB



                       ![m^3/s]  = [m^3/s]
                        SonFlux    =  WaterFlux_XY(i, j, k) ![m/s*m^3/s]


                        ![m^3/s]  = [m^2/s]*[m]
                        FatherFlux =      Sub_qXY (iSouth, jWest, k)  *                &
                                     dble(DYY_XX  (iSouth, jWest)   )

                        AverageFlux  = (FatherFlux + SonFlux) / 2.

                        if (AverageFlux > 0 ) then

                            ![m^3/s*m/s] = [m/s*m^3/s]
                            MomentumFlux = dble(Velocity_UV_Old(iSouth, jWest, k)) * AverageFlux

                        else

                            ![m^3/s*m/s] = [m/s*m^3/s]
                            MomentumFlux = dble(Velocity_UV_Old(i,  j,  k))          * AverageFlux

                        endif


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) + &
                                                         MomentumFlux                       

                    enddo dok2

                endif cd1
         
            endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_UX_VY_SubModel")
        endif

        !Nullify auxiliar pointers
        nullify (WaterFlux_XY        )
        nullify (Horizontal_Transport)
        !nullify (Sub_UV             )
        nullify (Sub_qXY             )
        nullify (DYY_XX              )
        nullify (KFloor_UV           )
        nullify (BoundaryFacesUV     )
        nullify (Velocity_UV_Old     )
        nullify (ComputeFaces3D_UV   )
        nullify (ImposedNormalFacesUV)

    End Subroutine Modify_UX_VY_SubModel

    
    !End ----------------------------------------------------------------------


    !------------------------------------------------------------------------------

    Subroutine Modify_UY_VX_Boundary  
      


        !Arguments------------------------------------------------------------
        


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, WaterFlux_YX

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ComputeFaces3D_VU
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV,                &
                                              BoundaryFacesVU

        real(8)                            :: MomentumFluxUp, MomentumFluxDown,          &
                                              WaterFluxUp   , WaterFluxDown

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest , i_East,                  &
                                              j_North, i_West, j_South

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        WaterFlux_YX         => Me%WaterFluxes%YX
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ComputeFaces3D_VU    => Me%External_Var%ComputeFaces3D_VU
        KFloor_UV            => Me%External_Var%KFloor_UV

        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV
        BoundaryFacesVU      => Me%External_Var%BoundaryFacesVU

        !End - Shorten variables name 

        CHUNK = CHUNK_J(JLB, JUB) 

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_UY_VX_Boundary")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,i_East,j_North,i_West) &
        !$OMP PRIVATE(j_South,Kbottom,WaterFluxUp,MomentumFluxUp) &
        !$OMP PRIVATE(WaterFluxDown,MomentumFluxDown)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj

            i_East   = i +   dj
            j_North  = j +   di

            i_West   = i -   dj
            j_South  = j -   di


             
            Kbottom = KFloor_UV(i, j)

            !Momentum changes perpendicular to the velocity
            ! in boundary faces perpendicular also to the velocity
            !If the velocity is in the X direction the boundaries 
            ! compute are the West and the East ones
            !If the velocity is in the Y direction the boundaries 
            ! compute are the South and the North ones


cd0:        if (BoundaryFacesUV  (i, j     ) == Boundary .and.                           &
                ComputeFaces3D_UV(i, j, KUB) == Covered) then

        dok1:   do k = Kbottom, KUB

                    ![m^3/s*m/s]  = [m^3/s*m/s]
                    WaterFluxUp       = (dble(ComputeFaces3D_VU(i - di + dj, j - dj + di, k)) * &
                                         WaterFlux_YX          (i - di + dj, j - dj + di, k)  + &
                                         dble(ComputeFaces3D_VU(i_East     , j_North    , k)) * &
                                         WaterFlux_YX          (i_East     , j_North    , k)) 

                    if (WaterFluxUp > 0) then
                        
                        MomentumFluxUp = dble(Velocity_UV_Old  (i     , j      , k)) * WaterFluxUp

                    else

                        MomentumFluxUp = dble(Velocity_UV_Old  (i_East, j_North, k)) * WaterFluxUp

                    endif


                    WaterFluxDown     = (dble(ComputeFaces3D_VU(iSouth    , jWest     , k)) * &
                                         WaterFlux_YX          (iSouth    , jWest     , k)  + &
                                         dble(ComputeFaces3D_VU(i          , j          , k)) * &
                                         WaterFlux_YX          (i          , j          , k)) 


                    if (WaterFluxDown > 0) then
                        
                        MomentumFluxDown = dble(Velocity_UV_Old  (i_West, j_South, k)) * WaterFluxDown

                    else

                        MomentumFluxDown = dble(Velocity_UV_Old  (i     , j      , k)) * WaterFluxDown

                    endif

                    !The same tangential boundary condition assumed 
                    !for the velocity is assumed for the water flow 
                    if (Me%ComputeOptions%VelTangentialBoundary == NULL_VALUE) then 

                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) - &
                                                         MomentumFluxUp    / 2.        + &
                                                         MomentumFluxDown  / 2.

                    else if (Me%ComputeOptions%VelTangentialBoundary == NULL_GRADIENT) then 
                        

                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) - &
                                                         MomentumFluxUp        +         &
                                                         MomentumFluxDown 

                    endif


                enddo dok1

            endif cd0




        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_UY_VX_Boundary")
        endif

        !Nullify auxiliar pointers
        nullify(WaterFlux_YX         )
        nullify(Horizontal_Transport )
        nullify(Velocity_UV_Old      )

        nullify(ComputeFaces3D_UV    )
        nullify(ComputeFaces3D_VU    )
        nullify(KFloor_UV            )

        nullify(BoundaryFacesUV      )
        nullify(BoundaryFacesVU      )

    End Subroutine Modify_UY_VX_Boundary

    
    !End ----------------------------------------------------------------------


    !------------------------------------------------------------------------------

    !------------------------------------------------------------------------------

    Subroutine Modify_UY_VX_SubModel  
      


        !Arguments------------------------------------------------------------
        


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, WaterFlux_YX, Sub_qYX
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old !,Sub_UV, Sub_VU
        real,    dimension(:,:  ), pointer :: DXX_YY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV       , ComputeFaces3D_VU
        integer, dimension(:,:,:), pointer :: ImposedTangentialFacesUV, ImposedTangentialFacesVU 
        integer, dimension(:,:),   pointer :: BoundaryFacesUV, KFloor_UV

        real(8)                            :: MomentumFluxUp, MomentumFluxDown
        real(8)                            :: WaterFluxUp, WaterFluxDown
        real(8)                            :: WaterFluxImposed, WaterFluxComputed

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest , i_East,                  &
                                              j_North

        integer                            :: j_South, i_West 


        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        WaterFlux_YX         => Me%WaterFluxes%YX
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        Sub_qYX              => Me%SubModel%qYX

        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        ComputeFaces3D_VU        => Me%External_Var%ComputeFaces3D_VU

        ImposedTangentialFacesVU => Me%External_Var%ImposedTangentialFacesVU
        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV
        KFloor_UV                => Me%External_Var%KFloor_UV

        DXX_YY                   => Me%External_Var%DXX_YY

        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV


        !End - Shorten variables name 

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_UY_VX_SubModel")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,i_East,j_North) &
        !$OMP PRIVATE(i_West,j_South,Kbottom,WaterFluxImposed) &
        !$OMP PRIVATE(WaterFluxComputed,WaterFluxUp,MomentumFluxUp) &
        !$OMP PRIVATE(WaterFluxDown,MomentumFluxDown)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doj: do j=JLB, JUB
    doi: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj

            i_East   = i +   dj
            j_North  = j +   di

            i_West   = i -   dj
            j_South  = j -   di
                

            !Momentum changes perpendicular to the velocity
            ! in boundary faces perpendicular also to the velocity
            !If the velocity is in the X direction the boundaries 
            ! compute are the West and the East ones
            !If the velocity is in the Y direction the boundaries 
            ! compute are the South and the North ones


cd0:        if (BoundaryFacesUV  (i, j     ) == Boundary .and.                           &
                ComputeFaces3D_UV(i, j, KUB) == Covered) then
                
                !East or North face
cd1:            if (ComputeFaces3D_UV       (i_East, j_North, KUB) == Covered   .or.     &         
                    ImposedTangentialFacesUV(i_East, j_North, KUB) == Imposed) then

                    Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_East, j_North))

dok1:               do k = Kbottom, KUB

                        ![m^3/s]          = [m^2/s]*[m]
                        WaterFluxImposed  =  dble(ImposedTangentialFacesVU(i - di + dj, j - dj + di, k)) * &
                                                  Sub_qYX                 (i - di + dj, j - dj + di, k)  * &
                                             dble(DXX_YY                  (i - di + dj, j - dj + di   )) + &
                                             dble(ImposedTangentialFacesVU(i_East     , j_North    , k)) * &
                                                  Sub_qYX                 (i_East     , j_North    , k)  * &
                                             dble(DXX_YY                  (i_East     , j_North       ))
                        ![m^3/s]          = [m^3/s]
                        WaterFluxComputed =  dble(ComputeFaces3D_VU(i - di + dj, j - dj + di, k)) * &
                                                  WaterFlux_YX     (i - di + dj, j - dj + di, k)  + &
                                             dble(ComputeFaces3D_VU(i_East     , j_North    , k)) * &
                                                  WaterFlux_YX     (i_East     , j_North    , k) 




                        WaterFluxUp       =  (WaterFluxImposed + WaterFluxComputed) / 2.


cd2:                    if (WaterFluxUp > 0) then

                            MomentumFluxUp = WaterFluxUp * dble(Velocity_UV_Old  (i , j , k))

                        else  cd2
                        
                            MomentumFluxUp = WaterFluxUp * dble(Velocity_UV_Old  (i_East, j_North, k))

                        endif cd2

                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) - &
                                                         MomentumFluxUp 

                    enddo dok1

                endif cd1


                !West or South face
cd3:            if (ComputeFaces3D_UV       (i_West, j_South, KUB) == Covered   .or.     &         
                    ImposedTangentialFacesUV(i_West, j_South, KUB) == Imposed) then

                    Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_West, j_South))

dok2:               do k = Kbottom, KUB

                        ![m^3/s]         = [m^2/s]*[m]
                        WaterFluxImposed =  dble(ImposedTangentialFacesVU(iSouth    , jWest     , k)) * &
                                                 Sub_qYX                 (iSouth    , jWest     , k)  * &
                                            dble(DXX_YY                  (iSouth    , jWest        )) + &
                                            dble(ImposedTangentialFacesVU(i          , j        , k)) * &
                                                 Sub_qYX                 (i          , j        , k)  * &
                                            dble(DXX_YY                  (i          , j           ))


                        ![m^3/s]         = [m^2/s]*[m]
                        WaterFluxComputed=  dble(ComputeFaces3D_VU(iSouth    , jWest     , k)) * &
                                                 WaterFlux_YX     (iSouth    , jWest     , k)  + &
                                            dble(ComputeFaces3D_VU(i          , j          , k)) * &
                                                 WaterFlux_YX     (i          , j          , k)


                        WaterFluxDown    =  (WaterFluxImposed + WaterFluxComputed) / 2.


cd4:                    if (WaterFluxDown > 0) then

                            MomentumFluxDown = WaterFluxDown * dble(Velocity_UV_Old  (i_West, j_South, k))

                        else  cd4
                        
                            MomentumFluxDown = WaterFluxDown * dble(Velocity_UV_Old  (i , j , k))

                        endif cd4

                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) + &
                                                         MomentumFluxDown 

                    enddo dok2

                endif cd3

            endif cd0

        enddo doi
        enddo doj
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_UY_VX_SubModel")
        endif

        !Nullify auxiliar pointers
        nullify(WaterFlux_YX         )
        nullify(Horizontal_Transport )
        nullify(Velocity_UV_Old      )

        nullify(Sub_qYX              )

        nullify(ComputeFaces3D_UV    )
        nullify(ComputeFaces3D_VU    )

        nullify(ImposedTangentialFacesUV)
        nullify(ImposedTangentialFacesVU)
        
        nullify(KFloor_UV            )

        nullify(BoundaryFacesUV      )

        nullify(DXX_YY               )

    End Subroutine Modify_UY_VX_SubModel

    
    !End ----------------------------------------------------------------------


    !------------------------------------------------------------------------------

    Subroutine AdvectionInSmallDepths  
      

        !Arguments------------------------------------------------------------

                                                

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport
        real,    dimension(:,:  ), pointer :: WaterColumn, WaterColumnUV, DUX_VY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV
         
        real                               :: FaceWaterColumn, Hmin_Advection
    
        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest

        integer                            :: IUB, ILB, JUB, JLB, KUB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Shorten variables name 
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        !WaterColumn          => Me%External_Var%WaterColumn
        WaterColumnUV        => Me%External_Var%WaterColumnUV
        DUX_VY               => Me%External_Var%DUX_VY

        Horizontal_Transport => Me%Forces%Horizontal_Transport

        Hmin_Advection      =  Me%ComputeOptions%Hmin_Advection

        !End - Shorten variables name 

        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "AdvectionInSmallDepths")
        endif
        
        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,FaceWaterColumn,Kbottom)
        
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj

            !FaceWaterColumn = (WaterColumn(i      , j     ) * DUX_VY(iSouth, jWest) +  &
            !                   WaterColumn(iSouth, jWest) * DUX_VY(i      , j     ))/  &
            !                  (DUX_VY     (iSouth, jWest) + DUX_VY(i      , j     ))  

            FaceWaterColumn = WaterColumnUV(i, j)

 !If the depth in a face is smaller than Hmin_Advection then advection is cancelled
cd0:        if (ComputeFaces3D_UV(i, j, KUB) == Covered .and.                            &
                FaceWaterColumn < Hmin_Advection) then


                Kbottom = KFloor_UV(i, j)

                !West or South Face
        dok1:   do k = Kbottom, KUB
                  
                    Horizontal_Transport(i, j, k) = 0.                    

                enddo dok1
                
            endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "AdvectionInSmallDepths")
        endif

        nullify (WaterColumn         )
        nullify (DUX_VY              )

        !End ----------------------------------------------------------------------

    end Subroutine AdvectionInSmallDepths


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal diffusion with the same direction of the     !
    !  velocity. For the U velocity compute the diffusion with the X direction             !       
    !  for the V velocity compute the diffusion with the Y direction                       !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_Diffusion_UX_VY ( Velocity_UV_Old, Biharmonic)           
     
        !Variables category 
        ! Geometry : Volume_Z, DUX_VY (Volume and length of the elevation control volume)
        ! Flow     : Visc_H_Center (Turbulent viscosity in the center of the elevation control volume), 
        !            Velocity_UV_Old (U or V velocity)
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces) 
        ! Direction: Direction (DirectionX=1,DirectionY_=2)
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)

        !Variables direction dependent: 
        ! Horizontal_Transport, DUX_VY, Velocity_UV_Old, ComputeFaces3D_UV, Direction, Kfloor_UV


        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        logical, intent (IN)               :: Biharmonic
                                            
        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_Z_New, Volume_UV
        real,    dimension(:,:,:), pointer :: Visc_H_Center
        real,    dimension(:,:),   pointer :: DUX_VY, DZX_ZY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV

        logical                            :: ConservativeHorDif, ComputeFlux

        real                               :: FaceFlux_WestSouth1, FaceFlux_WestSouth2, Aux, ViscAux
        
        real                               :: Vel_UV_South, Vel_UV_North
        
        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_North, j_East

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
                
        !$ integer                            :: CHUNK
        
        !Begin-----------------------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ConservativeHorDif   =  Me%ComputeOptions%ConservativeHorDif

        Visc_H_Center        => Me%External_Var%Visc_H_Center
        
        Horizontal_Transport => Me%Forces%Horizontal_Transport

        ImposedNormalFacesUV => Me%External_Var%ImposedNormalFacesUV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        Volume_Z_New         => Me%External_Var%Volume_Z_New
        DUX_VY               => Me%External_Var%DUX_VY

        DZX_ZY               => Me%External_Var%DZX_ZY
        Volume_UV            => Me%External_Var%Volume_UV

        !End - Shorten variables name 

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_Diffusion_UX_VY")
        endif
        
        
        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))        

        !$ CHUNK = CHUNK_J(JLB,JUB)
        
        !It was lacking Vel_UV_South and Vel_UV_North in private what created OpenMP errors
        !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, &
        !$OMP                   iSouth, jWest, i_North, j_East, &
        !$OMP                   ComputeFlux, &
        !$OMP                   ViscAux,FaceFlux_WestSouth1,FaceFlux_WestSouth2, &
        !$OMP                   Aux,Vel_UV_South,Vel_UV_North)        

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj
            i_North  = i +   di
            j_East   = j +   dj

            ComputeFlux = .false.

            if (Me%ComputeOptions%SlippingCondition) then

                if (ComputeFaces3D_UV(i      , j   , KUB) == Covered  .and.            &
                    ComputeFaces3D_UV(iSouth, jWest, KUB) == Covered )   ComputeFlux = .true. 

            else

                if (ComputeFaces3D_UV   (i      , j     , KUB) == Covered  .or.          &
                    ComputeFaces3D_UV   (iSouth, jWest, KUB) == Covered) ComputeFlux = .true. 

            endif

            !When the boundary is Cyclic the momentum diffusion flux is also compute for the boundary faces
            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                            Me%CyclicBoundary%Direction == DirectionXY_))  then

                if ((ComputeFaces3D_UV   (i     , j     , KUB) == Covered .and.          &
                     ImposedNormalFacesUV(iSouth, jWest , KUB) == Imposed) .or.          &
                    (ComputeFaces3D_UV   (iSouth, jWest , KUB) == Covered .and.          &
                     ImposedNormalFacesUV(i     , j     , KUB) == Imposed))              &
                                                                           ComputeFlux = .true.

            endif

cd0:        if (ComputeFlux) then  
                Kbottom = max(KFloor_UV(i, j), KFloor_UV(iSouth, jWest)) 

dok1:           do k = Kbottom, KUB

                    if (BiHarmonic) then
            
                        ViscAux = Me%ComputeOptions%BiHarmonicCoef

                    else
                        
                        ViscAux = Visc_H_Center( iSouth, jWest, k)

                    endif
                    
                    Vel_UV_South = Velocity_UV_Old( iSouth, jWest, k)
                    Vel_UV_North = Velocity_UV_Old( i     , j    , k)   
                    
                    if (Me%WaterFluxes%Discharges( iSouth, jWest, k) > 0. .and.     &
                                ComputeFaces3D_UV( iSouth, jWest, k) /= Covered) then

                        if (Me%ComputeOptions%MomentumDischarge) then
                            Vel_UV_South = Me%WaterFluxes%DischargesVelUV(iSouth, jWest, k)
                        endif
                        
 
                    endif 
                    
                    if (Me%WaterFluxes%Discharges(i, j, k) > 0. .and.               &
                                ComputeFaces3D_UV(i, j, k) /= Covered) then

                        if (Me%ComputeOptions%MomentumDischarge) then
                            Vel_UV_South = Me%WaterFluxes%DischargesVelUV(i, j, k)
                        endif                      
 
                    endif
                    
cd1:                if (ConservativeHorDif) then 

                        ! West or South Face

                        ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m] * [m^3] / [m]
                        FaceFlux_WestSouth1 = ViscAux                            *      & ! Turbulent viscosity
                                             (Vel_UV_North - Vel_UV_South) /            &
                                             DUX_VY( iSouth, jWest) *                   & ! Velocity gradient
                                             Volume_Z_New( iSouth, jWest, k) /          &
                                             DUX_VY( iSouth, jWest)                     ! Face Area
                    
                        FaceFlux_WestSouth2 = FaceFlux_WestSouth1

                    else cd1
                        
                        ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                        Aux                 = ViscAux                           *       & ! Turbulent viscosity
                                            (Vel_UV_North - Vel_UV_South) /             &
                                             DUX_VY( iSouth, jWest)                       ! Velocity gradient

                        !The velocity gradient plus the volume divided by the distance between 
                        !volume faces is equal to compute in a non-conservative way the lapalcian of the 
                        !velocity plus viscosity. The effect of the variable horizontal_transport in the velocity 
                        !is compute dividing the variable horizontal_Transport/VolumeU*DT = Visc * Laplacian(Velocity)
                        !

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_WestSouth1 = Aux * Volume_UV(i      , j     , k) /      &
                                                    DZX_ZY   (i - di , j - dj)

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_WestSouth2 = Aux * Volume_UV(iSouth, jWest, k) /      &
                                                    DZX_ZY   (iSouth - di , jWest - dj)

                    endif cd1
                    
                    Horizontal_Transport(i, j, k)            = Horizontal_Transport(i, j, k) &
                                                              - FaceFlux_WestSouth1  

                    Me%Aux3DFlux        (iSouth, jWest, k)           =  FaceFlux_WestSouth2                   

                 enddo dok1

             endif cd0

        enddo doj
        enddo doi
        !$OMP END DO

        do k=KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB
            Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) + Me%Aux3DFlux(i, j, k)         
        enddo
        enddo
        !$OMP END DO NOWAIT        
        enddo

        !$OMP END PARALLEL

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (Volume_Z_New        )
        nullify (Visc_H_Center       )
        nullify (DUX_VY              )
        nullify (DZX_ZY              )
        nullify (ComputeFaces3D_UV   )
        nullify (ImposedNormalFacesUV)
        nullify (KFloor_UV           )
        nullify (Volume_UV           )

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_Diffusion_UX_VY")
        endif

    End Subroutine Modify_Diffusion_UX_VY

    
        !End ----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal diffusion perpendicular to the               !
    !  velocity. For the U velocity compute the diffusion with the Y direction             !       
    !  for the V velocity compute the diffusion with the X direction                       !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_Diffusion_UY_VX ( Velocity_UV_Old, Biharmonic)           


        !Variables categories 
        ! Geometry : Area_VU (area of the compute V or U compute points), DYY_XX (centered 
        !   width of the V or U control volume)
        !
        ! Flow     : Visc_H_Corner (Turbulent viscosity in the SW corner of the elevation 
        !   control volume), Velocity_UV_Old (U or V velocity)
        !
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  
        !   (1 - covered faces, 0 - not covered faces) 
        !
        ! Direction: Direction (DirectionX=1,DirectionY_=2)
        !
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), 
        !            KUB (k upper bound)
        !
        !Variables direction dependent: 
        !DUX_DVY, Velocity_UV_Old, ComputeFaces3D_UV, Direction, Kfloor_UV

        !Arguments--------------------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old 
        logical, intent (IN)               :: Biharmonic
        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_UV
        real,    dimension(:,:,:), pointer :: Area_VU
        real,    dimension(:,:),   pointer :: DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:,:), pointer :: ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: FaceFlux_SouthWest1, FaceFlux_SouthWest2

        real                               :: Aux, ViscAux

        logical                            :: ConservativeHorDif, NoSlipFace,            &
                                              ComputeFlux, ComputeFlux1, ComputeFlux2
    
        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_West, j_South

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !$ integer                            :: CHUNK
        
        !Begin-------------------------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ConservativeHorDif   =  Me%ComputeOptions%ConservativeHorDif
       
        Horizontal_Transport => Me%Forces%Horizontal_Transport

        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV
        
        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV            => Me%External_Var%KFloor_UV

        Volume_UV            => Me%External_Var%Volume_UV
        Area_VU              => Me%External_Var%Area_VU
        DYY_XX               => Me%External_Var%DYY_XX

        !End - Shorten variables name 

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_Diffusion_UY_VX")
        endif

        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, &
        !$OMP                   iSouth, jWest, i_West, j_South, &
        !$OMP                   ComputeFlux, ComputeFlux1, ComputeFlux2, &
        !$OMP                   ViscAux,FaceFlux_SouthWest1,FaceFlux_SouthWest2, &
        !$OMP                   NoSlipFace, Aux)
        
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i - di
            jWest   = j - dj

            i_West   = i - dj
            j_South  = j - di

            ComputeFlux  = .false.
            ComputeFlux1 = .false.
            ComputeFlux2 = .false.

            if (Me%ComputeOptions%SlippingCondition) then

                if (ComputeFaces3D_UV(i     , j      , KUB) == Covered .and.             &
                    ComputeFaces3D_UV(i_West, j_South, KUB) == Covered) ComputeFlux = .true. 

            else

                if (ComputeFaces3D_UV        (i     , j      , KUB) == Covered .or.      &
                    ComputeFaces3D_UV        (i_West, j_South, KUB) == Covered) then
                    
                    ComputeFlux = .true. 
                    if (ComputeFaces3D_UV    (i     , j      , KUB) == Covered) ComputeFlux1 = .true.
                    if (ComputeFaces3D_UV    (i_West, j_South, KUB) == Covered) ComputeFlux2 = .true.

                endif

            endif

            !When the boundary is Cyclic the momentum diffusion flux is also compute for the boundary faces
            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                            Me%CyclicBoundary%Direction == DirectionXY_))  then

                if ((ComputeFaces3D_UV       (i     , j       , KUB) == Covered .and.    &
                     ImposedTangentialFacesUV(i_West, j_South , KUB) == Imposed) .or.    &
                    (ComputeFaces3D_UV       (i_West, j_South , KUB) == Covered .and.    &
                     ImposedTangentialFacesUV(i     , j       , KUB) == Imposed)) then

                    ComputeFlux = .true.

                    ComputeFlux1 = .true.

                    ComputeFlux2 = .true.

                  endif

            endif

cd0:        if (ComputeFlux) then  

                Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_West, j_South))

       dok1:    do k = Kbottom, KUB                    

                   ! West or South Face

!cd1:                if (ComputeFaces3D_U(i-1,  j,  k) == Covered .and. &
!                        ComputeFaces3D_U(i,  j,  k) == Covered .and. &
!                        ComputeFaces3D_V(i,  j-1,k) == Covered .and. &
!                        ComputeFaces3D_V(i,  j,  k) == Covered) then

           
                        if (Biharmonic) then
                
                            ViscAux = Me%ComputeOptions%BiHarmonicCoef

                        else
                            
                            ViscAux = Me%External_Var%Visc_H_Corner(i, j, k)

                        endif

!                    else cd1

!                        ViscAux = 0.

!                    endif cd1

                    NoSlipFace = .false.

                    !Test if one of the faces is not covered
                    if (.not. Me%ComputeOptions%SlippingCondition)  then
                        
                        call DiffusionAlongNotCoveredFaces(Velocity_UV_Old,              &
                                                      ComputeFlux1,                      &
                                                      ComputeFlux2,                      &
                                                      DYY_XX, Volume_UV,                 &
                                                      FaceFlux_SouthWest1,               &
                                                      FaceFlux_SouthWest2,               &
                                                      NoSlipFace,                        &
                                                      ViscAux,                           &
                                                      i_West, j_South, i, j, k)

                    endif

cd3:                if (.not. NoSlipFace) then

cd2:                    if (ConservativeHorDif) then 

                            ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m]  * [m^2] 
                            FaceFlux_SouthWest1 = ViscAux               *           & ! Turbulent viscosity
                                            (Velocity_UV_Old(i, j, k) -             &
                                             Velocity_UV_Old(i_West, j_South, k)) / &
                                            (DYY_XX(i_West, j_South) +              &
                                             DYY_XX( i, j)) *                       & ! half of the Velocity gradient
                                            (Area_VU(iSouth, jWest, k) +            &
                                             Area_VU(i     , j    , k))               ! double of the Face Area

                            FaceFlux_SouthWest2 = FaceFlux_SouthWest1

                        else cd2
                        
                   
                            ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                            Aux = ViscAux                *                                   &  ! Turbulent viscosity
                                 (Velocity_UV_Old(i, j, k) -                                 &
                                  Velocity_UV_Old(i_West, j_South, k)) /                     &
                                 (DYY_XX(i_West, j_South) +                                  &
                                  DYY_XX( i, j)) * 2                        ! Velocity gradient

                            ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_SouthWest1 = Aux  *                                     &
                                                  Volume_UV   (i     , j, k) /               &  ! Area
                                                  DYY_XX      (i     , j   )
                        
                            ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_SouthWest2 = Aux  *                                     &
                                                  Volume_UV   (i_West, j_South, k) /         &
                                                  DYY_XX      (i_West, j_South)
                                                            
                        endif cd2

                    endif cd3


                    Horizontal_Transport(i, j, k)            = Horizontal_Transport(i, j, k) - &
                                                               FaceFlux_SouthWest1           * &
                                                               ComputeFaces3D_UV   (i, j, k)

                    Me%Aux3DFlux(i_West, j_South, k)         = FaceFlux_SouthWest2   * &
                                                               ComputeFaces3D_UV   (i_West, j_South, k)


                enddo dok1
                
            endif cd0 

        enddo doj
        enddo doi
        !$OMP END DO
        
        do k=KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB
            Horizontal_Transport(i, j, k)= Horizontal_Transport(i, j, k) + Me%Aux3DFlux(i, j, k)
        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo        

        !$OMP END PARALLEL
        
        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_Diffusion_UY_VX")
        endif

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (Area_VU)
        nullify (DYY_XX)
        nullify (ComputeFaces3D_UV)
        nullify (ImposedTangentialFacesUV)
        nullify (KFloor_UV)
        nullify (Volume_UV)

    End Subroutine Modify_Diffusion_UY_VX

    Subroutine DiffusionAlongNotCoveredFaces(Velocity_UV_Old, ComputeFlux1, ComputeFlux2,&
                                             DYY_XX, Volume_UV,                          &
                                             FaceFlux_SouthWest1,                        &
                                             FaceFlux_SouthWest2,                        &
                                             NoSlipFace,                                 &
                                             ViscAux,                                    &
                                             i_West, j_South, i, j, k)
            !Arguments--------------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old 
        real(8), dimension(:,:,:), pointer :: Volume_UV
        real,    dimension(:,:),   pointer :: DYY_XX
        logical, intent(IN )               :: ComputeFlux1, ComputeFlux2
        real,    intent(OUT)               :: FaceFlux_SouthWest1, FaceFlux_SouthWest2
        logical, intent(OUT)               :: NoSlipFace

        real                               :: ViscAux

        integer                            :: i, j, k

        integer                            :: i_West, j_South

        !Begin-------------------------------------------------------------------------------


        ! i,j,k not covered face
        if (.not. ComputeFlux1) then

            FaceFlux_SouthWest1 = 0.
            ![m^3/s*m/s]         = [m2/s] * [m/s] / [m] * [m^3]/[m]
            FaceFlux_SouthWest2 = - ViscAux * Velocity_UV_Old(i_West, j_South, k) /      &
                                    DYY_XX      (i_West, j_South)    / 2.         *      &
                                    Volume_UV   (i_West, j_South, k) /                   &
                                    DYY_XX      (i_West, j_South)

            NoSlipFace = .true.
 
        endif  

        ! i_West, j_South, k not covered face
        if (.not. ComputeFlux2) then

            ![m^3/s*m/s]         = [m2/s] * [m/s] / [m] * [m^3]/[m]
            FaceFlux_SouthWest1 =   ViscAux * Velocity_UV_Old(i, j, k)  /                &
                                    DYY_XX      (i, j) / 2. *                            &
                                    Volume_UV   (i, j, k)   /                            &
                                    DYY_XX      (i, j)
            FaceFlux_SouthWest2 = 0.

            NoSlipFace = .true.

        endif  

    end Subroutine DiffusionAlongNotCoveredFaces


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal diffusion with the same direction of the     !
    !  velocity. For the U velocity compute the diffusion with the X direction             !       
    !  for the V velocity compute the diffusion with the Y direction                       !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ModifyDiffSub_UX_VY ( Velocity_UV_Old, Biharmonic)           
     

        !Variables category 
        ! Geometry : Volume_Z, DUX_VY (Volume and length of the elevation control volume)
        ! Flow     : Visc_H_Center (Turbulent viscosity in the center of the elevation control volume), 
        !            Velocity_UV_Old (U or V velocity)
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces) 
        ! Direction: Direction (DirectionX=1,DirectionY_=2)
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)

        !Variables direction dependent: 
        ! Horizontal_Transport, DUX_VY, Velocity_UV_Old, ComputeFaces3D_UV, Direction, Kfloor_UV


        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        logical, intent (IN)               :: Biharmonic
                                           
        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_Z_New, Volume_UV
        real,    dimension(:,:,:), pointer :: Visc_H_Center
        real,    dimension(:,:),   pointer :: DUX_VY, DZX_ZY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV

        logical                            :: ConservativeHorDif

        real                               :: FaceFlux_WestSouth, FaceFlux_EastNorth, Aux, ViscAux
    
        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_North, j_East

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin-----------------------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ConservativeHorDif   =  Me%ComputeOptions%ConservativeHorDif

        Visc_H_Center        => Me%External_Var%Visc_H_Center
        
        Horizontal_Transport => Me%Forces%Horizontal_Transport

        ComputeFaces3D_UV      => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV              => Me%External_Var%KFloor_UV
        ImposedNormalFacesUV   => Me%External_Var%ImposedNormalFacesUV

        Volume_Z_New         => Me%External_Var%Volume_Z_New
        DUX_VY               => Me%External_Var%DUX_VY

        DZX_ZY               => Me%External_Var%DZX_ZY
        Volume_UV            => Me%External_Var%Volume_UV

        !End - Shorten variables name 

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyDiffSub_UX_VY")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,i_North,j_East,Kbottom) &
        !$OMP PRIVATE(ViscAux,FaceFlux_WestSouth,Aux,FaceFlux_EastNorth)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB


            iSouth  = i -   di
            jWest   = j -   dj
            i_North  = i +   di
            j_East   = j +   dj


cd0:        if (ComputeFaces3D_UV(i, j, KUB)  == Covered) then 

                   
cd1:            if (ImposedNormalFacesUV(iSouth, jWest, KUB) == Imposed) then

                    Kbottom = KFloor_UV(i, j)
                    
dok1:               do k = Kbottom, KUB

cd2:                    if (BiHarmonic) then
            
                            ViscAux = Me%ComputeOptions%BiHarmonicCoef

                        else  cd2
                        
                            ViscAux = Visc_H_Center( iSouth, jWest, k)

                        endif cd2
             
                    
cd3:                    if (ConservativeHorDif) then 

                            ! West or South Face

                            ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m] * [m^3] / [m]
                            FaceFlux_WestSouth  = ViscAux                            *   & ! Turbulent viscosity
                                                 (Velocity_UV_Old( i, j, k) -            &
                                                 Velocity_UV_Old( iSouth, jWest, k)) / &
                                                 DUX_VY( iSouth, jWest) *              & ! Velocity gradient
                                                 Volume_Z_New( iSouth, jWest, k) /     &
                                                 DUX_VY( iSouth, jWest)                    ! Face Area
                    

                        else cd3
                        
                            ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                            Aux                 = ViscAux                           *    & ! Turbulent viscosity
                                                (Velocity_UV_Old( i, j, k) -             &
                                                Velocity_UV_Old( iSouth, jWest, k)) /  &
                                                DUX_VY( iSouth, jWest)                       ! Velocity gradient

                            !The velocity gradient plus the volume divided by the distance between 
                            !volume faces is equal to compute in a non-conservative way the lapalcian of the 
                            !velocity plus viscosity. The effect of the variable horizontal_transport in the velocity 
                            !is compute dividing the variable horizontal_Transport/VolumeU*DT = Visc * Laplacian(Velocity)
                            !

                            ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_WestSouth  = Aux * Volume_UV(i      , j     , k) /  &
                                                        DZX_ZY   (iSouth, jWest)

                        endif cd3

                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k)   &
                                                       - FaceFlux_WestSouth  
                    enddo dok1

                endif cd1



cd4:            if (ImposedNormalFacesUV(i_North, j_East, KUB) == Imposed) then

                    Kbottom = KFloor_UV(i, j)
                    
dok2:               do k = Kbottom, KUB


cd5:                    if (BiHarmonic) then
            
                            ViscAux = Me%ComputeOptions%BiHarmonicCoef

                        else cd5
                        
                            ViscAux = Visc_H_Center(i, j, k)

                        endif cd5
             
                    
cd6:                    if (ConservativeHorDif) then 

                            ! West or South Face

                            ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m] * [m^3] / [m]
                            FaceFlux_EastNorth  = ViscAux                             *  & ! Turbulent viscosity
                                                 (Velocity_UV_Old(i_North, j_East, k) -  &
                                                 Velocity_UV_Old( i      , j     , k))/  &
                                                 DUX_VY( i, j)                        *  & ! Velocity gradient
                                                 Volume_Z_New( i, j, k) /  DUX_VY( i, j)   ! Face Area
                    

                        else cd6
                        
                            ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                            Aux                 = ViscAux                            *   & ! Turbulent viscosity
                                                 (Velocity_UV_Old(i_North, j_East, k)-   &
                                                  Velocity_UV_Old( i, j, k))         /   & ! Velocity gradient
                                                  DUX_VY(  i, j)                             

                            !The velocity gradient plus the volume divided by the distance between 
                            !volume faces is equal to compute in a non-conservative way the lapalcian of the 
                            !velocity plus viscosity. The effect of the variable horizontal_transport in the velocity 
                            !is compute dividing the variable horizontal_Transport/VolumeU*DT = Visc * Laplacian(Velocity)
                            !

                            ![m^3/s*m/s]        = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_EastNorth  = Aux * Volume_UV(i      , j     , k) /  &
                                                        DZX_ZY   (iSouth, jWest)

                        endif cd6


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k)   &
                                                       + FaceFlux_EastNorth  
                 
                    enddo dok2

                 endif cd4
               

             endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL 

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyDiffSub_UX_VY")
        endif

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (Volume_Z_New        )
        nullify (Visc_H_Center       )
        nullify (DUX_VY              )
        nullify (DZX_ZY              )
        nullify (ComputeFaces3D_UV   )
        nullify (ImposedNormalFacesUV)
        nullify (KFloor_UV           )
        nullify (Volume_UV           )


    End Subroutine ModifyDiffSub_UX_VY

    
        !End ----------------------------------------------------------------------

    Subroutine ModifyDiffSub_UY_VX ( Velocity_UV_Old, Biharmonic)           


        !Arguments--------------------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old 
        logical, intent (IN)               :: Biharmonic


        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_UV
        real,    dimension(:,:,:), pointer :: Area_VU
        real,    dimension(:,:),   pointer :: DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ComputeFaces3D_U, ComputeFaces3D_V
        integer, dimension(:,:,:), pointer :: ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: FaceFlux_SouthWest, FaceFlux_NorthEast

        real                               :: Aux, ViscAux

        logical                            :: ConservativeHorDif
    
        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_West, j_South

        integer                            :: i_North, j_East, i_East, j_North

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin-------------------------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ConservativeHorDif   =  Me%ComputeOptions%ConservativeHorDif
       
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        
        ComputeFaces3D_U         => Me%External_Var%ComputeFaces3D_U
        ComputeFaces3D_V         => Me%External_Var%ComputeFaces3D_V
        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV                => Me%External_Var%KFloor_UV
        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV

        Volume_UV            => Me%External_Var%Volume_UV
        Area_VU              => Me%External_Var%Area_VU
        DYY_XX               => Me%External_Var%DYY_XX

        !End - Shorten variables name 

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyDiffSub_UY_VX")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,i_West,j_South,i_North) &
        !$OMP PRIVATE(j_East,i_East,j_North,Kbottom,ViscAux,FaceFlux_SouthWest) &
        !$OMP PRIVATE(Aux,FaceFlux_NorthEast)
        
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i - di
            jWest   = j - dj

            i_West   = i - dj
            j_South  = j - di

            i_North  = i + di
            j_East   = j + dj

            i_East   = i + dj
            j_North  = j + di


cd0:        if (ComputeFaces3D_UV(i, j, KUB) == Covered) then 

cd1:            if (ImposedTangentialFacesUV(i_West, j_South, KUB) == Imposed) then

                    Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_West, j_South))

           dok1:    do k = Kbottom, KUB
                    

                       ! West or South Face


cd2:                    if (BiHarmonic) then
                    
                            ViscAux = Me%ComputeOptions%BiHarmonicCoef

                        else cd2
                    
                            ViscAux = Me%External_Var%Visc_H_Corner(i, j, k)

                        endif cd2
                        
                                        
cd3:                    if (ConservativeHorDif) then 

                            ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m]  * [m^2] 
                            FaceFlux_SouthWest = ViscAux               *                 & ! Turbulent viscosity
                                            (Velocity_UV_Old(i, j, k) -                  &
                                             Velocity_UV_Old(i_West, j_South, k)) /      &
                                            (DYY_XX(i_West, j_South) +                   &
                                             DYY_XX( i, j)) *                            & ! half of the Velocity gradient
                                            (Area_VU(iSouth, jWest, k) +               &
                                             Area_VU(i      , j     , k))             ! double of the Face Area


                        else cd3
                    
               
                            ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                            Aux = ViscAux                *                               &  ! Turbulent viscosity
                                 (Velocity_UV_Old(i, j, k) -                             &
                                  Velocity_UV_Old(i_West, j_South, k)) /                 &
                                 (DYY_XX(i_West, j_South) +                              &
                                  DYY_XX( i, j)) * 2                        ! Velocity gradient

                            ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_SouthWest  = Aux  *                                 &
                                                  Volume_UV   (i     , j, k) /           &  ! Area
                                                  DYY_XX      (i     , j   )
                              
                        endif cd3


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k)   &
                                                       - FaceFlux_SouthWest

                    enddo dok1

                endif cd1


cd4:            if (ImposedTangentialFacesUV(i_East, j_North, KUB) == Imposed) then

                    Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_East, j_North))

           dok2:    do k = Kbottom, KUB
                    

                       ! East or North Face


cd5:                    if (BiHarmonic) then
                    
                            ViscAux = Me%ComputeOptions%BiHarmonicCoef

                        else cd5
                    
                            ViscAux = Me%External_Var%Visc_H_Corner(i_East, j_North, k)

                        endif cd5
                        
                                        
cd6:                    if (ConservativeHorDif) then 

                            ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m]  * [m^2] 
                            FaceFlux_NorthEast = ViscAux               *            & ! Turbulent viscosity
                                            (Velocity_UV_Old(i_East, j_North, k) -             &
                                             Velocity_UV_Old(i, j, k)) / &
                                            (DYY_XX(i_East, j_North) +              &
                                             DYY_XX( i, j)) *                       & ! half of the Velocity gradient
                                            (Area_VU(i_East     , j_North    , k) + &
                                             Area_VU(i - di + dj, j - dj + di, k))                        ! double of the Face Area


                        else cd6
                    
               
                            ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                            Aux = ViscAux                *                                   &  ! Turbulent viscosity
                                 (Velocity_UV_Old(i_East, j_North, k) -                                 &
                                  Velocity_UV_Old(i     , j      , k)) /                     &
                                 (DYY_XX(i_East, j_North) +                                  &
                                  DYY_XX( i, j)) * 2                        ! Velocity gradient

                            ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_NorthEast  = Aux  *                                     &
                                                  Volume_UV   (i     , j, k) /               &  ! Area
                                                  DYY_XX      (i     , j   )
                    
                        endif cd6


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k)       &
                                                       + FaceFlux_NorthEast

                    enddo dok2

                endif cd4


            endif cd0 

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyDiffSub_UY_VX")
        endif

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (Area_VU)
        nullify (DYY_XX)
        nullify (ComputeFaces3D_UV)
        nullify (ComputeFaces3D_U)
        nullify (ComputeFaces3D_V)
        nullify (KFloor_UV)
        nullify (ImposedTangentialFacesUV)
        nullify (Volume_UV)


    End Subroutine ModifyDiffSub_UY_VX

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the Laplacian                                               !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine LaplacianXY( Velocity_UV_Old, Aux_UX_VY) 
     

        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old, Aux_UX_VY
                                            
        !Local-----------------------------------------------------------------------------
        real,    dimension(:,:),   pointer :: DUX_VY, DZX_ZY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: Aux1, Aux2
    
        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_North, j_East

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin-----------------------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV             => Me%External_Var%KFloor_UV

        DUX_VY               => Me%External_Var%DUX_VY

        DZX_ZY               => Me%External_Var%DZX_ZY

        !End - Shorten variables name 

        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "LaplacianXY")
        endif
        
        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,i_North,j_East,Kbottom) &
        !$OMP PRIVATE(Aux1,Aux2)
        
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB


            iSouth  = i -   di
            jWest   = j -   dj
            i_North  = i +   di
            j_East   = j +   dj


cd0:        if (ComputeFaces3D_UV(i, j, KUB)            == Covered ) then 

                Kbottom = KFloor_UV(i, j)

dok1:           do k = Kbottom, KUB
             
                    
                    ! West or South Face
                    if (ComputeFaces3D_UV(iSouth, jWest, k) == Covered ) then
                        ![s^-1] = [m/s] / [m]
                        Aux1 =(Velocity_UV_Old( i      , j     , k) -                        &
                               Velocity_UV_Old( iSouth, jWest, k)) /                       &
                               DUX_VY( iSouth, jWest)                   
                    else

                        Aux1 = 0

                    endif 
                

                    ! East or North Face
                    if (ComputeFaces3D_UV(i_North, j_East, k) == Covered ) then

                        Aux2 =(Velocity_UV_Old( i_North, j_East, k) -                    &
                               Velocity_UV_Old( i      , j     , k)) /                   &
                               DUX_VY( i, j)                   

                    else

                        Aux2 = 0.

                    endif

                    Aux_UX_VY(i, j, k) = - (Aux2 - Aux1) / DZX_ZY( iSouth, jWest)

                 enddo dok1

             endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "LaplacianXY")
        endif

        !Nullify auxiliar pointers
        nullify (DUX_VY              )
        nullify (DZX_ZY              )
        nullify (ComputeFaces3D_UV   )
        nullify (KFloor_UV           )


    End Subroutine LaplacianXY

    
        !End ----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal diffusion perpendicular to the               !
    !  velocity. For the U velocity compute the diffusion with the Y direction             !       
    !  for the V velocity compute the diffusion with the X direction                       !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine LaplacianYX ( Velocity_UV_Old, Aux_UY_VX) 
     

        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old, Aux_UY_VX
                                            

        !Local-----------------------------------------------------------------------------
        real,    dimension(:,:),   pointer :: DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: Aux1, Aux2

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: i_West, j_South, i_East, j_North

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin-------------------------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj


        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        DYY_XX               => Me%External_Var%DYY_XX

        !End - Shorten variables name 

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "LaplacianYX")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,i_West,i_East,j_South,j_North,Kbottom) &
        !$OMP PRIVATE(Aux1,Aux2)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            i_West   = i - dj
            i_East   = i + dj

            j_South  = j - di
            j_North  = j + di

cd0:        if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

                Kbottom = KFloor_UV(i, j)
                    

       dok1:        do k = Kbottom, KUB
                    
                        
                        ! West or South Face
                        if (ComputeFaces3D_UV(i_West, j_South, k) == Covered) then 

                            ![s^-1] = [m/s] / [m]
                            Aux1 =(Velocity_UV_Old( i      , j     , k) -                &
                                   Velocity_UV_Old( i_West , j_South, k))* 2 /           &
                                   (DYY_XX(i_West, j_South) +  DYY_XX( i, j))     

                        else

                            Aux1 = 0.

                        endif

                        ! East or North Face
                        if (ComputeFaces3D_UV(i_East, j_North, k) == Covered) then 
                
                            Aux2 =(Velocity_UV_Old( i_East, j_North, k) -                &
                                   Velocity_UV_Old( i      , j     , k)) * 2 /           &
                                   (DYY_XX(i_East, j_North) +  DYY_XX( i, j))

                        else

                            Aux2 = 0

                        endif

                        Aux_UY_VX(i, j, k) = - (Aux2 - Aux1) / DYY_XX( i, j)

                            
                    enddo dok1
                    

            endif cd0 

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "LaplacianYX")
        endif

        !Nullify auxiliar pointers
        nullify (DYY_XX)
        nullify (ComputeFaces3D_UV)
        nullify (KFloor_UV)


    End Subroutine LaplacianYX


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the effect of volume variation in the velocity time         !
    !  variation.                                                                          !
    !                                                                                      !
    ! Input : Flow, Mapping,                                                               !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ModifyVolumeVariation  
      

        !Arguments------------------------------------------------------------
         


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_Z_Old, Volume_UV
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old 

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real(8)                            :: VolumeVariation, VolumeUVOld

        real                               :: DT_Velocity

        integer                            :: i, j, k, Kbottom, di, dj, iSouth, jWest

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity = Me%Velocity%DT

        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        Volume_Z_Old         => Me%External_Var%Volume_Z_Old
        Volume_UV            => Me%External_Var%Volume_UV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV


        !End - Shorten variables name 

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyVolumeVariation")
        endif
        
        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,Kbottom,VolumeUVOld) &
        !$OMP PRIVATE(VolumeVariation)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

    cd1:    if (ComputeFaces3D_UV(i, j, KUB) == Covered) then 

                iSouth  = i - di
                jWest   = j - dj

                Kbottom = KFloor_UV(i, j)

        dok1:   do k = Kbottom, KUB

                    VolumeUVOld                   = (Volume_Z_Old(iSouth, jWest, k)  + &
                                                     Volume_Z_Old(i, j, k) ) / 2. 

                    ![m/s*m^3/s]                  = [m^3] * [m/s] / [s] 
                    VolumeVariation               = (VolumeUVOld - Volume_UV(i, j, k)) * & 
                                                    dble(Velocity_UV_Old(i, j, k))     / &
                                                    dble(DT_Velocity)

                    Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k)      + &
                                                    VolumeVariation                       

                enddo dok1

            endif cd1

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyVolumeVariation")
        endif

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (Volume_UV)
        nullify (Volume_Z_Old)
        nullify (Velocity_UV_Old)
        nullify (ComputeFaces3D_UV)
        nullify (KFloor_UV)

    End Subroutine ModifyVolumeVariation

    
    !End ----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the effect of momentum discharges in the velocity time      !
    !  variation.                                                                          !
    !                                                                                      !
    ! Input : Flow, Mapping,                                                               !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ModifyMomentumDischarge 
      

        !Arguments------------------------------------------------------------
         


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old, DUZ_VZ
        real,    dimension(:,:  ), pointer :: Bathymetry, WaterColumnUV
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:  ), pointer :: KFloor_UV
        real,    dimension(:    ), pointer :: DistributionCoef
        real(8)                            :: MomentumDischarge
        real                               :: DischargeFlow, DischargeVelocity, AuxFlowK, AuxFlowIJ, SectionHeight
        real                               :: WaterLevelByPass !, Depth
        real                               :: CoordinateX, CoordinateY

        integer                            :: DirectionXY, DischargesNumber, DischargeID
        integer                            :: i, j, k, kd, kmin, kmax, di, dj, STAT_CALL, iNorth, jEast, KUB, n
        integer                            :: ib, jb !, kbottom, k1
        integer                            :: n_i, n_j, n_iNorth, n_jEast 

        integer                            :: FlowDistribution, nCells, nCellsAux
        integer, dimension(:    ), pointer :: VectorI, VectorJ, VectorK

        logical                            :: ByPassON, IgnoreOK, CoordinatesON

        integer                            :: DischVertical
        
        integer                            :: CHUNK
        
        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        DirectionXY = Me%Direction%XY
        KUB         = Me%WorkSize%KUB

        Horizontal_Transport => Me%Forces%Horizontal_Transport
        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old
        KFloor_UV            => Me%External_Var%KFloor_UV
        WaterColumnUV        => Me%External_Var%WaterColumnUV 
        DUZ_VZ               => Me%External_Var%DUZ_VZ



        !End - Shorten variables name 
        call GetDischargesNumber(Me%ObjDischarges, DischargesNumber, STAT = STAT_CALL)
        if (STAT_CALL/=SUCCESS_)stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR10'
             

        !Gets a pointer to Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR20'

do1:    do DischargeID = 1, DischargesNumber

            call GetDischargeON(Me%ObjDischarges,DischargeID, IgnoreOK, STAT = STAT_CALL)   
            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR25'

            if (IgnoreOK) cycle

            call GetDischargesGridLocalization(Me%ObjDischarges,                        &
                                               DischargeID,                             &
                                               Igrid         = I,                       &
                                               JGrid         = J,                       &
                                               KGrid         = kd,                      &
                                               IByPass       = Ib,                      &
                                               JByPass       = Jb,                      &
                                               DischVertical = DischVertical,           &
                                               WaterColumnZ  = Me%External_Var%Watercolumn,&
                                               Bathymetry    = Bathymetry,              &
                                               OpenPoints3D  = Me%External_Var%OpenPoints3D,&
                                               CoordinateX   = CoordinateX,             &
                                               CoordinateY   = CoordinateY,             & 
                                               CoordinatesON = CoordinatesON,           &
                                               TimeX         = Me%CurrentTime,          &
                                               STAT = STAT_CALL)   

            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR30'
        
            if (CoordinatesON) then
                call GetXYCellZ(Me%ObjHorizontalGrid, CoordinateX, CoordinateY, I, J, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR40'

                call CorrectsCellsDischarges(Me%ObjDischarges, DischargeID, I, J, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR45'                
            endif                   


            !Check if this is a bypass discharge. If it is gives the water level of the bypass end cell
            call GetByPassON(Me%ObjDischarges, DischargeID, ByPassON, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR50'

            if (ByPassON) then
                WaterLevelByPass = Me%WaterLevel%Old(ib, jb)
            else
                WaterLevelByPass = FillValueReal
            endif

            call GetDischargeWaterFlow(Me%ObjDischarges,                    &
                                       Me%CurrentTime, DischargeID,         &
                                       Me%WaterLevel%Old(I, J),             &
                                       DischargeFlow,                       &
                                       SurfaceElevation2 = WaterLevelByPass,&
                                       STAT = STAT_CALL)             

            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR60'

            if (DirectionXY == DirectionX_) then
                
                call GetDischargeFlowVelocity(Me%ObjDischarges,                 &
                                           Me%CurrentTime, DischargeID,         &
                                           VelocityU = DischargeVelocity, STAT = STAT_CALL)             

            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR70'

            else if (DirectionXY == DirectionY_) then


                call GetDischargeFlowVelocity(Me%ObjDischarges,                 &
                                           Me%CurrentTime, DischargeID,         &
                                           VelocityV = DischargeVelocity, STAT = STAT_CALL)             

                if (STAT_CALL/=SUCCESS_)                                                     &
                    stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR80'

            endif


            di  = Me%Direction%di
            dj  = Me%Direction%dj


            call GetDischargeFlowDistribuiton(Me%ObjDischarges, DischargeID, nCells, FlowDistribution, &
                                              VectorI, VectorJ, VectorK, kmin, kmax, STAT = STAT_CALL)             

            if (STAT_CALL/=SUCCESS_)                                                     &
                stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR90'


i1:         if (nCells > 1) then
                allocate(DistributionCoef(1:nCells))
i2:             if      (FlowDistribution == DischByCell_       ) then
                    
                    nCellsAux = 0
                    do n = 1, nCells
                        n_i      = VectorI(n)
                        n_j      = VectorJ(n)
                        n_iNorth = n_i+di
                        n_jEast  = n_j+dj

                        if (ComputeFaces3D_UV(n_i,      n_j,     KUB) == Covered .or. &
                            ComputeFaces3D_UV(n_iNorth, n_jEast, KUB) == Covered) then
                            nCellsAux = nCellsAux + 1
                        endif
                    enddo
                    
                    if (nCellsAux > 0) then
                        DistributionCoef(1:nCells) = 1./float(nCellsAux)
                    else
                        DistributionCoef(1:nCells) = FillValueReal
                    endif

                else i2
                    
                    stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR100'

                endif i2
            endif i1

            AuxFlowIJ = abs(DischargeFlow)

            CHUNK = CHUNK_K(kmin,kmax)
                
            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "ModifyMomentumDischarge")
            endif
            

            if (Me%OutPut%TimeSerieDischON) then
                if (dj==1) then
                    Me%OutPut%TimeSerieDischProp(DischargeID,2) = 0.
                else
                    Me%OutPut%TimeSerieDischProp(DischargeID,3) = 0.
                endif                    
            endif
 
                
            !$OMP PARALLEL PRIVATE(k,AuxFlowK,MomentumDischarge,SectionHeight)
            
dn:         do n=1, nCells
                !$OMP MASTER
                if (nCells > 1) then
                    i         = VectorI(n)
                    j         = VectorJ(n)
                    kd        = VectorK(n)

                    call GetDischargeWaterFlow(Me%ObjDischarges,                        &
                                               Me%CurrentTime, DischargeID,             &
                                               Me%WaterLevel%Old(I, J),                 &
                                               AuxFlowIJ,                               &
                                               SurfaceElevation2 = WaterLevelByPass,    &    
                                               FlowDistribution  = DistributionCoef(n), &                                      
                                               STAT              = STAT_CALL)     

                    if (STAT_CALL/=SUCCESS_)                                            &
                        stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR95'

                endif

                iNorth = i+di
                jEast =  j+dj

                if (DischVertical == DischUniform_) then
                
                    if (kmin == FillValueInt) then
                        if      (ComputeFaces3D_UV(i     , j    , KUB) == Covered) then
                            kmin = KFloor_UV(i     , j    )
                        else if (ComputeFaces3D_UV(iNorth, jEast, KUB) == Covered) then
                            kmin = KFloor_UV(iNorth, jEast)
                        else 
                            kmin  = KUB                        
                        endif                    
                    endif
                    
                    if (kmax == FillValueInt) kmax = KUB
                    
                    SectionHeight = 0                    
                    if      (ComputeFaces3D_UV(i     , j    , KUB) == Covered) then                                            
                        do k=kmin, kmax                            
                            SectionHeight = SectionHeight + DUZ_VZ(i,j,k)                        
                        enddo                    
                    else if (ComputeFaces3D_UV(iNorth, jEast, KUB) == Covered) then
                        do k=kmin, kmax                            
                            SectionHeight = SectionHeight + DUZ_VZ(iNorth, jEast,k)                        
                        enddo                    
                    endif                                    
                else
            
                    kmin = kd; kmax = kd

                endif

                MomentumDischarge = 0.
                !$OMP END MASTER
                !$OMP BARRIER
                
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
dk:             do k = kmin,kmax

                    AuxFlowK = AuxFlowIJ

                    if (ComputeFaces3D_UV(i, j, k) == Covered) then

                        if (DischVertical == DischUniform_) AuxFlowK = DUZ_VZ(i,j,k) / SectionHeight * AuxFlowIJ

                        ![m/s*m^3/s]                  = [m^3] * [m/s] / [s] 
                        if (DischargeFlow >= 0.) then

                            MomentumDischarge  = AuxFlowK * DischargeVelocity
                            
                            Me%WaterFluxes%DischargesVelUV(iNorth, jEast, k) = DischargeVelocity
                            
                        else

                            MomentumDischarge  = AuxFlowK * Velocity_UV_Old(i, j, k)
                            
                            Me%WaterFluxes%DischargesVelUV(iNorth, jEast, k) = Velocity_UV_Old(i, j, k)
            
                        endif 


                        Horizontal_Transport(i     , j    , k) =                                 &
                            Horizontal_Transport(i     , j    , k)   +   MomentumDischarge                       

                    else if (ComputeFaces3D_UV(iNorth, jEast, k) == Covered) then

                        if (DischVertical == DischUniform_)                                      &
                                    AuxFlowK = DUZ_VZ(iNorth, jEast,k) / SectionHeight * AuxFlowIJ

                        ![m/s*m^3/s]                  = [m^3] * [m/s] / [s] 
                        if (DischargeFlow >= 0.) then

                            MomentumDischarge  = AuxFlowK * DischargeVelocity 
                            
                            Me%WaterFluxes%DischargesVelUV(i, j, k) = DischargeVelocity
                            
                        else

                            MomentumDischarge  = AuxFlowK * Velocity_UV_Old(iNorth, jEast, k)
                            
                            Me%WaterFluxes%DischargesVelUV(i, j, k) = Velocity_UV_Old(iNorth, jEast, k)
                            
                        endif 

                        Horizontal_Transport(iNorth, jEast, k) =                                 &
                            Horizontal_Transport(iNorth, jEast, k)   +   MomentumDischarge   
                            
                            
                    else if (abs(MomentumDischarge) > AllmostZero) then
                        !!! $OMP CRITICAL (MMD1_WARN01)
                        write(*,*) 'WARNING_ - The Model is trying to discharge Momentum in a No Compute Face'
                        write(*,*) 'WARNING_ - ModifyMomentumDischarge - ModuleHydrodynamic - WARN01'
                        !!! $OMP END CRITICAL (MMD1_WARN01)
                    endif 
                    
                    if (Me%OutPut%TimeSerieDischON) then
                        if (dj==1) then
                            Me%OutPut%TimeSerieDischProp(DischargeID,2) = Me%OutPut%TimeSerieDischProp(DischargeID,2) + &
                                                                          MomentumDischarge
                        else
                            Me%OutPut%TimeSerieDischProp(DischargeID,3) = Me%OutPut%TimeSerieDischProp(DischargeID,3) + &
                                                                          MomentumDischarge
                        endif                    
                    endif                    

                enddo dk
                !$OMP END DO

            enddo dn
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "ModifyMomentumDischarge")
            endif
            
            if (Me%OutPut%TimeSerieDischON) then
                if (dj==1) then
                    if (Me%OutPut%TimeSerieDischProp(DischargeID,1) /=0) then
                        Me%OutPut%TimeSerieDischProp(DischargeID,2) = Me%OutPut%TimeSerieDischProp(DischargeID,2)/ &
                                                                      Me%OutPut%TimeSerieDischProp(DischargeID,1)
                    else
                        Me%OutPut%TimeSerieDischProp(DischargeID,2) = 0.
                    endif                                                                       
                else
                   if (Me%OutPut%TimeSerieDischProp(DischargeID,1) /=0) then
                        Me%OutPut%TimeSerieDischProp(DischargeID,3) = Me%OutPut%TimeSerieDischProp(DischargeID,3)/ &
                                                                      Me%OutPut%TimeSerieDischProp(DischargeID,1)
                    else
                        Me%OutPut%TimeSerieDischProp(DischargeID,3) = 0.
                    endif   
                endif                    
            endif            

            if (nCells>1) deallocate(DistributionCoef)

            call UnGetDischarges(Me%ObjDischarges, VectorI, STAT = STAT_CALL)             
            if (STAT_CALL/=SUCCESS_)                                                    &
                stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR110'

            call UnGetDischarges(Me%ObjDischarges, VectorJ, STAT = STAT_CALL)             
            if (STAT_CALL/=SUCCESS_)                                                    &
                stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR120'

            call UnGetDischarges(Me%ObjDischarges, VectorK, STAT = STAT_CALL)             
            if (STAT_CALL/=SUCCESS_)                                                    &
                stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR130'

        enddo do1

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (ComputeFaces3D_UV   )
        nullify (Velocity_UV_Old     )
        nullify (KFloor_UV           )
        nullify (WaterColumnUV       )
        nullify (DUZ_VZ              )


        !Disposes pointer to the Bathymetry
        call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR140'


    End Subroutine ModifyMomentumDischarge

    
    !End ----------------------------------------------------------------------


Subroutine ModifyMomentumDischargeVert 
      

        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_W, DWZ
        real,    dimension(:,:  ), pointer :: Bathymetry, WaterColumnZ
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_W
        integer, dimension(:,:  ), pointer :: KFloor_Z
        real,    dimension(:    ), pointer :: DistributionCoef
        real(8)                            :: MomentumDischarge
        real                               :: DischargeFlow, DischargeVelocity, AuxFlowK, AuxFlowIJ, SectionHeight
        real                               :: WaterLevelByPass, CoordinateX, CoordinateY
        
        integer                            :: DischargesNumber, DischargeID
        integer                            :: i, j, k, kd, kmin, kmax, STAT_CALL, KUB, n
        integer                            :: ib, jb !, kbottom, k1
        integer                            :: n_i, n_j

        integer                            :: FlowDistribution, nCells, nCellsAux
        integer, dimension(:    ), pointer :: VectorI, VectorJ, VectorK

        logical                            :: ByPassON, IgnoreOK, CoordinatesON

        integer                            :: DischVertical
        
        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name 

        KUB         = Me%WorkSize%KUB

        ComputeFaces3D_W     => Me%External_Var%ComputeFaces3D_W
        Velocity_W           => Me%Velocity%Vertical%Cartesian
        KFloor_Z             => Me%External_Var%KFloor_Z
        WaterColumnZ         => Me%External_Var%WaterColumn
        DWZ                  => Me%External_Var%DWZ

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyMomentumDischargeVert")
        endif     


        !End - Shorten variables name 
        call GetDischargesNumber(Me%ObjDischarges, DischargesNumber, STAT = STAT_CALL)
        if (STAT_CALL/=SUCCESS_)stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR10'
             

        !Gets a pointer to Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR20'

do1:    do DischargeID = 1, DischargesNumber

            call GetDischargeON(Me%ObjDischarges,DischargeID, IgnoreOK, STAT = STAT_CALL)   
            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR25'

            if (IgnoreOK) cycle

            call GetDischargesGridLocalization(Me%ObjDischarges,                        &
                                               DischargeID,                             &
                                               Igrid         = I,                       &
                                               JGrid         = J,                       &
                                               KGrid         = kd,                      &
                                               IByPass       = Ib,                      &
                                               JByPass       = Jb,                      &
                                               DischVertical = DischVertical,           &
                                               WaterColumnZ  = WaterColumnZ,            &
                                               Bathymetry    = Bathymetry,              &
                                               OpenPoints3D  = Me%External_Var%OpenPoints3D,&
                                               CoordinateX   = CoordinateX,             &
                                               CoordinateY   = CoordinateY,             & 
                                               CoordinatesON = CoordinatesON,           &
                                               TimeX         = Me%CurrentTime,          &
                                               STAT = STAT_CALL)   

            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR30'


            if (CoordinatesON) then
                call GetXYCellZ(Me%ObjHorizontalGrid, CoordinateX, CoordinateY, I, J, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR40'

                call CorrectsCellsDischarges(Me%ObjDischarges, DischargeID, I, J, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR45'                
            endif            

            !Check if this is a bypass discharge. If it is gives the water level of the bypass end cell
            call GetByPassON(Me%ObjDischarges, DischargeID, ByPassON, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR50'

            if (ByPassON) then
                WaterLevelByPass = Me%WaterLevel%Old(ib, jb)
            else
                WaterLevelByPass = FillValueReal
            endif

            call GetDischargeWaterFlow(Me%ObjDischarges,                    &
                                       Me%CurrentTime, DischargeID,         &
                                       Me%WaterLevel%Old(I, J),             &
                                       DischargeFlow,                       &
                                       SurfaceElevation2 = WaterLevelByPass,&
                                       STAT = STAT_CALL)             

            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR60'

            call GetDischargeFlowVelocity(Me%ObjDischarges,                 &
                                       Me%CurrentTime, DischargeID,         &
                                       VelocityW = DischargeVelocity, STAT = STAT_CALL)             

            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR70'



            call GetDischargeFlowDistribuiton(Me%ObjDischarges, DischargeID, nCells, FlowDistribution, &
                                              VectorI, VectorJ, VectorK, kmin, kmax, STAT = STAT_CALL)             

            if (STAT_CALL/=SUCCESS_)                                                     &
                stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR90'


i1:         if (nCells > 1) then
                allocate(DistributionCoef(1:nCells))
i2:             if      (FlowDistribution == DischByCell_       ) then
                    
                    nCellsAux = 0
                    do n = 1, nCells
                        n_i      = VectorI(n)
                        n_j      = VectorJ(n)

                        if (ComputeFaces3D_W(n_i,      n_j,     KUB) == Covered) then
                            nCellsAux = nCellsAux + 1
                        endif
                    enddo
                    
                    if (nCellsAux > 0) then
                        DistributionCoef(1:nCells) = 1./float(nCellsAux)
                    else
                        DistributionCoef(1:nCells) = FillValueReal
                    endif

                else i2
                    
                    stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR100'

                endif i2
            endif i1

            AuxFlowIJ = abs(DischargeFlow)

            if (Me%OutPut%TimeSerieDischON) then
                Me%OutPut%TimeSerieDischProp(DischargeID,4) = 0.
            endif
        
dn:         do n=1, nCells

                if (nCells > 1) then
                    i         = VectorI(n)
                    j         = VectorJ(n)
                    kd        = VectorK(n)

                    call GetDischargeWaterFlow(Me%ObjDischarges,                        &
                                               Me%CurrentTime, DischargeID,             &
                                               Me%WaterLevel%Old(I, J),                 &
                                               AuxFlowIJ,                               &
                                               SurfaceElevation2 = WaterLevelByPass,    &    
                                               FlowDistribution  = DistributionCoef(n), &                                      
                                               STAT              = STAT_CALL)     

                    if (STAT_CALL/=SUCCESS_)                                            &
                        stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR95'

                endif

                if (DischVertical == DischUniform_) then
                
                    if (kmin == FillValueInt) kmin = KFloor_Z(i, j)

                    if (kmax == FillValueInt) kmax = KUB
                    
                    SectionHeight = 0     

                    do k=kmin, kmax                            
                        SectionHeight = SectionHeight + DWZ(i,j,k)                        
                    enddo                    
                                 
                else
            
                    kmin = kd; kmax = kd

                endif

                MomentumDischarge = 0.

dk:             do k = kmin,kmax

                    AuxFlowK = AuxFlowIJ

                    if (ComputeFaces3D_W(i, j, k) == Covered) then

                        if (DischVertical == DischUniform_) AuxFlowK = DWZ(i,j,k) / SectionHeight * AuxFlowIJ

                        ![m/s*m^3/s]                  = [m^3] * [m/s] / [s] 
                        ! if (DischargeFlow >= 0.) then

                            MomentumDischarge  = AuxFlowK * DischargeVelocity
                            
                            Me%WaterFluxes%DischargesVelUV(i, j, k) = DischargeVelocity
                            
                       ! else

                         !   MomentumDischarge  = AuxFlowK * Velocity_W(i, j, k)
                            
                         !   Me%WaterFluxes%DischargesVelUV(i, j, k) = Velocity_W(i, j, k)
            
                        !endif 

                        Me%Coef%D3%Ti (i, j, k) = Me%Coef%D3%Ti (i, j, k) + MomentumDischarge                       

                            
                    else if (abs(MomentumDischarge) > AllmostZero) then
                        write(*,*) 'WARNING_ - The Model is trying to discharge Momentum in a No Compute Face'
                        write(*,*) 'WARNING_ - ModifyMomentumDischargeVert - ModuleHydrodynamic - WARN01'
                    endif 
                    
                    if (Me%OutPut%TimeSerieDischON) then
                        Me%OutPut%TimeSerieDischProp(DischargeID,4) = Me%OutPut%TimeSerieDischProp(DischargeID,4) + &
                                                                      MomentumDischarge
                 
                    endif                    

                enddo dk

            enddo dn

            
            if (Me%OutPut%TimeSerieDischON) then
               if (Me%OutPut%TimeSerieDischProp(DischargeID,1) /=0) then
                    Me%OutPut%TimeSerieDischProp(DischargeID,4) = Me%OutPut%TimeSerieDischProp(DischargeID,4)/ &
                                                                  Me%OutPut%TimeSerieDischProp(DischargeID,1)
                else
                    Me%OutPut%TimeSerieDischProp(DischargeID,4) = 0.
                endif   
            endif            

            if (nCells>1) deallocate(DistributionCoef)

            call UnGetDischarges(Me%ObjDischarges, VectorI, STAT = STAT_CALL)             
            if (STAT_CALL/=SUCCESS_)                                                    &
                stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR110'

            call UnGetDischarges(Me%ObjDischarges, VectorJ, STAT = STAT_CALL)             
            if (STAT_CALL/=SUCCESS_)                                                    &
                stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR120'

            call UnGetDischarges(Me%ObjDischarges, VectorK, STAT = STAT_CALL)             
            if (STAT_CALL/=SUCCESS_)                                                    &
                stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR130'

        enddo do1
        
        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyMomentumDischargeVert")
        endif        

        !Nullify auxiliar pointers
        nullify (ComputeFaces3D_W    )
        nullify (Velocity_W          )
        nullify (KFloor_Z            )
        nullify (WaterColumnZ        )
        nullify (DWZ                 )


        !Disposes pointer to the Bathymetry
        call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR140'


    End Subroutine ModifyMomentumDischargeVert

    
    !End ----------------------------------------------------------------------


    subroutine Modify_ScraperEffect
        
        !Local---------------------------------------------------------------------
        real                                :: VelScraper
        integer                             :: IUB, ILB, JUB, JLB, KUB, KLB, kbottom
        integer                             :: di, dj, i, j, k, STAT_CALL
        !$ integer                          :: CHUNK

        !Begin---------------------------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_ScraperEffect")
        endif

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj
        
        if (Me%Scraper%ID_U%SolutionFromFile .and. dj == 1) then

            call ModifyFillMatrix(FillMatrixID      = Me%Scraper%ID_U%ObjFillMatrix,        &
                                  Matrix3D          = Me%Scraper%VelU,                      &
                                  PointsToFill3D    = Me%External_Var%WaterPoints3D,        &
                                  STAT              = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_) stop 'Modify_ScraperEffect - ModuleHydrodynamic - ERR10'

        endif
                
        if (Me%Scraper%ID_V%SolutionFromFile .and. dj == 0) then

            call ModifyFillMatrix(FillMatrixID      = Me%Scraper%ID_V%ObjFillMatrix,        &
                                  Matrix3D          = Me%Scraper%VelV,                      &
                                  PointsToFill3D    = Me%External_Var%WaterPoints3D,        &
                                  STAT              = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_) stop 'Modify_ScraperEffect - ModuleHydrodynamic - ERR20'

        endif

        
        if(.not.(associated(Me%Forces%Scraper_Aceleration))) then

                allocate(Me%Forces%Scraper_Aceleration(Me%Size%ILB:Me%Size%IUB,         &
                                              Me%Size%JLB:Me%Size%JUB,                  &
                                              Me%Size%KLB:Me%Size%KUB))
                
        endif     
        
        Me%Forces%Scraper_Aceleration(:,:,:) = 0.                             
        
        Me%Scraper%Position(:,:,:) = Me%External_Var%WaterPoints3D(:,:,:)
        

        !$ CHUNK = CHUNK_J(JLB, JUB)

        !griflet: new simple parallelization
        !$OMP PARALLEL PRIVATE(i,j,k,kbottom)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do j = JLB, JUB
do2:    do i = ILB, IUB

            if (Me%External_Var%WaterPoints3D(I, J, KUB) == WaterPoint) then 

                kbottom = Me%External_Var%KFloor_Z(I, J)
                
do3:            do k = kbottom, KUB

                        if (Me%Scraper%VelU(i, j  , k) > Me%Scraper%VelLimit) then
                            Me%Scraper%Position(i,j,k) = 0
                        endif                            

                        if (Me%Scraper%VelV(i,   j, k) > Me%Scraper%VelLimit) then
                            Me%Scraper%Position(i,j,k) = 0
                        endif
                    
                enddo do3

            endif

        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        !$ CHUNK = CHUNK_J(JLB, JUB)

        !griflet: new simple parallelization
        !$OMP PARALLEL PRIVATE(i,j,k,kbottom,VelScraper)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do4:    do j = JLB, JUB
do5:    do i = ILB, IUB


            if (Me%External_Var%ComputeFaces3D_UV(I, J, KUB) == Covered) then 


                kbottom = Me%External_Var%KFloor_UV(I, J)
                
do6:            do k = kbottom, KUB

                    if (dj == 1) then
                        VelScraper = Me%Scraper%VelU(i, j, k)
                    else                        
                        VelScraper = Me%Scraper%VelV(i, j, k)
                    endif
                    
                    if (VelScraper > Me%Scraper%VelLimit) then
                    
                        ![m/s2]              =    [m/s] / [s]
                        Me%Forces%Scraper_Aceleration(i, j, k) =                        &
                            (VelScraper - Me%Velocity%Horizontal%UV%New(I,J,K)) / Me%Scraper%TimeScale

                    endif
                    
                enddo do6

            endif

        enddo do5
        enddo do4
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL
        

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_ScraperEffect")
        endif

    end subroutine Modify_ScraperEffect  

    !End ----------------------------------------------------------------------

    subroutine ModifyThinWallsDissipation
        
        !Local---------------------------------------------------------------------
        real                                :: CurrentWLGrad, AuxWLGrad 
        integer                             :: di, dj, i, j, k, n, nFaces
        logical                             :: ComputeDissipation
        

        !Begin---------------------------------------------------------------------
        ! If the thinwalls are variable in time and are in open Mode
        if (Me%ThinWalls%CloseFlag == 0) then
        
            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "ModifyThinWallsDissipation")
            endif

            di  = Me%Direction%di
            dj  = Me%Direction%dj
            
            Me%Forces%ThinWalls_Dissipation(:,:,:) = 0.
            
            ComputeDissipation = .false.
            
            if (dj == 1) then 
                if (Me%ThinWalls%UOn) then
                    nFaces = Me%ThinWalls%nU
                    ComputeDissipation = .true.
                endif                    
            else
                if (Me%ThinWalls%VOn) then
                    nFaces = Me%ThinWalls%nV
                    ComputeDissipation = .true.
                endif   
            endif
            
            if (ComputeDissipation) then
     
                do n=1, nFaces

                    if (dj == 1) then
                        i = Me%ThinWalls%FaceU_I(n)
                        j = Me%ThinWalls%FaceU_J(n)
                        k = Me%ThinWalls%FaceU_K(n)
                    else
                        i = Me%ThinWalls%FaceV_I(n)
                        j = Me%ThinWalls%FaceV_J(n)
                        k = Me%ThinWalls%FaceV_K(n)
                    endif
                    
                    if (Me%External_Var%ComputeFaces3D_UV(i, j, k) == Covered) then 
                        CurrentWLGrad = (Me%WaterLevel%New(i,j) - Me%WaterLevel%New(i-di,j-dj)) / Me%External_Var%DZX_ZY(i-di, j-dj)
                        
                        if (CurrentWLGrad < 0.) then
                            if (CurrentWLGrad < - Me%ThinWalls%GradWL_Limit) then
                                AuxWLGrad = CurrentWLGrad + Me%ThinWalls%GradWL_Limit
                            else    
                                AuxWLGrad = 0.
                            endif                            
                        else
                            if (CurrentWLGrad > Me%ThinWalls%GradWL_Limit) then
                                AuxWLGrad = CurrentWLGrad - Me%ThinWalls%GradWL_Limit
                            else    
                                AuxWLGrad = 0.
                            endif             
                        endif

                        if (abs(AuxWLGrad) > 0.) then
                            ![m/s2]              =    [m/s2] * [m/m]
                            Me%Forces%ThinWalls_Dissipation(i, j, k) = Gravity * AuxWLGrad 
                        endif                        
                    endif
                    
                enddo 
        
            endif
        
            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "ModifyThinWallsDissipation")
            endif
            
        endif            

    end subroutine ModifyThinWallsDissipation 

    !End ---------------------------------------------------------------------- 


    subroutine ModifyThinWallsMapping
        
        !Local---------------------------------------------------------------------
        integer                             :: STAT_CALL
        type (T_Time)                       :: Time1, Time2
        real                                :: Value1, Value2
        logical                             :: TimeCycle

        !Begin---------------------------------------------------------------------
        
        if (Me%ThinWalls%VariableInTime) then

            !Gets Value for current Time
            call GetTimeSerieValue (Me%ThinWalls%ObjTimeSerie, Me%CurrentTime,          &
                                    Me%ThinWalls%CloseFlagColumn,                       &
                                    Time1, Value1, Time2, Value2, TimeCycle,            &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR110'       

            if (Value1 == 1. .and. Value2 == 1) then                
                Me%ThinWalls%CloseFlag = 1
            else
                Me%ThinWalls%CloseFlag = 0
            endif

        else
            Me%ThinWalls%CloseFlag = 1
        endif
        
        ! If the thinwalls are in close Mode
        if (Me%ThinWalls%CloseFlag == 1) then
        
            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "ModifyThinWallsMapping")
            endif

            if      (Me%ThinWalls%UOn) then
                
                call UpdateComputeFaces3D(Map_ID        = Me%ObjMap,                    &
                                          FaceType      = TypeU_,                       &
                                          nFaces        = Me%ThinWalls%Nu,              &
                                          VectorI       = Me%ThinWalls%FaceU_I,         &
                                          VectorJ       = Me%ThinWalls%FaceU_J,         &
                                          VectorK       = Me%ThinWalls%FaceU_K,         &
                                          STAT          = STAT_CALL)                   
                
            elseif  (Me%ThinWalls%VOn) then
                
                call UpdateComputeFaces3D(Map_ID        = Me%ObjMap,                    &
                                          FaceType      = TypeV_,                       &
                                          nFaces        = Me%ThinWalls%Nv,              &
                                          VectorI       = Me%ThinWalls%FaceV_I,         &
                                          VectorJ       = Me%ThinWalls%FaceV_J,         &
                                          VectorK       = Me%ThinWalls%FaceV_K,         &
                                          STAT          = STAT_CALL)                   

            elseif  (Me%ThinWalls%WOn) then
                
                call UpdateComputeFaces3D(Map_ID        = Me%ObjMap,                    &
                                          FaceType      = TypeW_,                       &
                                          nFaces        = Me%ThinWalls%Nw,              &
                                          VectorI       = Me%ThinWalls%FaceW_I,         &
                                          VectorJ       = Me%ThinWalls%FaceW_J,         &
                                          VectorK       = Me%ThinWalls%FaceW_K,         &
                                          STAT          = STAT_CALL)                   
                
            endif        
        
            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "ModifyThinWallsMapping")
            endif
            
        endif            

    end subroutine ModifyThinWallsMapping 

    !End ---------------------------------------------------------------------- 

    subroutine Modify_ObstacleDrag
        
        !Local---------------------------------------------------------------------
        integer                             :: STAT_CALL
        integer                             :: IUB, ILB, JUB, JLB, KUB, KLB, kbottom
        integer                             :: di, dj, i, j, k
        real                                :: FaceDragCoef, VelMod_UV
        integer                             :: iSouth, I_North, J_East, jWest
        !$ integer                          :: CHUNK

        !Begin---------------------------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_ObstacleDrag")
        endif

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        if (Me%Drag%ID%SolutionFromFile) then

            call ModifyFillMatrix(FillMatrixID      = Me%Drag%ID%ObjFillMatrix,             &
                                  Matrix3D          = Me%Drag%Coef,                         &
                                  PointsToFill3D    = Me%External_Var%WaterPoints3D,        &
                                  STAT              = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_) stop 'Modify_ObstacleForces - ModuleHydrodynamic - ERR10'

        endif
        
     

        !$ CHUNK = CHUNK_J(JLB, JUB)

        !griflet: new simple parallelization
        !$OMP PARALLEL PRIVATE(i,j,k,kbottom,iSouth,jWest,I_North,J_East, &
        !$OMP                  VelMod_UV, FaceDragCoef)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do j = JLB, JUB
do2:    do i = ILB, IUB

            if (Me%External_Var%ComputeFaces3D_UV(I, J, KUB) == Covered) then 


                kbottom = Me%External_Var%KFloor_UV(I, J)

                iSouth     = I - di
                jWest      = J - dj 

                ! This values (i_North and j_east) can only be used to compute the velocity modulus in a face
                I_North     = I + dj
                J_East      = J + di


do3:            do k = kbottom, KUB
                

                    VelMod_UV       = Face_Velocity_Modulus(                                &
                                      Me%Velocity%Horizontal%VU%New(I_North, jWest, K),     &
                                      Me%Velocity%Horizontal%VU%New(I_North, J_East, K),    &
                                      Me%Velocity%Horizontal%VU%New(iSouth, jWest, K),      &
                                      Me%Velocity%Horizontal%VU%New(iSouth, J_East, K),     &
                                      Me%External_Var%DXX_YY(I_North, jWest),               &
                                      Me%External_Var%DXX_YY(I_North, J_East),              &
                                      Me%External_Var%DXX_YY(iSouth, jWest),                &
                                      Me%External_Var%DXX_YY(iSouth, J_East),               &
                                      Me%Velocity%Horizontal%UV%New(I,J,K))                               
                                                
                    FaceDragCoef    = Face_Interpolation(Me%Drag%Coef(i, j, k),             &
                                                         Me%Drag%Coef(iSouth, jWest, K),    &
                                                         Me%External_Var%DUX_VY(I, J),      &
                                                         Me%External_Var%DUX_VY(iSouth, jWest))

                    
                    ![m/s2]              =    [1/m] * [m/s] * [m/s]
                    Me%Forces%ObstacleDrag_Aceleration(i, j, k) = -1. * FaceDragCoef * VelMod_UV * &
                                                                      Me%Velocity%Horizontal%UV%New(I,J,K)

                enddo do3

            endif

        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_ObstacleDrag")
        endif

    end subroutine Modify_ObstacleDrag


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the coriolis force devided by the density                   !
    !  for both horizontal directions : X and Y                                            ! 
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: Coriolis force                                                               !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Modify_InertiaForces 

        ! X direction (Coriolis_Force(Vvar, Volume_U, Coriolis_Freq, DXX, DUX, KFloorU, CoveredFacesX, &
        !              ILB, IUB, JLB, JUB, KUB, Direction=1, Inertial_Aceleration)
        ! Y direction (Coriolis_Force(Uvar, Volume_V, Coriolis_Freq, DYY, DVY, KFloorV, CoveredFacesY, &
        !              ILB, IUB, JLB, JUB, KUB, Direction=0, Inertial_Aceleration)

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Velocity_UV_New, Velocity_VU_New, Inertial_Aceleration
        real,    dimension(:,:),   pointer :: DXX_YY, DYY_XX, DUX_VY, DVY_UX, DZX_ZY, Coriolis_Freq

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, LandBoundaryFacesVU
        integer, dimension(:,:),   pointer :: KFloor_UV
        
        real,    dimension(:  ),   pointer :: XX 

        real                               :: VUvar1, VUvar2, VUAverage, F_UV
        integer                            :: di, dj, k, kbottom, NoLand1, NoLand2
        integer                            :: I, I1, I2, I3
        integer                            :: J, J1, J2, J3

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        real                               :: Radius, Xorig, Yorig, Coriolis_Aceleration, &
                                              Centrifugal_Aceleration
        real                               :: dx1, dx2, Area, dxdy, dydx, f_Curvature

        integer                            :: FATAL_, INTERNAL_, ICOORD_TIP, CIRCULAR,   &
                                              status, Iaux

        !$ integer                            :: CHUNK

        !------------initialization----

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        Inertial_Aceleration => Me%Forces%Inertial_Aceleration
        Velocity_UV_New      => Me%Velocity%Horizontal%UV%New
        Velocity_VU_New      => Me%Velocity%Horizontal%VU%New

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV            => Me%External_Var%KFloor_UV


        DXX_YY               => Me%External_Var%DXX_YY
        DYY_XX               => Me%External_Var%DYY_XX

        DUX_VY               => Me%External_Var%DUX_VY
        DVY_UX               => Me%External_Var%DVY_UX

        DZX_ZY               => Me%External_Var%DZX_ZY

        Coriolis_Freq        => Me%External_Var%Coriolis_Freq

        LandBoundaryFacesVU  => Me%External_Var%LandBoundaryFacesVU

        !End - Shorten variables name 
        !Gets the type of Coordinates
        call GetCoordTypeList(CIRCULAR  = CIRCULAR)

        call GetGridCoordType(Me%ObjHorizontalGrid, ICOORD_TIP, STAT = status)
        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "Modify_InertiaForces - Hydrodynamic - ERR01")
                            
        if (ICOORD_TIP == CIRCULAR .and. Me%ComputeOptions%CentrifugalForce) then
            
            !Gets XX (radius when the grid coordinates are circular
            call GetHorizontalGrid(Me%ObjHorizontalGrid, XX = XX, STAT = status)
            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "Modify_InertiaForces - Hydrodynamic - ERR02")

            !Gets Origin of the Bathymetry
            call GetGridOrigin(Me%ObjHorizontalGrid, Xorig, Yorig, STAT = status)
            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "Modify_InertiaForces - Hydrodynamic - ERR03")


        endif


        !------------Main cicle--------

        !$ CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_InertiaForces")
        endif

        !$OMP PARALLEL PRIVATE( I,J,K,I1,J1,I2,J2,I3,J3,kbottom,VUvar1,NoLand1, &
        !$OMP                   VUvar2,NoLand2,VUAverage,F_UV,Coriolis_Aceleration, &
        !$OMP                   Radius,Centrifugal_Aceleration,Area,dydx,dx1,dx2,dxdy, &
        !$OMP                   f_Curvature, Iaux)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB
                                
cd1:        if (ComputeFaces3D_UV(I, J, KUB) == Covered) then 

                kbottom = KFloor_UV(I, J)


                I1    = I+dj-di
                J1    = J-dj+di
                I2    = I+dj
                J2    = J+di
                I3    = I-di
                J3    = J-dj


                
    do3:        do K=kbottom, KUB


                    !Null gradient is admitted in the land boundary.
                    if ((LandBoundaryFacesVU(I1, J1, K) + LandBoundaryFacesVU(I2, J2, K)) == 0) then

                        VUvar1 = (Velocity_VU_New(I1, J1, K) * DXX_YY(I2, J2) + &
                                  Velocity_VU_New(I2, J2, K) * DXX_YY(I1, J1))/ &
                                 (DXX_YY(I1, J1) +  DXX_YY(I2, J2))

                        NoLand1  = 1

                    else

                        VUvar1 = (1 - LandBoundaryFacesVU(I1, J1, K)) * Velocity_VU_New(I1, J1, K) + &
                                 (1 - LandBoundaryFacesVU(I2, J2, K)) * Velocity_VU_New(I2, J2, K)

                        NoLand1  = 2 - LandBoundaryFacesVU(I1, J1, K) - LandBoundaryFacesVU(I2, J2, K)

                    endif

                    if ((LandBoundaryFacesVU(I3, J3, K) + LandBoundaryFacesVU(I, J, K)) == 0) then
                        
                        VUvar2 = (Velocity_VU_New(I3, J3, K) * DXX_YY(I, J)   + &
                                  Velocity_VU_New(I,   J, K) * DXX_YY(I3, J3))/ &
                                 (DXX_YY(I3, J3) +  DXX_YY(I, J))

                       NoLand2  = 1

                    else

                       VUvar2 = (1 - LandBoundaryFacesVU(I3, J3, K)) * Velocity_VU_New(I3, J3, K) + &
                                (1 - LandBoundaryFacesVU(I,   J, K)) * Velocity_VU_New(I,   J, K)

                       NoLand2  = 2 - LandBoundaryFacesVU(I3, J3, K) - LandBoundaryFacesVU(I,   J, K)

                    endif

                    Iaux = NoLand1 + NoLand2
               
                    if (Iaux > 0) then
                        VUAverage  = (VUvar1 * NoLand1 + VUvar2 * NoLand2) / real(Iaux)
                    else
                        VUAverage  = 0.
                    endif   
                    

                    !VUvar1 = (Velocity_VU_New(I1, J1, K) * DXX_YY(I2, J2) + &
                    !          Velocity_VU_New(I2, J2, K) * DXX_YY(I1, J1))/ &
                    !         (DXX_YY(I1, J1) +  DXX_YY(I2, J2))

                    !VUvar2 = (Velocity_VU_New(I3, J3, K) * DXX_YY(I, J)   + &
                    !          Velocity_VU_New(I,   J, K) * DXX_YY(I3, J3))/ &
                    !         (DXX_YY(I3, J3) +  DXX_YY(I, J))

                    !VUAverage  = (VUvar1  + VUvar2) / 2.

                    Inertial_Aceleration(I, J, K) = 0.


                    if (Me%ComputeOptions%Coriolis) then

                        ! Interpolates Coriolis_Freq for the face 
                        F_UV = (DUX_VY(I3, J3) * Coriolis_Freq(I, J) + DUX_VY(I, J) * Coriolis_Freq(I3, J3)) / &
                               (DUX_VY(I3, J3) + DUX_VY(I, J))


                        ! Compute aceleration force

                        ![m/s^2]                 =            [s^-1] * [m/s]
                        Coriolis_Aceleration     = (dj - di) * F_UV * VUAverage 
                        Inertial_Aceleration(I, J, K) = Inertial_Aceleration(I, J, K) +  Coriolis_Aceleration

                    endif

                    if (Me%ComputeOptions%CentrifugalForce) then

                                       
                        if (ICOORD_TIP == CIRCULAR) then

                            Radius      = Xorig + XX(J)
                       
                            ![m/s^2]                =           [m/s] * [m/s] / [m]
                            Centrifugal_Aceleration =  dj * VUAverage * VUAverage / Radius

                            ![m/s^2]                 =            [m/s^2]  + [m/s^2] 
                            Inertial_Aceleration(I, J, K) = Inertial_Aceleration(I, J, K) + Centrifugal_Aceleration

                        else 

                            Area      = DZX_ZY(i3, j3) * DYY_XX(i, j)

                            !If 
                            dydx      = DVY_UX(i, j) - DVY_UX(i3, j3)

                            dx2       = (DXX_YY(i1, j1) + DXX_YY(i2, j2)) / 2.
                            dx1       = (DXX_YY(i , j ) + DXX_YY(i3, j3)) / 2.

                            dxdy      = dx2 - dx1

                            ! [s-1]     =   [m/s * m / m^2]
                            f_Curvature =   (VUAverage * dydx - Velocity_UV_New(i, j, k) * dxdy) / Area
                       
                            ![m/s^2]                =           [m/s] * [s-1]
                            Centrifugal_Aceleration =  VUAverage * f_Curvature

                            ![m/s^2]                 =            [m/s^2]  + [m/s^2] 
                            Inertial_Aceleration(I, J, K) = Inertial_Aceleration(I, J, K) + Centrifugal_Aceleration


                        endif

                    endif
                    
                    
                enddo do3
                
            end if cd1
                    
        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_InertiaForces")
        endif

        if (ICOORD_TIP == CIRCULAR) then
            
            !Gets XX and YY
            call UngetHorizontalGrid(Me%ObjHorizontalGrid, XX, STAT = status)
            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "Modify_InertiaForces - Hydrodynamic - ERR02")


        endif
              
        nullify (Inertial_Aceleration)
        nullify (Velocity_UV_New)
        nullify (Velocity_VU_New)

        nullify (DXX_YY)
        nullify (DYY_XX)
        nullify (DUX_VY)
        nullify (DVY_UX)
        nullify (DZX_ZY)

        nullify (Coriolis_Freq)

        nullify (ComputeFaces3D_UV, LandBoundaryFacesVU)
        nullify (KFloor_UV)

    End Subroutine Modify_InertiaForces

    !End------------------------------------------------------------------------------

    Subroutine ModifyRelaxAceleration 


        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Velocity_UV_New, SubModel_UV_New,          &
                                              Relax_Aceleration, DecayTime,              &
                                              VelAssimilation, DUZ_VZ

        real,    dimension(:,:  ), pointer :: WaterColumnUV
        
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV

        integer, dimension(:,:),   pointer :: KFloor_UV 

        type (T_Time)                      :: CurrentTime, BeginTime, EndTime

        real                               :: ColdPeriod, ColdOrder, DT_RunPeriod, CoefCold, VelModel, VelReference

        integer                            :: Vel_ID, status
        integer                            :: ILB, IUB, JLB, JUB, KUB, kbottom, i, j, k

        integer                            :: CHUNK

    !------------initialization----

        !Begin - Shorten variables name         
        Relax_Aceleration    => Me%Forces%Relax_Aceleration

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV            => Me%External_Var%KFloor_UV
        
        WaterColumnUV        => Me%External_Var%WaterColumnUV 

        DUZ_VZ               => Me%External_Var%DUZ_VZ


cd1:    if (Me%Relaxation%ReferenceVelocity == TotalVel_   .or.             &
            Me%Relaxation%ReferenceVelocity == BarotrVel_)  then

            Velocity_UV_New      => Me%Velocity%Horizontal%UV%New

        else if (Me%Relaxation%ReferenceVelocity == BaroclVel_) then cd1

            Velocity_UV_New      => Me%VelBaroclinic%UV%New

        endif cd1

        
        IUB = Me%WorkSize%IUB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        ILB = Me%WorkSize%ILB
        JLB = Me%WorkSize%JLB

        EndTime     = Me%EndTime 

        BeginTime   = Me%BeginTime 

        CurrentTime = Me%CurrentTime

        !End - Shorten variables name         


        nullify (SubModel_UV_New)
      
cd2:    if      (Me%Direction%XY == DirectionX_) then

            Vel_ID = VelocityU_
            if (Me%SubModel%ON)                                             &
                SubModel_UV_New => Me%SubModel%U_New

        else if (Me%Direction%XY == DirectionY_) then cd2

            Vel_ID = VelocityV_
            if (Me%SubModel%ON)                                             &
                SubModel_UV_New => Me%SubModel%V_New

        endif cd2


        call GetAssimilationField(Me%ObjAssimilation,                   &
                                  ID              = Vel_ID,                          &
                                  Field3D         = VelAssimilation,                 &
                                  STAT            = status)

        if (status /= SUCCESS_)                                                      &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAceleration - Hydrodynamic - ERR10")


        call GetAssimilationCoef (Me%ObjAssimilation,                                &
                                  ID          = Vel_ID,                              &
                                  CoefField3D = DecayTime,                           &
                                  ColdRelaxPeriod = ColdPeriod,                      &
                                  ColdOrder       = ColdOrder,                       &
                                  STAT        = status)

        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAceleration - Hydrodynamic - ERR20")


        DT_RunPeriod = CurrentTime - BeginTime

        if (ColdPeriod > (EndTime - BeginTime) .and. Me%FirstIteration) then 
            write(*,*) "ModifyRelaxAceleration - Hydrodynamic - WRN30"
            write(*,*) "Cold Relaxation Aceleration period larger than simulation period"
        endif               

cd4:    if (ColdPeriod <= DT_RunPeriod) then
            CoefCold = 1
        else  cd4
            CoefCold = (DT_RunPeriod / ColdPeriod) ** ColdOrder
            if (CoefCold < 1.e-32) CoefCold = 1.e-32
        endif cd4

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyRelaxAceleration")
        endif

        !$OMP PARALLEL PRIVATE(I,J,K,kbottom,VelModel,VelReference)
        
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB
            
cd5:        if (ComputeFaces3D_UV(I, J, KUB) == Covered ) then 

                kbottom = KFloor_UV(I, J)                            
                       
cd6:            if (Me%Relaxation%ReferenceVelocity == BarotrVel_) then

                    VelModel  = 0.

do4:                do K=kbottom, KUB

                        VelModel  =  VelModel + Velocity_UV_New(i, j, k) *               &
                                     DUZ_VZ(i, j, k) / WaterColumnUV(i, j)

                    enddo do4

                endif cd6

do3:            do K=kbottom, KUB
                    
                    if (Me%Relaxation%ReferenceVelocity /= BarotrVel_)      &
                        VelModel  = Velocity_UV_New(i, j, k)

                    if     (Me%ComputeOptions%LocalSolution == AssimilaPlusSubModel_  .or.  &
                            Me%ComputeOptions%LocalSolution == AssimilaGaugeSubmodel_) then

                         VelReference = VelAssimilation(i, j, k)  + SubModel_UV_New(i, j, k)
                    
                    elseif (Me%ComputeOptions%LocalSolution == Submodel_)             then

                        VelReference = SubModel_UV_New(i, j, k)
                        
                    elseif (Me%ComputeOptions%LocalSolution == GaugePlusSubModel_)    then
                    
                        VelReference = SubModel_UV_New(i, j, k)

                    elseif (Me%ComputeOptions%LocalSolution == NoLocalSolution_ .or.    &
                            Me%ComputeOptions%LocalSolution == AssimilationField_) then

                        VelReference = VelAssimilation(i, j, k)

                    elseif (Me%ComputeOptions%LocalSolution == Gauge_) then

                        stop 'ModifyRelaxAceleration - ModuleHydrodynamic - ERR40'

                    endif
                    
                    ![m/s^2]                   = []*([m/s] - [m/s]) / [s]
                    Relax_Aceleration(i, j, k) = CoefCold  * (VelReference - VelModel)/ DecayTime(i, j, k)
                    

                enddo do3
                            
            endif cd5
                 
        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyRelaxAceleration")
        endif

        call UnGetAssimilation(Me%ObjAssimilation, DecayTime, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAceleration - Hydrodynamic - ERR50")

        call UnGetAssimilation(Me%ObjAssimilation, VelAssimilation,         &
                               STAT        = status)

        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAceleration - Hydrodynamic - ERR60")

        nullify(Relax_Aceleration)
        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV        )
        nullify(Velocity_UV_New  )    
        nullify(WaterColumnUV    )
        nullify(DUZ_VZ           )
        
        if (Me%SubModel%ON)                                                 &
            nullify(SubModel_UV_New)
 

    End Subroutine ModifyRelaxAceleration

    !End------------------------------------------------------------------------------

    Subroutine ModifyRelaxAcelerationVert 


        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Velocity_W, DecayTime,                    &
                                              VelAssimilation
        integer, dimension(:,:,:), pointer :: OpenPoints3D
        integer, dimension(:,:),   pointer :: KFloor_Z
        type (T_Time)                      :: CurrentTime, BeginTime, EndTime
        real                               :: ColdPeriod, ColdOrder, DT_RunPeriod, CoefCold, VelModel   
        integer                            :: status
        integer                            :: ILB, IUB, JLB, JUB, KUB, kbottom, i, j, k
        integer                            :: CHUNK

    !------------initialization----

        !Begin - Shorten variables name         

        OpenPoints3D         => Me%External_Var%OpenPoints3D
        KFloor_Z             => Me%External_Var%KFloor_Z
        Velocity_W           => Me%Velocity%Vertical%CartesianOld

       
        IUB = Me%WorkSize%IUB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        ILB = Me%WorkSize%ILB
        JLB = Me%WorkSize%JLB

        EndTime     = Me%EndTime 
        BeginTime   = Me%BeginTime 
        CurrentTime = Me%CurrentTime

        !End - Shorten variables name         

        call GetAssimilationField(Me%ObjAssimilation,                                   &
                                  ID              = VelocityW_,                         &
                                  Field3D         = VelAssimilation,                    &
                                  STAT            = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAcelerationVert - Hydrodynamic - ERR10")


        call GetAssimilationCoef (Me%ObjAssimilation,                                   &
                                  ID              = VelocityW_,                         &
                                  CoefField3D     = DecayTime,                          &
                                  ColdRelaxPeriod = ColdPeriod,                         &
                                  ColdOrder       = ColdOrder,                          &
                                  STAT            = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAcelerationVert - Hydrodynamic - ERR20")


        DT_RunPeriod = CurrentTime - BeginTime

        if (ColdPeriod > (EndTime - BeginTime) .and. Me%FirstIteration) then 
            write(*,*) "ModifyRelaxAcelerationVert - Hydrodynamic - WRN30"
            write(*,*) "Cold Relaxation Aceleration period larger than simulation period"
        endif               

cd4:    if (ColdPeriod <= DT_RunPeriod) then
            CoefCold = 1
        else  cd4
            CoefCold = (DT_RunPeriod / ColdPeriod) ** ColdOrder
            if (CoefCold < 1.e-32) CoefCold = 1.e-32
        endif cd4

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyRelaxAcelerationVert")
        endif

        !$OMP PARALLEL PRIVATE(I,J,K,kbottom)
        
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB
            
cd5:        if (OpenPoints3D(I, J, KUB) == Covered ) then 

                kbottom = KFloor_Z(I, J)                            
                       
                VelModel  = 0.

do4:            do K=kbottom+1, KUB

                    ![m/s]                 = []* [s] * ([m/s] - [m/s]) / [s]
                    Me%THOMAS%Ti (i, j, k) = Me%THOMAS%Ti (i, j, k) + CoefCold  * Me%WaterLevel%DT *         &
                                             (VelAssimilation(i,j,k) - Velocity_W(i,j,k))/ DecayTime(i, j, k) 
                
                enddo do4
            endif cd5
                 
        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyRelaxAcelerationVert")
        endif

        call UnGetAssimilation(Me%ObjAssimilation, DecayTime, STAT = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAcelerationVert - Hydrodynamic - ERR50")

        call UnGetAssimilation(Me%ObjAssimilation, VelAssimilation, STAT = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAcelerationVert - Hydrodynamic - ERR60")
 

        nullify(OpenPoints3D     )
        nullify(KFloor_Z         )
        nullify(Velocity_W       )




    End Subroutine ModifyRelaxAcelerationVert

    !End------------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the aceleration due to the geostrophic velocity             !
    !  resultant from Cooper and Haines Method.                                            ! 
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: RelaxAltimGeostAceleration                                                   !
    ! Author: João Nogueira (May 2006)                                                     !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ModifyAltimAceleration 


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old, Altim_Relax_Aceleration
        real,    dimension(:,:,:), pointer :: GeostrophicVelocity_UV

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV
        
        integer                            :: kbottom 
        integer                            :: I, J, K
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        
        real                               :: AltimDecayTime
        !$ integer                         :: CHUNK

        !------------initialization----

        !Begin shorten variables---------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyAltimAceleration")
        endif

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        Velocity_UV_Old             => Me%Velocity%Horizontal%UV%Old
        GeostrophicVelocity_UV      => Me%Geostroph%UV
        Altim_Relax_Aceleration     => Me%Forces%Altim_Relax_Aceleration

        ComputeFaces3D_UV           => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV                   => Me%External_Var%KFloor_UV

        AltimDecayTime              = Me%External_Var%AltimDecayTime


        !End - Shorten variables name                            


        if (Me%CurrentTime .le.( Me%BeginTime +                                         &
            (10.* Me%ComputeOptions%AltimetryAssimilation%DT_Compute))) then

            !Compute GeostrophicVelocity_VU                       


            call ComputeGeostrophicVelocity(Me%External_Var%AltimWaterLevelAnalyzed,    &
                                            Me%External_Var%AltimSigmaDensAnalyzed)
        endif



        !$ CHUNK = CHUNK_J(JLB, JUB)

        !griflet: new simple parallelization
        !$OMP PARALLEL PRIVATE(I,J,K,kbottom)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB

cd1:        if (ComputeFaces3D_UV(I, J, KUB) == Covered) then 

                kbottom = KFloor_UV(I, J)

    do3:        do K=kbottom, KUB


                    Altim_Relax_Aceleration(I, J, K) = 0.


                    ! Compute aceleration force  [m/s^2]  =  [m/s]/[s]

                    Altim_Relax_Aceleration(I, J, K) = (GeostrophicVelocity_UV(I, J, K) & 
                                                        - Velocity_UV_Old(I, J, K))/    &
                                                        AltimDecayTime

                enddo do3

            end if cd1
                    

        enddo do2
        enddo do1        
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        !Nullify auxiliar pointers
        nullify (Velocity_UV_Old)
        nullify (GeostrophicVelocity_UV)
        nullify (Altim_Relax_Aceleration)

        nullify (ComputeFaces3D_UV)
        nullify (KFloor_UV)

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyAltimAceleration")
        endif

    End Subroutine ModifyAltimAceleration


    !End------------------------------------------------------------------------------



    Subroutine ComputeGeostrophicVelocity (WaterLevel, SigmaDens)

        !
        !   This routine computes the geostrophic velocity with thermal wind equations.
        !   

        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: SigmaDens
        real,    dimension(:,:)  , pointer :: WaterLevel


        !Local---------------------------------------------------------------------
        real,    dimension(:,:),   pointer :: DUX_VY, Coriolis_Freq

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV
        
        real                               :: F_UV
        integer                            :: di, dj, k, kbottom
        integer                            :: I, IAux
        integer                            :: J, JAux
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, dir


        !------------initialization----

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        Coriolis_Freq                   => Me%External_Var%Coriolis_Freq

        ComputeFaces3D_UV               => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV                       => Me%External_Var%KFloor_UV

        DUX_VY                          => Me%External_Var%DUX_VY


        !End - Shorten variables name                            

ddir:   do dir = 1, 2

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        
        Me%Geostroph%PressGrad   (:,:,:) = 0.

        ! Compute Pressure Gradient

        call ComputeGeostPressGrad(SigmaDens, WaterLevel, Me%Geostroph%PressGrad)

        ! Compute gestrophic Velocity
        
        Me%Geostroph%AuxDesCentre(:,:,:) = 0.

do1:    do  J = JLB, JUB-1
do2:    do  I = ILB, IUB-1


cd1:        if (ComputeFaces3D_UV(I, J, KUB) == Covered) then 

                kbottom = KFloor_UV(I, J)

                IAux    = I-di
                JAux    = J-dj


    do3:        do K=kbottom, KUB

                    if (Me%ComputeOptions%Coriolis) then

                        ! Interpolates Coriolis_Freq for the face 
                        F_UV = (DUX_VY(IAux, JAux) * Coriolis_Freq(I, J) + DUX_VY(I, J) &
                               * Coriolis_Freq(IAux, JAux))                             &
                                /(DUX_VY(IAux, JAux) + DUX_VY(I, J))
                        
                        Me%Geostroph%AuxDesCentre(I, J, K)= (di - dj) *                 &
                                                     Me%Geostroph%PressGrad (I, J, K)   &
                                                     /(F_UV * SigmaDensityReference)

                    else
                        
                        Write(*,*) 'You can´t compute Geostrophic Velocity without Coriolis aceleration'
                        
                        Stop 'ComputeGeostrophicVelocity - ModuleHydrodynamic - ERR01'

                    endif
                    


                enddo do3

            end if cd1
                    

        enddo do2
        enddo do1

        call ChangeDirection
       
        ! Correct geostrophic velocity faces
        call CoriolisInterpolation(Me%Geostroph%AuxDesCentre, Me%Geostroph%UV)
        
       enddo ddir

        
        !Nullify auxiliar pointers


        nullify (Coriolis_Freq)

        nullify (ComputeFaces3D_UV)
        nullify (KFloor_UV)

        nullify (DUX_VY)


    End Subroutine ComputeGeostrophicVelocity


    !End------------------------------------------------------------------------------


    Subroutine ComputeGeostPressGrad (SigmaDens, WaterLevel,                            &
                                      GeostrophicPressureGradient_UV)
                                      


        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: GeostrophicPressureGradient_UV
        real,    dimension(:,:,:), pointer :: SigmaDens
        real,    dimension(:,:)  , pointer :: WaterLevel


        !Local---------------------------------------------------------------------


        ! Compute baroclinic part of pressure gradient using the same model integration

        call Modify_ROX3(SigmaDens, GeostrophicPressureGradient_UV)

        ! Compute barotropic part of pressure gradient using level gradient

        call Compute_SurfaceAceleration(WaterLevel, GeostrophicPressureGradient_UV)


    End Subroutine ComputeGeostPressGrad


    !End------------------------------------------------------------------------------


    Subroutine Compute_SurfaceAceleration (WaterLevel, GeostrophicPressureGradient_UV)


        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: GeostrophicPressureGradient_UV
        real,    dimension(:,:)  , pointer :: WaterLevel


        !Local---------------------------------------------------------------------


        real,    dimension(:,:  ), pointer :: DUX_VY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV 
        Integer                            :: i, j, di, dj, k, kbottom, ileft, jleft

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        
        real                               :: GradLevel
        
    !------------initialization----

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV
        BoundaryFacesUV   => Me%External_Var%BoundaryFacesUV
        KFloor_UV         => Me%External_Var%KFloor_UV

        DUX_VY            => Me%External_Var%DUX_VY  

        

        !End - Shorten variables name 
        


    !------------Main cicle--------

do1:     do J = JLB, JUB
do2:     do I = ILB, IUB
                    
cd1:        if (ComputeFaces3D_UV(i, j, KUB)== Covered) then 

                kbottom = KFloor_UV(i, j)

                ileft = i - di
                jleft = j - dj

                ! Calcular o gradiente de nivel

                GradLevel = 2 * (WaterLevel(i,j) - WaterLevel(ileft,jleft))             &
                            /(DUX_VY(ileft,jleft)+DUX_VY(i,j))* SigmaDensityReference

do3:            do  k=KUB, kbottom,-1

                ! Somar o gradiente de nivel ao que ja tinha

                    GeostrophicPressureGradient_UV(i,j,k) =                             &
                                            (GeostrophicPressureGradient_UV(i,j,k)      &
                                            - GradLevel) * Gravity 

                enddo do3                    

                    
            end if cd1

        enddo do2
        enddo do1



        
        !Nullify auxiliar pointers


        nullify (ComputeFaces3D_UV)
        nullify (BoundaryFacesUV)
        nullify (KFloor_UV)

        nullify (DUX_VY)  


    End Subroutine Compute_SurfaceAceleration


    !End------------------------------------------------------------------------------


    Subroutine CoriolisInterpolation(Geostrophic_UV, Geostrophic_UV_New) 

        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Geostrophic_UV
        real,    dimension(:,:,:), pointer :: Geostrophic_UV_New


        !Local---------------------------------------------------------------------

        real,    dimension(:,:),   pointer :: DXX_YY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, LandBoundaryFacesVU
        integer, dimension(:,:),   pointer :: KFloor_UV
        

        integer                            :: di, dj, k, kbottom, NoLand1, NoLand2
        integer                            :: I, I1, I2, I3
        integer                            :: J, J1, J2, J3
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        integer                            :: Iaux
        real                               :: VUvar1, VUvar2, VUAverage
                                              

        !------------initialization----

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        LandBoundaryFacesVU  => Me%External_Var%LandBoundaryFacesVU
        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        DXX_YY               => Me%External_Var%DXX_YY


        !End - Shorten variables name                            


        !------------Main cicle--------

do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB
                                
cd1:        if (ComputeFaces3D_UV(I, J, KUB) == Covered) then 

                kbottom = KFloor_UV(I, J)


                I1    = I+dj-di
                J1    = J-dj+di
                I2    = I+dj
                J2    = J+di
                I3    = I-di
                J3    = J-dj

                
    do3:        do K=kbottom, KUB


                    !Null gradient is admitted in the land boundary.
                    if ((LandBoundaryFacesVU(I1, J1, K) +                               &
                         LandBoundaryFacesVU(I2, J2, K)) == 0) then

                        VUvar1 = (Geostrophic_UV(I1, J1, K) * DXX_YY(I2, J2) +          &
                                  Geostrophic_UV(I2, J2, K) * DXX_YY(I1, J1))/          &
                                 (DXX_YY(I1, J1) +  DXX_YY(I2, J2))

                        NoLand1  = 1

                    else

                        VUvar1 = (1 - LandBoundaryFacesVU(I1, J1, K))                   &
                                  * Geostrophic_UV(I1, J1, K)                           &
                                  + (1 - LandBoundaryFacesVU(I2, J2, K))                &
                                  * Geostrophic_UV(I2, J2, K)

                        NoLand1  = 2 - LandBoundaryFacesVU(I1, J1, K)                   &
                                   - LandBoundaryFacesVU(I2, J2, K)

                    endif

                    if ((LandBoundaryFacesVU(I3, J3, K) +                               &
                         LandBoundaryFacesVU(I, J, K)) == 0) then
                        
                        VUvar2 = (Geostrophic_UV(I3, J3, K) * DXX_YY(I, J)   +          &
                                  Geostrophic_UV(I,   J, K) * DXX_YY(I3, J3))/          &
                                 (DXX_YY(I3, J3) +  DXX_YY(I, J))

                       NoLand2  = 1

                    else

                       VUvar2 = (1 - LandBoundaryFacesVU(I3, J3, K))                    &
                                 * Geostrophic_UV(I3, J3, K)                            &
                                 + (1 - LandBoundaryFacesVU(I,   J, K))                 &
                                 * Geostrophic_UV(I,   J, K)

                       NoLand2  = 2 - LandBoundaryFacesVU(I3, J3, K)                    &
                                  - LandBoundaryFacesVU(I,   J, K)

                    endif

                    Iaux = NoLand1 + NoLand2
               
                    if (Iaux > 0) then
                        VUAverage  = (VUvar1 * NoLand1 + VUvar2 * NoLand2) / real(Iaux)
                    else
                        VUAverage  = 0.
                    endif   
                    
                    Geostrophic_UV_New(I, J, K) = VUAverage
                    
                enddo do3
                
            end if cd1
                    
        enddo do2
        enddo do1

        
        !Nullify auxiliar pointers

        nullify (ComputeFaces3D_UV)
        nullify (KFloor_UV)
        nullify (LandBoundaryFacesVU)

        nullify (DXX_YY)


   End Subroutine CoriolisInterpolation
    
    !End------------------------------------------------------------------------------
    



    Subroutine ModifyRelaxHorizAdv 


        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport
        real,    dimension(:,:,:), pointer :: DecayTime
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV 

        real                               :: DecayTimeMin

        integer                            :: HT_ID, status
        integer                            :: ILB, IUB, JLB, JUB, KUB, kbottom, i, j, k

        integer                            :: CHUNK

    !------------initialization----

        !Begin - Shorten variables name         

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV            => Me%External_Var%KFloor_UV

        Horizontal_Transport => Me%Forces%Horizontal_Transport

        
        IUB = Me%WorkSize%IUB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        ILB = Me%WorkSize%ILB
        JLB = Me%WorkSize%JLB

      
cd2:    if      (Me%Direction%XY == DirectionX_) then

            HT_ID = HorizontalTransportX_


        else if (Me%Direction%XY == DirectionY_) then cd2

            HT_ID = HorizontalTransportY_

        endif cd2

        call GetAssimilationCoef (Me%ObjAssimilation,                       &
                                  ID          = HT_ID,                                   &
                                  Minimum     = DecayTimeMin,                            &
                                  CoefField3D = DecayTime,                               &
                                  STAT        = status)

        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxHorizAdv - Hydrodynamic - ERR01")

        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyRelaxHorizAdv")
        endif
        
        !$OMP PARALLEL PRIVATE(I,J,K,kbottom)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB
            
cd5:        if (ComputeFaces3D_UV(I, J, KUB) == Covered ) then 

                kbottom = KFloor_UV(I, J)                            
                       
do3:            do K=kbottom, KUB
                    
                    ![m3/s*m/s]                   = [m3/s*m/s] * [s/s]
                    Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k)*(1. - DecayTimeMin / DecayTime(i, j, k))
                    

                enddo do3
                            
            endif cd5
                 
        enddo do2
        enddo do1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyRelaxHorizAdv")
        endif

        call UnGetAssimilation(Me%ObjAssimilation, DecayTime, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxHorizAdv - Hydrodynamic - ERR02")


        nullify(ComputeFaces3D_UV   )
        nullify(KFloor_UV           )
        nullify(Horizontal_Transport)

    End Subroutine ModifyRelaxHorizAdv

    !End------------------------------------------------------------------------------

    !-----------------------------------------------------------------

    Subroutine ModifyTidePotential

        !Arguments-------------------------------------------------------------
       
        !Local-----------------------------------------------------------------

        real,    pointer, dimension (:,:)   :: GridLatitude, GridLongitude, &
                                               TidePotentialLevel
        real,    pointer, dimension (:  )   :: Beta, EqAmp, Freq, L, AstroArg
        integer, pointer, dimension (:  )   :: m
        !griflet: lets make L2 and AstroArg local variables, statically allocated.
        real, dimension(3)                  :: L2
        integer, pointer, dimension (:,:,:) :: WaterPoints3D
        type (T_Time)                       :: CurrentTime, TimeRef
        real(8)                             :: UTSeconds, tc, h0, s0, p0, Tau, TimeSeconds !ps, ns,
        real                                :: LatRad, LongRad, Run_Period, Aux, LongDegree
        real                                :: Year, Month, Day, Hour, Minute, Seconds
        integer                             :: STATUS, JulDay, D
        integer                             :: IUB, ILB, JUB, JLB, KUB, i, j, Ncomp, n

        !$ integer                             :: CHUNK

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyTidePotential")
        endif

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        TidePotentialLevel => Me%Forces%TidePotentialLevel
        
        Beta           => Me%TidePotential%Beta
        EqAmp          => Me%TidePotential%Amplitude
        Freq           => Me%TidePotential%Frequency
        AstroArg       => Me%TidePotential%Arguments
        m              => Me%TidePotential%m
        L              => Me%TidePotential%L

        Ncomp          =  Me%TidePotential%ComponentsNumber

        WaterPoints3D  => Me%External_Var%WaterPoints3D

        TimeRef        =  Me%TidePotential%TimeRef

        CurrentTime    = Me%CurrentTime

        Run_Period     = Me%CurrentTime - Me%BeginTime

        call GetGridLatitudeLongitude(Me%ObjHorizontalGrid,                 &
                                      GridLatitude  = GridLatitude,                      &
                                      GridLongitude = GridLongitude,                     &
                                      STAT = STATUS)

        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyTidePotential - Hydrodynamic - ERR01")        

        call ExtractDate(CurrentTime, Year, Month, Day, Hour, Minute, Seconds)
        
        if (year < 1975) call SetError (FATAL_, INTERNAL_, "ModifyTidePotential - Hydrodynamic - ERR02")        

        call JulianDay(CurrentTime, JulDay)

        D = JulDay + 365*(int(year)-1975)+int((year-1973)/4)
      
        !Universal Time in seconds (by default is consider that the model time is the UT)
        UTSeconds = Hour * 3600. + Minute * 60. + Seconds

        if (Me%TidePotential%Algorithm == Kantha) then
        
            !time in Junlian centuries (36525 days)
            !TimeSeconds = CurrentTime - TimeRef
            !tc = TimeSeconds / 86400. / 36525.
            tc = (27392.500528+1.0000000356*real(D))/36525 

            !Lunar and solar ephemerides in degrees - Kantha e Clayson, 2000 (pág. 435)

            h0 = 279.69668    + 36000.768925485*tc + 3.03e-4 *tc*tc
            s0 = 270.434358   + 481267.88314137*tc - 0.001133*tc*tc   + 1.9e-6*tc*tc*tc
            p0 = 334.329653   + 4069.0340329575*tc - 0.10325 *tc*tc   - 1.2e-5*tc*tc*tc
            !ns = 259.16000    - 1934.14        *tc + 0.0021  *tc*tc
            !ps = 281.22083    + 1.71902        *tc + 0.00045 *tc*tc   + 3.0e-6*tc*tc*tc
    
            !Astronomical Arguments (Table 6.2.1 Kantha and Clayson, 2000)
            AstroArg(Ssa) =  2*h0
            AstroArg(Mm ) =  s0 - p0
            AstroArg(Mf ) =  2*s0

            AstroArg(K1 ) =          h0      +90.
            AstroArg(O1 ) = -2*s0 +  h0      -90.
            AstroArg(P1 ) =       -  h0      -90.
            AstroArg(Q1 ) = -3*s0 +  h0 + p0 -90. 

            AstroArg(M2 ) = -2*s0 + 2*h0
            AstroArg(S2 ) = 0.
            AstroArg(N2 ) = -3*s0 + 2*h0 + p0
            AstroArg(K2 ) = 2*h0
            
        else if (Me%TidePotential%Algorithm == Lefevre) then

            !time in Junlian centuries (36525 days)
            !Seconds TimeRef = 1900/1/1 : 0h0m 
    
            TimeSeconds = CurrentTime - TimeRef

            tc = TimeSeconds / 86400. / 36525.

            !Lefévre, 2001 (4.19) chapter 4 page 55 (phD Thesis).
            h0 = 280.18950    +  36000.76892*tc + 3.00e-4 *tc*tc
            s0 = 277.02480    + 481267.89060*tc + 2.00e-3 *tc*tc 
            p0 = 334.38530    +   4069.03400*tc + 1.03e-2 *tc*tc
            !ns = 100.84320    +   1934.14200*tc + 2.10e-3 *tc*tc
            !ps = 281.22086    +      1.71920*tc + 5.00e-4 *tc*tc   

            !Astronomical Arguments (Table 5 Lefèvre, 2001)
            ! + 0
            AstroArg(Ssa) =  2*h0
            AstroArg(Mm ) =  s0 - p0
            AstroArg(Mf ) =  2*s0

            !Lefèvre, 2001 do not make reference to the phase corrections (+- 90º)
            !However this corrections are made in the ModuleToga (Foreman Tidal Analysis package)
            !and are also maed by Kantha e Clayson, 2000.
            ! + Tau
            AstroArg(K1 ) =  s0         + 90.
            AstroArg(O1 ) =  - s0         - 90.
            AstroArg(P1 ) =  s0 - 2*h0  - 90.
            AstroArg(Q1 ) =  - 2*s0 + p0  - 90.

            ! + 2*Tau
            AstroArg(M2 ) = 0.                 
            AstroArg(S2 ) = 2*s0 - 2*h0    
            AstroArg(N2 ) = -   s0 +   p0    
            AstroArg(K2 ) = 2*s0           

        endif
        
        !Conversion of Degrees in Radians
        do n = 1, Ncomp
          AstroArg(n) = AstroArg(n) * Pi / 180.
        enddo

        !$ CHUNK = CHUNK_J(JLB, JUB)
        !griflet: needs to privatize array L2
        !griflet: The solution was simply to make L2 a local, *static* array.
        !
        !$OMP PARALLEL PRIVATE(i,j,LatRad,LongDegree,LongRad,L2,n,Aux,Tau)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB

iw1:        if (WaterPoints3D(i, j, KUB) == WaterPoint)  then

                LatRad     = GridLatitude (i, j) * Pi / 180.

                LongDegree = GridLongitude(i, j)

                do while (LongDegree>=360.)
                    LongDegree = LongDegree - 360.
                enddo
                do while (LongDegree<   0.)
                    LongDegree = LongDegree + 360.
                enddo

                LongRad = LongDegree * Pi / 180.

                !griflet: need to make this variable local!
                !L (changed from L(0), L(1), L(2) to L(1), L(2), L(3).
                L2(1) = 1.5*cos(LatRad)*cos(LatRad) - 1.
                L2(2) = sin(2*LatRad)
                L2(3) = cos(LatRad)*cos(LatRad)

                TidePotentialLevel(i,j) = 0.

it1:            if (Me%TidePotential%Algorithm == Kantha) then

                    !griflet: m(n) was taken care of in the construct and yields 1,2 or 3 only.
                    do n=1, Ncomp
                        TidePotentialLevel(i,j) = TidePotentialLevel(i,j) +  Beta (n) * EqAmp(n) * L2(m(n)) *     &
                                                  cos ( AstroArg(n) + Freq(n)*UTSeconds/3600 + real(m(n))*LongRad)
                    enddo

                else if (Me%TidePotential%Algorithm == Lefevre) then it1

                    Tau = (UTseconds / 86400.*360. + LongDegree - s0 + h0) * Pi / 180.

                    !griflet: m(n) was taken care of in the construct and yields 
                    !1(Ssa,Mm,Mf),2(Q1,O1,N1,P1) or 3(M2,N2,O2,P2) only.
                    do n=1, 11                         
                        TidePotentialLevel(i,j) = TidePotentialLevel(i,j) +  Beta (n) * EqAmp(n) * L2(m(n)) *     &
                                                  cos ( AstroArg(n) + (real(m(n))-1)*Tau )
                    enddo                    

                endif it1

                if (Me%ComputeOptions%TideSlowStartCoef > 0.)  then

                    Aux = Run_Period / Me%ComputeOptions%TideSlowStartCoef
 
                    if (Aux < 1) TidePotentialLevel(i,j)= TidePotentialLevel(i,j) * Aux 

                endif 

            else  iw1

                TidePotentialLevel(i, j) = FillValueReal

            endif iw1

        enddo
        enddo
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        call UngetHorizontalGrid(Me%ObjHorizontalGrid,  &
                                 Array = GridLatitude, STAT = STATUS)

        if (STATUS /= SUCCESS_)                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyTidePotential - Hydrodynamic - ERR03")

        call UngetHorizontalGrid(Me%ObjHorizontalGrid,  &
                                 Array = GridLongitude, STAT = STATUS)

        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyTidePotential - Hydrodynamic - ERR04")

        !nullify auxiliar pointers
        nullify(TidePotentialLevel)
        nullify(Beta     )
        nullify(EqAmp    )
        nullify(Freq     )
        nullify(AstroArg )
        nullify(m        )
        nullify(L        )
        nullify(WaterPoints3D)

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyTidePotential")
        endif

    end Subroutine ModifyTidePotential

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Compute the horizontal water flow                                                    !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_HorizontalWaterFlow 

         !Variables Categories  
            !Geometry  : Area_UV
            !Flow      : WaterFlux_XY, Me%WaterFluxes%New_Old, Velocity_UV_New, Velocity_UV_Old
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction

         
         !Variables Direction Dependent
           !Area_UV, WaterFlux_XY, Me%WaterFluxes%New_Old, Velocity_UV_New, Velocity_UV_Old
           !ComputeFaces3D_UV, KFloor_UV, Direction
        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_XY
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old, Velocity_UV_New, Area_UV, DWZ
        real,    dimension(:,:,:), pointer :: Baroclinic_UV_New, Baroclinic_UV_Old,      &
                                              DUZ_VZ, SZZ
        real,    dimension(:,:  ), pointer :: WaterColumnUV, DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV,   &
                                              ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: KFloor_Z, KFloor_UV, BoundaryPoints

        real(8)                            :: TotalFlux, dz

        integer                            :: I, J, K, Kbottom, di, dj

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, ic, jc

        integer                            :: CHUNK

        !--------------------------------------------------------------------------

        !A if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Modify_HorizontalWaterFlow")

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        WaterFlux_XY      => Me%WaterFluxes%XY
        Velocity_UV_Old   => Me%Velocity%Horizontal%UV%Old
        Velocity_UV_New   => Me%Velocity%Horizontal%UV%New

        Baroclinic_UV_New => Me%VelBaroclinic%UV%New
        Baroclinic_UV_Old => Me%VelBaroclinic%UV%Old

        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        KFloor_Z                 => Me%External_Var%KFloor_Z
        KFloor_UV                => Me%External_Var%KFloor_UV
        Area_UV                  => Me%External_Var%Area_UV
        ImposedNormalFacesUV     => Me%External_Var%ImposedNormalFacesUV
        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV

        BoundaryPoints           => Me%External_Var%BoundaryPoints

        DYY_XX                   => Me%External_Var%DYY_XX
        DWZ                      => Me%External_Var%DWZ

        SZZ                      => Me%External_Var%SZZ
        WaterColumnUV            => Me%External_Var%WaterColumnUV
        DUZ_VZ                   => Me%External_Var%DUZ_VZ

        !End - Shorten variables name 

        call SetMatrixValue(WaterFlux_XY, Me%WorkSize, dble(0.0))

        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_HorizontalWaterFlow")
        endif
        
        !$OMP PARALLEL PRIVATE(i,j,k,Kbottom,ic,jc,TotalFlux,dz)
        
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj:     do j = JLB, JUB
doi:     do i = ILB, IUB

Cov1:       if (ComputeFaces3D_UV(I, J, KUB) == Covered) then

                Kbottom = KFloor_UV(i, j)

dok:            do  k = Kbottom, KUB
 
                    ![m^3/s]              = [ ] * [m/s] * [m^2]
                    WaterFlux_XY(i, j, k) = (dble(Me%WaterFluxes%New_Old) *                  &
                                            dble(Velocity_UV_New(i, j, k))  + &
                                            dble((1. - Me%WaterFluxes%New_Old)) *            &
                                            dble(Velocity_UV_Old(i, j, k))) * &
                                            dble(Area_UV(i, j, k))
                enddo dok

            endif Cov1

        enddo doi
        enddo doj
        !$OMP END DO NOWAIT
        
cd3:    if (Me%SubModel%ON) then 
            
cd5:        if (Me%SubModel%Set) then 

                CHUNK = CHUNK_J(JLB, JUB + dj)

                dok2: do k = KLB, KUB 
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                doj2: do j = JLB, JUB + dj
                doi2: do i = ILB, IUB + di

                    !The faces that are exterior are put equal to the father model

cd4:                if (ImposedNormalFacesUV    (i, j, k) == Imposed   .or.              &
                        ImposedTangentialFacesUV(i, j, k) == Imposed) then                  
                
                        !Specific flow 
                        ![m^2/s]            = [m/s] * [m]
                        Me%SubModel%qXY(i, j, k)   =  (dble(Me%WaterFluxes%New_Old) *      &
                                            dble(Velocity_UV_New(i, j, k))        +      &
                                            dble((1. - Me%WaterFluxes%New_Old))                  *      &
                                            dble(Velocity_UV_Old(i, j, k)))       *      &
                                            dble(Me%SubModel%DUVZ_Old(i, j, k))
                        

                    endif cd4


cd11:               if (ComputeFaces3D_UV(i, j, k) == Covered) then                  
                
                        !Specific flow 
                        ![m^2/s]            = [m/s] * [m]
                        Me%SubModel%qXY(i, j, k)   =  (dble(Me%WaterFluxes%New_Old)           * &
                                            dble(Me%SubModel%UV_New(i, j, k))  + &
                                            dble((1. - Me%WaterFluxes%New_Old))                            * &
                                            dble(Me%SubModel%UV_Old(i, j, k))) * &
                                            dble(Me%SubModel%DUVZ_Old(i, j, k))
                        

                    endif cd11


                enddo doi2
                enddo doj2
                !$OMP END DO
                enddo dok2

            else cd5

                !$OMP MASTER
                call SetError (FATAL_, INTERNAL_, "Modify_HorizontalWaterFlow - Hydrodynamic - ERR01")        
                !$OMP END MASTER

            endif cd5

        endif cd3

        !$OMP BARRIER

cd6:    if (Me%ComputeOptions%BaroclinicRadia == Horizontal_) then 

            CHUNK = CHUNK_J(JLB, JUB + dj)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doj3:   do j = JLB, JUB + dj
    doi3:   do i = ILB, IUB + di
                
cd9:            if (ImposedNormalFacesUV(i, j, KUB) == Imposed) then



                    if      (BoundaryPoints(i - di, j - dj) == Boundary) then



                        ic = i - di
                        jc = j - dj 
                
                    else if (BoundaryPoints(i     , j     ) == Boundary) then

                        ic = i 
                        jc = j 

                    endif

                    Kbottom = KFloor_Z(ic, jc)

                    TotalFlux = 0.

            dok3:   do k = Kbottom, KUB 


                        ![m^3/s]              = [ ] * [m/s] * [m] * [m]
                        WaterFlux_XY(i, j, k) = (dble(Me%WaterFluxes%New_Old)                     *         &
                                                dble(Baroclinic_UV_New (i, j, k))  +         &
                                                dble((1. - Me%WaterFluxes%New_Old))               *         &
                                                dble(Baroclinic_UV_Old(i, j, k)))  *         &
                                                dble(DWZ(ic, jc, k)) * dble(DYY_XX(i, j))

!                        WaterFlux_XY(i, j, k) = dble(Baroclinic_UV_New (i, j, k))  *         &
!                                                dble(DWZ(ic, jc, k)) * dble(DYY_XX(i, j))


                        TotalFlux = TotalFlux + WaterFlux_XY(i, j, k)

                    enddo dok3


            dok5:   do k = Kbottom, KUB 

                        dz = dble(SZZ(ic, jc, k       - 1) - SZZ(ic, jc, k  )) /         &
                             dble(SZZ(ic, jc, kbottom - 1) - SZZ(ic, jc, KUB))

                        ![m^3/s]              = [ ] * [m/s] * [m^2]
                        WaterFlux_XY(i, j, k) = WaterFlux_XY(i, j, k) -                  &
                                                TotalFlux * dz
                    enddo dok5

                    
                                            
                endif cd9

                
cd10:           if (ImposedTangentialFacesUV(i, j, KUB) == Imposed) then

                    Kbottom = KFloor_UV(i, j)

                    TotalFlux = 0.

            dok4:   do k = Kbottom, KUB 

                        ![m^3/s]              = [ ] * [m/s] * [m^2]
                        WaterFlux_XY(i, j, k) = (dble(Me%WaterFluxes%New_Old)                     *         &
                                                dble(Baroclinic_UV_New (i, j, k))  +         &
                                                dble((1. - Me%WaterFluxes%New_Old))               *         &
                                                dble(Baroclinic_UV_Old(i, j, k)))  *         &
                                                Area_UV(i, j, k)

!                        ![m^3/s]              = [ ] * [m/s] * [m^2]
!                        WaterFlux_XY(i, j, k) = dble(Baroclinic_UV_New (i, j, k))  *         &
!                                                Area_UV(i, j, k)


                        TotalFlux = TotalFlux + WaterFlux_XY(i, j, k)

                    enddo dok4

   
            dok6:   do k = Kbottom, KUB 

                        dz = dble(DUZ_VZ(i, j, k)) / dble(WaterColumnUV(i, j))

                        ![m^3/s]              = [ ] * [m/s] * [m^2]
                        WaterFlux_XY(i, j, k) = WaterFlux_XY(i, j, k) -                  &
                                                TotalFlux * dz

                    enddo dok6

                                            
                endif cd10


            enddo doi3
            enddo doj3
            !$OMP END DO

        
        endif cd6
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_HorizontalWaterFlow")
        endif

        if (Me%CyclicBoundary%ON) then
        
        
            if (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                Me%CyclicBoundary%Direction == DirectionXY_)  then
                call CyclicBoundVectNormal    ( VectorD = WaterFlux_XY)
            endif

            if (Me%CyclicBoundary%Direction == Me%Direction%YX .or. &
                Me%CyclicBoundary%Direction == DirectionXY_)  then
                call CyclicBoundVectTangential( VectorD = WaterFlux_XY)
            endif

        endif


        nullify (WaterFlux_XY)
        nullify (Velocity_UV_Old)

        nullify (ComputeFaces3D_UV       )
        nullify (KFloor_UV               )
        nullify (KFloor_Z                )
        nullify (Area_UV                 ) 
        nullify (ImposedNormalFacesUV    )
        nullify (ImposedTangentialFacesUV)
        nullify (DYY_XX                  )
        nullify (DWZ                     )
        nullify (Baroclinic_UV_New       )
        nullify (Baroclinic_UV_Old       )
        nullify (SZZ                     )
        nullify (WaterColumnUV           )
        nullify (DUZ_VZ                  )
        
        !A if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Modify_HorizontalWaterFlow")

    end Subroutine Modify_HorizontalWaterFlow

    !------------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the density gradient integral                               !
    !  for both horizontal directions : X and Y                                            ! 
    !                                                                                      !
    ! Input : Geometry, Mapping, density                                                   !
    ! OutPut: Rox3 - density gradient integral                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Modify_ROX3 (SigmaDens, Rox3XY)

        !Arguments------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: SigmaDens, Rox3XY

        !Local----------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: DWZ, DUZ_VZ, SZZ

        real,    dimension(:,:  ), pointer :: DZX_ZY, Coriolis_Freq, DUX_VY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:  ), pointer :: BoundaryFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV
        Integer                            :: i, j, di, dj, k, kbottom, ileft, jleft

        Integer, dimension( : ), pointer   :: Kleft,Kright

        Real(8), dimension( : ), pointer   :: Depth_integ, Hcenter, Hleft, &
                                              Hright, HroLeft, HroRight,   &
                                              DensRight, DensLeft

        Real(8)                            :: DAux,DAuxRight,DAuxLeft, AuxRight, AuxLeft, &
                                              ZRight, ZLeft, DRight, DLeft, DensZRight, DensZLeft

        type (T_Time)                      :: CurrentTime

        Real                               :: TimeCoef, F_UV, DT_RunPeriod, InertialPeriods

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        integer                            :: NRight, NLeft, kbright, kbleft, PoliDegree

        logical                            :: FoundBottomRight, FoundBottomLeft, FoundSurfaceRight, FoundSurfaceLeft
        logical                            :: BaroclinicRAMP, BoundaryBaroclinic, PoliIsEven
        !$ integer                            :: CHUNK
        integer                            :: TID
        !griflet
        type(T_Coef_Baroc), pointer        :: LocalBaroc
        
    !------------initialization----
        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Modify_ROX3")


        !$ CHUNK = CHUNK_J(JLB,JUB)

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV
        BoundaryFacesUV   => Me%External_Var%BoundaryFacesUV
        KFloor_UV         => Me%External_Var%KFloor_UV

        DWZ               => Me%External_Var%DWZ
        SZZ               => Me%External_Var%SZZ
        DUZ_VZ            => Me%External_Var%DUZ_VZ
        DZX_ZY            => Me%External_Var%DZX_ZY  
        DUX_VY            => Me%External_Var%DUX_VY  

        !End - Shorten variables name

        call SetMatrixValue(Rox3XY, Me%WorkSize, FillValueReal)

!        Kleft             = FillValueInt   !rcm 7
!        Kright            = FillValueInt
!
!        Depth_integ       = FillValueReal
!        Hcenter           = FillValueReal
!        Hleft             = FillValueReal
!        Hright            = FillValueReal
!        HroLeft           = FillValueReal
!        HroRight          = FillValueReal

    !------------Main cicle--------

         !griflet
         !$ CHUNK = CHUNK_J(JLB,JUB)
         ! We don't compute turbulence coefficients at the limits of the domain. 
         !$OMP PARALLEL &
         !$OMP PRIVATE(i,j,k,kbottom,ileft,jleft,       &
         !$OMP         Kleft, Kright, Depth_integ,      &
         !$OMP         Hcenter, Hleft, Hright,          &
         !$OMP         HroLeft, HroRight,               &
         !$OMP         DensRight, DensLeft,             &
         !$OMP         DAuxRight, DAuxLeft, DAux,       &
         !$OMP         Zright, Zleft,                   &
         !$OMP         Dright, Dleft,                   &
         !$OMP         AuxRight, AuxLeft,               &
         !$OMP         DensZRight, DensZLeft,           &
         !$OMP         NRight, NLeft,                   &
         !$OMP         kbright, kbleft,                 &
         !$OMP         PoliDegree, PoliIsEven,          &
         !$OMP         FoundBottomRight, FoundBottomLeft,   & 
         !$OMP         FoundSurfaceRight, FoundSurfaceLeft, &
         !$OMP         TID, LocalBaroc)
         !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do4:     do j = JLB, JUB
do5:     do i = ILB, IUB

            TID = 1
            !$ TID = 1 + omp_get_thread_num();
            LocalBaroc => Me%Coef%Baroc(TID)

            Kleft             => LocalBaroc%Kleft
            Kright            => LocalBaroc%Kright
            Depth_integ       => LocalBaroc%Depth_integ
            Hcenter           => LocalBaroc%Hcenter
            Hleft             => LocalBaroc%Hleft
            Hright            => LocalBaroc%Hright
            HroLeft           => LocalBaroc%HroLeft
            HroRight          => LocalBaroc%HroRight
            DensRight         => LocalBaroc%DensRight
            DensLeft          => LocalBaroc%DensLeft

cd1:        if (ComputeFaces3D_UV(i, j, KUB)== Covered) then 

do7:            do k = KLB, KUB
                    Kleft      (k)       = FillValueInt    !rcm 8
                    Kright     (k)       = FillValueInt

                    Depth_integ(k)       = FillValueReal
                    Hcenter    (k)       = FillValueReal
                    Hleft      (k)       = FillValueReal
                    Hright     (k)       = FillValueReal
                    HroLeft    (k)       = FillValueReal
                    HroRight   (k)       = FillValueReal

                    DensRight  (k)       = FillValueReal
                    DensLeft   (k)       = FillValueReal 
                end do do7


                kbottom = KFloor_UV(i, j)

                ileft = i - di
                jleft = j - dj

                call calc_depth_and_Hro (Hcenter, Hleft, Hright, HroLeft, HroRight,     &
                                         DensRight, DensLeft, DWZ, SZZ, DUZ_VZ, SigmaDens,&
                                         i, j, ileft, jleft, KUB, kbottom)

                if      (Me%ComputeOptions%BaroclinicMethod == MARSALEIX) then

                     HroRight(KUB+1) = 0.
                     HroLeft (KUB+1) = 0.      

                     HRight(KUB+1)   = 0.
                     HLeft (KUB+1)   = 0.      

do23:                do  k=KUB, kbottom,-1

                        !pressure in the lower face
                        HroRight(k) = HroRight(k + 1) + dble(SigmaDens(i    ,j    ,k)) * dble(DWZ (    i,    j,  k))
                        Hroleft (k) = Hroleft (k + 1) + dble(SigmaDens(ileft,jleft,k)) * dble(DWZ (ileft, jleft, k))

                        !depth of lower face
                        HRight(k)   = HRight  (k + 1) + dble(DWZ (    i,    j,  k))
                        HLeft (k)   = HLeft   (k + 1) + dble(DWZ (ileft, jleft, k))

                        !pressure in the center cell
                        DAuxRight  =  (HroRight(k) + HroRight(k+1)) / 2.
                        DAuxLeft   =  (HroLeft (k) + HroLeft (k+1)) / 2.

                        !depth of the cell center
                        Zright     =  (Hright(k) + Hright(k+1)) / 2.
                        Zleft      =  (Hleft (k) + Hleft (k+1)) / 2.

                        !Along the iso-sigma
                        DAux       =  (DAuxRight - DAuxLeft)/ dble(DZX_ZY(ileft, jleft))

                        !Correction for the cartesian space
                        Rox3XY(i,j,k) = Daux + (SigmaDens(i, j, k) + SigmaDens(ileft, jleft, k)) * &
                                        (Zright - Zleft) / dble(DZX_ZY(ileft, jleft)) / 2.

                    enddo do23                    
                    
                endif 

                if      (Me%ComputeOptions%BaroclinicMethod == DensityUniform  .or.     &
                         Me%ComputeOptions%BaroclinicMethod == DensityLinear) then

                    call Calc_Depth_integration(Hcenter, Hleft, Hright,                 &
                                                Kleft, Kright, Depth_integ, KUB, kbottom) 



do6:                do  k=KUB, kbottom,-1

                        Zright   = Depth_integ    (k)  - Hright (kright(k) + 1)    
                        Dright   = Hright (kright (k)) - Hright (kright(k) + 1)

                        Zleft    = Depth_integ    (k)  - Hleft  (kleft (k) + 1)    
                        Dleft    = Hleft  (kleft  (k)) - Hleft  (kleft (k) + 1)

                              

                        if      (Me%ComputeOptions%BaroclinicMethod == DensityUniform) then

                            !Constant SigmaDens in each layer

                            AuxRight = Zright / Dright

                            AuxLeft  = Zleft  / Dleft


                            ![M/m^3 * m]  = [M/m^3 * m]               
                            DAuxRight=     HroRight(kright(k) + 1)                        + &
                                          (HroRight(kright(k)) - HroRight(kright(k) + 1)) * &
                                           AuxRight

                            DAuxLeft =     Hroleft (kleft (k) + 1)                        + &
                                          (Hroleft(kleft  (k)) - Hroleft(kleft(k)  + 1))  * &
                                           AuxLeft

                        else if (Me%ComputeOptions%BaroclinicMethod == DensityLinear) then

                            !Linear SigmaDens evolution in each layer
                            DensZRight = (DensRight(kright(k)    ) *  Zright/2.          +  &
                                          DensRight(kright(k) + 1) * (Dright-Zright/2.)) /  &
                                          Dright

                            DensZLeft  = (DensLeft(kLeft  (k)    ) *  ZLeft/2.           +  &
                                          DensLeft(kLeft  (k) + 1) * (DLeft-ZLeft/2.))   /  &
                                          DLeft
                        

                            ![M/m^3 * m]  = [M/m^3 * m]               
                            DAuxRight  =  HroRight (kright(k) + 1) + DensZRight * Zright

                            DAuxLeft   =  Hroleft  (kleft (k) + 1) + DensZLeft  * ZLeft

                        endif

                        ! DAuxLeft (i or i -1, j-1 or j) - DAuxRight (i,j)
                        DAux     =     DAuxLeft - DAuxRight

                        ![M/m^3] =     [M/m^3 * m] / [m]              
                        DAux     =     DAux/dble(DZX_ZY(ileft, jleft))

                        !if Rox3 is positive then the baroclinic force is positive 
                        !in the pass was the opposite but to maintain coherence with the 
                        !other pressure forces now (Rox3 = (DAuxLeft - DAuxRight)/dxy) 
                        !in the pass (Rox3 = (- DAuxLeft + DAuxRight)/dxy)
                        Rox3XY(i,j,k) = real(DAux)

                enddo do6                    

            endif
                    
                    
            if (Me%ComputeOptions%BaroclinicMethod == Leibniz .or.                     &
                Me%ComputeOptions%BaroclinicMethod == Leibniz2) then

                Rox3XY(i,j,KUB +1) = 0.

                kbright = Me%External_Var%KFloor_Z(i, j)

                NRight = KUB - kbright + 1

                kbleft = Me%External_Var%KFloor_Z(ileft, jleft)


                Hright  (KUB+1) = null_real
                Hleft   (KUB+1) = null_real

                DensRight(KUB+1)   = null_real
                DensLeft (KUB+1)   = null_real                
                
                do k = KUB , kbright, -1
                   Hright  (k) = (dble(SZZ (  i,       j, k)) + dble(SZZ (    i,     j, k-1))) / 2.
                   DensRight(k) = dble(SigmaDens(i    ,j    ,k  ))
                enddo

                do k = KUB , kbleft , -1
                   Hleft   (k) = (dble(SZZ (ileft, jleft, k)) + dble(SZZ (ileft, jleft, k-1))) / 2.
                   DensLeft (k) = dble(SigmaDens(ileft,jleft,k  ))
                enddo   

                NLeft  = KUB - kbLeft + 1

do27:           do  k=KUB, kbottom,-1

                    if      (Me%ComputeOptions%BaroclinicMethod == Leibniz) then

                        !Linear interpolation
                        DensZRight = InterpolateProfileR8 (Hcenter(k), NRight, Hright(kbright:KUB),  &
                                                           DensRight(kbright:KUB), FoundBottomRight, &
                                                           FoundSurfaceRight)
                    
                        DensZLeft  = InterpolateProfileR8 (Hcenter(k), NLeft , HLeft (kbleft :KUB),  &
                                                           DensLeft (kbleft :KUB), FoundBottomLeft , &
                                                           FoundSurfaceLeft )

                        if (.not. FoundBottomRight .and. .not. FoundBottomLeft                       &
                            .and. .not.FoundSurfaceRight .and. .not. FoundSurfaceLeft) then

                            DAux       =  (DensZLeft - DensZRight) * DUZ_VZ(i, j, k)  / dble(DZX_ZY(ileft, jleft))

                        else
                            DAux = 0.
                        endif

                    else if (Me%ComputeOptions%BaroclinicMethod == Leibniz2) then

                        if ( (KUB - kbright) == 0) then
                            !Uniform profile is assumed when there only one layer
                            DensZRight = DensRight(KUB)
                        else
                            !Interpolation n degree
                            PoliDegree = min (Me%ComputeOptions%BaroclinicPoliDegree, KUB - kbright)

                            if(IsOdd(PoliDegree))then
                                PoliIsEven = .false.
                            else
                                PoliIsEven = .true.
                            endif

                            DensZRight = PolIntProfile  (Hcenter(k), NRight, Hright(kbright:KUB), &
                                                         DensRight(kbright:KUB), PoliDegree,      &
                                                         PoliIsEven)
                        endif

                        if ( (KUB - kbleft ) == 0) then
                            !Uniform profile is assumed when there only one layer
                            DensZLeft  = DensLeft (KUB)
                        else
                            !Interpolation n degree
                            PoliDegree = min (Me%ComputeOptions%BaroclinicPoliDegree, KUB - kbleft )

                            if(IsOdd(PoliDegree))then
                                PoliIsEven = .false.
                            else
                                PoliIsEven = .true.
                            endif

                            DensZLeft  = PolIntProfile  (Hcenter(k), NLeft , HLeft (kbleft :KUB), &
                                                         DensLeft (kbleft :KUB), PoliDegree,      &
                                                         PoliIsEven)
                        endif

                        DAux       =  (DensZLeft - DensZRight) * DUZ_VZ(i, j, k)  / dble(DZX_ZY(ileft, jleft))

                    endif

                    Rox3XY(i,j,k) = Rox3XY(i,j,k+1) + DAux

                enddo do27

            endif

            end if cd1

        enddo do5
        enddo do4
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        !If the baroclinic force is not to be consider in the boundary then
        BoundaryBaroclinic = Me%ComputeOptions%BoundaryBaroclinic
        
!        if (MonitorPerformance) then
!            call StartWatch ("ModuleHydrodynamic", "Modify_ROX3")
!        endif
        
cd10:   if ( .not. BoundaryBaroclinic ) then 

            !$ CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(I,J,K,kbottom)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do41:       do J = JLB, JUB
do51:       do I = ILB, IUB
                    
cd11:           if (BoundaryFacesUV(i, j) == Boundary) then 

                    kbottom = KFloor_UV(i, j)

do61:               do  K = kbottom, KUB

                        Rox3XY (i, j, k) = 0.
                    
                    enddo do61

                endif cd11

            enddo do51
            enddo do41       
            !$OMP END DO
            !$OMP END PARALLEL

        endif cd10

        !If the RAMP option is on then the baroclinic force is gradually imposed
        BaroclinicRAMP = Me%ComputeOptions%BaroclinicRAMP

cd12:   if ( BaroclinicRAMP ) then 

            CurrentTime  = Me%CurrentTime

            DT_RunPeriod = CurrentTime - Me%ComputeOptions%RAMP_BeginTime

            if (Me%ComputeOptions%RampPeriod>0.) then            
                TimeCoef = DT_RunPeriod / Me%ComputeOptions%RampPeriod            
            endif

            InertialPeriods = Me%ComputeOptions%InertialPeriods

            Coriolis_Freq => Me%External_Var%Coriolis_Freq

            !$ CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(I,J,K,ileft,jleft,F_UV,TimeCoef,kbottom)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do42:       do J = JLB, JUB
do52:       do I = ILB, IUB

cd13:           if (ComputeFaces3D_UV(i, j, KUB)== Covered) then

                    ileft = i - di
                    jleft = j - dj

                    ! Interpolates Coriolis_Freq for the face 
                    F_UV = (DUX_VY(ileft, jleft) * Coriolis_Freq(I, J) + DUX_VY(I, J) * Coriolis_Freq(ileft, jleft)) / &
                           (DUX_VY(ileft, jleft) + DUX_VY(I, J))
                           
                    if (Me%ComputeOptions%RampPeriod<0.) then
                        TimeCoef = abs (DT_RunPeriod * F_UV / (2 * Pi) / InertialPeriods)
                    endif                        

cd14:               if (TimeCoef < 1) then
                    
                        kbottom = KFloor_UV(i, j)

do62:                   do  K = kbottom, KUB

                            Rox3XY (i, j, k) = TimeCoef * Rox3XY (i, j, k)
                    
                        enddo do62

                    endif cd14

                endif cd13

            enddo do52
            enddo do42
            !$OMP END DO
            !$OMP END PARALLEL
            
            nullify (Coriolis_Freq)

        endif cd12

!        if (MonitorPerformance) then
!            call StopWatch ("ModuleHydrodynamic", "Modify_ROX3")
!        endif
        
        !Nullify auxiliar pointers
        nullify (Kleft)
        nullify (Kright)
        nullify (Depth_integ)
        nullify (Hcenter)
        nullify (Hleft)
        nullify (Hright)
        nullify (HroLeft)
        nullify (HroRight)
        nullify (DensRight)
        nullify (DensLeft )


        nullify (ComputeFaces3D_UV)
        nullify (BoundaryFacesUV)
        nullify (KFloor_UV)

        nullify (DWZ, SZZ)
        nullify (DZX_ZY)
        nullify (DUX_VY)  
        nullify (DUZ_VZ)

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Modify_ROX3")

    End Subroutine Modify_ROX3



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine relaxes 3D hydrodynamic properties of single precision for a         !
    ! specific value                                                                       !
    !                                                                                      !
    ! Input : Hydrodynamic Property compute by the model                                   !
    ! OutPut: Hydrodynamic Property after assimilation                                     !
    ! Author: Paulo Chambel & Manuel Ruiz Villarreal  (2000/12)                                                              !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine HydroPropAssimilation3D( PropertyID, PropModel,           &
                                       PropSubModel, Map3D, KFloor, DT)

        !Arguments------------------------------------------------------------


        real,    dimension(:,:,:), pointer :: PropModel, PropSubModel

        integer, dimension(:,:,:), pointer :: Map3D

        integer, dimension(:,:),   pointer :: KFloor

        real                               :: DT

        integer                            :: PropertyID

        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: DecayTime
        
        real,    dimension(:,:,:), pointer :: PropAssimilation

        type(T_Time)                       :: CurrentTime, EndTime, BeginTime

        real                               :: ColdPeriod, ColdOrder, CoefCold, DT_RunPeriod, AuxDecay
    
        integer                            :: I, J, K, Kbottom

        integer                            :: IUB, JUB, KUB, ILB, JLB, KLB, status
        
        integer                            :: CHUNK  

    !------------initialization----


        !Begin - Shorten variables name         
        
        IUB = Me%WorkSize%IUB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        ILB = Me%WorkSize%ILB
        JLB = Me%WorkSize%JLB
        KLB = Me%WorkSize%KLB

        EndTime     = Me%EndTime 

        BeginTime   = Me%BeginTime 

        CurrentTime = Me%CurrentTime

        !End - Shorten variables name         


        if (associated(PropSubModel)) then

            PropAssimilation => PropSubModel
            ColdPeriod       =  0.

        else

            call GetAssimilationField(Me%ObjAssimilation,                               &
                                      ID              = PropertyID,                     &
                                      Field3D         = PropAssimilation,               &
                                      STAT            = status)

            if (status /= SUCCESS_)                                                     &

                call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation3D - Hydrodynamic - ERR01")

        endif

        call GetAssimilationCoef (Me%ObjAssimilation,                                   &
                                  ID          = PropertyID,                             &
                                  CoefField3D = DecayTime,                              &
                                  ColdRelaxPeriod = ColdPeriod,                         &
                                  ColdOrder       = ColdOrder,                          &
                                  STAT        = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation3D - Hydrodynamic - ERR02")


        DT_RunPeriod = CurrentTime - BeginTime

        if (ColdPeriod > (EndTime - BeginTime))                                         &
            call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation3D - Hydrodynamic - ERR03")

        if (ColdPeriod <= DT_RunPeriod) then
            CoefCold = 1
        else
            CoefCold = (DT_RunPeriod / ColdPeriod) ** ColdOrder
            if (CoefCold < 1.e-32) CoefCold = 1.e-32
        endif

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "HydroPropAssimilation3D")

        !$OMP PARALLEL PRIVATE(I,J,K,kbottom,AuxDecay)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB
            
cd2:        if (Map3D(I, J, KUB) == Covered ) then 

                kbottom = KFloor(I, J)                            

do3:            do K=kbottom, KUB

                    AuxDecay = CoefCold  * DT / DecayTime(i, j, k)                   

                    PropModel(i, j, k) = (PropModel (i, j, k)                  +         &
                                        AuxDecay * PropAssimilation(i, j, k))  /         &
                                        (1 + AuxDecay)

                enddo do3
                            
            endif cd2
                 
        enddo do2
        enddo do1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "HydroPropAssimilation3D")

        call UnGetAssimilation(Me%ObjAssimilation, DecayTime,        &
                               STAT        = status)

        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation3D - Hydrodynamic - ERR04")

        if (.not. associated(PropSubModel)) then

            call UnGetAssimilation(Me%ObjAssimilation, PropAssimilation,    &
                                   STAT        = status)

            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation3D - Hydrodynamic - ERR05")

        else

            nullify(PropAssimilation)

        endif
 

    End Subroutine HydroPropAssimilation3D


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine relaxes 2D hydrodynamic properties of single precision for a         !
    ! specific value                                                                       !
    !                                                                                      !
    ! Input : Hydrodynamic Property computed by the model                                   !
    ! OutPut: Hydrodynamic Property after assimilation                                     !
    ! Author: Manuel & Paulo(2000/12)                                                              !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine HydroPropAssimilation2D( PropertyID, PropModel, PropSubModel, Map3D, DT)

        !Arguments------------------------------------------------------------


        real,    dimension(:,:  ), pointer :: PropModel, PropSubModel

        integer, dimension(:,:,:), pointer :: Map3D

        real                               :: DT

        integer                            :: PropertyID

        !Local---------------------------------------------------------------------
        real,    dimension(:,:  ), pointer :: DecayTime
        
        real,    dimension(:,:  ), pointer :: PropAssimilation
        
        type(T_Time)                       :: CurrentTime, EndTime, BeginTime

        real                               :: ColdPeriod, ColdOrder, CoefCold, DT_RunPeriod, AuxDecay, AuxProp
    
        integer                            :: I, J

        integer                            :: IUB, JUB, KUB, ILB, JLB, status
        integer                            :: CHUNK

    !------------initialization----


        !Begin - Shorten variables name         
        
        IUB = Me%WorkSize%IUB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        ILB = Me%WorkSize%ILB
        JLB = Me%WorkSize%JLB


        EndTime     = Me%EndTime 

        BeginTime   = Me%BeginTime 

        CurrentTime = Me%CurrentTime

        !End - Shorten variables name         

        if (associated(PropSubModel)) then

            PropAssimilation => PropSubModel

        else

            call GetAssimilationField(Me%ObjAssimilation,                               &
                                      ID              = PropertyID,                     &
                                      Field2D         = PropAssimilation,               &
                                      STAT            = status)

            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation2D - Hydrodynamic - ERR01")

        endif

        call GetAssimilationCoef (Me%ObjAssimilation,                                   &
                                  ID          = PropertyID,                             &
                                  CoefField2D = DecayTime,                              &
                                  ColdRelaxPeriod = ColdPeriod,                         &
                                  ColdOrder       = ColdOrder,                          &
                                  STAT        = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation2D - Hydrodynamic - ERR02")


        DT_RunPeriod = CurrentTime - BeginTime

        if (ColdPeriod > (EndTime - BeginTime))                                         &
            call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation3D - Hydrodynamic - ERR03")

        if (ColdPeriod <= DT_RunPeriod) then
            CoefCold = 1
        else
            CoefCold = (DT_RunPeriod / ColdPeriod) ** ColdOrder
            if (CoefCold < 1.e-32) CoefCold = 1.e-32
        endif

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "HydroPropAssimilation2D")

        !$OMP PARALLEL PRIVATE(I,J,AuxDecay,AuxProp)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB

cd2:        if (Map3D(I, J, KUB) == Covered ) then 

                AuxDecay = CoefCold  * DT / DecayTime(i, j)                   
                
                AuxProp = PropAssimilation(i, j)

                PropModel(i, j) = (PropModel (i, j) + AuxDecay * AuxProp)  / (1 + AuxDecay)
                       
            endif cd2
                 
        enddo do2
        enddo do1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "HydroPropAssimilation2D")

        call UnGetAssimilation(Me%ObjAssimilation, DecayTime, STAT = status)
        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation2D - Hydrodynamic - ERR04")

        if (.not. associated(PropSubModel)) then

            call UnGetAssimilation(Me%ObjAssimilation, PropAssimilation,    &
                                   STAT        = status)

            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation2D - Hydrodynamic - ERR05")
                    
        else


            nullify(PropAssimilation)

        endif

 

    End Subroutine HydroPropAssimilation2D


    Subroutine VelocityRelaxation

        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Velocity_UV_New, SubModel_UV_New
        
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV

        integer, dimension(:,:),   pointer :: KFloor_UV 

        integer                            :: Vel_ID

    !------------initialization----

        !Begin - Shorten variables name         
        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV            => Me%External_Var%KFloor_UV

        Velocity_UV_New      => Me%Velocity%Horizontal%UV%New

       !End - Shorten variables name   


        nullify (SubModel_UV_New)
      
        if      (Me%Direction%XY == DirectionX_) then

            !call GetAssimilationList(VelocityU = Vel_ID)
            Vel_ID = VelocityU_
            if (Me%SubModel%ON)                                             &
                SubModel_UV_New => Me%SubModel%U_New

        else if (Me%Direction%XY == DirectionY_) then

            !call GetAssimilationList(VelocityV = Vel_ID)
            Vel_ID = VelocityV_
            if (Me%SubModel%ON)                                             &
                SubModel_UV_New => Me%SubModel%V_New

        endif


        call HydroPropAssimilation ( Vel_ID, Velocity_UV_New,            &
                                    SubModel_UV_New, ComputeFaces3D_UV, KFloor_UV,       &
                                    Me%Velocity%DT)


        nullify(Velocity_UV_New  )
        nullify(KFloor_UV        )
        nullify(ComputeFaces3D_UV)


    End Subroutine VelocityRelaxation        
    !----------------------------------------------------------------

    Subroutine WaterLevelRelaxation

        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real,    dimension(:,:  ), pointer :: WaterLevel_New, SubModel_Z
        
        integer, dimension(:,:,:), pointer :: OpenPoints3D

        integer, dimension(:,:),   pointer :: KFloor_Z 

        integer                            :: Vel_ID

    !------------initialization----

        !Begin - Shorten variables name         
        OpenPoints3D        => Me%External_Var%OpenPoints3D

        KFloor_Z            => Me%External_Var%KFloor_Z

        WaterLevel_New      => Me%WaterLevel%New

       !End - Shorten variables name   
      
        !call GetAssimilationList(WaterLevel = Vel_ID)
        Vel_ID = WaterLevel_
        nullify (SubModel_Z)
        
        if (Me%SubModel%ON)                                                 &
            SubModel_Z => Me%SubModel%Z


        call HydroPropAssimilation ( Vel_ID, WaterLevel_New, SubModel_Z, &
                                    OpenPoints3D, Me%WaterLevel%DT)


        nullify(WaterLevel_New   )
        nullify(KFloor_Z         )
        nullify(OpenPoints3D     )
        nullify(SubModel_Z       )


    End Subroutine WaterLevelRelaxation        
    !----------------------------------------------------------------

    !----------------------------------------------------------------

    Subroutine  WaterLevelRelaxationAltimetry

        !Local -----------------------------------------------------------------
        real,    pointer, dimension(:,:)            :: LevelAnalyzed
        real                                        :: AltimDecayTime
        integer                                     :: ILB, IUB 
        integer                                     :: JLB, JUB 
        integer                                     :: KLB, KUB
        integer                                     :: I, J
        real                                        :: AuxDecay

        !Begin shorten variable names ----------------------------------------------

        if (MonitorPerformance)                                                         &
            call StartWatch ("ModuleHydrodynamic", "WaterLevelRelaxationAltimetry")

        ILB = Me%WorkSize%ILB 
        IUB = Me%WorkSize%IUB 
        JLB = Me%WorkSize%JLB 
        JUB = Me%WorkSize%JUB 
        KLB = Me%WorkSize%KLB 
        KUB = Me%WorkSize%KUB 

        LevelAnalyzed => Me%External_Var%AltimWaterLevelAnalyzed
        AltimDecayTime = Me%External_Var%AltimDecayTime

cd2:    if( Me%ComputeOptions%AltimetryAssimilation%flag)  then

            !Testar o tempo a ver se e agora que se assimila
            !Se for entao assimilar (nudge)
            if (Me%CurrentTime .ge. Me%ComputeOptions%AltimetryAssimilation%NextCompute) then

                ! C(t+dt) = (C(t) + Cref*dt/Tref) / (1 + dt / Tref) -> Implicit
                 
                !Nudging Water Level.     
                do j = JLB, JUB
                do i = ILB, IUB
                    
                    if (Me%External_Var%OpenPoints3D(i, j, KUB) == OpenPoint) then

                        AuxDecay = Me%ComputeOptions%AltimetryAssimilation%DT_Compute   &
                                     / AltimDecayTime

                        Me%WaterLevel%New(i, j) = (Me%WaterLevel%New(i, j) +            &
                                                   LevelAnalyzed(i, j) *                &
                                                   AuxDecay) / (1. + AuxDecay)
                    endif
                                  

                enddo
                enddo 
                       
                Me%ComputeOptions%AltimetryAssimilation%NextCompute =                   &
                        Me%ComputeOptions%AltimetryAssimilation%NextCompute  +          &
                        Me%ComputeOptions%AltimetryAssimilation%DT_Compute

            endif

        else cd2

                Me%ComputeOptions%AltimetryAssimilation%NextCompute  =                  &
                            Me%CurrentTime                                              & 
                            + Me%ComputeOptions%AltimetryAssimilation%DT_Compute

                Me%ComputeOptions%AltimetryAssimilation%flag = .true.
        
        end if cd2

        if (MonitorPerformance)                                                         &
            call StopWatch ("ModuleHydrodynamic", "WaterLevelRelaxationAltimetry")

    End Subroutine WaterLevelRelaxationAltimetry        
    !----------------------------------------------------------------

    !----------------------------------------------------------------
    Subroutine calc_depth_and_Hro (Hcenter, Hleft, Hright, HroLeft, HroRight,           &
                                   DensRight, DensLeft, DWZ, SZZ, DUZ_VZ, SigmaDens,    &
                                   i, j, ileft, jleft, KUB, kbottom)

        

        !Arguments
        Integer,  intent(in )              :: i, j, ileft, jleft, KUB, kbottom
        
        !griflet: these arguments are intent(out)
        Real(8), pointer,  dimension ( : ) :: Hleft, Hright, Hcenter, HroLeft, HroRight, DensRight, DensLeft
        
        !griflet: these arguments are intent(in)
        Real, pointer, dimension(:, :, :)  :: DWZ, DUZ_VZ, SigmaDens, SZZ

        !Local variable
        Integer     :: k

        !integer                            :: CHUNK

        !Begin---------------------------------------------------------------------


        if (Me%ComputeOptions%BaroclinicMethod == Leibniz .or. Me%ComputeOptions%BaroclinicMethod == Leibniz2) then

            Hcenter (KUB+1) = null_real           
            Hcenter (KUB  ) = (dble(SZZ (i, j, KUB)) + dble(SZZ (ileft, jleft, KUB))) / 2. + dble(DUZ_VZ( i, j, KUB) / 2.) 
            
            do k = KUB-1 , kbottom, -1
                Hcenter(k)  = Hcenter(k+1) + dble(DUZ_VZ( i, j, k+1) / 2.) + dble(DUZ_VZ( i, j, k) / 2.) 
            enddo
 
        else

            Hcenter (KUB+1) = 0           
            Hcenter (KUB  ) = dble(DUZ_VZ( i, j, KUB) / 2.) 

            do k = KUB-1 , kbottom, -1
                Hcenter(k)  = Hcenter(k+1) + dble(DUZ_VZ( i, j, k+1) / 2.) + dble(DUZ_VZ( i, j, k) / 2.) 
            enddo

            Hright  (KUB+1) = 0.0 !rcm 9
            Hleft   (KUB+1) = 0.0

            do k = KUB , kbottom, -1
               Hright  (k) = Hright  (k + 1) + dble(DWZ ( i, j, k))
               Hleft   (k) = Hleft   (k + 1) + dble(DWZ (ileft, jleft, k))
            enddo


            HroRight(KUB+1) = 0.0
            Hroleft (KUB+1) = 0.0


            if      (Me%ComputeOptions%BaroclinicMethod == DensityUniform) then

               
                do k = KUB , kbottom, -1
                   HroRight(k) = HroRight(k + 1) + dble(SigmaDens(i    ,j    ,k)) * dble(DWZ (    i,    j,  k))
                   Hroleft (k) = Hroleft (k + 1) + dble(SigmaDens(ileft,jleft,k)) * dble(DWZ (ileft, jleft, k))
                enddo                       

        
            else if (Me%ComputeOptions%BaroclinicMethod == DensityLinear) then

                DensRight(KUB+1)   = dble(SigmaDens(i    ,j    ,KUB    ))
                DensLeft (KUB+1)   = dble(SigmaDens(ileft,jleft,KUB    ))

                DensRight(kbottom) = dble(SigmaDens(i    ,j    ,kbottom))
                DensLeft (kbottom) = dble(SigmaDens(ileft,jleft,kbottom))

                !griflet: I want to parallelize the calling subroutine, so I un-parallelize the call-ee.
                !CHUNK = CHUNK_K(kbottom+1, KUB)

                !if (MonitorPerformance) then
                !    call StartWatch ("ModuleHydrodynamic", "Calc_depth_and_Hro")
                !endif

                !!!! $OMP PARALLEL PRIVATE(k)
                !!!! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = kbottom+1, KUB
                   DensRight(k) = (dble(SigmaDens(i    ,j    ,k  )) * dble(DWZ (    i,    j,  k-1)) +  &
                                   dble(SigmaDens(i    ,j    ,k-1)) * dble(DWZ (    i,    j,  k  ))) / &
                                  (dble(DWZ    (i    ,j    ,k-1)) + dble(DWZ (    i,    j,  k  )))

                   DensLeft (k) = (dble(SigmaDens(ileft,jleft,k  )) * dble(DWZ (ileft,jleft,  k-1)) +  &
                                   dble(SigmaDens(ileft,jleft,k-1)) * dble(DWZ (ileft,jleft,  k  ))) / &
                                  (dble(DWZ    (ileft,jleft,k-1)) + dble(DWZ (ileft,jleft,  k  )))
                enddo
                !!!! $OMP END DO
                !!!! $OMP END PARALLEL

                !if (MonitorPerformance) then
                !    call StopWatch ("ModuleHydrodynamic", "Calc_depth_and_Hro")
                !endif

                DensRight(kbottom : KUB+1) =  DensRight(kbottom : KUB+1)
                DensLeft (kbottom : KUB+1) =  DensLeft (kbottom : KUB+1)

                do k = KUB , kbottom, -1
                   HroRight(k) = HroRight(k + 1) + (DensRight(k+1) + DensRight(k)) / 2. * dble(DWZ (    i,    j,  k))
                   Hroleft (k) = Hroleft (k + 1) + (DensLeft (k+1) + DensLeft (k)) / 2. * dble(DWZ (ileft, jleft, k))
                enddo

            endif

        endif

    End subroutine calc_depth_and_Hro

    !-------------------------------------------------

    subroutine Calc_Depth_integration(Hcenter, Hleft, Hright,  &
                                      Kleft, Kright, Depth_integ, KUB, kbottom)

        

        ! External variables

        Integer, intent(in )             :: KUB, kbottom
        
        !griflet: these arguments are intent(out)
        Real(8), pointer, dimension( : ) :: Hleft, Hright, Hcenter
        Integer, pointer, dimension( : ) :: kleft, kright        
        Real(8), pointer, dimension( : ) :: Depth_integ
        
        ! Internal

        Integer  :: k    

        !------------------------------------------------------------------------

!        Depth_integ = 0 !rcm 10
!        kleft       = 0
!        kright      = 0

dok:     do k=KUB,kbottom,-1

          kleft (k) = Locate_Layer(KUB, kbottom, Hcenter(k), Hleft )
          kright(k) = Locate_Layer(KUB, kbottom, Hcenter(k), Hright)

          Depth_integ(k)= min(Hcenter(k), Hleft(kleft (k)), Hright(kright(k)) )

          kleft (k) = Locate_Layer (KUB, kbottom, Depth_integ(k), Hleft )
          kright(k) = Locate_Layer (KUB, kbottom, Depth_integ(k), Hright)

        enddo dok

    end subroutine Calc_Depth_integration

    !--------------------------------------------------------------------

    function Locate_Layer (KUB, kbottom, Zpoint, Zside)
    Integer  :: Locate_Layer

        ! External variables

        Integer,   intent(in )                       :: KUB, kbottom
        Real(8),   pointer, dimension(:)             :: Zside
        Real(8), intent(in)                          :: Zpoint
        ! Internal 
        Integer                   :: k_Locate_Layer

        k_Locate_Layer = KUB

        Do While ( (Zside(k_Locate_Layer) < Zpoint) .and. (k_Locate_Layer > kbottom) )
            k_Locate_Layer = k_Locate_Layer -1
        Enddo 

        Locate_Layer=k_Locate_Layer

    end function Locate_Layer

    !--------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Compute the vertical water flow                                                      !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_VerticalWaterFlow( Grid)

        !Variables Categories  
            !Geometry  : Volume_Z_New, Volume_Z_Old
            !Flow      : WaterFlux_X, WaterFlux_Y, WaterFlux_Z
            !Mapping   : ComputeFaces3D_U, ComputeFaces3D_V
 
        !Arguments------------------------------------------------------------

        integer                            :: Grid

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_Z_New, Volume_Z_Old, WaterFlux_X,   &
                                              WaterFlux_Y, WaterFlux_Z, DischargeFlow,   &
                                              qX, qY

        real,    dimension(:,:)  , pointer :: DXX, DYY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_U, ComputeFaces3D_V,        &
                                              WaterPoints3D,                             &
                                              ImposedNormalFacesU, ImposedNormalFacesV,  &
                                              ImposedTangentialFacesU,                   &
                                              ImposedTangentialFacesV

        integer, dimension(:,:  ), pointer :: BoundaryPoints

!        real                               :: DT_Elevation, Evolution
        real                               :: Evolution, DT
        real(8)                            :: dVdt, Discharge,                           &
                                              WestFlux, EastFlux, SouthFlux, NorthFlux

        logical                            :: DischargesON
    
        integer                            :: I, J, K, IUB, ILB, JUB, JLB, KUB, KLB
        integer                            :: STAT_CALL

        integer                            :: CHUNK

        !Begin--------------------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

!        DT_Elevation = Me%WaterLevel%DT
        call GetComputeTimeStep(Me%ObjTime, DT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Modify_VerticalWaterFlow - ModuleHydrodynamic - ERR00.'


        Volume_Z_New      => Me%External_Var%Volume_Z_New
        Volume_Z_Old      => Me%External_Var%Volume_Z_Old

        ComputeFaces3D_U  => Me%External_Var%ComputeFaces3D_U
        ComputeFaces3D_V  => Me%External_Var%ComputeFaces3D_V
        WaterPoints3D     => Me%External_Var%WaterPoints3D

        WaterFlux_X       => Me%WaterFluxes%X
        WaterFlux_Y       => Me%WaterFluxes%Y
        WaterFlux_Z       => Me%WaterFluxes%Z
        DischargeFlow     => Me%WaterFluxes%Discharges

        ImposedNormalFacesU      => Me%External_Var%ImposedNormalFacesU
        ImposedTangentialFacesU  => Me%External_Var%ImposedTangentialFacesU
        ImposedNormalFacesV      => Me%External_Var%ImposedNormalFacesV
        ImposedTangentialFacesV  => Me%External_Var%ImposedTangentialFacesV
        BoundaryPoints           => Me%External_Var%BoundaryPoints 
        DYY                      => Me%External_Var%DYY
        DXX                      => Me%External_Var%DXX
        qX                       => Me%SubModel%qX
        qY                       => Me%SubModel%qY


        !End - Shorten variables name 



        !Compute volume variation if the grid is not fixed
        if (Grid == Variable) then 

            Evolution = 1.

        else if (Grid == Fix) then 

            Evolution = 0.

        else 

            stop 'Subroutine Modify_VerticalWaterFlow; Module ModuleHydrodynamic. ERR01'

        endif

        DischargesON = .false.

        Discharge    = 0.

        if (associated(DischargeFlow)) then

            DischargesON = .true.

        endif

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_VerticalWaterFlow")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,dVdt,Discharge,WestFlux,EastFlux,SouthFlux) &
        !$OMP PRIVATE(NorthFlux)

        !Fluxes divergence
dok3:   do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj3:   do j = JLB, JUB
doi3:   do i = ILB, IUB
!            dVdt =  dble(Evolution) * (Volume_Z_New(i, j, k) - Volume_Z_Old(i, j, k)) / &
!                    dble(DT_Elevation )
            dVdt =  dble(Evolution) * (Volume_Z_New(i, j, k) - Volume_Z_Old(i, j, k)) / &
                    dble(DT)
                    !E preciso alterar esta parte para que se possa calcular fluxos verticais independentemente
                    !de como sao calculados os fluxos horizontais

            if (DischargesON) Discharge = DischargeFlow (i    , j    , k)


            WaterFlux_Z(i, j, k + 1) = WaterFlux_Z          (i    , j    , k)     +      &  !Bottom Face
                                       WaterFlux_X          (i    , j    , k)     *      &
                                       dble(ComputeFaces3D_U(i    , j    , k))    -      &  !West Face
                                       WaterFlux_X          (i    , j + 1, k)     *      &
                                       dble(ComputeFaces3D_U(i    , j + 1, k))    +      &  !East Face   
                                       WaterFlux_Y          (i    , j    , k)     *      &
                                       dble(ComputeFaces3D_V(i    , j    , k))    -      &  !South Face
                                       WaterFlux_Y          (i + 1, j    , k)     *      &
                                       dble(ComputeFaces3D_V(i + 1, j    , k))    +      &  !North Face
                                       Discharge                                  *      &  
                                       dble(WaterPoints3D   (i    , j    , k))    -      &  !Discharges contribution
                                       dVdt

        enddo doi3
        enddo doj3
        !$OMP END DO
        enddo dok3

cd5:    if (Me%SubModel%ON) then

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)

            !Fluxes divergence
            doj4: do j = JLB, JUB
            doi4: do i = ILB, IUB
                                
                                                
cd4:            if (BoundaryPoints(i, j) == Boundary) then

                    dok4: do k = KLB, KUB
                                
                            dVdt =  dble(Evolution) * (Volume_Z_New(i, j, k) - Volume_Z_Old(i, j, k)) / &
                                dble(DT)

                            if (DischargesON) Discharge = DischargeFlow (i    , j    , k)


                            !West Face
                            WestFlux = WaterFlux_X(i, j, k) * dble(ComputeFaces3D_U(i, j, k)) + &
                                       qX         (i, j, k) * dble(DYY             (i, j   )) * &
                                       (dble(ImposedNormalFacesU    (i,   j, k))              + &
                                        dble(ImposedTangentialFacesU(i,   j, k)))

                            !East Face
                            EastFlux = WaterFlux_X(i, j+1, k) * dble(ComputeFaces3D_U(i, j+1, k)) + &
                                       qX         (i, j+1, k) * dble(DYY             (i, j+1))    * &
                                       (dble(ImposedNormalFacesU    (i, j+1, k))                  + &
                                        dble(ImposedTangentialFacesU(i, j+1, k)))



                            !South Face
                            SouthFlux = WaterFlux_Y(i, j, k) * dble(ComputeFaces3D_V (i, j, k)) + &
                                        qY         (i, j, k) * dble(DXX              (i, j))    * &
                                       (dble(ImposedNormalFacesV    (i  , j, k))                + &
                                        dble(ImposedTangentialFacesV(i  , j, k)))


                            !North Face
                            NorthFlux = WaterFlux_Y(i+1, j, k) * dble(ComputeFaces3D_V (i+1, j, k)) + &
                                        qY         (i+1, j, k) * dble(DXX              (i+1, j))    * &
                                       (dble(ImposedNormalFacesV    (i+1, j, k))                    + &
                                        dble(ImposedTangentialFacesV(i+1, j, k)))



                            WaterFlux_Z(i, j, k + 1) = WaterFlux_Z          (i    , j    , k)      + &  !Bottom Face
                                                       WestFlux - EastFlux + SouthFlux - NorthFlux + &  
                                                       Discharge                                   * &  
                                                       dble(WaterPoints3D   (i    , j    , k))     - &  !Discharges contribution
                                                       dVdt

                        enddo dok4
                    endif cd4
        
            enddo doi4
            enddo doj4
            !$OMP END DO
        

        endif cd5

        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_VerticalWaterFlow")
        endif

        !Nullify auxiliar pointers 
        nullify(Volume_Z_New)
        nullify(Volume_Z_Old)

        nullify(ComputeFaces3D_U)
        nullify(ComputeFaces3D_V)
        nullify(WaterPoints3D   )

        nullify(WaterFlux_X)
        nullify(WaterFlux_Y)
        nullify(WaterFlux_Z)
        nullify(DischargeFlow)

        nullify(ImposedNormalFacesU    )
        nullify(ImposedTangentialFacesU)
        nullify(ImposedNormalFacesV    )
        nullify(ImposedTangentialFacesV)
        nullify(BoundaryPoints         )
        nullify(DYY                    )
        nullify(DXX                    )
        nullify(qX                     )
        nullify(qY                     )

    end Subroutine Modify_VerticalWaterFlow

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Filter the vertical and horizontal Fluxes                                            !
    !                                                                                      !
    ! Input : Flow, Mapping                                                                !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (99/6)                                                         !
    ! Main Objective: To imposed vertical flux null at the Z boundary points               !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Filter_3D_Fluxes 
        !Variables Categories  
            !Flow      : WaterFlux_Z
            !Mapping   : BoundaryPoints
        !Local---------------------------------------------------------------------
        integer                            :: I, J, K
        integer                            :: CHUNK

        !Begin--------------------------------------------------------------------------
 
        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
 
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Filter_3D_Fluxes")
        endif
 
        !$OMP PARALLEL PRIVATE(i,j,k)
        do k = Me%WorkSize%KLB, Me%WorkSize%KUB 
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            !Vertical flux null at the open boundary points
            Me%WaterFluxes%Z(i, j, k + 1) = Me%WaterFluxes%Z(i, j, k + 1) *    &
                                            (1. - Me%External_Var%BoundaryPoints(i, j))
        enddo
        enddo
        !$OMP END DO
        enddo
        !$OMP END PARALLEL
 
        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Filter_3D_Fluxes")
        endif
 
    end subroutine Filter_3D_Fluxes

    !------------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Defines a boundary condition for the vertical water fluxes in the boundary
    !                                                                                      !
    ! Input : Flow, Mapping                                                                !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (2001/6)                                                       !
    ! Main Objective: To imposed radiation boundary condition in the baroclinic            !
    !                 component of the vertical flux at the Z boundary points              !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Boundary_VerticalFlow ( Grid)

        !Arguments------------------------------------------------------------

        integer                            :: Grid

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_X, WaterFlux_Y
        real   , dimension(:,:  ), pointer :: DZX, DZY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_U, ComputeFaces3D_V
        integer, dimension(:,:  ), pointer :: BoundaryFacesU, BoundaryFacesV, BoundaryPoints
   
        integer                            :: I, J, IUB, ILB, JUB, JLB, KUB

        integer                            :: CHUNK
        
        !Begin--------------------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        DZX               => Me%External_Var%DZX
        DZY               => Me%External_Var%DZY

        BoundaryFacesU    => Me%External_Var%BoundaryFacesU
        BoundaryFacesV    => Me%External_Var%BoundaryFacesV
        BoundaryPoints    => Me%External_Var%BoundaryPoints 

        ComputeFaces3D_U  => Me%External_Var%ComputeFaces3D_U
        ComputeFaces3D_V  => Me%External_Var%ComputeFaces3D_V

        WaterFlux_X       => Me%WaterFluxes%X
        WaterFlux_Y       => Me%WaterFluxes%Y

        !End - Shorten variables name 


        if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_)        &
            call ComputeBaroclinicVertVelocity( Grid)

        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Boundary_VerticalFlow")
        endif
        
        !$OMP PARALLEL PRIVATE(i,j)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
   do1: do j = JLB, JUB
   do2: do i = ILB, IUB

            if (BoundaryFacesU(i, j) == Boundary .and. ComputeFaces3D_U(i, j, KUB) == Covered) then


                if (BoundaryPoints(i, j) == Boundary) then

                    call Compute_BoundaryVertFlux( WaterFlux_XY = WaterFlux_X,  &
                                                  WaterFlux_YX = WaterFlux_Y,                   &
                                                  i = i, j = j, di = 0, dj = 1, db = 1) 


                else

                    call Compute_BoundaryVertFlux( WaterFlux_XY = WaterFlux_X,  &
                                                  WaterFlux_YX = WaterFlux_Y,                   &
                                                  i = i, j = j, di = 0, dj = 1, db = 0) 
                endif



            endif

        enddo do2
        enddo do1
        !$OMP END DO

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do3:    do j = JLB, JUB
do4:    do i = ILB, IUB

            if (BoundaryFacesV(i, j) == Boundary .and. ComputeFaces3D_V(i, j, KUB) == Covered) then

                if (BoundaryPoints(i, j) == Boundary) then

                    call Compute_BoundaryVertFlux( WaterFlux_XY = WaterFlux_Y, &
                                                  WaterFlux_YX = WaterFlux_X,                  &
                                                  i = i, j = j, di = 1, dj = 0, db = 1)               
                else

                    call Compute_BoundaryVertFlux( WaterFlux_XY = WaterFlux_Y, &
                                                  WaterFlux_YX = WaterFlux_X,                  &
                                                  i = i, j = j, di = 1, dj = 0, db = 0) 

                endif
                

            endif

        enddo do4
        enddo do3
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Boundary_VerticalFlow")
        endif

        !Nullify auxiliar pointers 
        nullify(DZX , DZY       )
        nullify(ComputeFaces3D_U)
        nullify(ComputeFaces3D_V)
        nullify(BoundaryFacesU  )
        nullify(BoundaryFacesV  )
        nullify(BoundaryPoints  )

        nullify(WaterFlux_X     )
        nullify(WaterFlux_Y     )

    end Subroutine Boundary_VerticalFlow

    !------------------------------------------------------------------------------

    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Defines a boundary condition for the vertical water fluxes in the boundary
    !                                                                                      !
    ! Input : Flow, Mapping                                                                !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (2001/6)                                                       !
    ! Main Objective: To imposed radiation boundary condition in the baroclinic            !
    !                 component of the vertical flux at the Z boundary points              !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Compute_BoundaryVertFlux ( WaterFlux_XY, WaterFlux_YX,    &
                                         i, j, di, dj, db) 

        !Arguments------------------------------------------------------------

        real(8), dimension(:,:,:), pointer :: WaterFlux_XY, WaterFlux_YX
        integer                            :: i, j, di, dj, db

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_Z
        real   , dimension(:,:,:), pointer :: Velocity_Z, Vel_Z_Cartesian,               &
                                              Vel_Z_Baroclinic, SZZ, Density,            &
                                              Vel_Z_BaroclinicOld
        real   , dimension(:,:  ), pointer :: WaterLevel_New, WaterLevel_Old, DUX, DVY
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_W
        integer, dimension(:,:  ), pointer :: KFloor_Z

        real                               :: Vel_Z_BoundBarot,                          &
                                              Vel_Z_B_BarocUp,  Vel_Z_B_BarocLow
        real                               :: DT_Elevation
        real(8)                            :: BarotBoundFlux, BarocBoundFlux,            &
                                              DivBarocFlux, dz
   
        integer                            :: ib, jb, i_int, j_int, K, KUB, i_int2, j_int2, i_ext, j_ext
        integer                            :: i_Tang1, j_Tang1, i_Tang2, j_Tang2
        integer                            :: kbottom

        !Begin--------------------------------------------------------------------------


        !Begin - Shorten variables name 
        KUB = Me%WorkSize%KUB


        DT_Elevation        =  Me%WaterLevel%DT

        DUX                 => Me%External_Var%DUX
        DVY                 => Me%External_Var%DVY

        KFloor_Z            => Me%External_Var%KFloor_Z
        SZZ                 => Me%External_Var%SZZ

        Density             => Me%External_Var%Density
        ComputeFaces3D_W    => Me%External_Var%ComputeFaces3D_W

        Velocity_Z          => Me%Velocity%Vertical%Across
        Vel_Z_Cartesian     => Me%Velocity%Vertical%Cartesian
        Vel_Z_Baroclinic    => Me%VelBaroclinic%W_New
        Vel_Z_BaroclinicOld => Me%VelBaroclinic%W_Old

        WaterFlux_Z         => Me%WaterFluxes%Z
        WaterLevel_New      => Me%WaterLevel%New
        WaterLevel_Old      => Me%WaterLevel%Old


        !End - Shorten variables name 


        ib    = i - di * (1- db)
        jb    = j - dj * (1- db)

        i_int = i - di * db
        j_int = j - dj * db

        i_int2 = i - di * (3 * db - 1)
        j_int2 = j - dj * (3 * db - 1)

        i_ext  = i + di * (2 * db - 1)
        j_ext  = j + dj * (2 * db - 1)

        i_tang1  = i_ext * (1 - db) + i     * db  
        j_tang1  = j_ext * (1 - db) + j     * db  

        i_tang2  = i + di * (db - 1) + dj
        j_tang2  = j + dj * (db - 1) + di

        kbottom = KFloor_Z(ib, jb)

        BarotBoundFlux = 0.

dok1:   do k = kbottom, KUB


            !Compute the vertical velocity induced by the 
            !water level variation barotropic. 
            !To this vertical velocity is called 
            !vertical barotropic velocity
            BarotBoundFlux = BarotBoundFlux + WaterFlux_XY(i, j, k) 

        enddo dok1

        Vel_Z_B_BarocLow = 0.


dok2:   do k = kbottom + 1, KUB + 1

            ![m/s]           = ([m] - [m]) / [s] * [m] / [m]
            Vel_Z_BoundBarot =  (WaterLevel_New(ib, jb) -  WaterLevel_Old(ib, jb)) / &
                                 DT_Elevation                                      * &
                                (SZZ(ib, jb, kbottom - 1) - SZZ(ib, jb, k - 1))   /  &
                                (SZZ(ib, jb, kbottom - 1) - SZZ(ib, jb, KUB)) 

cd1:        if (Me%ComputeOptions%BaroclinicRadia == Horizontal_) then 

                ![]= [m] / [m]
                dz = dble(SZZ(ib, jb, k - 2) - SZZ(ib, jb, k - 1))    /              &
                     dble(SZZ(ib, jb, kbottom - 1) - SZZ(ib, jb, KUB)) 

            

                ![m^3/s]       = [m^3/s] - [m^3/s] * []
                BarocBoundFlux = WaterFlux_XY(i, j, k - 1) - BarotBoundFlux * dz

                DivBarocFlux   = (2*db - 1) * (BarocBoundFlux - WaterFlux_XY(i_ext, j_ext, k - 1))

                !PCL
                DivBarocFlux   = DivBarocFlux + WaterFlux_YX(i_Tang1, j_Tang1, k - 1) - WaterFlux_YX(i_Tang2, j_Tang2, k - 1)

                Vel_Z_B_BarocUp  = DivBarocFlux / DUX(ib, jb) / DVY(ib, jb) + Vel_Z_B_BarocLow

                Vel_Z_B_BarocLow = Vel_Z_B_BarocUp

            else

                Vel_Z_B_BarocUp = 0.

            endif cd1 


            !Compute the vertical velocity relatively to the grid
            !When the cartesian velocity is compute in the routine "ComputeCartesianVelocity"
            !the across grid velocity in the boundary points is consider zero so the 
            !Vel_Z_Cartesian(ib, jb, k) only consider the mesh velocity in the boundary points

            !Vel_Z_Cartesian(ib, jb, k) - is temporarlly the grid velocity in the boundary points


            !Across Velocity           = (cartesian = barotropic + baroclinic) - Grid velocity
            Velocity_Z(ib, jb, k)      = Vel_Z_BoundBarot + Vel_Z_B_BarocUp - Vel_Z_Cartesian(ib, jb, k)

            !In this way the cartesian velocity is computed in a realistic way in the boundary points
            Vel_Z_Cartesian(ib, jb, k) = Vel_Z_BoundBarot + Vel_Z_B_BarocUp

            !The water flux across grid is also compute for the boundary points
            WaterFlux_Z(ib, jb, k)     = Velocity_Z(ib, jb, k) * DUX(ib, jb) * DVY(ib, jb)



        enddo dok2


        !Nullify auxiliar pointers 
        nullify(DUX, DVY           )
        nullify(KFloor_Z           )
        nullify(ComputeFaces3D_W   )
        nullify(SZZ                )
        nullify(Density            )
        nullify(Velocity_Z         )
        nullify(Vel_Z_Cartesian    )
        nullify(Vel_Z_Baroclinic   )
        nullify(Vel_Z_BaroclinicOld)

        nullify(WaterFlux_Z        )
        nullify(WaterLevel_New     )
        nullify(WaterLevel_Old     )
 
    end Subroutine Compute_BoundaryVertFlux

    !------------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine ComputeCartesianVertVelocity(Grid, MeshSlope)

        !Arguments-------------------------------------------------------------
        integer, optional                   :: Grid                             
        logical, optional                   :: MeshSlope

        !Local-----------------------------------------------------------------
        real(8), dimension(:,:,:), pointer  :: Volz_old, Volum_z
        real,    dimension(:,:,:), pointer  :: Velocity_W_Cartesian, Velocity_W_Across,  &
                                               uavar, vavar           
        real   , dimension(:,:  ), pointer  :: WaterLevel_New, WaterLevel_Old
        integer, dimension(:,:,:), pointer  :: ComputeFaces3D_U, ComputeFaces3D_V,       &
                                               ComputeFaces3D_W, WaterPoints3D

        integer, dimension(:,:  ), pointer  :: BoundaryPoints

        real                                :: velusup, veluinf, velu, velvsup, velvinf, velv, &
                                               dt, dszdt, szzxp1, dzxp1, szzxm1, dzxm1, dszdx, &
                                               szzyp1, dzyp1, szzym1, dzym1, dszdy

        integer                             :: IUB,ILB,JUB,JLB,KUB,KLB, i, j, k

        real,    dimension(:,:  ), pointer  :: dzx, dzy, dux, dvy
        real,    dimension(:,:,:), pointer  :: dwz, szz

        logical                             :: MeshVelocity_, MeshSlope_

        integer                             :: CHUNK

        !Begin-----------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        Velocity_W_Cartesian    => Me%Velocity%Vertical%Cartesian
        Velocity_W_Across       => Me%Velocity%Vertical%Across
        uavar                   => Me%Velocity%Horizontal%U%New
        vavar                   => Me%Velocity%Horizontal%V%New
        dt                      =  Me%Waterlevel%DT
        ComputeFaces3D_U        => Me%External_Var%ComputeFaces3D_U
        ComputeFaces3D_V        => Me%External_Var%ComputeFaces3D_V
        ComputeFaces3D_W        => Me%External_Var%ComputeFaces3D_W
        WaterPoints3D           => Me%External_Var%WaterPoints3D
        BoundaryPoints          => Me%External_Var%BoundaryPoints
        Volz_old                => Me%External_Var%Volume_Z_Old
        Volum_z                 => Me%External_Var%Volume_Z_New
        dzx                     => Me%External_Var%DZX
        dzy                     => Me%External_Var%DZY
        dux                     => Me%External_Var%DUX
        dvy                     => Me%External_Var%DVY
        dwz                     => Me%External_Var%DWZ
        szz                     => Me%External_Var%SZZ

                               
        WaterLevel_New          => Me%WaterLevel%New
        WaterLevel_Old          => Me%WaterLevel%Old        

        ! ciclo a todos os pontos interiores

        dszdt = 0.
        velu  = 0.
        dszdx = 0.
        velv  = 0.
        dszdy = 0.


        if (Present(Grid)) then

            if      (Grid == Variable) then 

                MeshVelocity_ = .true.

            else if (Grid == Fix     ) then

                MeshVelocity_ = .false.

            endif

        else

            MeshVelocity_ = .true.

        endif

        if (Present(MeshSlope)) then

            MeshSlope_ = MeshSlope

        else

            MeshSlope_ = .true.

        endif

        CHUNK = CHUNK_I(ILB, IUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ComputeCartesianVertVelocity")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,dszdt,szzxp1,dzxp1,szzxm1,dzxm1,dszdx) &
        !$OMP PRIVATE(szzyp1,dzyp1,szzym1,dzym1,dszdy,velusup,veluinf,velvsup) &
        !$OMP PRIVATE(velvinf,velu,velv)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do i = ILB, IUB
do2:    do j = JLB, JUB
            dszdt=0.0

            if (WaterPoints3D(i, j, KUB) == WaterPoint) then

                Velocity_W_Cartesian(i,j,KUB+1)= (WaterLevel_New(i,j)-WaterLevel_Old(i,j)) / dt

            endif

do3:        do k = KLB, KUB
                            
cd1:            if (ComputeFaces3D_W(i,j,k) == Covered ) then

                    ! mesh velocity
                    if (MeshVelocity_)                                                   &
                        dszdt  = dszdt-(volum_z(i,j,k-1)-volz_old(i,j,k-1))/dux(i,j)/dvy(i,j)/dt


cd2:                if (MeshSlope_ .and. BoundaryPoints(i, j) /= Boundary) then
                        ! mesh slope in X direction: central, progressive or regressive differences are used as a function of the
                        ! land boundary. The boundary is automatically detected in the equation through "ComputeFaces3D_W" matrix
                        szzxp1 = ComputeFaces3D_W(i,j+1,k)*szz(i,j+1,k-1)+(1-ComputeFaces3D_W(i,j+1,k))*szz(i,j,k-1)
                        dzxp1  = ComputeFaces3D_W(i,j+1,k)*dzx(i,j)
                        szzxm1 = ComputeFaces3D_W(i,j-1,k)*szz(i,j-1,k-1)+(1-ComputeFaces3D_W(i,j-1,k))*szz(i,j,k-1)
                        dzxm1  = ComputeFaces3D_W(i,j-1,k)*dzx(i,j-1)
                        if ((dzxp1+dzxm1) /= 0) then
                          dszdx=(szzxp1-szzxm1)/(dzxp1+dzxm1)
                        else
                          dszdx=0.0
                        endif

                        ! mesh slope in Y direction: central, progressive or regressive differences are used as a function of the
                        ! land boundary. The boundary is automatically detected in the equation through "ComputeFaces3D_W" matrix
                        szzyp1 = ComputeFaces3D_W(i+1,j,k)*szz(i+1,j,k-1)+(1-ComputeFaces3D_W(i+1,j,k))*szz(i,j,k-1)
                        dzyp1  = ComputeFaces3D_W(i+1,j,k)*dzy(i,j)
                        szzym1 = ComputeFaces3D_W(i-1,j,k)*szz(i-1,j,k-1)+(1-ComputeFaces3D_W(i-1,j,k))*szz(i,j,k-1)
                        dzym1  = ComputeFaces3D_W(i-1,j,k)*dzy(i-1,j)
                        if ((dzyp1+dzym1) /= 0) then
                          dszdy=(szzyp1-szzym1)/(dzyp1+dzym1)
                        else
                          dszdy=0.0
                        endif

                        ! Velocity components at cell center
                        if ((ComputeFaces3D_U(i,j,k)+ComputeFaces3D_U(i,j+1,k)) /=0) then
                            velusup=(ComputeFaces3D_U(i,j,k)*uavar(i,j,k)+ComputeFaces3D_U(i,j+1,k)*uavar(i,j+1,k))/ &
                                    (ComputeFaces3D_U(i,j,k)+ComputeFaces3D_U(i,j+1,k))
                        else
                            velusup=0.0
                        endif
                        if ((ComputeFaces3D_U(i,j,k-1)+ComputeFaces3D_U(i,j+1,k-1)) /=0) then
                            veluinf=(ComputeFaces3D_U(i,j,k-1)*uavar(i,j,k-1)+ComputeFaces3D_U(i,j+1,k-1)*uavar(i,j+1,k-1))/ &
                                    (ComputeFaces3D_U(i,j,k-1)+ComputeFaces3D_U(i,j+1,k-1))
                        else
                            veluinf=0.0
                        endif
                        velu=(velusup*dwz(i,j,k-1)+veluinf*dwz(i,j,k))/(dwz(i,j,k-1)+dwz(i,j,k))

                        if ((ComputeFaces3D_V(i,j,k)+ComputeFaces3D_V(i+1,j,k)) /=0) then
                            velvsup=(ComputeFaces3D_V(i,j,k)*vavar(i,j,k)+ComputeFaces3D_V(i+1,j,k)*vavar(i+1,j,k))/ &
                                    (ComputeFaces3D_V(i,j,k)+ComputeFaces3D_V(i+1,j,k))
                        else
                            velvsup=0.0
                        endif
                        if ((ComputeFaces3D_V(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1)) /=0) then
                            velvinf=(ComputeFaces3D_V(i,j,k-1)*vavar(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1)*vavar(i+1,j,k-1))/ &
                                    (ComputeFaces3D_V(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1))
                        else
                            velvinf=0.0
                        endif
                    
                        velv=(velvsup*dwz(i,j,k-1)+velvinf*dwz(i,j,k))/(dwz(i,j,k-1)+dwz(i,j,k))

                    else  cd2

                          dszdx=0.0
                          dszdy=0.0

                    endif cd2

                    !Cartesian vertical velocity
                    Velocity_W_Cartesian(i,j,k)=Velocity_W_Across(i,j,k) - dszdt - velu * dszdx - velv * dszdy

                endif cd1
            enddo do3
            
        enddo do2
        enddo do1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ComputeCartesianVertVelocity")
        endif

        if (Me%CyclicBoundary%ON) then
        
            call CyclicBoundVertical (Vector = Velocity_W_Cartesian)

        endif
  

        !nulify auxiliar variables
        nullify(Velocity_W_Cartesian, Velocity_W_Across, uavar, vavar, ComputeFaces3D_U, ComputeFaces3D_V, &
                ComputeFaces3D_W, Volz_old, Volum_z, dzx, dzy, dux, dvy, dwz, szz, WaterPoints3D)

        nullify(WaterLevel_New, WaterLevel_Old)

        nullify(BoundaryPoints)

    !----------------------------------------------------------------------

    end subroutine ComputeCartesianVertVelocity

    !--------------------------------------------------------------------------

    subroutine ComputeBaroclinicVertVelocity( Grid)

        !Arguments------------------------------------------------------------

        integer                            :: Grid

        !Local---------------------------------------------------------------------
        real   , dimension(:,:,:), pointer :: Vel_Z_Cartesian, Vel_Z_Baroclinic, SZZ,    &
                                              Vel_Z_BaroclinicOld
        real   , dimension(:,:  ), pointer :: WaterLevel_New, WaterLevel_Old
        integer, dimension(:,:  ), pointer :: KFloor_Z

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_W
   
        real                               :: DT_Elevation, Vel_Z_Barotropic
        integer                            :: I, J, K, IUB, ILB, JUB, JLB, KUB, kbottom

        integer                            :: CHUNK

        !Begin--------------------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        DT_Elevation         =  Me%WaterLevel%DT

        Vel_Z_Cartesian      => Me%Velocity%Vertical%Cartesian
        Vel_Z_Baroclinic     => Me%VelBaroclinic%W_New
        Vel_Z_BaroclinicOld  => Me%VelBaroclinic%W_Old

        WaterLevel_New       => Me%WaterLevel%New
        WaterLevel_Old       => Me%WaterLevel%Old

        SZZ                  => Me%External_Var%SZZ
        KFloor_Z             => Me%External_Var%KFloor_Z

        ComputeFaces3D_W     => Me%External_Var%ComputeFaces3D_W

        !End - Shorten variables name 

        if (Grid == Fix) then 
            
            Vel_Z_BaroclinicOld(:, :, :)  = Vel_Z_Baroclinic(:, :, :)

        endif

        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ComputeBaroclinicVertVelocity")
        endif
        
        !$OMP PARALLEL PRIVATE(i,j,k,kbottom,Vel_Z_Barotropic)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj:    do j=JLB, JUB
doi:    do i=ILB, IUB        
            
cd1:        if (ComputeFaces3D_W(i, j, KUB) == Covered) then
            
                kbottom = KFloor_Z(i, j)

dok:            do k = kbottom + 1, KUB

                    !Compute the vertical velocity induced by the 
                    !water level variation. 
                    !To this vertical velocity is called 
                    !vertical barotropic velocity
                    Vel_Z_Barotropic =  (WaterLevel_New(i, j) - WaterLevel_Old(i, j)) /  &
                                         DT_Elevation                                 *  &
                                        (SZZ(i, j, kbottom - 1) - SZZ(i, j, k - 1))   /  &
                                        (SZZ(i, j, kbottom - 1) - SZZ(i, j, KUB)) 

       
                    !Compute in all the vertical faces the baroclinic velocity
                    Vel_Z_Baroclinic(i, j, k)  = Vel_Z_Cartesian(i, j, k) - Vel_Z_Barotropic

                enddo dok

            endif cd1

        enddo doi
        enddo doj
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ComputeBaroclinicVertVelocity")
        endif

        !Nullify auxiliar pointers 
        nullify(KFloor_Z, SZZ      )
        nullify(Vel_Z_Cartesian    )
        nullify(Vel_Z_Baroclinic   )
        nullify(Vel_Z_BaroclinicOld)

        nullify(ComputeFaces3D_W   )
        nullify(WaterLevel_New     )
        nullify(WaterLevel_Old     )


    end Subroutine ComputeBaroclinicVertVelocity

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Compute the vertical water flow                                                      !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine Compute_VerticalVelocity 

        !Variables Categories  
            !Flow      : WaterFlux_Z, Velocity_Z
            !HorizontalGrid : DUX, DVY
        !Local---------------------------------------------------------------------
        integer                            :: I, J, K

        integer                            :: CHUNK 

        !Begin--------------------------------------------------------------------------

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Compute_VerticalVelocity")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k)

        do k = Me%WorkSize%KLB, Me%WorkSize%KUB+1
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            if (Me%External_Var%WaterPoints3D(i, j, k - 1) == 1) then

                Me%Velocity%Vertical%Across(i, j, k)  = Me%WaterFluxes%Z(i, j, k) / &
                                                        Me%External_Var%DUX(i, j) / &
                                                        Me%External_Var%DVY(i, j)

            endif

        enddo
        enddo
        !$OMP END DO
        enddo
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Compute_VerticalVelocity")
        endif

    end subroutine Compute_VerticalVelocity

    !--------------------------------------------------------------------

    
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the effect of all the explicit forces ( Baroclinic and      !
    !  barotropic water pressure, Coriolis, Atmospheric pressure,                          !
    !  Horizontal transport - covection + diffusion)                                       !
    !  in the velocity evolution                                                           !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping, Forces                                              !
    ! OutPut: TiCoef_3D                                                                    !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Velocity_ExplicitForces

        !Variables Categories
            !Geometry  : WaterLevel_New, DUX_VY, DZX_ZY
            !WaterProp : Density
            !Forces    : Inertial_Aceleration, Horizontal_Transport, ROX3, AtmPressure
            !Time      : DT_Velocity
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : TiCoef_3D

         !Variables Direction Dependent
            !DUX_VY, DZX_ZY, ComputeFaces3D_UV, KFloor_UV, Direction

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV, Horizontal_Transport,           &
                                              ECoef_3D

        real,    dimension(:,:,:), pointer :: Density, Inertial_Aceleration,             &
                                              Rox3XY, DCoef_3D, FCoef_3D, TiCoef_3D,     &
                                              Relax_Aceleration, PressureCorrect,        &
                                              Altim_Relax_Aceleration

        real,    dimension(:,:),   pointer :: DZX_ZY, DUX_VY,                            &
                                              WaterLevel_New, WaterLevel_Old,            &
                                              AtmPressure, TidePotentialLevel

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        real                               :: DT_Velocity, Alpha

        real                               :: FaceDensity, WaterPressure_Aceleration,          &
                                              AtmosphericPressure_Aceleration,                 &
                                              Barotropic_Aceleration, Baroclinic_Aceleration,  &
                                              Transport_Aceleration, TidePotentialAceleration

        integer                            :: I, J, K, kbottom, di, dj, iSouth, jWest
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        real                               :: TimeCoef, DT_RunPeriod
        real                               :: TimeCoef2
        real,    dimension(:,:  ), pointer :: Coriolis_Freq

        !$ integer                            :: CHUNK
        
        !Begin---------------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity = Me%Velocity%DT

        DCoef_3D                => Me%Coef%D3%D
        ECoef_3D                => Me%Coef%D3%E
        FCoef_3D                => Me%Coef%D3%F
        TiCoef_3D               => Me%Coef%D3%Ti

        Rox3XY                  => Me%Forces%Rox3XY
        Horizontal_Transport    => Me%Forces%Horizontal_Transport
        Inertial_Aceleration    => Me%Forces%Inertial_Aceleration
        TidePotentialLevel      => Me%Forces%TidePotentialLevel
        Relax_Aceleration       => Me%Forces%Relax_Aceleration
        Altim_Relax_Aceleration => Me%Forces%Altim_Relax_Aceleration

        WaterLevel_New          => Me%WaterLevel%New
        WaterLevel_Old          => Me%WaterLevel%Old

        PressureCorrect         => Me%NonHydrostatic%PressureCorrect

        Density                 => Me%External_Var%Density
        AtmPressure             => Me%External_Var%AtmosphericPressure

        Volume_UV               => Me%External_Var%Volume_UV

        ComputeFaces3D_UV       => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV               => Me%External_Var%KFloor_UV

        BoundaryFacesUV         => Me%External_Var%BoundaryFacesUV

        DZX_ZY                  => Me%External_Var%DZX_ZY
        DUX_VY                  => Me%External_Var%DUX_VY

        !End - Shorten variables name 


        if (Me%TidePotential%Compute) then
            
            Alpha = Me%TidePotential%Alpha

        else

            Alpha = 1.

        endif

        if (Me%ComputeOptions%AtmosphereRAMP) then
            
            TimeCoef = Me%ComputeOptions%AtmosphereCoef

        elseif (Me%ComputeOptions%BaroclinicRamp) then

            DT_RunPeriod = Me%CurrentTime - Me%ComputeOptions%RAMP_BeginTime
        
            Coriolis_Freq => Me%External_Var%Coriolis_Freq

        endif

        !$ CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Velocity_ExplicitForces")
        endif

        !griflet: removed critical. Added TimeCoef to private variables.        
        !$OMP PARALLEL PRIVATE( i,j,k,iSouth,jWest,kbottom,FaceDensity, &
        !$OMP                   WaterPressure_Aceleration,TidePotentialAceleration, &
        !$OMP                   AtmosphericPressure_Aceleration,Barotropic_Aceleration, &
        !$OMP                   Baroclinic_Aceleration,Transport_Aceleration,TimeCoef2)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj:     do j = JLB, JUB
doi:     do i = ILB, IUB

Cov1:       if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

                iSouth     = i - di
                jWest      = j - dj 

                kbottom = KFloor_UV(i, j)
                
                !griflet: this was the important step to make the
                !code thread safe. The FIRSTPRIVATE clause could have been used
                !but I'm more reliant on good old fortran logic, rather than
                !openmp logic ;)
                if (Me%ComputeOptions%atmosphereRAMP) TimeCoef2 = TimeCoef

dok:            do  k = kbottom, KUB

                    if (Me%ComputeOptions%LocalDensity) then

                        !!! $OMP CRITICAL (VEF1_FNC01)
                        FaceDensity    = Face_Interpolation(Density(i, j, k),            &
                                                            Density(iSouth, jWest, k), &
                                                            DUX_VY(i, j),                &
                                                            DUX_VY(iSouth, jWest))
                        !!! $OMP END CRITICAL (VEF1_FNC01)
                    else

                        FaceDensity    = SigmaDensityReference

                    endif


                    !Aceleration due the coriolis and centrifugal force 

                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2] 
                    TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * Inertial_Aceleration(i, j, k)  


                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2] 
                    if (Me%Relaxation%Force)   then                             
                        !!!! $OMP CRITICAL (VEF1_FNC023)
                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity *          &
                                                                  Relax_aceleration(i, j, k)  
                        !!!! $OMP END CRITICAL (VEF1_FNC023)
                    endif 

                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2] 
                    if (Me%ComputeOptions%Obstacle)                                     &
                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity *         &
                                                                  Me%Forces%ObstacleDrag_Aceleration(i, j, k)  

                    if (Me%ComputeOptions%Scraper)                                      &
                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity *         &
                                                                  Me%Forces%Scraper_Aceleration(i, j, k)  
                                                                  
                    if (Me%ThinWalls%ON .and. Me%ThinWalls%CloseFlag == 0)              &
                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity *         &
                                                                  Me%Forces%ThinWalls_Dissipation(i,j,k)


                    !Aceleration due to barotropic water Pressure 

                    ![m/s^2]                   = [m/s^2] * [m] / [m] 
                    WaterPressure_Aceleration  = Gravity * (WaterLevel_New(iSouth, jWest) - &
                                                 WaterLevel_New(i, j)) /                    &
                                                 DZX_ZY(iSouth, jWest) 

                    !Deformation "crosta terrestre" - Tide Potential
                    WaterPressure_Aceleration  = Alpha * WaterPressure_Aceleration
                                                 

                    if (Me%NonHydrostatic%ON) then
                    
                        ![m/s^2]           = [m/s^2]  +     [m^2/s^2] / [m] 
                        WaterPressure_Aceleration = WaterPressure_Aceleration +            &
                                             (1. - Me%NonHydrostatic%ThetaUV) *            &
                                             (PressureCorrect(iSouth, jWest, k) -          &
                                              PressureCorrect(i     , j    , k))/          &
                                              DZX_ZY(iSouth, jWest)  
                    endif


                    !Aceleration due the tide potential 
                    ![m/s^2]                   = [m/s^2] * [m] / [m]
                    TidePotentialAceleration   = - Gravity * (TidePotentialLevel(iSouth, jWest) - &
                                                 TidePotentialLevel(i, j)) /                      &
                                                 DZX_ZY(iSouth, jWest)
                
                
                    if (Me%ComputeOptions%AtmPressure) then
                    !Aceleration due to Atmospheric Pressure
                        ![m/s^2]                        = [M*m/s^2/m^2] / [M/m^3] / [m]
                        AtmosphericPressure_Aceleration = (AtmPressure(iSouth, jWest) - AtmPressure(i, j)) / &
                                                           FaceDensity / DZX_ZY(iSouth, jWest)           

                        if (Me%ComputeOptions%atmosphereRAMP) then
                            
                            if (TimeCoef2 < 1) then

                                AtmosphericPressure_Aceleration = TimeCoef2 * AtmosphericPressure_Aceleration

                            endif

                        endif

                    else 
                        
                        AtmosphericPressure_Aceleration = 0.

                    endif


                    !Aceleration due to Barotropic Pressure

                    Barotropic_Aceleration = WaterPressure_Aceleration + AtmosphericPressure_Aceleration + &
                                             TidePotentialAceleration

                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2] 
                    TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * Barotropic_Aceleration  

                    !Aceleration due to Baroclinic Pressure

                    ![m/s^2]               = [m/s^2] * [M/m^3] / [M/m^3]
                    Baroclinic_Aceleration = Gravity * Rox3XY(i, j, k) / FaceDensity

                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2] 
                    TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * Baroclinic_Aceleration  



                    !Aceleration due to Horizontal transport = advection + diffusion
                    ![m/s^2]              = [m^4/s^2] / [m^3]                
                    Transport_Aceleration = Horizontal_Transport (i, j, k) / Volume_UV(i, j, k)


                    !Aceleration due to Horizontal transport = advection + diffusion

                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2] 
                    TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * Transport_Aceleration  

                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2]     
                    if (Me%ComputeOptions%AltimetryAssimilation%flag .and.                          &
                        Me%CurrentTime .ge. Me%ComputeOptions%AltimetryAssimilation%NextCompute)    &
                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity *                     &
                                             Altim_Relax_Aceleration(i, j, k)  


                enddo dok      

            endif Cov1

        enddo doi
        enddo doj
        !griflet: added NOWAIT
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Velocity_ExplicitForces")
        endif

        !Nullify auxiliar pointers 
        nullify(DCoef_3D)
        nullify(ECoef_3D)
        nullify(FCoef_3D)
        nullify(TiCoef_3D)

        nullify(Rox3XY)
        nullify(Horizontal_Transport)
        nullify(Inertial_Aceleration)
        nullify(TidePotentialLevel)
        nullify(Relax_Aceleration)
        nullify(Altim_Relax_Aceleration)

        nullify(WaterLevel_New, WaterLevel_Old)

        nullify(Density)
        nullify(AtmPressure)

        nullify(Volume_UV)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)

        nullify(DZX_ZY)
        nullify(DUX_VY)
        nullify(Coriolis_Freq)

   end Subroutine Velocity_ExplicitForces

    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the vertical advection and is able to do the               !
    !  calculation explicit or implicit                                                    !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D                                              !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Velocity_VerticalAdvection 

        !Variables Categories
        ! Geometry : Volume_UV, Area_UV (Control Volume and Area for the U faces or V faces)
        ! Flow     : WaterFlux_Z (Vertical water fluxes), Velocity_UV (U or V velocity)
        ! Time     : DT_Velocity (velocity time step) 
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces) 
        ! Options  : UpStream_CenterDif (1- Upwind and 0- Centered differences), ImplicitVertAdvection (1- implict, 0- explicit)
        ! Direction: Direction (DirectionX_=1,DirectionY_=2)
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)

        !Variables dependent from the direction: 
        !Volume_UV, Area_UV, Velocity_UV, ComputeFaces3D_UV, Direction, KFloor_UV

        !Variables independent from the direction. In the future this arguments 
        !will enter the subroutine associated with modules: 
        !WaterFlux_Z, DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,            
        !DT_Velocity, UpStream_CenterDif, ImplicitVertAdvection,  
        !ILB, IUB, JLB, JUB, KUB

        !X direction 
        !call VerticalAdvection(Volume_U, Area_U, Velocity_U,             &
        !                        ComputeFaces3D_U, KFloorU, DirectionX_,      &
        !                        WaterFlux_Z,                              &
        !                        DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,          &
        !                        DT_Velocity,                              &
        !                        UpStream_CenterDif, ImplicitVertAdvection,   &
        !                        ILB, IUB, JLB, JUB, KUB)             

        !Y direction 
        !call VerticalAdvection(Volume_V, Area_V, Velocity_V,             &
        !                        ComputeFaces3D_V, KFloorV, DirectionY_,      &
        !                        WaterFlux_Z,                              &
        !                        DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,          &   
        !                        DT_Velocity,                              &
        !                        UpStream_CenterDif, ImplicitVertAdvection,   &
        !                        ILB, IUB, JLB, JUB, KUB)             



        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV, WaterFlux_Z, ECoef_3D

        real,    dimension(:,:,:), pointer :: DCoef_3D, FCoef_3D, TiCoef_3D, &
                                              Area_UV, Velocity_UV_Old

        real,    dimension(:,:  ), pointer :: DZX_ZY, WaterColumnUV, DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        real                               :: UpStream_CenterDif, ImplicitVertAdvection, WaterColumn2D

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, di, dj

        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4

        real(8)                            :: Correction, Face_Flux, MomentumFlux

        integer                            :: i, j, k, Kbottom, iSouth, jWest

        logical                            :: NearBoundary

        !griflet: needed to initialize outside of the parallel zone of the code
        real                               :: DT
        integer                            :: STAT_CALL

        !$ integer                            :: CHUNK

        !Begin---------------------------------------------------------------------


        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

!        DT_Velocity          =  Me%Velocity%DT

        UpStream_CenterDif   =  Me%ComputeOptions%UpStream_CenterDif
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        ImplicitVertAdvection   =  Me%ComputeOptions%ImplicitVertAdvection

        WaterFlux_Z          => Me%WaterFluxes%Z

        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        Volume_UV            => Me%External_Var%Volume_UV
        Area_UV              => Me%External_Var%Area_UV

        DZX_ZY               => Me%External_Var%DZX_ZY
        DYY_XX               => Me%External_Var%DYY_XX
        WaterColumnUV        => Me%External_Var%WaterColumnUV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV

        !End - Shorten variables name 

        !griflet: this call must be made outside of the parallelized zone.
        call GetComputeTimeStep(Me%ObjTime, DT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "Velocity_VerticalAdvection - ModuleHydrodynamic - ERR01")

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Velocity_VerticalAdvection")
        endif

        !$ CHUNK = CHUNK_J(JLB, JUB)

        !griflet: Ok, it is assumed that *statically* allocated arrays may be safely replicated
        !with the private directive.
        !$OMP PARALLEL PRIVATE( i,j,k,iSouth,jWest,Kbottom,Correction,      &
        !$OMP                   Face_Flux,NearBoundary,Vel4,                &
        !$OMP                   du4,V4,MomentumFlux,CFace,                  &
        !$OMP                   DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D)

        DCoef_3D             => Me%Coef%D3%D
        ECoef_3D             => Me%Coef%D3%E
        FCoef_3D             => Me%Coef%D3%F
        TiCoef_3D            => Me%Coef%D3%Ti

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj:    do j=JLB, JUB
doi:    do i=ILB, IUB

            !This if impose in the open boundary gradient null for the vertical advection
cd1:        if (    ComputeFaces3D_UV(i, j, KUB) == Covered  .and.              &
                    WaterColumnUV(i, j) > WaterColumn2D .and.                   &
                    .not. (                                                     &
                        BoundaryFacesUV  (i, j) == Boundary .and.               &
                        .not. Me%SubModel%ON .and. (                            &
                            .not. Me%CyclicBoundary%ON .or.                     &
                            (Me%CyclicBoundary%ON .and.                         &
                            Me%CyclicBoundary%Direction == Me%Direction%YX)     &
                         )                                                      &
                    )                                                           &
             ) then

                iSouth = i - di
                jWest  = j - dj

                Kbottom = KFloor_UV(i, j)

                Correction = 0.

dok1:           do  k = Kbottom + 1, KUB                              

                    Face_Flux    = (WaterFlux_Z(iSouth, jWest, k) + WaterFlux_Z(i, j, k))/2.

                    if (Me%SubModel%ON .and. BoundaryFacesUV  (i, j) == Boundary ) then

                        !GRiflet, openmp: no reduce danger.
                        Correction = VertAdvectionSubModel ( Correction, DT, i, j, k)

                        Face_Flux   = Face_Flux + Correction / 2.

                    endif
                    
                    !griflet: Falta esta linha! Sem esta linha os
                    !griflet: resultados com e sem openmp não batem certo.
                    !griflet: O problema é que com esta linha activa
                    !griflet: o meu caso teste, o pcoms, rebenta logo :(
                    !griflet: mudando o esquema de adv vertical para upwind1
                    !griflet: já corre.
                    !griflet: Podes confirmar isso Paulo? Obrigado.
                    !griflet: 2011-08-08
                    NearBoundary = .false.

                    if (Face_Flux > 0) then
                        if (k == Kbottom + 1) NearBoundary = .true.
                    else
                        if (k == KUB        ) NearBoundary = .true.
                    endif

                    Vel4(1) = Velocity_UV_Old(i, j, k - 2);
                    Vel4(2) = Velocity_UV_Old(i, j, k - 1);
                    Vel4(3) = Velocity_UV_Old(i, j, k    );
                    Vel4(4) = Velocity_UV_Old(i, j, k + 1);

                    du4(1) = Area_UV(i, j, k - 2) / DYY_XX(i, j);
                    du4(2) = Area_UV(i, j, k - 1) / DYY_XX(i, j);
                    du4(3) = Area_UV(i, j, k    ) / DYY_XX(i, j);
                    du4(4) = Area_UV(i, j, k + 1) / DYY_XX(i, j);

                    !This formulation assumes that AreaUV / VolumeUV = DZX_ZY, because
                    !is the only way of cancel the vertical diffusion and advection terms 
                    !when the water flow is considered implicit in the water level calculation. 
                    !However, this relation is not true when AreaUV is computed using the 
                    !minimum thickness metodology.    
                    !See ModuleGeometry 
                    ![s/m]                   =   [s] /  [m]
!                    DT_V                     =   DT_Velocity / (Area_UV(i, j, k) * DZX_ZY(iSouth, jWest))

                    V4   (1) = Area_UV(i, j, k - 2) * DZX_ZY(iSouth, jWest);
                    V4   (2) = Area_UV(i, j, k - 1) * DZX_ZY(iSouth, jWest);
                    V4   (3) = Area_UV(i, j, k    ) * DZX_ZY(iSouth, jWest);
                    V4   (4) = Area_UV(i, j, k + 1) * DZX_ZY(iSouth, jWest);
                    
                    !griflet: here all the variables are private including, the statically allocated arrays.
                    call ComputeAdvectionFace(Vel4, V4, du4, Me%Velocity%DT,            &
                                              Face_Flux,                                &
                                              Me%ComputeOptions%VolumeRelMax,           &
                                              Me%ComputeOptions%AdvectionMethodV,       &
                                              Me%ComputeOptions%TVD_LimV,               &
                                              NearBoundary,                             &
                                              Me%ComputeOptions%Upwind2V, CFace)



                    MomentumFlux = dble(Vel4(1) * CFace(1)  + Vel4(2) * CFace(2)  +     &
                                        Vel4(3) * CFace(3)  + Vel4(4) * CFace(4)) *     &
                                        Face_Flux ![m/s*m^3/s]

                    TiCoef_3D(i, j, k  )  = TiCoef_3D(i, j, k  ) + (1. - ImplicitVertAdvection) * &
                                            MomentumFlux * Me%Velocity%DT / V4(3)

                    TiCoef_3D(i, j, k-1)  = TiCoef_3D(i, j, k-1) - (1. - ImplicitVertAdvection) * &
                                            MomentumFlux * Me%Velocity%DT / V4(2)

                    DCoef_3D (i, j, k  )  = DCoef_3D (i, j, k  ) - ImplicitVertAdvection *  &
                                            CFace(2) * Face_Flux *  Me%Velocity%DT / V4(3)

                    ECoef_3D (i, j, k  )  = ECoef_3D (i, j, k  ) - ImplicitVertAdvection *  &
                                            CFace(3) * Face_Flux *  Me%Velocity%DT / V4(3)

                    ECoef_3D (i, j, k-1)  = ECoef_3D (i, j, k-1) + ImplicitVertAdvection *  &
                                            CFace(2) * Face_Flux *  Me%Velocity%DT / V4(2)

                    FCoef_3D (i, j, k-1)  = FCoef_3D (i, j, k-1) + ImplicitVertAdvection *  &
                                            CFace(3) * Face_Flux *  Me%Velocity%DT / V4(2)

                enddo dok1

            endif cd1

        enddo doi
        enddo doj
        !$OMP END DO
        
        !$OMP END PARALLEL
        
        !Nullify auxiliar pointers
        nullify(DCoef_3D)
        nullify(ECoef_3D)
        nullify(FCoef_3D)
        nullify(TiCoef_3D)
        
        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Velocity_VerticalAdvection")
        endif
        
        nullify(WaterFlux_Z)

        nullify(Velocity_UV_Old)

        nullify(Volume_UV)
        nullify(Area_UV  )
        nullify(DZX_ZY, DYY_XX)
        nullify(WaterColumnUV)
        
        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)
        nullify(BoundaryFacesUV)


!        Deallocate(BottomCell_BottomFace, CenterCell_BottomFace, &
!                   CenterCell_TopFace,    TopCell_TopFace)

    End Subroutine Velocity_VerticalAdvection

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Corrects the vertical flux in the boundary faces                                     !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    function VertAdvectionSubModel ( BottomFlux, DT, i, j, k)

        !Arguments------------------------------------------------------------


        real(8)               :: BottomFlux
        integer               :: i, j, k
        real(8)               :: VertAdvectionSubModel
        real                  :: DT

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: qXY, qYX, WaterFlux_XY, WaterFlux_YX,      &
                                              Volume_Z_New, Volume_Z_Old
        real   , dimension(:,:  ), pointer :: DYY_XX, DXX_YY
        integer, dimension(:,:,:), pointer :: ImposedNormalFacesUV,                      &
                                              ImposedTangentialFacesVU,                  &
                                              ComputeFaces3D_UV, ComputeFaces3D_VU

        integer, dimension(:,:  ), pointer :: BoundaryPoints

        integer                            :: di, dj
        !integer                           :: status

        !--------------------------------------------------------------------------

        !Begin - Shorten variables name 

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ImposedNormalFacesUV     => Me%External_Var%ImposedNormalFacesUV
        ImposedTangentialFacesVU => Me%External_Var%ImposedTangentialFacesVU
        DYY_XX                   => Me%External_Var%DYY_XX
        DXX_YY                   => Me%External_Var%DXX_YY
        BoundaryPoints           => Me%External_Var%BoundaryPoints 
        qXY                      => Me%SubModel%qXY
        qYX                      => Me%SubModel%qYX

        Volume_Z_New             => Me%External_Var%Volume_Z_New
        Volume_Z_Old             => Me%External_Var%Volume_Z_Old

        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        ComputeFaces3D_VU        => Me%External_Var%ComputeFaces3D_VU

        WaterFlux_XY             => Me%WaterFluxes%XY
        WaterFlux_YX             => Me%WaterFluxes%YX

        !End - Shorten variables name

        !griflet: This call to a subroutine messes up the calling parallel zone.
        !call GetComputeTimeStep(Me%ObjTime, DT, STAT = status)
        !if (status /= SUCCESS_)                                                          &
        !    call SetError (FATAL_, INTERNAL_, "VertAdvectionSubModel - Hydrodynamic - ERR01")

        !Bottom flux  - positive
        VertAdvectionSubModel = BottomFlux

cd1:    if (BoundaryPoints(i, j) == 1) then

            !Volume Variation - negative
            VertAdvectionSubModel = VertAdvectionSubModel - (Volume_Z_New(i, j, k) - Volume_Z_Old(i, j, k)) /        &
                      dble(DT)

            !Face West (Face Boundary) - positive
            VertAdvectionSubModel = VertAdvectionSubModel + dble(ComputeFaces3D_UV (i, j, k)) * WaterFlux_XY(i, j, k)

            !Face East - negative
            VertAdvectionSubModel = VertAdvectionSubModel - dble(ImposedNormalFacesUV (i + di , j + dj, k))     *    & 
                        qXY(i + di , j + dj, k) * dble(DYY_XX(i + di , j + dj))

            !Face South - positive
            if (ImposedTangentialFacesVU (i , j , k) == 1 .and.                          &
                ComputeFaces3D_VU        (i , j , k) == 1)                               &
                call SetError (FATAL_, INTERNAL_, "VertAdvectionSubModel - Hydrodynamic - ERR02")

            VertAdvectionSubModel = VertAdvectionSubModel + dble(ImposedTangentialFacesVU (i , j , k))          *    & 
                        qYX(i, j, k) * dble(DXX_YY(i , j))                               &
                      + dble(ComputeFaces3D_VU (i, j, k))                           *    &
                        WaterFlux_YX(i, j, k)


            !Face North  - negative
            if (ImposedTangentialFacesVU (i + dj , j + di, k) == 1 .and.                 &
                ComputeFaces3D_VU        (i + dj , j + di, k) == 1)                      &
                call SetError (FATAL_, INTERNAL_, "VertAdvectionSubModel - Hydrodynamic - ERR03")

            VertAdvectionSubModel = VertAdvectionSubModel - dble(ImposedTangentialFacesVU (i + dj , j + di, k)) *    & 
                        qYX(i + dj , j + di, k) * dble(DXX_YY(i + dj , j + di))          &
                      - dble(ComputeFaces3D_VU (i + dj , j + di, k))                *    &
                        WaterFlux_YX(i + dj , j + di, k)


        else if (BoundaryPoints(i - di , j - dj) == 1) then cd1

            !Volume Variation - negative
            VertAdvectionSubModel = VertAdvectionSubModel - (Volume_Z_New(i - di , j - dj, k) &
                                    - Volume_Z_Old(i - di , j - dj, k)) / dble(DT)


            !Face West - positive
            VertAdvectionSubModel = VertAdvectionSubModel + dble(ImposedNormalFacesUV (i - di , j - dj, k))     *    & 
                        qXY(i - di , j - dj, k) * dble(DYY_XX(i - di , j - dj))


            !Face East (Face Boundary) - negative
            VertAdvectionSubModel = VertAdvectionSubModel - dble(ComputeFaces3D_UV (i, j, k)) * WaterFlux_XY(i, j, k)



            !Face South - positive
            if (ImposedTangentialFacesVU (i - di, j - dj, k) == 1 .and.                  &
                ComputeFaces3D_VU        (i - di, j - dj, k) == 1)                       &
                call SetError (FATAL_, INTERNAL_, "VertAdvectionSubModel - Hydrodynamic - ERR04")

            VertAdvectionSubModel = VertAdvectionSubModel + dble(ImposedTangentialFacesVU (i - di, j - dj, k))  *    & 
                        qYX(i - di, j - dj, k) * dble(DXX_YY(i - di, j - dj))            &
                      + dble(ComputeFaces3D_VU (i - di, j - dj, k))                 *    &
                        WaterFlux_YX(i - di, j - dj, k)


            !Face North  - negative
            if (ImposedTangentialFacesVU (i - di + dj, j - dj + di, k) == 1 .and.        &
                ComputeFaces3D_VU        (i - di + dj, j - dj + di, k) == 1)             &
                call SetError (FATAL_, INTERNAL_, "VertAdvectionSubModel - Hydrodynamic - ERR05")

            VertAdvectionSubModel = VertAdvectionSubModel - dble(ImposedTangentialFacesVU (i - di + dj, j - dj + di, k)) *  & 
                        qYX(i - di + dj, j - dj + di, k) * dble(DXX_YY(i - di + dj, j - dj + di)) &
                      - dble(ComputeFaces3D_VU (i - di + dj, j - dj + di, k))         *  &
                        WaterFlux_YX(i - di + dj, j - dj + di, k)


        else  cd1 

            
            call SetError (FATAL_, INTERNAL_, "VertAdvectionSubModel - Hydrodynamic - ERR06")


        endif cd1


        !Nullify auxiliar pointers 
        nullify (ImposedNormalFacesUV    )
        nullify (ImposedTangentialFacesVU)

        nullify (ComputeFaces3D_UV       )
        nullify (ComputeFaces3D_VU       )

        nullify (DYY_XX                  )
        nullify (DXX_YY                  )

        nullify (qXY                     )
        nullify (qYX                     )
        nullify (WaterFlux_XY            )
        nullify (WaterFlux_YX            )

        nullify (Volume_Z_New)
        nullify (Volume_Z_Old)

    end function VertAdvectionSubModel

   !End ----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the vertical diffusion and is able to do the                !
    !  calculation explicit or implicit                                                    !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D                                      !
    ! Author: Paulo Chambel (99/6)                                                         !
    ! Modifications: 2001 Manuel Ruiz Villarreal, 
    !                limitation to maximum bottom viscosity   !                                                  !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Velocity_VerticalDiffusion 
        

        !Variables Categories 
        ! 3DGeometry : Volume_UV, Area_UV (Control Volume and Area for the U faces or V faces)
        ! GridGeomtry: DZX_ZY (U or V Control volume length), DUX_VY (distance between faces), DYY_XX (U or V Control Volume width) 
        ! Flow       : Velocity_UV_Old (U or V velocity), VerticalViscosity (Vertical turbulent Viscosity)
        ! Time       : DT_Velocity (velocity time step) 
        ! Mapping    : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces) 
        !
        ! Options    : UpStream_CenterDif (1 - UpStream and 0 - Centered differences), 
        !   ImplicitVertAdvection (1 - implict, 0 - explicit)
        !
        ! Direction  : Direction (DirectionX_=1,DirectionY_=2)
        ! Dimension  : ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)

        !Variables dependent from the direction: 
         !Volume_UV, Area_UV, Velocity_UV_Old, DZX_ZY, DUX_VY, DYY_DXX,    
         !VerticalViscosity, ComputeFaces3D_UV, Direction, KFloor_UV

        !Variables independent from the direction. In the future this arguments 
        !will enter the subroutine associated with modules: 
         !WaterFlux_Z, DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,            
         !DT_Velocity, ImplicitVertDiffusion,  
         !ILB, IUB, JLB, JUB, KUB


        !X direction 
        ! call VerticalDiffusion(Volume_U, Area_U, DZX, DUX, DYY,      &
        !                        VerticalViscosity, Velocity_U,        &
        !                        CoveredFacesX, DirectionX_, KFloorU,   & 
        !                        DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,      &
        !                        DT_Velocity, ImplicitVertDiffusion,       &
        !                        ILB, IUB, JLB, JUB, KUB)

        !Y direction 
        ! call VerticalDiffusion(Volume_V, Area_V, DZY, DVY, DXX,      &
        !                        VerticalViscosity, Velocity_V,        &
        !                        CoveredFacesY, DirectionY_, KFloorV,   & 
        !                        DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,      &
        !                        DT_Velocity, ImplicitVertDiffusion,       &
        !                        ILB, IUB, JLB, JUB, KUB)

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV, ECoef_3D

        real,    dimension(:,:,:), pointer :: DCoef_3D, FCoef_3D, TiCoef_3D,             &
                                              Velocity_UV_Old,                           & !DUZ_VZ                 &
                                              Vertical_Viscosity, DUZ_VZ

        real,    dimension(:,:  ), pointer :: DUX_VY, DYY_XX, DZX_ZY, WaterColumnUV

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: DT_Velocity, ImplicitVertDiffusion

        real                               :: BottomFaceViscosity,TopFaceViscosity, DT_Z, &
                                              ExplicitVerticalDiffusion, WaterColumn2D
    
        integer                            :: di, dj, i, j, k, Kbottom, iSouth, jWest

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        real(8), allocatable, dimension(:) :: BottomCell_BottomFace, CenterCell_BottomFace, &
                                              CenterCell_TopFace, TopCell_TopFace

        real                               :: DUZ_Top, DUZ_Bottom, Visc_bottom_max,      &
                                              BottomViscCoef

        integer                            :: CHUNK

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity          =  Me%Velocity%DT
        ImplicitVertDiffusion=  Me%ComputeOptions%ImplicitVertDiffusion
        BottomViscCoef       =  Me%ComputeOptions%BottomViscCoef
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        DCoef_3D             => Me%Coef%D3%D
        ECoef_3D             => Me%Coef%D3%E
        FCoef_3D             => Me%Coef%D3%F
        TiCoef_3D            => Me%Coef%D3%Ti
        
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        Volume_UV            => Me%External_Var%Volume_UV
        DUZ_VZ               => Me%External_Var%DUZ_VZ

        DUX_VY               => Me%External_Var%DUX_VY
        DYY_XX               => Me%External_Var%DYY_XX
        DZX_ZY               => Me%External_Var%DZX_ZY

        WaterColumnUV        => Me%External_Var%WaterColumnUV

        Vertical_Viscosity   => Me%External_Var%Vertical_Viscosity

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        !End - Shorten variables name 

        !T allocate(BottomCell_BottomFace(KUB), CenterCell_BottomFace(KUB), &
        !T         CenterCell_TopFace(KUB), TopCell_TopFace(KUB))               
        
        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Velocity_VerticalDiffusion")
        endif
  
        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,Kbottom,TopFaceViscosity,DUZ_Top) &
        !$OMP PRIVATE(DT_Z,BottomFaceViscosity,DUZ_Bottom) &
        !$OMP PRIVATE(visc_bottom_max,ExplicitVerticalDiffusion) &
        !$OMP PRIVATE(BottomCell_BottomFace,CenterCell_BottomFace) &
        !$OMP PRIVATE(TopCell_TopFace,CenterCell_TopFace)
  
        allocate(BottomCell_BottomFace(KUB), CenterCell_BottomFace(KUB), &
         CenterCell_TopFace(KUB), TopCell_TopFace(KUB))  
  
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth = i-di
            jWest  = j-dj

    cd1:    if (ComputeFaces3D_UV(i, j, KUB)==Covered .and.                              &
                WaterColumnUV(i,j) > WaterColumn2D) then 
                
                Kbottom          = KFloor_UV(i, j)

                TopFaceViscosity = FillValueReal
                DUZ_Top          = FillValueReal

                
    dok1:       do k = Kbottom, KUB
                    


                    !This formulation assumes that AreaUV / VolumeUV = DZX_ZY, because
                    !is the only way of cancel the vertical diffusion and advection terms 
                    !when the water flow is considered implicit in the water level calculation. 
                    !However, this relation is not true when AreaUV is computed using the 
                    !minimum thickness metodology.    
                    !See ModuleGeometry 
                    ![s/m]                   =   [s] /  [m]
                    DT_Z                     =   DT_Velocity / DUZ_VZ(i, j, k)

                    !When the faces area is compute using the average thickness metodology
                    !(See ModuleGeometry) then this relation and the above one are equal.  

                    ![s/m]                   =   [s] / [m^3] * [m] * [m]
!                    DT_Z                     =   DT_Velocity / Volume_UV(i, j, k) *      &
!                                                 DZX_ZY(iSouth, jWest) * DYY_XX(i, j)




! Manuel RV 2001 Changed!!! Vertical viscosities are calculated at faces with the notation that viscosity at bottom face 
!                           corresponds to viscosity (k)

                    BottomFaceViscosity      =   TopFaceViscosity

                    !Horizontal viscosity faces interpolation
                    TopFaceViscosity         =   (Vertical_Viscosity(i, j, k+1) * DUX_VY(iSouth, jWest)  + &
                                                 Vertical_Viscosity(iSouth, jWest, k+1) * DUX_VY(i, j)) /  &
                                                (DUX_VY(iSouth, jWest) + DUX_VY(i, j))

                    !Distance in vertical between adjacent velocity compute points.
                    DUZ_Bottom               =   DUZ_Top
                    DUZ_Top                  =  (DUZ_VZ(i, j, k) + DUZ_VZ(i, j, k + 1)) / 2.

                    !Limitation of bottom viscosity due to the semi-implicit discretization of bottom friction. MRV
                    if (Me%ComputeOptions%BottomVisc_LIM .and. k == kbottom) then

                        ![m^2/s]             =  [] * [m] * [m] / [s]
                        visc_bottom_max      =  BottomViscCoef * DUZ_VZ(i, j, k) * DUZ_Top / 2./ DT_Velocity
                        TopFaceViscosity     =  min (TopFaceViscosity , visc_bottom_max)                                            

                    end if     

!MRV New     
      
                   ![ ]                      =   [s/m]* [m^2/s] / [m]
                    BottomCell_BottomFace(k) = - DT_Z * BottomFaceViscosity / DUZ_Bottom

                   ![ ]                     =    [s/m]* [m^2/s] / [m]
                    TopCell_TopFace(k)       = - DT_Z * TopFaceViscosity    / DUZ_Top

      
                    CenterCell_BottomFace(k) = - BottomCell_BottomFace(k)

                    CenterCell_TopFace(k)    = - TopCell_TopFace(k) 
     
                enddo dok1


                !The bottom boundary conditions are imposed in another subroutine
                !see VelVerticalDiffusionBoundaries
                BottomCell_BottomFace(kbottom) = 0.

                CenterCell_BottomFace(kbottom) = 0.

                !The surface boundary conditions are imposed in another subroutine
                !see VelVerticalDiffusionBoundaries
                CenterCell_TopFace(KUB)        = 0.
      
                TopCell_TopFace(KUB)           = 0.

    dok2:       do k = kbottom, KUB

                   DCoef_3D (i, j, k)  = DCoef_3D (i, j, k) + ImplicitVertDiffusion * BottomCell_BottomFace(k)
       
                   ECoef_3D (i, j, k)  = ECoef_3D (i, j, k) + ImplicitVertDiffusion *  &
                                        (CenterCell_BottomFace(k) + CenterCell_TopFace(k))

                   FCoef_3D (i, j, k)  = FCoef_3D (i, j, k) + ImplicitVertDiffusion * TopCell_TopFace(k)

                   ExplicitVerticalDiffusion = (BottomCell_BottomFace(k) * Velocity_UV_Old(i, j, k-1)   +  &
                                               (CenterCell_BottomFace(k) +                             & 
                                                CenterCell_TopFace(k))   * Velocity_UV_Old(i, j, k)     +  &
                                                TopCell_TopFace(k)       * Velocity_UV_Old(i, j, k+1))

                   TiCoef_3D(i,j,k)  = TiCoef_3D(i,j,k) + (ImplicitVertDiffusion - 1) * ExplicitVerticalDiffusion
                         
                enddo dok2

            endif cd1

        enddo doj
        enddo doi
        !$OMP END DO
        
        Deallocate(BottomCell_BottomFace, CenterCell_BottomFace, &
           CenterCell_TopFace,    TopCell_TopFace)
        
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Velocity_VerticalDiffusion")
        endif

        !Nullify auxiliar pointers 
        nullify(DCoef_3D)
        nullify(ECoef_3D)   
        nullify(FCoef_3D)   
        nullify(TiCoef_3D)  
        
        nullify(Velocity_UV_Old)

        nullify(Vertical_Viscosity)

        nullify(DYY_XX)
        nullify(DUX_VY)
        nullify(DZX_ZY)

        nullify(WaterColumnUV)

        nullify(Volume_UV)
        nullify(DUZ_VZ   )


        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)




    End Subroutine Velocity_VerticalDiffusion

        !End-----------------------------------------------------------------------

    Subroutine Velocity_WaveStress
        

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV
        real,    dimension(:,:,:), pointer :: TiCoef_3D, Density, DUZ_VZ

        real,    dimension(:,:  ), pointer :: DUX_VY, DYY_XX, DZX_ZY, TauWaves_UV,       &
                                              WaterColumnUV

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: DT_Velocity

        real                               :: Aux_2D, TauFace, FaceDensity
    
        integer                            :: di, dj, i, j, k, Kbottom, iSouth, jWest

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity          =  Me%Velocity%DT

        TiCoef_3D            => Me%Coef%D3%Ti
        
        Volume_UV            => Me%External_Var%Volume_UV

        DUX_VY               => Me%External_Var%DUX_VY
        DYY_XX               => Me%External_Var%DYY_XX
        DZX_ZY               => Me%External_Var%DZX_ZY

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        Density              => Me%External_Var%Density

        TauWaves_UV          => Me%External_Var%TauWaves_UV
        DUZ_VZ               => Me%External_Var%DUZ_VZ
        WaterColumnUV        => Me%External_Var%WaterColumnUV

        !End - Shorten variables name 


  
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth = i-di
            jWest  = j-dj

    cd1:    if (ComputeFaces3D_UV(i, j, KUB)==Covered) then 
        
                Kbottom          = KFloor_UV(i, j)

                TauFace  = Face_Interpolation(TauWaves_UV(I,J), TauWaves_UV(iSouth, jWest), &
                                              DUX_VY(I, J), DUX_VY(iSouth, jWest))                
                ![M*m/s]   [s] * [m] * [m] * [M*m/s^2/m^2] 
                Aux_2D   = DT_Velocity * DZX_ZY(iSouth, jWest) * DYY_XX(I, J) * TauFace 

    dok1:       do k = Kbottom, KUB

                    if (Me%ComputeOptions%LocalDensity) then

                        FaceDensity  = Face_Interpolation(Density(I, J, k),                  &
                                                          Density(iSouth, jWest, k),       &
                                                          DUX_VY(I, J), DUX_VY(iSouth, jWest))
                    else

                        FaceDensity  = SigmaDensityReference

                    endif

                    ![m/s]                                 [M*m/s] / [m^3] / [M/m^3]  
                    TiCoef_3D(i,j,k)  = TiCoef_3D(i,j,k) + Aux_2D / Volume_UV(i, j, k) / FaceDensity &
                                                         * DUZ_VZ(i, j, k) / WaterColumnUV(i, j)
                         
                enddo dok1

            endif cd1

        enddo doj
        enddo doi

        !Nullify auxiliar pointers 
        nullify(TiCoef_3D)  
        

        nullify(DYY_XX)
        nullify(DUX_VY)
        nullify(DZX_ZY)

        nullify(Volume_UV)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)

        nullify(TauWaves_UV, Density)
        nullify(DUZ_VZ, WaterColumnUV)


    End Subroutine Velocity_WaveStress

        !End-----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the vertical diffusion surface and bottom boundaries.       !
    !  Compute always the wind effect explicit                                             !
    !  the bottom friction effect implicit can be explicit or implicit (advised)           !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: ECoef_3D,  TiCoef_3D                                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine VelVerticalDiffusionBoundaries            
        

        !Variables Categories 
        ! 3DGeometry : Volume_UV, Area_UV (Control Volume and Area for the U faces or V faces)
        ! GridGeomtry: DZX_ZY (U or V Control volume length), DUX_VY (distance between faces), DYY_XX (U or V Control Volume width) 
        ! Flow       : Velocity_UV_Old (U or V velocity), VerticalViscosity (Vertical turbulent Viscosity)
        ! Time       : DT_Velocity (velocity time step) 
        !
        ! Mapping    : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  
        !   (1 - covered faces, 0 - not covered faces) 
        !
        ! Options    : UpStream_CenterDif (1 - UpStream and 0 - Centered differences),  
        !              ImplicitVertAdvection(1 - implict, 0 - explicit)
        !
        ! Direction  : Direction (DirectionX_=1,DirectionY_=2)
        !
        ! Dimension  : ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), 
        !              JUB (j upper bound), KUB (k upper bound)

        !Variables dependent from the direction: 
         !Volume_UV, Area_UV, Velocity_UV_Old, DZX_ZY, DUX_VY, DYY_DXX,    
         !ComputeFaces3D_UV, Direction, KFloor_UV


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV, ECoef_3D

        real,    dimension(:,:,:), pointer :: DCoef_3D, FCoef_3D, TiCoef_3D,             &
                                              Velocity_UV_Old, Velocity_VU_New, Density, &
                                              DUZ_VZ

        real,    dimension(:,:  ), pointer :: DUX_VY, DYY_XX, DXX_YY, DZX_ZY, ChezyVelUV,&
                                              TauWind_UV, WaterColumnUV

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: DT_Velocity, ImplicitVertDiffusion

        real                               :: CellFace_BottomFace, CellFace_TopFace, SmoothCoef, RunPeriod

        real                               :: DT_Z, TauFace, FaceDensity, Coef, WaterColumn2D
        real(8)                            :: TotalVolume
    
        integer                            :: di, dj, i, j, Kbottom, iSouth, jWest, i_North, j_East, k

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK
        
        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity          =  Me%Velocity%DT

        ImplicitVertDiffusion=  Me%ComputeOptions%ImplicitVertDiffusion 

        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        DCoef_3D             => Me%Coef%D3%D
        ECoef_3D             => Me%Coef%D3%E
        FCoef_3D             => Me%Coef%D3%F
        TiCoef_3D            => Me%Coef%D3%Ti
        
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old
        Velocity_VU_New      => Me%Velocity%Horizontal%VU%New

        Volume_UV            => Me%External_Var%Volume_UV
        DUZ_VZ               => Me%External_Var%DUZ_VZ
        WaterColumnUV        => Me%External_Var%WaterColumnUV

        DUX_VY               => Me%External_Var%DUX_VY
        DYY_XX               => Me%External_Var%DYY_XX
        DXX_YY               => Me%External_Var%DXX_YY
        DZX_ZY               => Me%External_Var%DZX_ZY

        ChezyVelUV           => Me%External_Var%ChezyVelUV
        TauWind_UV           => Me%External_Var%TauWind_UV

        Density              => Me%External_Var%Density

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        !End - Shorten variables name 
  
        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "VelVerticalDiffusionBoundaries")
        endif
        
        !$OMP PARALLEL PRIVATE(i,j,iSouth,jWest,i_North,j_East,Kbottom,CellFace_BottomFace) &
        !$OMP PRIVATE(FaceDensity,SmoothCoef,RunPeriod,TauFace,DT_Z,CellFace_TopFace) &
        !$OMP PRIVATE(TotalVolume,Coef,k)
        
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doi:     do j=JLB, JUB
doj:     do i=ILB, IUB

            iSouth = i - di
            jWest  = j - dj
            ! This values (i_North and j_east) can only be use to compute the velocity modulus in a face
            i_North = i + dj
            j_East  = j + di


cd1:        if (ComputeFaces3D_UV(i, j, KUB)==Covered) then 
        

                !Bottom boundary condition (bottom friction)
                        
                Kbottom = KFloor_UV(i, j)

                ![s/m^3]                  = [s] / [m^3] * [m] * [m]
!                DT_Z                      = DT_Velocity / Volume_UV(i, j, Kbottom)       &
!                                            * DZX_ZY(iSouth, jWest) * DYY_XX(I, J)

!                VelMod_UV                 = Face_Velocity_Modulus(                     &
!                                            Velocity_VU_New(I_North, jWest, kbottom), &
!                                            Velocity_VU_New(I_North, J_East, kbottom), &
!                                            Velocity_VU_New(iSouth, jWest, kbottom), &
!                                            Velocity_VU_New(iSouth, J_East, kbottom), &
!                                            DXX_YY(I_North, jWest),               &
!                                            DXX_YY(I_North, J_East),               &
!                                            DXX_YY(iSouth, jWest),               &
!                                            DXX_YY(iSouth, J_East),               &
!                                            Velocity_UV_Old(I,J,kbottom))

!                Face_Chezy                = (Chezy(iSouth, jWest) * DUX_VY(I, J)   +  &
!                                             Chezy (I, J) * DUX_VY(iSouth, jWest)) /  &
!                                            (DUX_VY(iSouth, jWest) + DUX_VY(I, J))

!                Face_Chezy              = ChezyVelUV (I, J)


                ![ ]                      = [s/m] * [ ] * [m/s]
!                CellFace_BottomFace     = DT_Z  * Face_Chezy * VelMod_UV

                CellFace_BottomFace     = ChezyVelUV (I, J)

                ![m/s ]                   =          [ ]          *     [m/s]
                !ExplicitVerticalDiffusion = CellFace_BottomFace * Velocity_UV_Old(i, j, Kbottom) 

                !TiCoef_3D(i, j, Kbottom)    = TiCoef_3D(i, j, Kbottom) + (ImplicitVertDiffusion - 1) * &
                !                            ExplicitVerticalDiffusion

                !Surface boundary condition (Wind)

                if (Me%ComputeOptions%Wind /= NoWind_) then

                    if (Me%ComputeOptions%LocalDensity) then
                        !!!! $OMP CRITICAL (VVDB1_FNC01)
                        FaceDensity  = Face_Interpolation(Density(I, J, KUB),                &
                                                          Density(iSouth, jWest, KUB),     &
                                                          DUX_VY(I, J), DUX_VY(iSouth, jWest))
                        !!!! $OMP END CRITICAL (VVDB1_FNC01)
                    else

                        FaceDensity  = SigmaDensityReference

                    endif


                    SmoothCoef = 1.
                    
                    if (Me%ComputeOptions%AtmosphereRAMP) then

                        RunPeriod = Me%CurrentTime - Me%BeginTime

                        if (RunPeriod < Me%ComputeOptions%AtmospherePeriod) then

                            SmoothCoef = Me%ComputeOptions%AtmosphereCoef

                        endif

                    elseif (Me%ComputeOptions%Wind == InitialSmoothWind_) then

                        RunPeriod = Me%CurrentTime - Me%BeginTime

                        if (RunPeriod < Me%ComputeOptions%SmoothInitialPeriod) then

                            SmoothCoef = RunPeriod / Me%ComputeOptions%SmoothInitialPeriod

                        endif

                    endif

                    !!!! $OMP CRITICAL (VVDB2_FNC02)
                    TauFace  = Face_Interpolation(TauWind_UV(I,J), TauWind_UV(iSouth, jWest), &
                                                  DUX_VY(I, J), DUX_VY(iSouth, jWest))
                    !!!! $OMP END CRITICAL (VVDB2_FNC02)

                    TauFace  = SmoothCoef * TauFace

                    DT_Z                      = DT_Velocity / Volume_UV(i, j, KUB)       &
                                                * DZX_ZY(iSouth, jWest) * DYY_XX(I, J)

                    ![m/s]                    = [s/m] * [M*m/s^2/m^2] / [M/m^3]
                    CellFace_TopFace        = DT_Z * TauFace / FaceDensity
                else

                    CellFace_TopFace        = 0.

                endif


                !In case of 3D models where the depth is very low a linear profile 
                !is assumed to the shear stress (pressure = shear stress) and the momentum 
                !is decrease in uniform way along the entire water column
                !
                if (KUB > 1 .and. WaterColumnUV(i,j) <= WaterColumn2D) then

                    TotalVolume = 0.

                    do k = Kbottom, KUB

                        TotalVolume = TotalVolume + Volume_UV(i, j, k)

                    enddo

                    do k = Kbottom, KUB

                        Coef = real (Volume_UV(i, j, k) / TotalVolume)

                        ECoef_3D (i, j, k)  = ECoef_3D (i, j, k) + CellFace_BottomFace * Coef

                        !Wind must be always explicit
                        TiCoef_3D(i, j, k)  = TiCoef_3D(i, j, k) + CellFace_TopFace * Coef

                    enddo

                else

                    !the bottom friction is consider always implicit like is done in the water level compute.

                    ECoef_3D (i, j, Kbottom)    = ECoef_3D (i, j, Kbottom) + CellFace_BottomFace 

                    !Wind must be always explicit
                    TiCoef_3D(i, j, KUB)        = TiCoef_3D(i, j, KUB)     + CellFace_TopFace

                endif
             

            endif cd1

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "VelVerticalDiffusionBoundaries")
        endif

        !Nullify auxiliar pointers 
        nullify(DCoef_3D)
        nullify(ECoef_3D)   
        nullify(FCoef_3D)   
        nullify(TiCoef_3D)  
        
        nullify(Velocity_UV_Old)
        nullify(Velocity_VU_New)

        nullify(ChezyVelUV) 
        nullify(TauWind_UV)

        nullify(Density)

        nullify(DYY_XX)
        nullify(DUX_VY)
        nullify(DZX_ZY)
        nullify(DXX_YY)
        nullify(WaterColumnUV)

        nullify(Volume_UV)
        nullify(DUZ_VZ   )

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)


    End Subroutine VelVerticalDiffusionBoundaries

        !End-----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine compute the barotropic pressure effect in the water level            !
    ! calculation. The barotropic pressure is the water barotropic pressure plus           !
    ! the atmospheric pressure                                                             !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_BarotropicPressure    
        
        !Variables Categories  
            !Geometry  : WaterColumn, DUX_VY, DVY_UX, DYY_XX, DZX_ZY 
            !WaterProp : Density, AtmPressure
            !Time      : DT_Elevation, DT_Velocity, Num_Discretization
            !Mapping   : ComputeFaces3D_UV, Direction
            !Equations : DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D

         
        !Variables Direction Dependent
            !DUX_VY, DVY_UX, DYY_XX, DZX_ZY, ComputeFaces3D_UV, Direction


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Density, Area_UV, SZZ

        real(8), dimension(:,:),   pointer :: ECoef_2D, ECoef_2D_Aux

        real,    dimension(:,:),   pointer :: DCoef_2D, FCoef_2D, TiCoef_2D, &
                                              WaterColumnUV, AtmPressure,    &
                                              RadCoef_2D, TiRadCoef_2D,      &
                                              TidePotentialLevel, TiCoef_2D_Aux

        real,    dimension(:,:  ), pointer :: DUX_VY, DVY_UX, DYY_XX, DZX_ZY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        real                               :: DT_Elevation, DT_Velocity, Num_Discretization, &
                                              Alpha

        integer                            :: I, J, di, dj, iSouth, jWest, kbottom

        real                               :: AuxPressure, AuxImplicit, AuxExplicit,  &
                                              WaterColumn_High, DT_AUX, DT_AreaCell1, & 
                                              DT_AreaCell2, AreaCell1, AreaCell2,     &
                                              SurfaceFaceDensity,                     &
                                              AtmosphericExplicit,                    &
                                              TidePotentialExplicit
        
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, BarotropicRadia
        
        !$ integer                          :: CHUNK

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name 

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_BarotropicPressure")
        endif
        
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity          =  Me%Velocity%DT
        DT_Elevation         =  Me%WaterLevel%DT

        Num_Discretization   =  Me%ComputeOptions%Num_Discretization

        BarotropicRadia      =  Me%ComputeOptions%BarotropicRadia

        !WaterColumn          => Me%External_Var%WaterColumn
        WaterColumnUV        => Me%External_Var%WaterColumnUV
        AtmPressure          => Me%External_Var%AtmosphericPressure
        TidePotentialLevel   => Me%Forces%TidePotentialLevel


        DUX_VY               => Me%External_Var%DUX_VY
        DVY_UX               => Me%External_Var%DVY_UX
        DYY_XX               => Me%External_Var%DYY_XX
        DZX_ZY               => Me%External_Var%DZX_ZY

        Density              => Me%External_Var%Density

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV

        Area_UV              => Me%External_Var%Area_UV
        SZZ                  => Me%External_Var%SZZ

        !End - Shorten variables name 

        if (Me%TidePotential%Compute) then
            
            Alpha = Me%TidePotential%Alpha

        else

            Alpha = 1.

        endif
        
        call SetMatrixValue( Me%Coef%D2%Eaux,  Me%WorkSize2D,      dble(0.0))
        call SetMatrixValue( Me%Coef%D2%Tiaux,  Me%WorkSize2D, 0.0)

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !GRiflet: pointers are made private as well. They must be initialized
        !GRiflet: within the OMP zone
        !! $OMP PARALLEL PRIVATE( I, J, iSouth, jWest, kbottom,           &
        !! $OMP                   AuxPressure, AuxImplicit, AuxExplicit,  &
        !! $OMP                   WaterColumn_High, DT_AUX, DT_AreaCell1, & 
        !! $OMP                   DT_AreaCell2, AreaCell1, AreaCell2,     &
        !! $OMP                   SurfaceFaceDensity,                     &
        !! $OMP                   AtmosphericExplicit,                    &
        !! $OMP                   TidePotentialExplicit,                  &
        !! $OMP                   ECoef_2D, ECoef_2D_Aux,                 &
        !! $OMP                   DCoef_2D, FCoef_2D, TiCoef_2D, TiCoef_2D_Aux, &
        !! $OMP                   RadCoef_2D, TiRadCoef_2D)

        DCoef_2D             => Me%Coef%D2%D
        ECoef_2D             => Me%Coef%D2%E
        FCoef_2D             => Me%Coef%D2%F
        TiCoef_2D            => Me%Coef%D2%Ti

        ECoef_2D_Aux         => Me%Coef%D2%Eaux
        TiCoef_2D_Aux        => Me%Coef%D2%Tiaux

        RadCoef_2D           => Me%Coef%D2%Rad
        TiRadCoef_2D         => Me%Coef%D2%TiRad

        !! $OMP DO SCHEDULE(DYNAMIC, CHUNK)
    doj: do j = JLB, JUB
    doi: do i = ILB, IUB

    Cov1:   if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

                iSouth     = I - di
                jWest      = J - dj 

                kbottom = KFloor_UV(i, j)

                !WaterColumn_Left  = SZZ(iSouth, jWest, kbottom - 1) - SZZ(iSouth, jWest, KUB)

                !WaterColumn_Right = SZZ(I      , J     , kbottom - 1) - SZZ(I      , J     , KUB)


                !WaterColumn_High  = Face_Interpolation(WaterColumn_Right, WaterColumn_Left, &
                !                                       DUX_VY(I, J), DUX_VY(iSouth, jWest))
                WaterColumn_High   = WaterColumnUV(i, j)

                ![m*s]            = [m] * [m] * [s] / [m] 
                AuxPressure       = WaterColumn_High * DYY_XX(I, J) * &
                                    DT_Velocity / DZX_ZY(iSouth, jWest)

                !Alpha - Deformation "crosta terreste" Tide potential effect
                AuxPressure       = AuxPressure * Alpha

                !The barotropic water pressure effect is consider implicit while the
                !the atmospheric pressure must be explicit 

                !Water Pressure 
                ![m^2/s]     = [m*s] * [m/s^2]
                AuxImplicit  = AuxPressure * Gravity 

                ![s]         = [s] * []
                DT_AUX       = DT_Elevation * Num_Discretization / 2.
            
                !Area of a South or West Z cell 
                ![m^2]       = [m] * [m]
                AreaCell1    = DUX_VY(iSouth, jWest) * DVY_UX(iSouth, jWest)

                !Area of a North or East Z cell 
                ![m^2]       = [m] * [m]
                AreaCell2    = DUX_VY(I,J) * DVY_UX(I,J)

                ![s/m^2]     = [s] / [m^2]
                DT_AreaCell1 = DT_AUX / AreaCell1
                
                ![s/m^2]     = [s] / [m^2]
                DT_AreaCell2 = DT_AUX / AreaCell2

                !Atmospheric pressure

                if (Me%ComputeOptions%AtmPressure) then

                    !It should be use the average density of the water column to compute 
                    !atmospheric pressure effect but for speed up the program and to simplify the
                    !code was used the surface density. This aproximation dosen't introduce 
                    !a large error (<0.3 %).

                    if (Me%ComputeOptions%LocalDensity) then

                        ![M/m^3]
                        SurfaceFaceDensity = Face_Interpolation(Density(I,       J,      KUB), &
                                                                Density(iSouth, jWest, KUB), &
                                                                DUX_VY (I,       J),           &
                                                                DUX_VY (iSouth, jWest))
                    else

                        SurfaceFaceDensity = SigmaDensityReference

                    endif


                    ![m^3/s]                  = [m*s]       *  [M*m/s^2/m^2] / [M/m^3] 
                    AtmosphericExplicit       = AuxPressure * (AtmPressure(iSouth, jWest) -     &
                                                               AtmPressure(I, J)) / SurfaceFaceDensity
                else

                    AtmosphericExplicit       = 0.

                endif

                !Tide potential pressure
                ![m^3/s]                  = [m*s]       * [m/s^2] * [m] 
                TidePotentialExplicit     = - AuxPressure * Gravity * (TidePotentialLevel(iSouth, jWest) - &
                                              TidePotentialLevel(I, J)) 

                AuxExplicit               = AtmosphericExplicit + TidePotentialExplicit 

ic1:            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_))  then


                    call CyclicCoef2D ( TiCoef_2D, TiCoef_2D_Aux,                                    &
                                       AuxExplicit, DT_AreaCell1,                        &
                                       DT_AreaCell2, I, J, iSouth, jWest,                &
                                       Dcoef_2D, ECoef_2D, ECoef_2D_Aux, FCoef_2D, AuxImplicit)

                else ic1

                    ![ ]                      = [ ]                        +  [m^2/s]    * [s/m^2]
                    DCoef_2D(I, J)            = DCoef_2D(I, J)             - AuxImplicit * DT_AreaCell2 
                
                    ![ ]                      = [ ]                        +  [m^2/s]    * [s/m^2]
                    ECoef_2D(I, J)            = ECoef_2D(I, J)             + AuxImplicit * DT_AreaCell2 

                    ![ ]                      = [ ]                        +  [m^2/s]    * [s/m^2]
                    FCoef_2D(iSouth, jWest)   = FCoef_2D(iSouth, jWest)  - AuxImplicit * DT_AreaCell1 

                    ![ ]                      = [ ]                        +  [m^2/s]    * [s/m^2]
!                    ECoef_2D(iSouth, jWest)   = ECoef_2D(iSouth, jWest)  + AuxImplicit * DT_AreaCell1 
                    ECoef_2D_Aux(iSouth, jWest)   = AuxImplicit * DT_AreaCell1 
           
           
                    ![m]                      = [m]                        + [m^3/s] * [s/m^2]
                    TiCoef_2D (I, J)          = TiCoef_2D(I, J)            + AuxExplicit * DT_AreaCell2 

                    ![m]                      = [m]                        + [m^3/s] * [s/m^2]
!                    TiCoef_2D(iSouth, jWest)  = TiCoef_2D(iSouth, jWest) - AuxExplicit * DT_AreaCell1 
                    TiCoef_2D_Aux(iSouth, jWest)  = - AuxExplicit * DT_AreaCell1 

                endif ic1

                if ((BarotropicRadia == FlatherWindWave_       .or.                      &
                     BarotropicRadia == FlatherLocalSolution_) .and.                     &
                     BoundaryFacesUV(I, J) == Boundary) then
                    ![m^3/s]
                    TiRadCoef_2D (I, J)   = TiRadCoef_2D(I, J   )      + AuxExplicit * Num_Discretization / 2.

                   ![m^2/s] 
                    RadCoef_2D   (I, J)   = RadCoef_2D(I, J)           + AuxImplicit * Num_Discretization / 2.

                endif 

            endif Cov1

        enddo doi
        enddo doj
        !! $OMP END DO
        
        !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            ECoef_2D(i, j) = ECoef_2D(i, j) + ECoef_2D_Aux(i, j)
            TiCoef_2D(i, j) = TiCoef_2D(i, j) + TiCoef_2D_Aux(i, j)

        enddo
        enddo
        !! $OMP END DO NOWAIT

        !! $OMP END PARALLEL

        !Nullify auxiliar pointers 
        nullify(DCoef_2D)
        nullify(ECoef_2D)   
        nullify(FCoef_2D)   
        nullify(TiCoef_2D)  
        
        nullify(ECoef_2D_Aux)
        nullify(TiCoef_2D_Aux)
        
        nullify(RadCoef_2D)   
        nullify(TiRadCoef_2D)  

        nullify(WaterColumnUV)
        nullify(AtmPressure)

        nullify(TidePotentialLevel)

        nullify(Density)

        nullify(DYY_XX)
        nullify(DUX_VY)
        nullify(DVY_UX)
        nullify(DZX_ZY)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)
        nullify(BoundaryFacesUV)

        nullify(Area_UV)

        nullify(SZZ)

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_BarotropicPressure")
        endif
        
    end Subroutine WaterLevel_BarotropicPressure

    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This suborutine computes the bottom friction effect in the water level calculation   !
    !                                                                                      !
    ! Input : Geomtry, Flow, Mapping, Time steps                                           !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_BottomFriction 
        
        !Variables Categories  
            !Geometry  : Volume_UV, Area_UV, DUX_VY, DVY_UX, DXX_YY, DYY_XX, DZX_ZY  
            !Flow      : Velocity_UV_Old, Velocity_VU_Old, Vert_Viscosity
            !WaterProp : Density
            !Boundary  : AtmPressure, Chezy
            !Forces    : Horizontal_Transport, Rox3, 
            !Time      : DT_Elevation, DT_Velocity
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D
            
         
        !Variables Direction Dependent
            !Volume_UV, Area_UV, DUX_VY, DVY_UX, DXX_YY, DYY_XX, DZX_ZY
            !Velocity_UV_Old, Velocity_VU_Old, ComputeFaces3D_UV, KFloor_UV, Direction 
        

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV, Horizontal_Transport
        real(8), dimension(:,:  ), pointer :: ECoef_2D,ECoef_2D_Aux

        real,    dimension(:,:,:), pointer :: Area_UV, Velocity_UV_Old, Velocity_VU_New, &
                                              Density, Inertial_Aceleration, Rox3XY,     &
                                              Vertical_Viscosity, DUZ_VZ,                &
                                              Relax_Aceleration, PressureCorrect

        real,    dimension(:,:  ), pointer :: DCoef_2D, FCoef_2D, TiCoef_2D,             &
                                              DUX_VY, DVY_UX, DYY_XX, DZX_ZY, DXX_YY,    & 
                                              ChezyVelUV, AtmPressure, RadCoef_2D,       &
                                              TiRadCoef_2D, TidePotentialLevel,          &
                                              WaterColumnUV, TiCoef_2D_Aux

        !Manuel
        real                               :: visc_bottom_max


        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        real                               :: DT_Velocity, DT_Elevation, Num_Discretization, &
                                              Alpha, Transport_Aceleration

        integer                            :: I, J, kbottom, di, dj, iSouth, I_North, J_East, jWest

        real                               :: FC, FC_Area, VelModXY, FaceDensity,        &
                                              DUZ, ViscAux, AuxImplicit, AuxExplicit,    &
                                              DT_AUX, DT_AreaCell1, DT_AreaCell2,        &
                                              AreaCell1, AreaCell2, BottomViscCoef      !, CoefRelax

        real                               :: WaterColumn2D


        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, BarotropicRadia
        
        !$ integer                          :: CHUNK
    
        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity          =  Me%Velocity%DT
        DT_Elevation         =  Me%WaterLevel%DT

        Num_Discretization   =  Me%ComputeOptions%Num_Discretization

        BarotropicRadia      =  Me%ComputeOptions%BarotropicRadia
        BottomViscCoef       =  Me%ComputeOptions%BottomViscCoef
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Inertial_Aceleration => Me%Forces%Inertial_Aceleration
        Rox3XY               => Me%Forces%Rox3XY
        TidePotentialLevel   => Me%Forces%TidePotentialLevel
        Relax_Aceleration    => Me%Forces%Relax_Aceleration

        AtmPressure          => Me%External_Var%AtmosphericPressure
        ChezyVelUV           => Me%External_Var%ChezyVelUV

        DUX_VY               => Me%External_Var%DUX_VY
        DVY_UX               => Me%External_Var%DVY_UX
        DYY_XX               => Me%External_Var%DYY_XX
        DXX_YY               => Me%External_Var%DXX_YY
        DZX_ZY               => Me%External_Var%DZX_ZY

        Density              => Me%External_Var%Density

        Volume_UV            => Me%External_Var%Volume_UV
        Area_UV              => Me%External_Var%Area_UV
        DUZ_VZ               => Me%External_Var%DUZ_VZ
        WaterColumnUV        => Me%External_Var%WaterColumnUV

        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old
        Velocity_VU_New      => Me%Velocity%Horizontal%VU%New

        Vertical_Viscosity   => Me%External_Var%Vertical_Viscosity

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV

        PressureCorrect      => Me%NonHydrostatic%PressureCorrect


        !End - Shorten variables name 


        if (Me%TidePotential%Compute) then
            
            Alpha = Me%TidePotential%Alpha

        else

            Alpha = 1.

        endif
       
        call SetMatrixValue( Me%Coef%D2%Eaux,  Me%WorkSize2D,      dble(0.0))
        call SetMatrixValue( Me%Coef%D2%Tiaux,  Me%WorkSize2D, 0.0)

        !$ CHUNK = CHUNK_J(JLB, JUB)

        !!GRiflet: just to make it even safer, I'm going to privatize the pointers
        !!GRiflet: of the arrays that are written.
        !! $OMP PARALLEL PRIVATE( I, J, iSouth, jWest, I_North, J_East, kbottom,          &
        !! $OMP                   VelModXY, FC, FC_Area, AuxImplicit, AuxExplicit,        &
        !! $OMP                   FaceDensity, Transport_Aceleration, VISCAUX,            &
        !! $OMP                   DUZ, visc_bottom_max, DT_Aux, AreaCell1, AreaCell2,     &
        !! $OMP                   DT_AreaCell1, DT_AreaCell2,                             &
        !! $OMP                   DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D,                &
        !! $OMP                   ECoef_2D_Aux, TiCoef_2D_Aux, RadCoef_2D, TiRadCoef_2D)

        DCoef_2D             => Me%Coef%D2%D
        ECoef_2D             => Me%Coef%D2%E
        FCoef_2D             => Me%Coef%D2%F
        TiCoef_2D            => Me%Coef%D2%Ti
        
        ECoef_2D_Aux         => Me%Coef%D2%Eaux
        TiCoef_2D_Aux        => Me%Coef%D2%Tiaux

        RadCoef_2D           => Me%Coef%D2%Rad
        TiRadCoef_2D         => Me%Coef%D2%TiRad

        !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doj: do j = JLB, JUB
    doi: do i = ILB, IUB

    Cov1:   if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

                iSouth     = I - di
                jWest      = J - dj 

                ! This values (i_North and j_east) can only be used to compute the velocity modulus in a face
                I_North     = I + dj
                J_East      = J + di

                kbottom     = KFloor_UV(I, J)

                VelModXY    = Face_Velocity_Modulus(Velocity_VU_New(I_North, jWest, kbottom), &
                                                    Velocity_VU_New(I_North, J_East, kbottom), &
                                                    Velocity_VU_New(iSouth, jWest, kbottom), &
                                                    Velocity_VU_New(iSouth, J_East, kbottom), &
                                                    DXX_YY(I_North, jWest),               &
                                                    DXX_YY(I_North, J_East),               &
                                                    DXX_YY(iSouth, jWest),               &
                                                    DXX_YY(iSouth, J_East),               &
                                                    Velocity_UV_Old(I,J,kbottom))
            
                !FC (FrictionCoefficient) is a non-dimensional coefficient
!                FC          = FrictionCoefficient(Chezy(iSouth, jWest) , Chezy (I, J), &
!                                                 DUX_VY(iSouth, jWest), DUX_VY(I, J), &
!                                                 VelModXY, DT_Velocity,                 &     
!                                                 DZX_ZY(iSouth, jWest), DYY_XX(I, J), &
!                                                 Volume_UV(I, J, kbottom))

                !FC (FrictionCoefficient) is a non-dimensional coefficient
                !FC = FB - 1 (FB - Backhaus friction coefficient )

                ![]         = [s] * [m] * [m] * [] * [m/s] / [m^3]
                !FC          = 1. / (1. + DT_Velocity * DZX_ZY(iSouth, jWest) *         &
                !              DYY_XX(I, J) * ChezyVelUV(I, J) * VelModXY /                  &
                !              Volume_UV(I, J, kbottom)) - 1.      

                ![]         =  []
                FC          = 1. / (1. + ChezyVelUV(I, J)) - 1.      


    
                FC_Area     = FC * Area_UV(I, J, kbottom) ! [m^2]

                ! Corrections to all terms of the bottom layer due to bottom friction (See Mesh3D technical manual)

                !Implicit effects : barotropic water pressure
                !Alpha - Deformation "crosta terreste" Tide potential effect

                ![m^2/s]    = [m^2] * [s] * [m/s^2] / [m] 
                AuxImplicit = FC_Area * DT_Velocity * Gravity / DZX_ZY(iSouth, jWest) * Alpha


                !Explicit effects
                ![m^3/s]
                AuxExplicit  = 0.   

                !WaterFlow in the bottom layer
                ![m^3/s]     = [m^3/s]      + [m^2]*[m/s] 
                AuxExplicit  = AuxExplicit  + FC_Area * Velocity_UV_Old(I, J, kbottom) 


                if (Me%ComputeOptions%LocalDensity) then

                    ![M/m^3]
                    FaceDensity = Face_Interpolation(Density(I,J,kbottom), Density(iSouth, jWest,kbottom), &
                                                     DUX_VY(I, J), DUX_VY(iSouth, jWest))

                else
                    ![M/m^3]
                    FaceDensity = SigmaDensityReference

                endif


                !Atmospheric pressure 

                if (Me%ComputeOptions%AtmPressure) then

                    ![m^3/s]     = [m^2] * [s] * [M*m/s^2/m^2] / [M/m^3] / [m]  
                    AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *              &
                                                  (AtmPressure(iSouth, jWest) -      &
                                                  AtmPressure(I,J))/                   &
                                                  FaceDensity / DZX_ZY(iSouth, jWest)
                endif


                !Tide potential pressure
                ![m^3/s]                  =   [m^2] * [s] * [m/s^2] * [m] / [m]
                AuxExplicit  = AuxExplicit  - FC_Area * DT_Velocity * Gravity *              &
                                              (TidePotentialLevel(iSouth, jWest) -         &
                                              TidePotentialLevel(I, J)) / DZX_ZY(iSouth, jWest)


                !Aceleration due to Horizontal transport = advection + diffusion
                ![m/s^2]              = [m^4/s^2] / [m^3]                
                Transport_Aceleration = Horizontal_Transport (I, J, kbottom) /               &
                                        Volume_UV(I, J, kbottom)


                !Horizontal Transport in the bottom layer = Advection, diffusion 
                ![m^3/s]     = [m^3/s]      +  [m^2]  * [s]  * [m/s^2]
                AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *                             &
                                              Transport_Aceleration
!                                              Horizontal_Transport(I, J, kbottom) / &
!                                              DZX_ZY(iSouth, jWest)

                !Coriolis and centrifugal force in the bottom layer
                ![m^3/s]     = [m^3/s]      + [m^2]   * [s]         * [m/s^2]

                AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *                   &
                                              Inertial_Aceleration(I, J, kbottom)
                                             
                if (Me%Relaxation%Force)                                    &
                    ![m^3/s]     = [m^3/s]      + [m^2]   * [s]         * [m/s^2]
                    AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *               &
                                                  Relax_Aceleration(I, J, kbottom)

                if(Me%ComputeOptions%Obstacle)                                          &
                    ![m^3/s]     = [m^3/s]      + [m^2]   * [s]         * [m/s^2]
                    AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *               &
                                                  Me%Forces%ObstacleDrag_Aceleration(I, J, kbottom)
                                              
                if (Me%ComputeOptions%Scraper)                                          &
                    AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *               &
                                                  Me%Forces%Scraper_Aceleration(i, j, kbottom)  
                                                  
                if (Me%ThinWalls%ON .and. Me%ThinWalls%CloseFlag == 0)                  &
                    AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *               &
                                                  Me%Forces%ThinWalls_Dissipation(i,j,kbottom)
                                                  
                                                  

                !baroclinic pressure in the bottom layer
                ![m^3/s]     = [m^3/s]      + [m^2] * [s] * [M/m^3] * [m/s^2] / [M/m^3]  
                AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *                    &
                                              Rox3XY(I, J, kbottom)   * Gravity / FaceDensity


                ! Shear stress between the first and the second layer
    kmax1:      if (KUB > kbottom) then
                    ![m^2/s]

                     ! Manuel Remember that viscosities are defined at faces.
                     VISCAUX = Face_Interpolation(Vertical_Viscosity(I, J, kbottom+1),            &
                                                 Vertical_Viscosity(iSouth, jWest, kbottom+1), &
                                                 DUX_VY(I, J), DUX_VY(iSouth, jWest))

                     ! Vertical distance between the velocities "Velocity_X kbottom +1" and "Velocity_X kbottom"
                     DUZ = (DUZ_VZ(I, J, kbottom + 1) + DUZ_VZ(I, J, kbottom)) / 2.0

                     !Limitation of bottom viscosity due to the semi-implicit discretization of bottom friction. MRV
                     if (Me%ComputeOptions%BottomVisc_LIM ) then

                         visc_bottom_max  = BottomViscCoef * DUZ_VZ(I, J, kbottom) * DUZ / 2. / DT_Velocity
                         

                         VISCAUX          = min(VISCAUX,visc_bottom_max)
                    
                    end if


                    !This formulation assumes that AreaUV / VolumeUV = DZX_ZY, because
                    !is the only way of cancel the vertical diffusion and advection terms. 
                    !However, this relation is not true when AreaUV is computed using the 
                    !minimum thickness metodology.    

                    
                    ![m^3/s]    = [m^3/s]     + [ ]* [s] * [m] * [m^2/s] * [m/s] / [m]  
                    AuxExplicit = AuxExplicit + FC * DT_Velocity * DYY_XX(i, j) * VISCAUX * &
                                                (Velocity_UV_Old(I, J, kbottom+1) -         &
                                                 Velocity_UV_Old(I, J, kbottom)) / DUZ 
                endif kmax1

                DT_Aux = DT_Elevation * Num_Discretization / 2.  

                !Area of a South or West Z cell
                ![m^2]
                AreaCell1 = DUX_VY(iSouth, jWest) * DVY_UX(iSouth, jWest)

                !Area of a North or East Z cell
                ![m^2]
                AreaCell2 = DUX_VY(I,J) * DVY_UX(I,J)

                ![s/m^2]
                DT_AreaCell1 = DT_Aux / AreaCell1  

                ![s/m^2]
                DT_AreaCell2 = DT_Aux / AreaCell2  


ic1:            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then

                    call CyclicCoef2D ( TiCoef_2D, TiCoef_2D_Aux,                                     &
                                       AuxExplicit, DT_AreaCell1,                        &
                                       DT_AreaCell2, I, J, iSouth, jWest,                &
                                       Dcoef_2D, ECoef_2D, ECoef_2D_Aux, FCoef_2D, AuxImplicit)

                else ic1

                    !Compute the coeficients of linear system equations for the I,J Z cell
                    ![ ]                   = [ ]         + [m^2/s] * [s/m^2]
                    DCoef_2D(I,J)             = DCoef_2D(I,J)  - AuxImplicit * DT_AreaCell2
                
                    ![ ]                   = [ ]         + [m^2/s] * [s/m^2]
                    ECoef_2D (I,J)            = ECoef_2D(I,J)  + AuxImplicit * DT_AreaCell2

                    ![m]                   = [m]         + [m^3/s] * [s/m^2] 
                    TiCoef_2D(I,J)            = TiCoef_2D(I,J) + AuxExplicit * DT_AreaCell2

                    !Compute the coeficients of linear system equations for the iSouth, jWest Z cell

                    ![ ]                   = [ ]                     + [m^2/s] * [s/m^2] 
                    FCoef_2D(iSouth, jWest) = FCoef_2D(iSouth, jWest)  - AuxImplicit * DT_AreaCell1

                    ![ ]                   = [ ]                     + [m^2/s] * [s/m^2] 
!                    ECoef_2D(iSouth, jWest) = ECoef_2D(iSouth, jWest)  + AuxImplicit * DT_AreaCell1
                    ECoef_2D_Aux(iSouth, jWest) = AuxImplicit * DT_AreaCell1

                    ![m]                   = [m]                     + [m^3/s] * [s/m^2] 
!                    TiCoef_2D(iSouth, jWest)= TiCoef_2D(iSouth, jWest) - AuxExplicit * DT_AreaCell1
                    TiCoef_2D_Aux(iSouth, jWest)= - AuxExplicit * DT_AreaCell1

                endif ic1


                !PCL - New changes
                if ((BarotropicRadia == FlatherWindWave_       .or.                    &
                     BarotropicRadia == FlatherLocalSolution_) .and.                   &
                     BoundaryFacesUV(I, J) == Boundary) then

                    ![m^3/s]
                    TiRadCoef_2D (I, J) = TiRadCoef_2D(I, J) + AuxExplicit * Num_Discretization / 2.

                   ![m^2/s] 
                    RadCoef_2D   (I, J) = RadCoef_2D  (I, J) + AuxImplicit * Num_Discretization / 2.

                endif 


            endif Cov1
   

        enddo doi
        enddo doj
        !! $OMP END DO
        
        !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            ECoef_2D(i, j) = ECoef_2D(i, j) + ECoef_2D_Aux(i, j)
            TiCoef_2D(i, j) = TiCoef_2D(i, j) + TiCoef_2D_Aux(i, j)

        enddo
        enddo
        !! $OMP END DO NOWAIT

        !! $OMP END PARALLEL


        !Nullify auxiliar pointers 
        nullify(DCoef_2D)
        nullify(ECoef_2D)   
        nullify(FCoef_2D)   
        nullify(TiCoef_2D)  

        nullify(RadCoef_2D)   
        nullify(TiRadCoef_2D)  
        
        nullify(AtmPressure)

        nullify(Density) 

        nullify(DYY_XX)
        nullify(DUX_VY)
        nullify(DVY_UX)
        nullify(DZX_ZY)
        nullify(DXX_YY)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)
        nullify(BoundaryFacesUV)

        nullify(Horizontal_Transport)
        nullify(Inertial_Aceleration)
        nullify(Relax_Aceleration   )
        nullify(Rox3XY)
        nullify(TidePotentialLevel)

        nullify(ChezyVelUV)

        nullify(Volume_UV)
        nullify(Area_UV  )
        nullify(DUZ_VZ   )

        nullify(Velocity_UV_Old)
        nullify(Velocity_VU_New)

        nullify(Vertical_Viscosity)


    end Subroutine WaterLevel_BottomFriction

    !------------------------------------------------------------------------------

    function Face_Interpolation(X,Y,DX,DY)

        !Arguments
        real ::  Face_Interpolation, X,Y,DX,DY
    
        !Begin---------------------------------------------------------------------

        Face_Interpolation = (X*DY+Y*DX)/(DX+DY)

    end function Face_Interpolation

    !------------------------------------------------------------------------------

    function Face_Velocity_Modulus(VelVU1, VelVU2, VelVU3, VelVU4, &
                                         DXY1, DXY2, DXY3, DXY4, VelUV)

        !Arguments      
        real :: Face_Velocity_Modulus, VelVU1, VelVU2, VelVU3, VelVU4, &
                DXY1, DXY2, DXY3, DXY4, VelUV

        !Local     
        real :: VU1, VU2, VU12

        !Begin---------------------------------------------------------------------
             
        !X - Direction i,j,kbottom face
        !
        !V1 = (Velocity_Y(I+1,J-1,kbottom)*DXX(I+1,J)+Velocity_Y(I+1,J,kbottom)* &
        !      DXX(I+1,J-1))/(DXX(I+1,J)+DXX(I+1,J-1))


        VU1 = Face_Interpolation(VelVU1, VelVU2, DXY1, DXY2)

        !X - Direction i,j,kbottom face
        !
        !V2 = (Velocity_Y(I,J-1,kbottom)*DXX(I,J)+Velocity_Y(I,J,kbottom)*       &
        !      DXX(I,J-1))/(DXX(I,J)+DXX(I,J-1))

        VU2 = Face_Interpolation(VelVU3, VelVU4, DXY3, DXY4)
           
        VU12= (VU1 + VU2)/2.

        Face_Velocity_Modulus = abs(cmplx(VelUV, VU12))
!        Face_Velocity_Modulus = SQRT(VelUV*VelUV + VU12*VU12)


    end function Face_Velocity_Modulus


    !------------------------------------------------------------------------------

    function FrictionCoefficient(Chezy1, Chezy2, DUV1, DUV2, VelMod, DT, &
                                       DZXY, DYX, Volume_UV)

        !Arguments
          real    :: FrictionCoefficient, Chezy1, Chezy2, DUV1, DUV2, VelMod, &
                     DT, DZXY, DYX
          real(8) :: Volume_UV

        ! Local
          real :: D

        !Begin---------------------------------------------------------------------


        !X - Direction i,j face
        !
        !D  = (CHEZY(I,J)*DUX(I,J-1)+CHEZY(I,J-1)*DUX(I,J))/         &
        !                 (DUX(I,J-1)+DUX(I,J))

        D = Face_Interpolation(Chezy1,Chezy2,DUV1,DUV2)

        !X - Direction i,j,kbottom face

        !FrictionCoefficient = 1./(1. + DT*DZX(I,J-1)*DYY(I,J)/Volume_U(I,J,kbottom)*D*VelMod)-1.      


        FrictionCoefficient = 1./(1. + DT*DZXY*DYX*D*VelMod/Volume_UV)-1.      


    End function FrictionCoefficient


    !------------------------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !The effect of all explicit forces in the elevation calculation is compute             !
    !in this subroutine except the atmospheric pressure that is compute in the             !
    ! WaterLevel_BarotropicPressure subroutine                                             !             !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine WaterLevel_ExplicitForces    
        
        !Variables Categories  
            !Geometry  : Area_UV, DUX_VY, DVY_UX, DYY_XX, DZX_ZY
            !WaterProp : Density
            !Forces    : Horizontal_Transport, Rox3, TauWind_UV, Inertial_Aceleration 
            !Time      : DT_Elevation, DT_Velocity
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : TiCoef_2D

         
        !Variables Direction Dependent
            !TauWind_UV, Area_UV, DUX_VY, DVY_UX, DYY_XX, DZX_ZY
            !ComputeFaces3D_UV, KFloor_UV, Direction
        

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_UV

        real,    dimension(:,:,:), pointer :: Area_UV, Density, Inertial_Aceleration,    &
                                              Rox3XY, Relax_Aceleration, PressureCorrect,&
                                              DUZ_VZ

        real,    dimension(:,:  ), pointer :: TiCoef_2D, TiRadCoef_2D, DUX_VY, DVY_UX,   &
                                              DYY_XX, DZX_ZY, TauWind_UV, TauWaves_UV,   &
                                              WaterColumnUV,TiCoef_2D_Aux

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        real                               :: DT_Velocity, DT_Elevation, Num_Discretization     

        integer                            :: I, J, K, kbottom, di, dj, iSouth, jWest

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, BarotropicRadia


        real                               :: FaceDensity, SurfaceFaceDensity, AuxExplicit, &
                                              DT_AUX, DT_AreaCell1, DT_AreaCell2,           &
                                              AreaCell1, AreaCell2, TauFace,                &
                                              Transport_Aceleration, SmoothCoef, RunPeriod, &
                                              Aux_2D
        !$ integer                          :: CHUNK

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity          =  Me%Velocity%DT
        DT_Elevation         =  Me%WaterLevel%DT

        Num_Discretization   =  Me%ComputeOptions%Num_Discretization


        BarotropicRadia      =  Me%ComputeOptions%BarotropicRadia

        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Inertial_Aceleration => Me%Forces%Inertial_Aceleration
        Relax_Aceleration    => Me%Forces%Relax_Aceleration
        Rox3XY               => Me%Forces%Rox3XY

        DUX_VY               => Me%External_Var%DUX_VY
        DVY_UX               => Me%External_Var%DVY_UX
        DYY_XX               => Me%External_Var%DYY_XX
        DZX_ZY               => Me%External_Var%DZX_ZY

        Density              => Me%External_Var%Density

        TauWind_UV           => Me%External_Var%TauWind_UV

        Area_UV              => Me%External_Var%Area_UV
        Volume_UV            => Me%External_Var%Volume_UV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV

        PressureCorrect      => Me%NonHydrostatic%PressureCorrect

        TauWaves_UV          => Me%External_Var%TauWaves_UV
        DUZ_VZ               => Me%External_Var%DUZ_VZ
        WaterColumnUV        => Me%External_Var%WaterColumnUV

        !End - Shorten variables name 
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_ExplicitForces")
        endif

        call SetMatrixValue( Me%Coef%D2%Tiaux,  Me%WorkSize2D, 0.0)

        !$ CHUNK = CHUNK_J(JLB, JUB)

        !! $OMP PARALLEL PRIVATE( I, J, K, kbottom, iSouth, jWest,                &
        !! $OMP                   FaceDensity, SurfaceFaceDensity, AuxExplicit,   &
        !! $OMP                   DT_AUX, DT_AreaCell1, DT_AreaCell2,             &
        !! $OMP                   AreaCell1, AreaCell2, TauFace,                  &
        !! $OMP                   Transport_Aceleration, SmoothCoef, RunPeriod,   &
        !! $OMP                   Aux_2D,TiCoef_2D, TiRadCoef_2D, TiCoef_2D_Aux   &
        !! $OMP                   )    
        
        TiCoef_2D            => Me%Coef%D2%Ti
        
        TiCoef_2D_Aux        => Me%Coef%D2%Tiaux

        TiRadCoef_2D         => Me%Coef%D2%TiRad

        !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)

    doj: do j = JLB, JUB
    doi: do i = ILB, IUB

    Cov1:   if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

                iSouth     = I - di
                jWest      = J - dj 


                kbottom     = KFloor_UV(I, J)
       
                AuxExplicit  = 0.

                if (Me%ComputeOptions%WaveStress) then 

                    TauFace  = Face_Interpolation(TauWaves_UV(I,J), TauWaves_UV(iSouth, jWest), &
                                          DUX_VY(I, J), DUX_VY(iSouth, jWest))


                    ![M * m/s] = [M*m/s^2/m^2] * [m] * [m] * [s] 
                    Aux_2D =   TauFace * DZX_ZY(iSouth, jWest) * DYY_XX(I, J)* DT_Velocity 

                endif

dok:            do  k = kbottom, KUB

                    if (Me%ComputeOptions%LocalDensity) then

                        ![M/m^3]                
                        FaceDensity  = Face_Interpolation(Density(I,J,K), Density(iSouth, jWest,K), &
                                                          DUX_VY(I, J), DUX_VY(iSouth, jWest))
                    else
                        ![M/m^3]
                        FaceDensity = SigmaDensityReference

                    endif

                    !Horizontal Transport - Advection, diffusion

                    !Aceleration due to Horizontal transport = advection + diffusion
                    ![m/s^2]              = [m^4/s^2] / [m^3]                
                    Transport_Aceleration = Horizontal_Transport (I, J, K) /             &
                                            Volume_UV(I, J, K)



                    ![m^3/s]     = [m^3/s]      + [s] * [m/s^2] * [m^2]
                    AuxExplicit  = AuxExplicit  + DT_Velocity * Transport_Aceleration *  &   
                                                  Area_UV(I, J, K)
                                                  ![m^3/s*m/s] / [m]
                                                  !Horizontal_Transport(I, J, K) / &
                                                  !DZX_ZY(iSouth, jWest)


                    !Coriolis and centrifugal force 

                    ![m^3/s]     = [m^3/s]      +     [s]     * [m/s^2] * [m^2]
                    AuxExplicit  = AuxExplicit  + DT_Velocity * Inertial_Aceleration(I, J, K) * &
                                                  Area_UV(I, J, K)

                    !Relaxation Force

                    if (Me%Relaxation%Force)                                &
                        ![m^3/s]     = [m^3/s]      +     [s]     * [m/s^2] * [m^2]
                        AuxExplicit  = AuxExplicit  + DT_Velocity * Relax_Aceleration(I, J, K) * &
                                                      Area_UV(I, J, K)

                    if(Me%ComputeOptions%Obstacle)                                           &
                        ![m^3/s]     = [m^3/s]      +     [s]     * [m^2]  * [m/s^2]
                        AuxExplicit  = AuxExplicit  + DT_Velocity * Area_UV(I, J, K)   *     &
                                                      Me%Forces%ObstacleDrag_Aceleration(I, J, K) 

                    if(Me%ComputeOptions%Scraper)                                            &
                        ![m^3/s]     = [m^3/s]      +     [s]     * [m^2]  * [m/s^2]
                        AuxExplicit  = AuxExplicit  + DT_Velocity * Area_UV(I, J, K)   *     &
                                                      Me%Forces%Scraper_Aceleration(I, J, K) 
                                                      
                    if (Me%ThinWalls%ON .and. Me%ThinWalls%CloseFlag == 0)                  &
                        ![m^3/s]     = [m^3/s]      +     [s]     * [m^2]  * [m/s^2]
                        AuxExplicit  = AuxExplicit  + DT_Velocity * Area_UV(I, J, K)   *     &
                                                      Me%Forces%ThinWalls_Dissipation(I, J, K)

                    !Baroclinic pressure

                    ![m^3/s]     = [m^3/s]      + [m^2] * [s] * [M/m^3] * [m/s^2] / [M/m^3]
                    AuxExplicit  = AuxExplicit  + Area_UV(I, J, K) * DT_Velocity *      &
                                                  Rox3XY (I, J, K) *                    &
                                                  Gravity / FaceDensity


                    if (Me%ComputeOptions%WaveStress) then 

                        ![m^3/s]           = [m^3/s] +  [m^2]        * [M * m/s] / [M/m^3] / [m^3] * [m] / [m]
                        AuxExplicit = AuxExplicit +  Area_UV  (I, J, K) * Aux_2D / FaceDensity  / &
                                                     Volume_UV(i, j, k) * DUZ_VZ(i, j, k) / WaterColumnUV(i, j)

                    endif


                
                enddo dok

                !Wind Shear Stress
                if (Me%ComputeOptions%Wind /= NoWind_) then

                    !The last k of the dok Cyclic is KUB - surface layer
                    SurfaceFaceDensity = FaceDensity


                    SmoothCoef = 1.
                    
                    if (Me%ComputeOptions%AtmosphereRAMP) then

                        RunPeriod = Me%CurrentTime - Me%BeginTime

                        if (RunPeriod < Me%ComputeOptions%AtmospherePeriod) then

                            SmoothCoef = Me%ComputeOptions%AtmosphereCoef

                        endif

                    elseif (Me%ComputeOptions%Wind == InitialSmoothWind_) then

                        RunPeriod = Me%CurrentTime - Me%BeginTime

                        if (RunPeriod < Me%ComputeOptions%SmoothInitialPeriod) then

                            SmoothCoef = RunPeriod / Me%ComputeOptions%SmoothInitialPeriod

                        endif

                    endif


                    TauFace  = Face_Interpolation(TauWind_UV(I,J), TauWind_UV(iSouth, jWest), &
                                                  DUX_VY(I, J), DUX_VY(iSouth, jWest))

                    TauFace  = TauFace * SmoothCoef

                    ![m^3/s]     = [m^3/s]     + [M*m/s^2/m^2] * [m] * [s] / [M/m^3]
                    AuxExplicit  = AuxExplicit + TauFace * DYY_XX(I, J) *                       &
                                                 DT_Velocity / SurfaceFaceDensity        
                endif


                DT_Aux = DT_Elevation * Num_Discretization / 2.

                !Area of a South or West Z cell
                AreaCell1 = DUX_VY(iSouth, jWest) * DVY_UX(iSouth, jWest)

                !Area of a North or East Z cell
                AreaCell2 = DUX_VY(I,J) * DVY_UX(I,J)

                DT_AreaCell1 = DT_Aux / AreaCell1   ![s/m^2]

                DT_AreaCell2 = DT_Aux / AreaCell2   ![s/m^2]



                !Compute the coeficients of linear system equations for the I,J Z cell

ic1:            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then


                    call CyclicCoef2D ( TiCoef_2D, TiCoef_2D_Aux,                                        &
                                       AuxExplicit, DT_AreaCell1,                        &
                                       DT_AreaCell2, I, J, iSouth, jWest)
                else ic1


                    ![m]                   = [m]         + [m^3/s]     * [s/m^2]
                    TiCoef_2D(I,J)            = TiCoef_2D(I,J) + AuxExplicit * DT_AreaCell2

                    !Compute the coeficients of linear system equations for the iSouth, jWest Z cell

                    ![m]                   = [m]                     + [m^3/s]     * [s/m^2]
                    TiCoef_2D_Aux(iSouth, jWest)= - AuxExplicit * DT_AreaCell1

                endif ic1

                !PCL - New changes
                if ((BarotropicRadia == FlatherWindWave_       .or.                    &
                     BarotropicRadia == FlatherLocalSolution_) .and.                   &
                     BoundaryFacesUV(I, J) == Boundary) then

                    ![m^3/s]
                    TiRadCoef_2D (I, J) = TiRadCoef_2D(I, J   ) + AuxExplicit * Num_Discretization / 2.

                endif 

            endif Cov1
        enddo doi
        enddo doj
        !! $OMP END DO
        
        !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            TiCoef_2D(i, j) = TiCoef_2D(i, j) + TiCoef_2D_Aux(i, j)

        enddo
        enddo
        !! $OMP END DO NOWAIT

        !! $OMP END PARALLEL
        
        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_ExplicitForces")
        endif
        
        !Nullify auxiliar pointers 
        nullify(TiCoef_2D)  

        nullify(TiRadCoef_2D)  


        nullify(Density) 

        nullify(TauWind_UV)

        nullify(TauWaves_UV)

        nullify(DYY_XX)
        nullify(DUX_VY)
        nullify(DVY_UX)
        nullify(DZX_ZY)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)
        nullify(BoundaryFacesUV)

        nullify(Horizontal_Transport)
        nullify(Inertial_Aceleration)
        nullify(Relax_Aceleration   )
        nullify(Rox3XY)

        nullify(Area_UV  )
        nullify(Volume_UV)
        nullify(DUZ_VZ, WaterColumnUV)



    end Subroutine WaterLevel_ExplicitForces

    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! The effect of all explicit water fluxes in the elevation calculation is compute      !
    ! in this subroutine                                                                   ! 
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine WaterLevel_WaterFluxes 
    
        
        !Variables Categories  
            !Geometry  : Area_UV, Area_VU, DUX_VY, DVY_UX
            !Flow      : Velocity_UV_Old, Velocity_VU_Old, Velocity_VU_New
            !Time      : DT_Elevation
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : TiCoef_2D
            !Domain    : KUB, ILB, IUB, JLB, JUB,              
            !Numeric   : Num_Discretization

         
        !Variables Direction Dependent
            !Area_UV, Area_VU, DUX_VY, DVY_UX, Velocity_UV_Old, Velocity_VU_Old, 
            !Velocity_VU_New, ComputeFaces3D_UV, KFloor_UV, Direction
        
        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old, Velocity_UV_New, Area_UV, &
                                              Velocity_VU_Old, Velocity_VU_New, Area_VU

        real,    dimension(:,:  ), pointer :: TiCoef_2D, TiRadCoef_2D, DUX_VY, DVY_UX, TiCoef_2D_Aux

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ComputeFaces3D_VU
        integer, dimension(:,:),   pointer :: KFloor_UV, KFloor_VU, BoundaryFacesUV

        real                               :: DT_Elevation, Num_Discretization

        integer                            :: I, J, K, kbottom, di, dj, iSouth, jWest

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, BarotropicRadia


        real                               :: AuxExplicit, DT_AUX, DT_AreaCell1, &
                                              DT_AreaCell2, AreaCell1, AreaCell2

        real                               :: Aux !,CoefRelax

        !$ integer                          :: CHUNK
        
        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name 

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Elevation         =  Me%WaterLevel%DT

        Num_Discretization   =  Me%ComputeOptions%Num_Discretization

        BarotropicRadia      =  Me%ComputeOptions%BarotropicRadia

        DUX_VY               => Me%External_Var%DUX_VY
        DVY_UX               => Me%External_Var%DVY_UX

        Area_VU              => Me%External_Var%Area_VU
        Area_UV              => Me%External_Var%Area_UV

        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old
        Velocity_UV_New      => Me%Velocity%Horizontal%UV%New

        Velocity_VU_Old      => Me%Velocity%Horizontal%VU%Old
        Velocity_VU_New      => Me%Velocity%Horizontal%VU%New

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ComputeFaces3D_VU    => Me%External_Var%ComputeFaces3D_VU
        KFloor_UV            => Me%External_Var%KFloor_UV
        KFloor_VU            => Me%External_Var%KFloor_VU
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV


        !End - Shorten variables name 

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_WaterFluxes")
        endif

        call SetMatrixValue( Me%Coef%D2%Tiaux,  Me%WorkSize2D, 0.0)

        !$ CHUNK = CHUNK_J(JLB, JUB)
        
        !! $OMP PARALLEL PRIVATE( I, J, K, kbottom, iSouth, jWest,            &
        !! $OMP                   AuxExplicit, DT_AUX, DT_AreaCell1,          &
        !! $OMP                   DT_AreaCell2, AreaCell1, AreaCell2, Aux,    &
        !! $OMP                   TiCoef_2D, TiRadCoef_2D, TiCoef_2D_Aux)

        TiCoef_2D            => Me%Coef%D2%Ti
        
        TiCoef_2D_Aux        => Me%Coef%D2%Tiaux

        TiRadCoef_2D         => Me%Coef%D2%TiRad

        !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
    do1: do j = JLB, JUB
    do2: do i = ILB, IUB

            iSouth = I - di
            jWest  = J - dj

    cd1:    if (ComputeFaces3D_UV(i, j, KUB) == Covered) then
        
                kbottom = KFloor_UV(I, J)

                AuxExplicit  = 0.
                
                !ACanas(2010): Parallelization removed as critical section 
                !ACanas(2010): causes the code sequential and REDUCTION clause causes
                !ACanas(2010): rounding errors that cannot be exactly certified.
                
                ! CHUNK = CHUNK_K(kbottom, KUB)

                ! !! $OMP PARALLEL PRIVATE(k,Aux) FIRSTPRIVATE(i,j)
                ! !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
    do3:        do  k = kbottom, KUB
                
                    !old U or V water flux
                    Aux = Velocity_UV_Old(I, J, K) * Area_UV (I, J, K) 

                    ! !! $OMP CRITICAL (WLWF1)
                    ![m^3/s]     = [m^3/s]      + [m/s] * [m^2]
                    AuxExplicit  = AuxExplicit  + Aux
                    ! !! $OMP END CRITICAL (WLWF1)

                enddo do3
                ! !! $OMP END DO
                ! !! $OMP END PARALLEL

                !Area of a South or West Z cell
                AreaCell1 = DUX_VY(iSouth, jWest) * DVY_UX(iSouth, jWest)

                !Area of a North or East Z cell
                AreaCell2 = DUX_VY(I, J) * DVY_UX(I, J)

                DT_AreaCell1 = DT_Elevation / AreaCell1   ![s/m^2]

                DT_AreaCell2 = DT_Elevation / AreaCell2   ![s/m^2]


                !Compute the coeficients of linear system equations for the I,J Z cell

ic1:            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then


                    call CyclicCoef2D (TiCoef_2D, TiCoef_2D_Aux,                                  &
                                       AuxExplicit, DT_AreaCell1,                        &
                                       DT_AreaCell2, I, J, iSouth, jWest)
                else ic1


                    ![m]                   = [m]         + [m^3/s]     * [s/m^2]
                    TiCoef_2D(I, J)           = TiCoef_2D(I      , J     ) + AuxExplicit * DT_AreaCell2

                    !Compute the coeficients of linear system equations for the iSouth, jWest Z cell

                    ![m]                   = [m]                     + [m^3/s]     * [s/m^2]
!                    TiCoef_2D(iSouth, jWest)= TiCoef_2D(iSouth, jWest) - AuxExplicit * DT_AreaCell1
                    TiCoef_2D_Aux(iSouth, jWest)= - AuxExplicit * DT_AreaCell1
                    
                endif ic1


                if ((BarotropicRadia == FlatherWindWave_       .or.                    &
                     BarotropicRadia == FlatherLocalSolution_) .and.                   &
                     BoundaryFacesUV(I, J) == Boundary) then

                    ![m^3/s]
                    TiRadCoef_2D (I, J)   = TiRadCoef_2D(I, J   )  + AuxExplicit

                endif 

            endif cd1
        enddo do2
        enddo do1
        !! $OMP END DO

        !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            TiCoef_2D(i, j) = TiCoef_2D(i, j) + TiCoef_2D_Aux(i, j)

        enddo
        enddo
        !! $OMP END DO
        
        !! $OMP CRITICAL
        call SetMatrixValue( Me%Coef%D2%Tiaux,  Me%WorkSize2D, 0.0)
        !! $OMP END CRITICAL

        !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
    do4: do j = JLB, JUB
    do5: do i = ILB, IUB

            iSouth = I - dj
            jWest  = J - di

    cd2:    if (ComputeFaces3D_VU(i, j, KUB) == Covered) then
        
                kbottom = KFloor_VU(I, J)

                AuxExplicit  = 0.
                
    do6:        do  k = kbottom, KUB
                

                    !Old V or U water flux

                    ![m^3/s]     = [m^3/s]      + [m/s] * [m^2]
                    AuxExplicit  = AuxExplicit  + Velocity_VU_Old(I, J, K) * Area_VU (I, J, K) 
                

                    !New V or U water flux

                    ![m^3/s]     = [m^3/s]      + [m/s] * [m^2]
                    AuxExplicit  = AuxExplicit  + (2. - Num_Discretization) * &
                                                  Velocity_VU_New(I, J, K) * Area_VU (I, J, K) 

                enddo do6

                DT_Aux = DT_Elevation * Num_Discretization / 2.  

                !Area of a South or West Z cell
                AreaCell1 = DUX_VY(iSouth, jWest) * DVY_UX(iSouth, jWest)

                !Area of a North or East Z cell
                AreaCell2 = DUX_VY(I,J) * DVY_UX(I,J)

                DT_AreaCell1 = DT_Aux / AreaCell1   ![s/m^2]

                DT_AreaCell2 = DT_Aux / AreaCell2   ![s/m^2]

                !Compute the coeficients of linear system equations for the I,J Z cell

ic2:            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then

                    call CyclicCoef2D (TiCoef_2D, TiCoef_2D_Aux,                                    &
                                       AuxExplicit, DT_AreaCell1,                        &
                                       DT_AreaCell2, I, J, iSouth, jWest, Direction = Me%Direction%YX)

                else ic2

                    ![m]                   = [m]         + [m^3/s]     * [s/m^2]
                    TiCoef_2D(I,J)         = TiCoef_2D(I,       J     ) + AuxExplicit * DT_AreaCell2

                    !Compute the coeficients of linear system equations for the iSouth, jWest Z cell

                    ![m]                   = [m]                     + [m^3/s]     * [s/m^2]
!                    TiCoef_2D(iSouth, jWest)= TiCoef_2D(iSouth, jWest) - AuxExplicit * DT_AreaCell1
                    TiCoef_2D_Aux(iSouth, jWest)= - AuxExplicit * DT_AreaCell1

                endif ic2

            endif cd2

        enddo do5
        enddo do4
        !! $OMP END DO

        !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            TiCoef_2D(i, j) = TiCoef_2D(i, j) + TiCoef_2D_Aux(i, j)

        enddo
        enddo
        !! $OMP END DO NOWAIT
        
        !! $OMP END PARALLEL

        !Nullify auxiliar pointers 
        nullify(TiCoef_2D)  

        nullify(TiRadCoef_2D)  

        nullify(DUX_VY)
        nullify(DVY_UX)

        nullify(ComputeFaces3D_UV)
        nullify(ComputeFaces3D_VU)
        nullify(KFloor_UV)
        nullify(KFloor_VU)
        nullify(BoundaryFacesUV)

        nullify(Area_UV)
        nullify(Area_VU)

        nullify(Velocity_UV_Old)
        nullify(Velocity_UV_New)
        nullify(Velocity_VU_Old)
        nullify(Velocity_VU_New)

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_WaterFluxes")
        endif

    end Subroutine WaterLevel_WaterFluxes

    !End------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! The effect of all explicit water discharges in the elevation calculation is compute  !
    ! in this subroutine                                                                   ! 
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine WaterLevelDischarges 
    
        
        !Variables Categories  
            !Geometry  : Area_UV, Area_VU, DUX_VY, DVY_UX
            !Flow      : Velocity_UV_Old, Velocity_VU_Old, Velocity_VU_New
            !Time      : DT_Elevation
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : TiCoef_2D
            !Domain    : KUB, ILB, IUB, JLB, JUB,              
            !Numeric   : Num_Discretization

         
        !Variables Direction Dependent
            !Area_UV, Area_VU, DUX_VY, DVY_UX, Velocity_UV_Old, Velocity_VU_Old, 
            !Velocity_VU_New, ComputeFaces3D_UV, KFloor_UV, Direction
        
        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: DischargeFlow
        real,    dimension(:,:  ), pointer :: TiCoef_2D, DUX, DVY

        integer, dimension(:,:,:), pointer :: WaterPoints3D
        integer, dimension(:,:),   pointer :: KFloor_Z

        real                               :: DT_Elevation

        integer                            :: I, J, K, kbottom

        integer                            :: IUB, ILB, JUB, JLB, KUB


        real                               :: AuxExplicit, DT_AreaCell, AreaCell

        integer                            :: CHUNK

        !Begin---------------------------------------------------------------------

cd0:    if (Me%ComputeOptions%SurfaceWaterFlux .or.                         &
            Me%ComputeOptions%WaterDischarges  .or.                         &
            Me%ComputeOptions%BottomWaterFlux) then


            !Begin - Shorten variables name 

            IUB = Me%WorkSize%IUB
            ILB = Me%WorkSize%ILB
            JUB = Me%WorkSize%JUB
            JLB = Me%WorkSize%JLB
            KUB = Me%WorkSize%KUB

            DT_Elevation         =  Me%WaterLevel%DT

            TiCoef_2D            => Me%Coef%D2%Ti
            DischargeFlow        => Me%WaterFluxes%Discharges

            DUX                  => Me%External_Var%DUX
            DVY                  => Me%External_Var%DVY

            WaterPoints3D        => Me%External_Var%WaterPoints3D
            KFloor_Z             => Me%External_Var%KFloor_Z
            !End - Shorten variables name 

            CHUNK = CHUNK_J(JLB, JUB)
            
            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "WaterLevelDischarges")
            endif
            
            !$OMP PARALLEL PRIVATE(i,j,k,kbottom,AuxExplicit,AreaCell) &
            !$OMP PRIVATE(DT_AreaCell)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:        do j = JLB, JUB
do2:        do i = ILB, IUB


cd1:            if (WaterPoints3D(i, j, KUB) == WaterPoint) then
        
                    kbottom = KFloor_Z(I, J)

                    AuxExplicit  = 0.
                    
do3:                do  k = kbottom, KUB
                
                        ![m^3/s]     = [m^3/s]      + [m^3/s]
                        AuxExplicit  = AuxExplicit  + DischargeFlow(i, j, k)

                    enddo do3

                    !Area of a North or East Z cell
                    AreaCell = DUX(I, J) * DVY(I, J)

                    DT_AreaCell = DT_Elevation / AreaCell   ![s/m^2]

                    !Compute the coeficients of linear system equations for the I,J Z cell

                    ![m]             = [m]             + [m^3/s]     * [s/m^2]
                    TiCoef_2D(I, J)  = TiCoef_2D(I, J) + AuxExplicit * DT_AreaCell


                endif cd1

            enddo do2
            enddo do1
            !$OMP END DO
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "WaterLevelDischarges")
            endif

            !Nullify auxiliar pointers 

            nullify(TiCoef_2D)  

            nullify(DUX)
            nullify(DVY)

            nullify(WaterPoints3D)
            nullify(KFloor_Z)

            nullify(DischargeFlow)

        endif cd0




    end Subroutine WaterLevelDischarges

    !End------------------------------------------------------------------------------

    !End------------------------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! The effect of all explicit water discharges in the elevation calculation is compute  !
    ! in this subroutine                                                                   ! 
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine ModifyWaterDischarges

        !Arguments-------------------------------------------------------------


        !Local----------------------------------------------------------------- 
        real,    dimension(:,:  ), pointer :: AddSurfaceWater
        type (T_Time)                      :: CurrentTime

        real                               :: DischargeFlow, AuxFlowK
        integer                            :: DischargesNumber, DischargeID, i, j, kd, k, kmin, kmax
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        integer                            :: STAT_CALL, kbottom

        integer, dimension(:,:,:), pointer :: OpenPoints3D, WaterPoints3D
        real(8), dimension(:,:  ), pointer :: BottomWaterFlux
        real,    dimension(:,:  ), pointer :: Bathymetry

        real,    dimension(:,:,:), pointer :: DWZ
        real,    dimension(:,:  ), pointer :: WaterColumnZ
        integer, dimension(:,:  ), pointer :: KFloor_Z

        integer                            :: DischVertical

        real                               :: WaterLevelByPass !, Depth
        integer                            :: ib, jb !, k1
        logical                            :: ByPassON, IgnoreOK !, DepthON

        real,    dimension(:    ), pointer :: DistributionCoef
        integer, dimension(:    ), pointer :: VectorI, VectorJ, VectorK
        real                               :: AuxFlowIJ, SectionHeight
        real                               :: CoordinateX, CoordinateY
        logical                            :: CoordinatesON
        integer                            :: nCells, n
        integer                            :: FlowDistribution 

        integer                            :: CHUNK
 
        !Begin----------------------------------------------------------------------

        !Begin - Shorten variables name 

        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB

        OpenPoints3D  => Me%External_Var%OpenPoints3D
        WaterPoints3D => Me%External_Var%WaterPoints3D
        KFloor_Z      => Me%External_Var%KFloor_Z
        DWZ           => Me%External_Var%DWZ
        WaterColumnZ  => Me%External_Var%WaterColumn

        call SetMatrixValue(Me%WaterFluxes%Discharges, Me%WorkSize, dble(0.0))

        !Water discharge - input of mass in the domain 
cd1:    if (Me%ComputeOptions%WaterDischarges) then

            ! Sinks and Sources
            call GetDischargesNumber(Me%ObjDischarges,&
                                      DischargesNumber, STAT = STAT_CALL)

            if (STAT_CALL/=SUCCESS_) stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR10'
            
            !Gets a pointer to Bathymetry
            call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR20'

do1:        do DischargeID = 1, DischargesNumber

                call GetDischargeON(Me%ObjDischarges,DischargeID, IgnoreOK, STAT = STAT_CALL)   
                if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR25'

                if (IgnoreOK) cycle

                call GetDischargesGridLocalization(Me%ObjDischarges,                    &
                                                   DischargeID,                         &
                                                   Igrid         = I,                   & 
                                                   JGrid         = J,                   &
                                                   KGrid         = Kd,                  &
                                                   IByPass       = Ib,                  &
                                                   JByPass       = Jb,                  &
                                                   DischVertical = DischVertical,       &
                                                   WaterColumnZ  = WaterColumnZ,        &
                                                   Bathymetry    = Bathymetry,          &
                                                   OpenPoints3D  = Me%External_Var%OpenPoints3D,&
                                                   CoordinateX   = CoordinateX,         &
                                                   CoordinateY   = CoordinateY,         & 
                                                   CoordinatesON = CoordinatesON,       &
                                                   TimeX         = Me%CurrentTime,      &
                                                   STAT          = STAT_CALL)   
                if (STAT_CALL/=SUCCESS_) stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR30'
            
                if (CoordinatesON) then
                    call GetXYCellZ(Me%ObjHorizontalGrid, CoordinateX, CoordinateY, I, J, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR40'

                    call CorrectsCellsDischarges(Me%ObjDischarges, DischargeID, I, J, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR45'                
                endif                        

                !Check if this is a bypass discharge. If it is gives the water level of the bypass end cell
                call GetByPassON(Me%ObjDischarges, DischargeID, ByPassON, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR50'

                if (ByPassON) then
                    WaterLevelByPass = Me%WaterLevel%Old(ib, jb)
                else
                    WaterLevelByPass = FillValueReal
                endif


                call GetDischargeWaterFlow(Me%ObjDischarges,                            &
                                           Me%CurrentTime, DischargeID,                 &
                                           Me%WaterLevel%Old(I, J),                     &
                                           DischargeFlow,                               &
                                           SurfaceElevation2 = WaterLevelByPass,        &                                           
                                           STAT = STAT_CALL)             

                if (STAT_CALL/=SUCCESS_) stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR60'


                call GetDischargeFlowDistribuiton(Me%ObjDischarges, DischargeID, nCells, FlowDistribution, &
                                                  VectorI, VectorJ, VectorK, kmin, kmax, STAT = STAT_CALL)             

                if (STAT_CALL/=SUCCESS_)                                                     &
                    stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR70'


i1:             if (nCells > 1) then
                    allocate(DistributionCoef(1:nCells))
i2:                 if      (FlowDistribution == DischByCell_ ) then
                    
                        DistributionCoef(1:nCells) = 1./float(nCells)

                    else i2
                    
                        stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR80'

                    endif i2
                endif i1

                AuxFlowIJ = DischargeFlow
                
                if (Me%OutPut%TimeSerieDischON) then
                    Me%OutPut%TimeSerieDischProp(DischargeID,1) = 0.
                endif

 dn:            do n=1, nCells
 
                    if (nCells > 1) then
                        i         = VectorI(n)
                        j         = VectorJ(n)
                        kd        = VectorK(n)

                        call GetDischargeWaterFlow(Me%ObjDischarges,                       &
                                                   Me%CurrentTime, DischargeID,            &
                                                   Me%WaterLevel%Old(I, J),                &
                                                   AuxFlowIJ,                              &
                                                   SurfaceElevation2 = WaterLevelByPass,   &    
                                                   FlowDistribution  = DistributionCoef(n),&                                      
                                                   STAT              = STAT_CALL)                        

                        if (STAT_CALL/=SUCCESS_)                                        &
                            stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR95'

                    endif

                    if (DischVertical == DischUniform_) then

                        if (kmin == FillValueInt) kmin = KFloor_Z(i, j)
                        if (kmax == FillValueInt) kmax = KUB
                        SectionHeight = 0                                                
                        
                        do k=kmin, kmax                            
                            SectionHeight = SectionHeight + DWZ(i, j, k)                        
                        enddo
                    else
            
                        kmin = kd; kmax = kd

                    endif

dk:                 do k=kmin, kmax

                        if (OpenPoints3D(i, j, k) /= OpenPoint .and. DischargeFlow < 0)  Cycle

                        if (DischVertical == DischUniform_) then
                        
                            AuxFlowK = DWZ(i, j, k) / SectionHeight * AuxFlowIJ

                        else

                            AuxFlowK = AuxFlowIJ

                        endif

                        Me%WaterFluxes%Discharges(i, j, k) =                                &
                            Me%WaterFluxes%Discharges(i, j, k) + AuxFlowK

                        if (Me%OutPut%TimeSerieDischON) then
                            Me%OutPut%TimeSerieDischProp(DischargeID,1) = Me%OutPut%TimeSerieDischProp(DischargeID,1) + AuxFlowK
                        endif
 
                    enddo dk

                enddo dn

                if (nCells > 1) deallocate(DistributionCoef)

                call UnGetDischarges(Me%ObjDischarges, VectorI, STAT = STAT_CALL)             
                if (STAT_CALL/=SUCCESS_)                                                    &
                    stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR90'

                call UnGetDischarges(Me%ObjDischarges, VectorJ, STAT = STAT_CALL)             
                if (STAT_CALL/=SUCCESS_)                                                    &
                    stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR100'

                call UnGetDischarges(Me%ObjDischarges, VectorK, STAT = STAT_CALL)             
                if (STAT_CALL/=SUCCESS_)                                                    &
                    stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR110'


            enddo do1

            !Disposes pointer to the Bathymetry
            call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR120'


        endif cd1

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyWaterDischarges")
        endif

cd2:    if (Me%ComputeOptions%SurfaceWaterFlux .and. .not. Me%State%Initial) then

            AddSurfaceWater => Me%External_Var%SurfaceWaterFlux 

            CurrentTime   = Me%CurrentTime
 
            CHUNK = CHUNK_J(JLB, JUB)
 
            !$OMP PARALLEL PRIVATE(i,j)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do2:            do j = JLB, JUB
do3:            do i = ILB, IUB

!                    !Precipitation Condition : AddSurfaceWater(i, j) > 0
!                    !Evaporation   Condition : AddSurfaceWater(i, j) < 0
!                    if ((OpenPoints3D (i, j, KUB) == OpenPoint .and. AddSurfaceWater(i, j) < 0) .or. &
!                        (WaterPoints3D(i, j, KUB) == WaterPoint.and. AddSurfaceWater(i, j) > 0)) then

                    if (OpenPoints3D (i, j, KUB) == OpenPoint) then
                                        
                        Me%WaterFluxes%Discharges(i, j, KUB)     =                      &
                            Me%WaterFluxes%Discharges(i, j, KUB) +                      &
                            AddSurfaceWater(i, j)

                    endif

            enddo do3
            enddo do2
            !$OMP END DO
            !$OMP END PARALLEL

        endif cd2

!Put BottomWaterFlux in data input
cd3:    if (Me%ComputeOptions%BottomWaterFlux .and. .not. Me%State%Initial) then

                BottomWaterFlux => Me%External_Var%BottomWaterFlux

                CHUNK = CHUNK_J(JLB, JUB)

                !$OMP PARALLEL PRIVATE(i,j)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do4:            do j = JLB, JUB
do5:            do i = ILB, IUB

                    kbottom  = Me%External_Var%KFloor_Z (i,j)

                    !Water out of sediment : BottomWaterFluxes(i, j) > 0
                    !Water infiltrating    : BottomWaterFluxes(i, j) < 0
                    if ((OpenPoints3D (i, j, KLB) == OpenPoint .and. BottomWaterFlux (i, j) < 0) .or. &
                        (WaterPoints3D(i, j, KLB) == WaterPoint.and. BottomWaterFlux (i, j) > 0)) then
                
                        Me%WaterFluxes%Discharges(i, j, kbottom)     =                  &
                            Me%WaterFluxes%Discharges(i, j, kbottom) +                  &
                            BottomWaterFlux(i, j)

                    endif

            enddo do5
            enddo do4
            !$OMP END DO
            !$OMP END PARALLEL

        endif cd3

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyWaterDischarges")
        endif        

        !Nullify auxilary pointers
        nullify (OpenPoints3D )
        nullify (WaterPoints3D)
        nullify (KFloor_Z     ) 
        nullify (DWZ          ) 
        nullify (WaterColumnZ )


    end subroutine ModifyWaterDischarges

    !End------------------------------------------------------------------------------

  
    subroutine Hydrodynamic_OutPut


        !Local-----------------------------------------------------------------
        real,  dimension(:), pointer        :: AuxFlow
        logical                             :: OutPutFileOK, OutPutSurfaceFileOK
        integer                             :: NextOutPut, STAT_CALL, iW, dis
        real                                :: DT_Model
        real                                :: Year, Month, Day, Hour, Minute, Second

        !Begin---------------------------------------------------------------------


        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Hydrodynamic_OutPut")

        Me%OutPut%Run_End       = .false.
        
        OutPutFileOK = .false.

        if (Me%OutPut%TimeSerieON .or. Me%OutPut%hdf5ON .or.                            &
            Me%OutPut%ProfileON   .or. Me%OutPut%HDF5_Surface_ON.or.                    &
            Me%OutW%OutPutWindowsON)then

            call ModifyMatrixesOutput

        end if
        
        !! $OMP PARALLEL SECTIONS
                
        !! $OMP SECTION
        if (Me%OutPut%hdf5ON) then 

            NextOutPut = Me%OutPut%NextOutPut

            if (NextOutPut <= Me%OutPut%Number) then
                if (Me%CurrentTime >= Me%OutPut%OutTime(NextOutPut)) then

                    OutPutFileOK = .true.
                    
                endif
            endif
            
            !Computes cartesian vertical velocity
            !if (OutPutFileOK .or. Me%OutPut%TimeSerieON) then

            !  call ComputeCartesianVertVelocity

            !endif

             !Next line changed to avoid rounding errors - Frank Aug - 2001
            if (OutPutFileOK) then

!            if ((Me%CurrentTime + DT_Model/10.) >= Me%OutPut%OutTime(NextOutPut)) then

                call GetComputeTimeStep(Me%ObjTime, DT_Model, STAT = STAT_CALL)

                !Next line changed to avoid rounding errors - Frank Aug - 2001
                if (Me%EndTime == Me%OutPut%OutTime(NextOutPut)) then
!                if (abs(Me%EndTime - Me%OutPut%OutTime(NextOutPut)) < DT_Model/10. ) then

                    Me%OutPut%Run_End = .true.

                endif


                !Output in HDF
                call Write_HDF5_Format

                !
                ! This passed to the module ModuleModel
                !
                !Message to the user
                !call PrintProgress(Me%ObjTime)     !Frank

#ifdef _USE_SEQASSIMILATION
                if (.not. Me%VirtualRun) then 
#endif _USE_SEQASSIMILATION

                Me%OutPut%NextOutPut = Me%OutPut%NextOutPut + 1

#ifdef _USE_SEQASSIMILATION
                endif
#endif _USE_SEQASSIMILATION

            endif

        endif
        
        !! $OMP SECTION
        if (Me%OutW%OutPutWindowsON)  then
        
            do iW = 1, Me%OutW%WindowsNumber

                NextOutPut = Me%OutW%OutPutWindows(iW)%NextOutPut
                
                OutPutFileOK = .false. 

                if (NextOutPut <= Me%OutW%OutPutWindows(iW)%Number) then
                    if (Me%CurrentTime >= Me%OutW%OutPutWindows(iW)%OutTime(NextOutPut)) then
                        OutPutFileOK = .true.
                    endif
                endif
                
                if (OutPutFileOK) then
                    call Write_HDF5_Format(iW)
                    
                    NextOutPut = NextOutPut + 1
                    
                    Me%OutW%OutPutWindows(iW)%NextOutPut = NextOutPut
                endif
            enddo
            
        endif        
        
        !! $OMP SECTION
        if(Me%OutPut%HDF5_Surface_ON)then

            OutPutSurfaceFileOK = .false.


            if (Me%OutPut%NextSurfaceOutPut <= Me%OutPut%NumberSurfaceOutputs) then
                if (Me%CurrentTime >= Me%OutPut%SurfaceOutTime(Me%OutPut%NextSurfaceOutPut)) then

                    OutPutSurfaceFileOK = .true.

                endif
            endif

            if(OutPutSurfaceFileOK)then

                call Write_Surface_HDF5_Format

                Me%OutPut%NextSurfaceOutPut = Me%OutPut%NextSurfaceOutPut + 1

            endif

        end if        
                
        !! $OMP SECTION
        if (Me%OutPut%TimeSerieON)  &
            call OutPut_TimeSeries

        !! $OMP SECTION
        if (Me%OutPut%ProfileON)    &
            call Output_Profile

        !! $OMP SECTION
        if(Me%OutPut%WriteRestartFile .and. .not. Me%OutPut%Run_End)then

            if(Me%CurrentTime >= Me%OutPut%RestartOutTime(Me%OutPut%NextRestartOutput))then

                call ReadUnLock_ModuleGeometry 

                if (Me%ComputeOptions%Evolution == Solve_Equations_) then
                    call Write_Final_Hydrodynamic_File
                endif


                call ReadLock_ModuleGeometry 


                Me%OutPut%NextRestartOutput = Me%OutPut%NextRestartOutput + 1

                call ExtractDate(Me%CurrentTime, Year = Year, Month  = Month,  Day    = Day, &
                                                 Hour = Hour, Minute = Minute, Second = Second)

                call SetError(WARNING_, INTERNAL_, "Hydrodynamic restart file saved        : ", &
                              Year, Month, Day, Hour, Minute, Second)

            end if

        end if         
        !! $OMP END PARALLEL SECTIONS

        if (Me%OutPut%TimeSerieDischON) then
            do dis = 1, Me%OutPut%DischargesNumber
   
                allocate(AuxFlow(4))
                
                AuxFlow(1:4) = Me%OutPut%TimeSerieDischProp(dis,1:4)
                
                call WriteTimeSerieLine(Me%OutPut%TimeSerieDischID(dis), AuxFlow,  STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Hydrodynamic_OutPut - ModuleHydrodynamic - ERR10'
                
                deallocate(AuxFlow)
                
            enddo    
        endif              
                
        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Hydrodynamic_OutPut")


    end subroutine Hydrodynamic_OutPut

    !End------------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    ! This subroutine is responsable for computing fluxes between boxes      

    subroutine ComputeBoxesWaterFluxes

        !Arguments-------------------------------------------------------------

         

        !External--------------------------------------------------------------
        
        integer :: STAT_CALL    

        !Local-----------------------------------------------------------------


        !----------------------------------------------------------------------
       
        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ComputeBoxesWaterFluxes")

cd1:    if (Me%State%BOXFLUXES) then

            call BoxDif(Me%ObjBoxDif,                                                    &
                        Me%WaterFluxes%X,                                                &
                        Me%WaterFluxes%Y,                                                &
                        Me%WaterFluxes%Z,                                                & 
                        Char_Water,                                                      &
                        Me%External_Var%OpenPoints3D,                                   &
                        STAT = STAT_CALL)

            if (STAT_CALL .NE. SUCCESS_)                                                 &
               stop 'Subroutine ComputeBoxesWaterFluxes; Module ModuleHydrodynamic. ERR01'

            call BoxDif(Me%ObjBoxDif,                                                    &
                        Me%External_Var%Volume_Z_New,                                    &
                        Char_Water,                                                      &
                        Me%External_Var%OpenPoints3D,                                   &
                        STAT = STAT_CALL)

            if (STAT_CALL .NE. SUCCESS_)                                                 &
               stop 'Subroutine ComputeBoxesWaterFluxes; Module ModuleHydrodynamic. ERR02'

        endif cd1

        !----------------------------------------------------------------------
        
        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ComputeBoxesWaterFluxes")

    end subroutine ComputeBoxesWaterFluxes

    !--------------------------------------------------------------------------


    !This subroutine computes 
    Subroutine ComputeResidualFlowProperties

        !Local-----------------------------------------------------------------
        integer                            :: i, j, k, kbottom
        integer                            :: ILB, JLB, KLB, IUB, JUB, KUB
        integer                            :: CHUNK
        
        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ComputeResidualFlowProperties")

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        CHUNK = CHUNK_J(JLB, JUB)

        !$OMP PARALLEL PRIVATE(I,J,K,kbottom)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)

do1:    do  j = JLB, JUB 
do2:    do  i = ILB, IUB
            
cd2:        if (Me%External_Var%WaterPoints3D(i, j, KUB) == WaterPoint) then 

                !Residual Water elevation
                Me%Residual%WaterLevel(i, j) =                                                   &
                                      (Me%Residual%WaterLevel(i, j) * Me%Residual%ResidualTime + &
                                       Me%WaterLevel%New(i, j) * Me%WaterLevel%DT)             / &
                                      (Me%Residual%ResidualTime + Me%WaterLevel%DT)

                kbottom = Me%External_Var%KFloor_Z(i, j)

do3:            do  k = kbottom, KUB
                    
                    !Residual horizontal velocity
                    Me%Residual%Velocity_U(i, j, k) =                                                     &
                                         (Me%Residual%Velocity_U(i, j, k) * Me%Residual%ResidualTime    + &
                                          Me%Velocity%Horizontal%U%New(i, j, k) * Me%WaterLevel%DT)     / &
                                         (Me%Residual%ResidualTime + Me%WaterLevel%DT)

                    Me%Residual%Velocity_V(i, j, k) = &
                                         (Me%Residual%Velocity_V(i, j, k) * Me%Residual%ResidualTime    + &
                                          Me%Velocity%Horizontal%V%New(i, j, k) * Me%WaterLevel%DT)     / &
                                         (Me%Residual%ResidualTime + Me%WaterLevel%DT)

                    !Residual vertical velocity
                    Me%Residual%Vertical_Velocity(i, j, k) =                                                  &
                                         (Me%Residual%Vertical_Velocity(i, j, k) * Me%Residual%ResidualTime + &
                                          Me%Velocity%Vertical%Across(i, j, k) * Me%WaterLevel%DT)          / &
                                         (Me%Residual%ResidualTime + Me%WaterLevel%DT)


                    !Residual Water fluxes by width (residual specifc flow)
                    Me%Residual%WaterFlux_X(i, j, k) =                                                        &
                                             (Me%Residual%WaterFlux_X(i, j, k) * Me%Residual%ResidualTime   + &
                                              Me%WaterFluxes%X(i, j, k) / Me%External_Var%DYY(i, j)         * &
                                              Me%WaterLevel%DT)                                             / &
                                             (Me%Residual%ResidualTime + Me%WaterLevel%DT)  

                    Me%Residual%WaterFlux_Y(i, j, k) =                                                        &
                                             (Me%Residual%WaterFlux_Y(i, j, k) * Me%Residual%ResidualTime   + &
                                              Me%WaterFluxes%Y(i, j, k) / Me%External_Var%DXX(i, j)         * &
                                              Me%WaterLevel%DT)                                             / &
                                             (Me%Residual%ResidualTime + Me%WaterLevel%DT)  

                    !Residual layer thickness
                    Me%Residual%DWZ(i, j, k) =                                                                &
                                            (Me%Residual%DWZ(i, j, k) * Me%Residual%ResidualTime            + &
                                             Me%External_Var%DWZ(i, j, k)* Me%WaterLevel%DT)                / &
                                            (Me%Residual%ResidualTime + Me%WaterLevel%DT) 

                enddo do3

            endif cd2

        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        Me%Residual%ResidualTime  = Me%Residual%ResidualTime + Me%WaterLevel%DT
       
        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ComputeResidualFlowProperties")


    end subroutine ComputeResidualFlowProperties
    
    !----------------------------------------------------------------------

    subroutine ComputeSystemEnergy !Frank Out99

        !Local-----------------------------------------------------------------
        real(8)                                     :: KineticEnergy,   TotalKineticEnergy        !*, ecin
        real(8)                                     :: BarotropicKineticEnergy,   TotalBarotropicKineticEnergy      
        real(8)                                     :: BaroclinicKineticEnergy,   TotalBaroclinicKineticEnergy      
        real(8)                                     :: PotentialEnergy, TotalPotentialEnergy      !potmat, epot
!        real(8)                                     :: APE, TotalAPE
!        real(8)                                     :: GPE, TotalGPE
        real(8)                                     :: Vorticity, TotalEnstrophy
        real(8)                                     :: Mass,            TotalMass                 !rmassa, rmtot
        real(8)                                     :: Volume,          TotalVolume, OpenVolume
        real(8)                                     :: TotalLevelArea, TotalArea, Area
        real(8)                                     :: Velocity2, AuxVel
        real                                        :: Year, Month, Day, Hour, Minute, Second
        real(8)                                     :: VelMaxBaroclinic, VelMax, BaroclinicU, BaroclinicV
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                                     :: WorkKLB, WorkKUB
        integer                                     :: i, j, k, iBuffer
        integer, dimension(:, :, :), pointer        :: WaterPoints3D
        integer, dimension(:, :, :), pointer        :: OpenPoints3D
        integer, dimension(:, :   ), pointer        :: BoundaryPoints
        real, dimension(:, :, :),    pointer        :: Density, SZZ, DWZ
        real(8), dimension(:, :, :), pointer        :: VolumeZ
        !real, dimension(:,:),        pointer        :: Bathymetry
        real, dimension(:,:),        pointer        :: DUX, DVY
        real, dimension(:,:),        pointer        :: DZX, DZY
        real, dimension(:,:),        pointer        :: WaterColumnZ
!        real, dimension(:, :, :),    pointer    :: S,T
!        real(8)                                 :: MinusOnePercentS, A, TotalA,Smin,Smax
!        real(8)                                 :: rho_p, rho

        integer                                     :: CHUNK

        !Begin --------------------------------------------------------------------------

        !A if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ComputeSystemEnergy")

        if (Me%CurrentTime >= Me%Energy%NextOutPut) then

            Me%Energy%NextOutPut = Me%Energy%NextOutPut + Me%Energy%DtOut
                                                

            !Size
            IUB     = Me%Size%IUB
            ILB     = Me%Size%ILB
            JUB     = Me%Size%JUB
            JLB     = Me%Size%JLB
            KUB     = Me%Size%KUB
            KLB     = Me%Size%KLB

            !WorkSize
            WorkILB = Me%Energy%Window%ILB 
            WorkIUB = Me%Energy%Window%IUB 
            WorkJLB = Me%Energy%Window%JLB 
            WorkJUB = Me%Energy%Window%JUB 
            WorkKLB = Me%Energy%Window%KLB 
            WorkKUB = Me%Energy%Window%KUB 

            !Gets a pointer to the bathymetry
            !call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            !if (STAT_CALL /= SUCCESS_) stop 'ComputeSystemEnergy - ModuleHydrodynamic - ERR00'

            !Shorten variable names
            WaterPoints3D => Me%External_Var%WaterPoints3D
            OpenPoints3D  => Me%External_Var%OpenPoints3D
            BoundaryPoints=> Me%External_Var%BoundaryPoints
            Density       => Me%External_Var%Density
            VolumeZ       => Me%External_Var%Volume_Z_New
            SZZ           => Me%External_Var%SZZ
            DWZ           => Me%External_Var%DWZ
            DUX           => Me%External_Var%DUX
            DVY           => Me%External_Var%DVY
            DZX           => Me%External_Var%DZX
            DZY           => Me%External_Var%DZY
            WaterColumnZ  => Me%External_Var%WaterColumn

            call CenterVelocity(Me%Energy%CenterU, Me%Energy%CenterV, VectorType = CurrentVelocity)

            call SetMatrixValue(Me%Energy%CenterW, Me%Size, 0.)

            CHUNK = CHUNK_J(WorkJLB, WorkJUB)

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "ComputeSystemEnergy")
            endif

            !$OMP PARALLEL PRIVATE(i,j,k)
            do k = WorkKLB, WorkKUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = WorkJLB, WorkJUB
            do i = WorkILB, WorkIUB
                if (k == WorkKLB) then
                    Me%Energy%CenterW(i, j, k) =  Me%Velocity%Vertical%Cartesian(i, j, k+1) / 2.
                elseif (k == WorkKUB) then
                    Me%Energy%CenterW(i, j, k) =  Me%Velocity%Vertical%Cartesian(i, j, k  ) / 2.
                else
                    Me%Energy%CenterW(i, j, k) = (Me%Velocity%Vertical%Cartesian(i, j, k+1) + &
                                                  Me%Velocity%Vertical%Cartesian(i, j, k  )) / 2.
                endif
            enddo
            enddo
            !$OMP END DO
            enddo
            !$OMP END PARALLEL

            !Inits variables
            TotalKineticEnergy   = 0.d0
            TotalPotentialEnergy = 0.d0
            TotalBarotropicKineticEnergy = 0.d0
            TotalBaroclinicKineticEnergy = 0.d0
            TotalEnstrophy = 0.d0
            TotalMass            = 0.d0
            TotalVolume          = 0.d0
!            TotalAPE             = 0.d0    

            OpenVolume           = 0.d0
            TotalLevelArea       = 0.d0
            TotalArea            = 0.d0
!            TotalA               = 0.d0    

            VelMax               = -99
            VelMaxBaroclinic     = -99

            !$OMP PARALLEL PRIVATE(i,j,k,Mass,Volume,BarotropicKineticEnergy)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK) &
            !$OMP REDUCTION(+:TotalBarotropicKineticEnergy)
            !ACanas(2010): REDUCTION clause has not found to produce rounding
            !ACanas(2010): errors in cases tested, perhaps due to operating in
            !ACanas(2010): variables with large values.

            !Calculates de barotropic velocity 
            do j = WorkJLB, WorkJUB
            do i = WorkILB, WorkIUB

                Me%Energy%BarotropicU(i, j) = 0. 
                Me%Energy%BarotropicV(i, j) = 0.
                Mass                        = 0.

                if (WaterPoints3D(i, j, WorkKUB) == WaterPoint .and. BoundaryPoints(i,j) /= Boundary) then 

                    do k = WorkKLB, WorkKUB

                        if (WaterPoints3D(i, j, k) == WaterPoint) then

                            Volume    = VolumeZ(i, j, k) 
                            Mass      = Mass + Density(i, j, k) * Volume

                            Me%Energy%BarotropicU(i, j) = Me%Energy%BarotropicU(i, j) + &
                                                          Me%Energy%CenterU(i, j, k)  * &
                                                          DWZ(i, j, k) / WaterColumnZ(i, j)
                            Me%Energy%BarotropicV(i, j) = Me%Energy%BarotropicV(i, j) + &
                                                          Me%Energy%CenterV(i, j, k)  * &
                                                          DWZ(i, j, k) / WaterColumnZ(i, j) 

                        endif
                    enddo

                    BarotropicKineticEnergy      = (Me%Energy%BarotropicU(i, j)**2  + &
                                                    Me%Energy%BarotropicV(i, j)**2) * Mass
                    TotalBarotropicKineticEnergy = TotalBarotropicKineticEnergy + BarotropicKineticEnergy

                endif
            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL            

            TotalBarotropicKineticEnergy = 0.5 * TotalBarotropicKineticEnergy

            CHUNK = CHUNK_I(WorkILB, WorkIUB)

            !Calculates Kinetic Energy and Potential Energy of all the sistem
            do i = WorkILB, WorkIUB
            do j = WorkJLB, WorkJUB
            do k = WorkKLB, WorkKUB

                if (WaterPoints3D(i, j, k) == WaterPoint .and. BoundaryPoints(i,j) /= Boundary) then 

                    Volume      = VolumeZ(i, j, k) 
                    Mass        = Density(i, j, k) * Volume

                    TotalVolume = TotalVolume + Volume
                    TotalMass   = TotalMass   + Mass
            
                    if (OpenPoints3D(i, j, k) == OpenPoint) then
                        Velocity2 = Me%Energy%CenterU(i, j, k)**2. + Me%Energy%CenterV(i, j, k)**2. + &
                                    Me%Energy%CenterW(i, j, k)**2.
                        AuxVel = sqrt(Velocity2)

                        if (AuxVel > VelMax) VelMax = AuxVel


                        KineticEnergy        = Mass * Velocity2
                        TotalKineticEnergy   = TotalKineticEnergy + KineticEnergy


                        BaroclinicU = Me%Energy%CenterU(i, j, k) - Me%Energy%BarotropicU(i, j)
                        BaroclinicV = Me%Energy%CenterV(i, j, k) - Me%Energy%BarotropicV(i, j)

                        Velocity2 = BaroclinicU**2.       + &
                                    BaroclinicV**2.       + &
                                    Me%Energy%CenterW(i, j, k)**2.
                        AuxVel = sqrt(Velocity2)

                        if (AuxVel > VelMaxBaroclinic) VelMaxBaroclinic = AuxVel

                        BaroclinicKineticEnergy        = Mass * Velocity2
                        TotalBaroclinicKineticEnergy   = TotalBaroclinicKineticEnergy + BaroclinicKineticEnergy

                    endif                    

                    !PotentialEnergy      = Mass * Gravity * (Bathymetry(i, j) - (SZZ(i, j, k) + DWZ(i, j, k)/2.))
                    !Potential energy compute relatively to hydrographic zero
                    
                    ![M*L/T^2*L]        =  [M] * [L/T^2]*[L]
                    PotentialEnergy      = Mass * Gravity * (- SZZ(i, j, k) - DWZ(i, j, k)/2.) 
                    
                    
                    if (Me%NonHydrostatic%ON) then
                        ![M*L/T^2*L]    = [M*L/T^2*L]     + [M] * [L^2/T^2]
                        PotentialEnergy = PotentialEnergy + Mass * Me%NonHydroStatic%PressureCorrect(i, j, k) 
                    endif                                                                  
                    TotalPotentialEnergy = TotalPotentialEnergy + PotentialEnergy

                    !Calculates the available potential energy
!                    rho_p = SigmaUNESCO(S(i,j,k),T(i,j,k))
!                    rho   = SigmaUNESCO(S(i,j,k+1),T(i,j,k+1))
!                    APE = (rho_p - rho) * DWZ(i,j,k) * volume
!                    TotalAPE = TotalAPE + APE
                    
                    !GravitationalPotentialEnergy
!                    GPE = Mass / (MeanRadius_ - SZZ(i,j,k) - 0.5 * DWZ(i,j,k))
!                    TotalGPE = TotalGPE + GPE

                    !To calculate the graph Level/Volume
                    if (OpenPoints3D(i, j, k) == OpenPoint) then
                        OpenVolume  = OpenVolume  + Volume
                        if (k == WorkKUB) then
                            Area            = DUX(i, j) * DVY(i, j)
                            TotalLevelArea  = TotalLevelArea  + Me%WaterLevel%New(i, j) * Area
                            TotalArea       = TotalArea + Area
                        endif
                    endif

                endif

            enddo
            enddo
            enddo            

            TotalKineticEnergy              = 0.5 * TotalKineticEnergy
            TotalBaroclinicKineticEnergy    = 0.5 * TotalBaroclinicKineticEnergy
            TotalPotentialEnergy            = TotalPotentialEnergy
!            TotalAPE = 0.5 * Gravity * TotalAPE
!            TotalGPE = mu_ * TotalGPE

!            Smin = 39.
!            Smax = 0.
!            do i = WorkILB, WorkIUB
!            do j = WorkJLB, WorkJUB
!            do k = WorkKLB, WorkKUB
                    
!                if (WaterPoints3D(i, j, k) == WaterPoint .and. BoundaryPoints(i,j) /= Boundary) then 
                
!                    if ( Smax .lt. S(i,j,k)) then
!                        Smax = S(i,j,k)
!                    endif

!                    if ( Smin .gt. S(i,j,k)) then
!                        Smin = S(i,j,k)
!                    endif

!                endif

!            enddo
!            enddo
!            enddo            

!            MinusOnePercentS = 0.d0
!            do i = WorkILB, WorkIUB
!            do j = WorkJLB, WorkJUB
                    
!                if (WaterPoints3D(i, j, WorkKUB) == WaterPoint .and. BoundaryPoints(i,j) /= Boundary) then 
                
!                    A = DUX(i, j) * DVY(i, j)
!                    MinusOnePercentS = MinusOnePercentS + S(i,j,WorkKUB) * A
!                    TotalA = TotalA + A

!                endif

!            enddo
!            enddo            
!            MinusOnePercentS = MinusOnePercentS * .99d0 / TotalA

!            TotalA = 0.d0
!            do i = WorkILB, WorkIUB
!            do j = WorkJLB, WorkJUB
                    
!                if (WaterPoints3D(i, j, WorkKUB) == WaterPoint .and. BoundaryPoints(i,j) /= Boundary) then 
                
!                    if ( S(i,j,WorkKUB) .lt. MinusOnePercentS ) then
!                        A = DUX(i, j) * DVY(i, j)
!                       TotalA = TotalA + A
!                    endif

!                endif

!            enddo
!            enddo            

            !Computes the Enstrophy
        
            CHUNK = CHUNK_J(WorkJLB, WorkJUB)

            !$OMP PARALLEL PRIVATE(i,j,k,Vorticity,Volume)        
dok:        do k = WorkKLB, WorkKUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK) REDUCTION(+:TotalEnstrophy)
doj:        do j = WorkJLB, WorkJUB
doi:        do i = WorkILB, WorkIUB
    
                Vorticity = 0
                Volume    = VolumeZ(i, j, k) 
                
cd1:            if (WaterPoints3D(i-1, j  ,k)== WaterPoint .and.                &
                    WaterPoints3D(i  , j  ,k)== WaterPoint) then 

                    Vorticity = - (Me%Energy%CenterU(i, j, k) - Me%Energy%CenterU(i-1, j, k)) / DZY(i-1,j)

                endif cd1

cd2:            if (WaterPoints3D(i  , j  ,k)== WaterPoint .and.                &
                    WaterPoints3D(i  , j-1,k)== WaterPoint) then 

                    Vorticity =  Vorticity + &
                                (Me%Energy%CenterV(i, j, k) - Me%Energy%CenterV(i , j-1, k)) / DZX(i,j-1)

                endif cd2

                TotalEnstrophy = TotalEnstrophy + Volume * Vorticity**2.

            enddo doi
            enddo doj
            !$OMP END DO
            enddo dok
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "ComputeSystemEnergy")
            endif

            ! TotalEnstrophy = 0.5 * TotalEnstrophy

            !Gets the current simulation time
            call ExtractDate(Me%CurrentTime,     &
                             Year   = Year,   Month = Month,  &
                             Day    = Day,    Hour  = Hour,   &
                             Minute = Minute, Second= Second)

            if (Me%Energy%FirstTime) then

                Me%Energy%FirstTime = .false.
            
                !Stores the energy of the first iteration as reference
                Me%Energy%PotentialEnergyReference = TotalPotentialEnergy

            endif


            !Stores Data in a Buffer
            Me%Energy%BufferCount = Me%Energy%BufferCount + 1
            iBuffer = Me%Energy%BufferCount

            Me%Energy%YearBuffer(iBuffer)      = Year
            Me%Energy%MonthBuffer(iBuffer)     = Month
            Me%Energy%DayBuffer(iBuffer)       = Day
            Me%Energy%HourBuffer(iBuffer)      = Hour
            Me%Energy%MinuteBuffer(iBuffer)    = Minute
            Me%Energy%SecondBuffer(iBuffer)    = Second
            Me%Energy%RelativeKEBuffer(iBuffer)= TotalKineticEnergy / TotalMass
            Me%Energy%RelativePEBuffer(iBuffer)= (TotalPotentialEnergy -                &
                                                  Me%Energy%PotentialEnergyReference) / &
                                                  TotalMass
            !Me%Energy%RelativeKEBuffer(iBuffer)= TotalGPE
            !Me%Energy%RelativePEBuffer(iBuffer)= TotalAPE

            Me%Energy%KineticBuffer(iBuffer)   =   TotalKineticEnergy

            Me%Energy%PotentialBuffer(iBuffer) =   TotalPotentialEnergy - Me%Energy%PotentialEnergyReference

            Me%Energy%VorticityBuffer(iBuffer) =   TotalEnstrophy

            Me%Energy%MassBuffer(iBuffer)      =   TotalMass

            Me%Energy%VolumeBuffer(iBuffer)    =   TotalVolume

            if (TotalArea > 0) then
                Me%Energy%WaterLevelBuffer(iBuffer)=   TotalLevelArea / TotalArea
            else
                Me%Energy%WaterLevelBuffer(iBuffer)=   -99.
            endif

            Me%Energy%OpenVolumeBuffer(iBuffer)    =   OpenVolume


            Me%Energy%BarotropicKEBuffer    (iBuffer)  =  TotalBarotropicKineticEnergy / TotalMass
            Me%Energy%BaroclinicKEBuffer    (iBuffer)  =  TotalBaroclinicKineticEnergy / TotalMass

!            Me%Energy%BarotropicKEBuffer    (iBuffer)  =  Smin
!            Me%Energy%BaroclinicKEBuffer    (iBuffer)  =  Smax

           Me%Energy%VelMaxBuffer          (iBuffer)  =  VelMax
!            Me%Energy%VelMaxBuffer          (iBuffer)  =  TotalA
            Me%Energy%VelMaxBaroclinicBuffer(iBuffer)  =  VelMaxBaroclinic

            !If the buffer is full, writes the data file
            if (iBuffer == EnergyBufferSize) then
                call WriteEnergyDataFile
            endif

            !Disposes pointer to the Bathymetry
            !call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            !if (STAT_CALL /= SUCCESS_) stop 'ComputeSystemEnergy - ModuleHydrodynamic - ERR03'

            !Nullifies pointers
            nullify(WaterPoints3D, Density, VolumeZ, SZZ, DWZ)
            nullify(OpenPoints3D, BoundaryPoints)
            nullify(DUX, DVY)


        endif


        !A if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ComputeSystemEnergy")


    end subroutine ComputeSystemEnergy

    !--------------------------------------------------------------------------

    subroutine WriteEnergyDataFile !Frank Out99

        !Arguments-------------------------------------------------------------
        

        !Local
        integer                             :: iBuffer


        do iBuffer = 1, Me%Energy%BufferCount
            write(Me%Energy%FileID, fmt=100) Me%Energy%YearBuffer            (iBuffer), &
                                             Me%Energy%MonthBuffer           (iBuffer), &
                                             Me%Energy%DayBuffer             (iBuffer), &
                                             Me%Energy%HourBuffer            (iBuffer), &
                                             Me%Energy%MinuteBuffer          (iBuffer), &
                                             Me%Energy%SecondBuffer          (iBuffer), &
                                             Me%Energy%KineticBuffer         (iBuffer), &
                                             Me%Energy%PotentialBuffer       (iBuffer), &
                                             Me%Energy%RelativeKEBuffer      (iBuffer), &
                                             Me%Energy%RelativePEBuffer      (iBuffer), &
                                             Me%Energy%MassBuffer            (iBuffer), &
                                             Me%Energy%VolumeBuffer          (iBuffer), &
                                             Me%Energy%OpenVolumeBuffer      (iBuffer), &
                                             Me%Energy%WaterLevelBuffer      (iBuffer), &
                                             Me%Energy%BarotropicKEBuffer    (iBuffer), &
                                             Me%Energy%BaroclinicKEBuffer    (iBuffer), &
                                             Me%Energy%VelMaxBuffer          (iBuffer), &
                                             Me%Energy%VelMaxBaroclinicBuffer(iBuffer), &
                                             Me%Energy%VorticityBuffer       (iBuffer)
                                                         
            100 format(1x, f5.0, 1x, f4.0, 1x, f4.0, 1x, f4.0, 1x, f4.0, f4.0, 1x, e16.8, 1x, e16.8, 1x, e16.8, 1x, e16.8, 1x,  &
                       e16.8, 1x, e16.8, 1x, e16.8, 1x, f12.6, 1x, e16.8, 1x, e16.8, 1x, e16.8, 1x, e16.8, 1x, e16.8)
                       
        enddo
        Me%Energy%BufferCount = 0

    end subroutine WriteEnergyDataFile

    !--------------------------------------------------------------------------

    subroutine Write_HDF5_Format(iW)
        !Arguments-------------------------------------------------------------
        integer,    optional                :: iW

        !Local-----------------------------------------------------------------
        integer                             :: STAT_CALL
        real, dimension(6), target          :: AuxTime
        real, dimension(:), pointer         :: TimePtr
        integer                             :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                             :: WorkKLB, WorkKUB, Index
        integer                             :: i, j, k, kbottom, ObjHDF5
        real, dimension(:, :, :), pointer   :: SZZ, DWZ   !flavio
        integer, dimension(:,:,:), pointer  :: WaterPoints3D, ComputeFaces3D_W ! flavio
        integer, dimension(:,:,:), pointer  :: OpenPoints3D
        integer, dimension(:,:),   pointer  :: KFloorZ
        character(len = StringLength)       :: AuxChar
        integer                             :: CHUNK
        logical                             :: SimpleOutPut
        type (T_Time)                       :: Aux
        real(8)                             :: AuxPeriod, TotalTime        

        !----------------------------------------------------------------------

        !A if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Write_HDF5_Format")
        
        SimpleOutPut = .false.

        !Bounds
        if (present(iW)) then

            WorkILB = Me%OutW%OutPutWindows(iW)%ILB
            WorkIUB = Me%OutW%OutPutWindows(iW)%IUB

            WorkJLB = Me%OutW%OutPutWindows(iW)%JLB
            WorkJUB = Me%OutW%OutPutWindows(iW)%JUB

            WorkKLB = Me%OutW%OutPutWindows(iW)%KLB
            WorkKUB = Me%OutW%OutPutWindows(iW)%KUB
            
            ObjHDF5 = Me%OutW%ObjHDF5(iW)
            
            !Current output index
            Index   = Me%OutW%OutPutWindows(iW)%NextOutPut     
            
            if (Me%OutW%Simple) SimpleOutPut = .true.
            
            if (Me%External_Var%BackTracking) then
                Index = Me%OutW%OutPutWindows(iW)%Number - Index + 1 
            endif               
           
        else

            WorkILB = Me%WorkSize%ILB 
            WorkIUB = Me%WorkSize%IUB 

            WorkJLB = Me%WorkSize%JLB 
            WorkJUB = Me%WorkSize%JUB 

            WorkKLB = Me%WorkSize%KLB 
            WorkKUB = Me%WorkSize%KUB 
            
            ObjHDF5 = Me%ObjHDF5
            
            !Current output index
            Index   = Me%OutPut%NextOutPut    
            
            if (Me%External_Var%BackTracking) then
                Index = Me%OutPut%Number - Index + 1 
            endif                      
            
        endif
        
        


        WaterPoints3D       => Me%External_Var%WaterPoints3D
        ComputeFaces3D_W    => Me%External_Var%ComputeFaces3D_W
        KFloorZ             => Me%External_Var%KFloor_Z
        OpenPoints3D        => Me%External_Var%OpenPoints3D

        SZZ                 => Me%External_Var%SZZ
        DWZ                 => Me%External_Var%DWZ

       if (Me%External_Var%BackTracking) then  
            TotalTime = Me%EndTime      - Me%BeginTime                  
            AuxPeriod = Me%CurrentTime  - Me%BeginTime
            AuxPeriod = TotalTime       - AuxPeriod
            
            Aux = Me%BeginTime + AuxPeriod
        else
            Aux = Me%CurrentTime
        endif           

        !Writes current time
        call ExtractDate   (Aux, AuxTime(1), AuxTime(2), AuxTime(3),                    &
                                 AuxTime(4), AuxTime(5), AuxTime(6))
        TimePtr => AuxTime
        call HDF5SetLimits  (ObjHDF5, 1, 6, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR10'

        call HDF5WriteData  (ObjHDF5, "/Time", "Time", "YYYY/MM/DD HH:MM:SS",        &
                             Array1D = TimePtr, OutputNumber = Index, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR20'

        if (Me%Generic4D%ON) then
            nullify(TimePtr)
            allocate(TimePtr(1))
            TimePtr(1) = Me%Generic4D%CurrentValue

            call HDF5SetLimits  (ObjHDF5, 1, 1, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR30'

            call HDF5WriteData  (ObjHDF5, "/Generic4D", "Generic4D", "-",        &
                                 Array1D = TimePtr, OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR40'
            deallocate(TimePtr)
            nullify(TimePtr)
        endif


        !Writes SZZ
        call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB, WorkJLB,                        &
                             WorkJUB, WorkKLB-1, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR50'

        call HDF5WriteData  (ObjHDF5, "/Grid/VerticalZ", "Vertical",                    &
                             "m", Array3D = SZZ, OutputNumber = Index, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR60'


        !Writes OpenPoints
        call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                                 &
                             WorkJLB, WorkJUB, WorkKLB, WorkKUB,                        &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR70'

        call HDF5WriteData  (ObjHDF5, "/Grid/OpenPoints", "OpenPoints",                 &
                             "-", Array3D = OpenPoints3D, OutputNumber = Index,         &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR80'
        
        if (Me%ComputeOptions%Scraper) then
            call HDF5WriteData  (ObjHDF5, "/Grid/ScraperPosition", "ScraperPosition",      &
                                 "-", Array3D = Me%Scraper%Position, OutputNumber = Index, &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR90'
        endif

        !Writes Waterlevel


        Me%OutPut%Aux2D(:, :) = Me%WaterLevel%New(:,:) * Me%OutPut%WaterLevelUnits
        Me%OutPut%WaterLevelMax(:, :) = Me%WaterLevel%Maxi(:,:) * Me%OutPut%WaterLevelUnits
        Me%OutPut%WaterLevelMin(:, :) = Me%WaterLevel%Mini(:,:) * Me%OutPut%WaterLevelUnits

        if      (Me%OutPut%WaterLevelUnits == 100.) then
            AuxChar = 'cm'
        else if (Me%OutPut%WaterLevelUnits == 1.  ) then
            AuxChar = 'm'
        endif

        call HDF5WriteData  (ObjHDF5,                                                   &
                             "/Results/"//trim(GetPropertyName (WaterLevel_)),          &
                             trim(GetPropertyName (WaterLevel_)), trim(AuxChar),        &
                             Array2D = Me%OutPut%Aux2D,                                 &
                             OutputNumber = Index, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR100'

        call HDF5WriteData  (ObjHDF5,                                                   &
                             "/Results/"//trim(GetPropertyName (WaterColumn_)),         &
                             trim(GetPropertyName (WaterColumn_)), "m",                 &
                             Array2D = Me%External_Var%WaterColumn,                     &
                             OutputNumber = Index, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR105'

        !!Writes Waterlevel maximum
        !call HDF5WriteData  (ObjHDF5,                                                &
        !                     "/Results/"//trim(GetPropertyName (WaterLevelMax_)),     &
        !                     trim(GetPropertyName (WaterLevelMax_)),                  &
        !                     "m/s", Array2D =  Me%OutPut%WaterLevelMax,                      &
        !                     OutputNumber = Index, STAT = STAT_CALL)
        !if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR181'

        !!Writes Waterlevel minimum
        !call HDF5WriteData  (ObjHDF5,                                                &
        !                     "/Results/"//trim(GetPropertyName (WaterLevelMin_)),     &
        !                     trim(GetPropertyName (WaterLevelMin_)),                  &
        !                     "m/s", Array2D =  Me%OutPut%WaterLevelMin,                      &
        !                     OutputNumber = Index, STAT = STAT_CALL)
        !if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR182'

        !Writes Velocity
        call HDF5WriteData  (ObjHDF5,                                                &
                             "/Results/"//trim(GetPropertyName (VelocityU_)),           &
                             trim(GetPropertyName (VelocityU_)),                        &
                             "m/s", Array3D = Me%OutPut%CenterU,                        &
                             OutputNumber = Index, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR110'
        
        call HDF5WriteData  (ObjHDF5,                                                &
                             "/Results/"//trim(GetPropertyName (VelocityV_)),           &
                             trim(GetPropertyName (VelocityV_)),                        &
                             "m/s", Array3D =  Me%OutPut%CenterV,                       &
                             OutputNumber = Index, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR120'

        if (Me%OutPut%Faces) then
            !Write velocity in faces
            !Set HDF5 limits to faces
            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                          &
                                 WorkJLB, WorkJUB+1, WorkKLB, WorkKUB,                  &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR130'

            call HDF5WriteData  (ObjHDF5,                                            &
                                 "/Results/"//"FacesVelocityU",                         &
                                 "FacesVelocityU",                                      &
                                 "m/s", Array3D = Me%Velocity%Horizontal%U%New,         &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR140'

            !Set HDF5 limits to faces
            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB+1,                        &
                                 WorkJLB, WorkJUB, WorkKLB, WorkKUB,                    &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR150'
        
            call HDF5WriteData  (ObjHDF5,                                            &
                                 "/Results/"//"FacesVelocityV",                         &
                                 "FacesVelocityV",                                      &
                                 "m/s", Array3D =  Me%Velocity%Horizontal%V%New,        &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR160'

            !Reset the HDF5 limits to cell center
            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                          &
                                 WorkJLB, WorkJUB, WorkKLB, WorkKUB,                    &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR170'
        endif

        !Writes Velocity modulus
        call HDF5WriteData  (ObjHDF5,                                                &
                             "/Results/"//trim(GetPropertyName (VelocityModulus_)),     &
                             trim(GetPropertyName (VelocityModulus_)),                  &
                             "m/s", Array3D =  Me%OutPut%ModulusH,                      &
                             OutputNumber = Index, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR180'

        !Writes Velocity W
        call HDF5WriteData  (ObjHDF5,                                                   &
                             "/Results/"//trim(GetPropertyName (VelocityW_)),           &
                             trim(GetPropertyName (VelocityW_)), "m/s",                 &
                             Array3D = Me%OutPut%CenterW,                               &
                             OutputNumber = Index, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190'

       !Writes YW         vorticity
       call HDF5WriteData  (ObjHDF5,                                                    &                               
                            "/Results/"//"Vorticity3D",                                 &                             
                            "Vorticity3D", "s-1",                                       &                             
                            Array3D = Me%OutPut%Vorticity3D,                            &                             
                            OutputNumber = Index, STAT = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190'
        !Do statistics analysis
        if (.not. present(iW)) then
            call Statistics_OutPut(Me%OutPut%CenterU, Me%OutPut%CenterV, Me%OutPut%CenterW, &
                                   Me%OutPut%ModulusH, Me%WaterLevel%New)
        endif
        
        CHUNK = CHUNK_J(WorkJLB, WorkJUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Write_HDF5_Format")
        endif
        
sp:     if (.not. SimpleOutPut) then

            if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then
                
                call SetMatrixValue(Me%OutPut%CenterWaux, Me%Size, FillValueReal)

                !$OMP PARALLEL PRIVATE(i,j,k,kbottom)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = WorkJLB, WorkJUB
                do i = WorkILB, WorkIUB

                    if (WaterPoints3D (i  ,j  ,WorkKUB) == WaterPoint) then

                        kbottom = KFloorZ(i, j)

                        !By default the vertical velocity in the faces that are not compute is zero
                        Me%VelBaroclinic%W_New(i, j, kbottom : WorkKUB + 1) = &
                        Me%VelBaroclinic%W_New(i, j, kbottom : WorkKUB + 1) * &
                        ComputeFaces3D_W                   (i, j, kbottom : WorkKUB + 1)

            
                        do k = kbottom, WorkKUB

                            Me%OutPut%CenterWaux(i, j, k) = (Me%VelBaroclinic%W_New(i, j, k+1) +  &
                                                             Me%VelBaroclinic%W_New(i, j, k)) / 2.
                        enddo

                    endif

                enddo
                enddo
                !$OMP END DO
                !$OMP END PARALLEL

                !Baroclinic Vertical Velocity
                call HDF5WriteData  (ObjHDF5, "/Results/Baroclinic/Z",                   &
                                     "B_Vel_Z", "m/s", Array3D = Me%OutPut%CenterWaux,      &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR230'

                
                !Baroclinic Horizontal Velocity
                call CenterVelocity(Me%OutPut%CenterUaux, Me%OutPut%CenterVaux, VectorType = BaroclinicVelocity)
                                    

                call HDF5WriteData  (ObjHDF5, "/Results/Baroclinic/X",                   &
                                     "B_Vel_X", "m/s", Array3D = Me%OutPut%CenterUaux,      &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR240'


                call HDF5WriteData  (ObjHDF5, "/Results/Baroclinic/Y",                   &
                                     "B_Vel_Y", "m/s", Array3D = Me%OutPut%CenterVaux,      &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR250'
            endif

            !$OMP PARALLEL PRIVATE(i,j)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = WorkJLB, WorkJUB
            do i = WorkILB, WorkIUB
                Me%OutPut%Aux2D(i, j) = Me%Velocity%Vertical%Across(i, j, WorkKUB + 1)
            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            call HDF5WriteData  (ObjHDF5, "/Results/Error",                              &
                                 "Error", "m/s", Array2D = Me%OutPut%Aux2D,                 &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR300'


            if (Me%TidePotential%Compute) then
                
                call HDF5WriteData  (ObjHDF5, "/Results/TidePotential",                  &
                                     "TidePotential", "m",                                  &
                                     Array2D = Me%Forces%TidePotentialLevel,                &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR320'

            endif

            if (Me%NonHydroStatic%ON) then

                call HDF5WriteData  (ObjHDF5, "/Results/NonHydroStaticCorrection",      &
                                     "NonHydroStaticCorrection", "m^2/s^2",             &
                                     Array3D = Me%NonHydroStatic%PressureCorrect,       &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR330'

            endif


            if (Me%ComputeOptions%Baroclinic) then
            
                call HDF5SetLimits(ObjHDF5, WorkILB, WorkIUB,                            &
                                               WorkJLB, WorkJUB,                            &
                                               WorkKLB, WorkKUB,                            &
                                               STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR340'

                call CenterVelocity(Me%OutPut%CenterUaux, Me%OutPut%CenterVaux, VectorType = BaroclinicForce)

                call HDF5WriteData  (ObjHDF5,                                            &
                                     "/Results/"//trim(GetPropertyName(BaroclinicForceX_)), &
                                     trim(GetPropertyName(BaroclinicForceX_)), "kg/m3",     &
                                     Array3D = Me%OutPut%CenterUaux,                        &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR370'

                call HDF5WriteData  (ObjHDF5,                                            &
                                     "/Results/"//trim(GetPropertyName(BaroclinicForceY_)), &
                                     trim(GetPropertyName(BaroclinicForceY_)), "kg/m3",     &
                                     Array3D = Me%OutPut%CenterVaux,                        &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR380'

            endif

            ! When using altimetry assimilation
            if (Me%ComputeOptions%AltimetryAssimilation%Yes) then

                call CenterVelocity(Me%OutPut%CenterUaux, Me%OutPut%CenterVaux, VectorType = AltimGeostrophicVelocity)

                call HDF5WriteData  (ObjHDF5, "/Results/AltimGeostrophicVelocityU",      &
                                     "AltimGeostrophicVelocityU", "m/s",                    &
                                     Array3D = Me%OutPut%CenterUaux,                        &
                                     OutputNumber = Index, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR430'

                call HDF5WriteData  (ObjHDF5, "/Results/AltimGeostrophicVelocityV",      &
                                     "AltimGeostrophicVelocityV", "m/s",                    &
                                     Array3D = Me%OutPut%CenterVaux,                        &
                                     OutputNumber = Index, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR440'

            endif
            
            if (Me%ComputeOptions%Level_Bottom_Anomaly) then

                !$OMP PARALLEL PRIVATE(i,j,k,kbottom)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                !Writes the bottom pressure anomaly converted to level (pressure/(density*gravity))
                do j = WorkJLB, WorkJUB
                do i = WorkILB, WorkIUB
                    if (WaterPoints3D (i  ,j  ,WorkKUB) == WaterPoint) then
                        kbottom = Me%External_Var%KFloor_Z(i, j)
                        
                        if (Me%FirstIteration) then
                            Me%OutPut%Aux2D(i, j) = 0.
                        else
                            Me%OutPut%Aux2D(i, j) = 0.
                            do k = WorkKUB, kbottom, -1
                                Me%OutPut%Aux2D(i, j)= Me%OutPut%Aux2D(i, j) +              &
                                                       Me%External_Var%Density(i, j, k) *   &
                                                       Me%External_Var%DWZ(i, j, k)
                            enddo
                            Me%OutPut%Aux2D(i, j) = Me%OutPut%Aux2D(i, j) / SigmaDensityReference
                        endif
                    else
                        Me%OutPut%Aux2D(i, j) = FillValueReal
                    endif
                enddo
                enddo
                !$OMP END DO
                !$OMP END PARALLEL
                
                call HDF5WriteData  (ObjHDF5, "/Results/bottom pressure",               &
                                     "bottom pressure", "m", Array2D = Me%OutPut%Aux2D, &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                        stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR480'
            endif

        endif sp            

              
cd2:    if (Me%OutPut%Run_End) then

            if (.not. SimpleOutPut) then

                call HDF5WriteData  (ObjHDF5, "/Results/VolumeCreated",                 &
                                     "Volume Created", "m3",                            &
                                     Array2D = Me%WaterLevel%VolumeCreated,             &
                                     STAT    = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ER36'

            endif

            !Residual Velocity
cd3:        if (Me%ComputeOptions%Residual .and. .not.  SimpleOutPut) then

                call CenterVelocity(Me%OutPut%CenterUaux, Me%OutPut%CenterVaux, VectorType = ResidualVelocity)
                
                !$OMP PARALLEL PRIVATE(i,j,k)
                
                !Calculates residual modulus
                do k = WorkKLB, WorkKUB
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = WorkJLB, WorkJUB
                do i = WorkILB, WorkIUB

                    if (WaterPoints3D(i, j, k) == WaterPoint) then

                        Me%OutPut%ModulusUVaux(i,j,k)= sqrt(Me%OutPut%CenterUaux(i,j,k)*&
                                                            Me%OutPut%CenterUaux(i,j,k)+&
                                                            Me%OutPut%CenterVaux(i,j,k)*&
                                                            Me%OutPut%CenterVaux(i,j,k))

                    endif 

                enddo
                enddo
                !$OMP END DO
                enddo                
                !$OMP END PARALLEL

                call HDF5SetLimits(ObjHDF5, WorkILB, WorkIUB,                            &
                                               WorkJLB, WorkJUB,                            &
                                               WorkKLB, WorkKUB,                            &
                                               STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR530'

                call HDF5WriteData  (ObjHDF5, "/Residual/Velocity/X",                &
                                     "Vel_X", "m/s", Array3D = Me%OutPut%CenterUaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR540'

                call HDF5WriteData  (ObjHDF5, "/Residual/Velocity/Y",     &
                                     "Vel_Y", "m/s", Array3D = Me%OutPut%CenterVaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR550'

                call HDF5WriteData  (ObjHDF5, "/Residual/Velocity/Modulus",     &
                                     "Modulus", "m/s", Array3D = Me%OutPut%ModulusUVaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR560'


                !Horizontal Residual Flux
                call CenterVelocity(Me%OutPut%CenterUaux, Me%OutPut%CenterVaux, VectorType = ResidualFlux)

                !$OMP PARALLEL PRIVATE(i,j,k)

                !Calculates residual flux modulus
                do k = WorkKLB, WorkKUB
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = WorkJLB, WorkJUB
                do i = WorkILB, WorkIUB

                    if (WaterPoints3D(i, j, k) == WaterPoint) then

                        Me%OutPut%ModulusUVaux(i,j,k)= sqrt(Me%OutPut%CenterUaux(i,j,k)*&
                                                            Me%OutPut%CenterUaux(i,j,k)+&
                                                            Me%OutPut%CenterVaux(i,j,k)*&
                                                            Me%OutPut%CenterVaux(i,j,k))

                    endif 

                enddo
                enddo
                !$OMP END DO
                enddo

                !$OMP MASTER
                call HDF5WriteData  (ObjHDF5, "/Residual/Flux/X", &
                                     "Flux X", "m2/s", Array3D = Me%OutPut%CenterUaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR570'

                call HDF5WriteData  (ObjHDF5, "/Residual/Flux/Y", &
                                     "Flux Y", "m2/s", Array3D = Me%OutPut%CenterVaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR580'
                
               call HDF5WriteData  (ObjHDF5, "/Residual/Flux/Modulus",     &
                                     "Modulus", "m/s", Array3D = Me%OutPut%ModulusUVaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR590'
                !$OMP END MASTER
                !$OMP BARRIER

                !Calculates residual flux by area.  This a kind of conservative average velocity.
                do k = WorkKLB, WorkKUB
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = WorkJLB, WorkJUB
                do i = WorkILB, WorkIUB

                    if (WaterPoints3D(i, j, k) == WaterPoint) then

                        !Divide the specific residual flow interpolate for the cell 
                        !center by the residual thickness
                        Me%OutPut%CenterUaux  (i, j, k) =  Me%OutPut%CenterUaux(i, j, k) / Me%Residual%DWZ(i, j, k)
                        Me%OutPut%CenterVaux  (i, j, k) =  Me%OutPut%CenterVaux(i, j, k) / Me%Residual%DWZ(i, j, k)
                        Me%OutPut%ModulusUVaux(i, j, k) = sqrt(Me%OutPut%CenterUaux(i,j,k)*Me%OutPut%CenterUaux(i,j,k) +         &
                                                               Me%OutPut%CenterVaux(i,j,k)*Me%OutPut%CenterVaux(i,j,k))

                    endif 

                enddo
                enddo
                !$OMP END DO
                enddo
                !$OMP END PARALLEL

                call HDF5WriteData  (ObjHDF5, "/Residual/FluxVel/X",                 &
                                     "Flux X", "m/s", Array3D = Me%OutPut%CenterUaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR600'

                call HDF5WriteData  (ObjHDF5, "/Residual/FluxVel/Y",                 &
                                     "Flux Y", "m/s", Array3D = Me%OutPut%CenterVaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR610'

                call HDF5WriteData  (ObjHDF5, "/Residual/FluxVel/Modulus",     &
                                     "Modulus", "m/s", Array3D = Me%OutPut%ModulusUVaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR620'

                call SetMatrixValue(Me%OutPut%CenterWaux, Me%Size, 0.)

                !$OMP PARALLEL PRIVATE(i,j,k)
                
                do k = WorkKLB, WorkKUB
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = WorkJLB, WorkJUB
                do i = WorkILB, WorkIUB

                    if (k == WorkKLB) then
                        Me%OutPut%CenterWaux(i, j, k) =  Me%Residual%Vertical_Velocity(i, j, k+1) / 2.
                    elseif (k == WorkKUB) then
                        Me%OutPut%CenterWaux(i, j, k) =  Me%Residual%Vertical_Velocity(i, j, k  ) / 2.
                    else
                        Me%OutPut%CenterWaux(i, j, k) = (Me%Residual%Vertical_Velocity(i, j, k+1) +  &
                                                         Me%Residual%Vertical_Velocity(i, j, k  ))/ 2.
                    endif

                enddo
                enddo
                !$OMP END DO
                enddo
                !$OMP END PARALLEL

                call HDF5WriteData  (ObjHDF5, "/Residual/Velocity/Z",                &
                                     "Vel_Z", "m/s", Array3D = Me%OutPut%CenterWaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR650'

                !Residual Water Level
                call HDF5WriteData  (ObjHDF5, "/Residual/Waterlevel",                &
                                     "Lev_Z", "m", Array2D = Me%Residual%WaterLevel,    &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR670'

            endif cd3
            
            if (.not. present(iW)) then
                call KillHydroStatistics
            endif

            call KillHDF5 (ObjHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR680'

        else  cd2

            !Writes everything to disk
            call HDF5FlushMemory (ObjHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR690'

        endif cd2

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Write_HDF5_Format")
        endif

        !Nullify auxiliar variables
        nullify(SZZ             ) 
        nullify(DWZ             )
        nullify(WaterPoints3D   )
        nullify(KFloorZ         )
        nullify(ComputeFaces3D_W)
        nullify(OpenPoints3D    )

        !A if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Write_HDF5_Format")

    end subroutine Write_HDF5_Format

    !--------------------------------------------------------------------------

    subroutine Write_Surface_HDF5_Format

        !Local-----------------------------------------------------------------
        integer                             :: NextSurfaceOutPut
        integer                             :: STAT_CALL
        real, dimension(6), target          :: AuxTime
        real, dimension(:), pointer         :: TimePtr
        integer                             :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                             :: WorkKLB, WorkKUB
        integer, dimension(:,:,:), pointer  :: OpenPoints3D
        real(8)                             :: AuxPeriod, TotalTime  
        type (T_Time)                       :: Aux              

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Write_Surface_HDF5_Format")


        WorkILB = Me%WorkSize%ILB 
        WorkIUB = Me%WorkSize%IUB 
        WorkJLB = Me%WorkSize%JLB 
        WorkJUB = Me%WorkSize%JUB 
        WorkKLB = Me%WorkSize%KLB 
        WorkKUB = Me%WorkSize%KUB 

        OpenPoints3D      => Me%External_Var%OpenPoints3D
        NextSurfaceOutPut =  Me%OutPut%NextSurfaceOutPut
        
           
        if (Me%External_Var%BackTracking) then
            NextSurfaceOutPut = Me%OutPut%NumberSurfaceOutputs - NextSurfaceOutPut + 1 
        endif         
    

        if (Me%External_Var%BackTracking) then  
            TotalTime = Me%EndTime         - Me%BeginTime                  
            AuxPeriod = Me%CurrentTime     - Me%BeginTime
            AuxPeriod = TotalTime          - AuxPeriod
            
            Aux = Me%BeginTime + AuxPeriod
        else
            Aux = Me%CurrentTime
        endif    
    
        !Writes current time
        call ExtractDate   (Aux, AuxTime(1), AuxTime(2), AuxTime(3),         &
                            AuxTime(4), AuxTime(5), AuxTime(6))
        TimePtr => AuxTime

        call HDF5SetLimits  (Me%ObjSurfaceHDF5, 1, 6, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR01'

        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Time",                                                   &
                             "Time", "YYYY/MM/DD HH:MM:SS",                             &
                             Array1D        = TimePtr,                                  &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR02'


        !Writes OpenPoints
        call HDF5SetLimits  (Me%ObjSurfaceHDF5, WorkILB, WorkIUB,                       &
                             WorkJLB, WorkJUB, WorkKUB, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR03'

        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Grid/OpenPoints",                                        &
                             "OpenPoints", "-",                                         &
                             Array3D        = OpenPoints3D,                             &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR04'

        !surface velocity U
        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Results/"//trim(GetPropertyName (VelocityU_)),           &
                             trim(GetPropertyName (VelocityU_)), "m/s",                 &
                             Array3D        = Me%OutPut%CenterU,                        &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR09'
        

        !surface velocity V
        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Results/"//trim(GetPropertyName (VelocityV_)),           &
                             trim(GetPropertyName (VelocityV_)), "m/s",                 &
                             Array3D        = Me%OutPut%CenterV,                        &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR10'
       
        !Writes Velocity modulus
        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Results/"//trim(GetPropertyName (VelocityModulus_)),     &
                             trim(GetPropertyName (VelocityModulus_)), "m/s",           &
                             Array3D        = Me%OutPut%ModulusH,                       &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR11'

        !Writes water level
        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Results/"//trim(GetPropertyName (WaterLevel_)),          &
                             trim(GetPropertyName (WaterLevel_)), "m",                  &
                             Array2D        = Me%WaterLevel%New,                        &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR12'


        !Writes everything to disk
        call HDF5FlushMemory (Me%ObjSurfaceHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR37'


        !Nullify auxiliar variables
        nullify(OpenPoints3D)

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Write_Surface_HDF5_Format")

    end subroutine Write_Surface_HDF5_Format


    subroutine ModifyMatrixesOutput


        !Arguments-------------------------------------------------------------
        

        !Local-----------------------------------------------------------------
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: i, j, k, kbottom
        integer                             :: CHUNK
        
        !----------------------------------------------------------------------

        !Bounds
        ILB = Me%WorkSize%ILB 
        IUB = Me%WorkSize%IUB 
        JLB = Me%WorkSize%JLB 
        JUB = Me%WorkSize%JUB 
        KLB = Me%WorkSize%KLB 
        KUB = Me%WorkSize%KUB 

        !Horizontal Velocity
        call CenterVelocity( Me%OutPut%CenterU, Me%OutPut%CenterV,    &
                            VectorType = CurrentVelocity)

        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyMatrixesOutput")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,kbottom)

        do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%External_Var%WaterPoints3D (i,j ,k) == WaterPoint) then

                Me%OutPut%ModulusH  (i, j, k) = abs(cmplx(Me%OutPut%CenterU(i, j, k), Me%OutPut%CenterV(i, j, k)))
                Me%OutPut%DirectionH(i, j, k) = atan2(Me%OutPut%CenterV(i, j, k), Me%OutPut%CenterU(i, j, k))
                Me%OutPut%DirectionH(i, j, k) = Me%OutPut%DirectionH(i, j, k) * 180. / Pi
                !Instituto Hidrografico convention
                Me%OutPut%DirectionH(i, j, k) = - Me%OutPut%DirectionH(i, j, k) + 90.
                if (Me%OutPut%DirectionH(i, j, k) < 0.) then
                    Me%OutPut%DirectionH(i, j, k) = Me%OutPut%DirectionH(i, j, k) + 360.
                endif

            end if

        enddo
        enddo
        !$OMP END DO NOWAIT       
        enddo

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB        
        do i = ILB, IUB
            if (Me%External_Var%WaterPoints3D (i  ,j  ,KUB) == WaterPoint) then

                kbottom = Me%External_Var%KFloor_Z(i, j)

                !By default the vertical velocity in the faces that are not compute is zero
                !Do not apply it to surface points (correction by Hernâni Theias)
                Me%Velocity%Vertical%Cartesian (i, j, kbottom : KUB) = &
                Me%Velocity%Vertical%Cartesian (i, j, kbottom : KUB) * &
                Me%External_Var%ComputeFaces3D_W(i, j, kbottom : KUB)

                do k = kbottom, KUB

                    Me%OutPut%CenterW(i, j, k) = (Me%Velocity%Vertical%Cartesian(i, j, k+1) +  &
                                                  Me%Velocity%Vertical%Cartesian(i, j, k)) / 2.
                enddo

            endif

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        do j = JLB, JUB
        do i = ILB, IUB            
            if (Me%External_Var%WaterPoints3D (i  ,j  ,KUB) == WaterPoint) then                
                kbottom = Me%External_Var%KFloor_Z(i, j)                
                !By default the vertical velocity in the faces that are not compute is zero                
                !Do not apply it to surface points (correction by Hernâni Theias)                
                Me%Velocity%Vertical%Cartesian (i, j, kbottom : KUB) = &                
                Me%Velocity%Vertical%Cartesian (i, j, kbottom : KUB) * &                
                Me%External_Var%ComputeFaces3D_W(i, j, kbottom : KUB)                
                do k = kbottom, KUB                    
                    Me%OutPut%Vorticity3D(i, j, k) = 0.     

                    !dw/dy                                                       
                    Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     +   &
                    0.5*(Me%OutPut%CenterW(i, j, k) - Me%OutPut%CenterW(i-1, j, k) * &
                    Me%External_Var%WaterPoints3D (i-1,j,k))/ &
                    Me%External_Var%DZY(i-1, j)                    
                    
                    Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     +   &
                    0.5*(-Me%OutPut%CenterW(i, j, k) + Me%OutPut%CenterW(i+1, j, k) * &
                    Me%External_Var%WaterPoints3D (i+1,j,k))/ &
                    Me%External_Var%DZY(i, j)

                    !dw/dx                                                       
                    Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     +   &
                    0.5*(Me%OutPut%CenterW(i, j, k) - Me%OutPut%CenterW(i, j-1, k) * &
                    Me%External_Var%WaterPoints3D (i,j-1,k))/ &
                    Me%External_Var%DZX(i, j-1)                    
                    
                    Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     +   &
                    0.5*(-Me%OutPut%CenterW(i, j, k) + Me%OutPut%CenterW(i, j+1, k) * &
                    Me%External_Var%WaterPoints3D (i,j+1,k))/ &
                    Me%External_Var%DZX(i, j)

                    !dv/dz                                                                           
                    Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                    0.5*(Me%OutPut%CenterV(i, j, k) - Me%OutPut%CenterV(i, j, k-1) * &
                    Me%External_Var%WaterPoints3D (i,j,k-1))/ &
                    Me%External_Var%DWZ(i, j, k)                    
                    
                    Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                    0.5*(-Me%OutPut%CenterV(i, j, k) + Me%OutPut%CenterV(i, j, k+1) * &
                    Me%External_Var%WaterPoints3D (i,j,k+1))/ &
                    Me%External_Var%DWZ(i, j, k)                

                    !du/dz
                    Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                    0.5*(Me%OutPut%CenterU(i, j, k) - Me%OutPut%CenterU(i, j, k-1) * &
                    Me%External_Var%WaterPoints3D (i,j,k-1))/ &
                    Me%External_Var%DWZ(i, j, k)                    
                    
                    Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                    0.5*(-Me%OutPut%CenterU(i, j, k) + Me%OutPut%CenterU(i, j, k+1) * &
                    Me%External_Var%WaterPoints3D (i,j,k+1))/ &
                    Me%External_Var%DWZ(i, j, k)                  

                    !dv/dx                                                                           
                    Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                    0.5*(Me%OutPut%CenterV(i, j, k) - Me%OutPut%CenterV(i, j-1, k) * &
                    Me%External_Var%WaterPoints3D (i,j-1,k))/ &
                    Me%External_Var%DZX(i, j-1)                    
                    
                    Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                    0.5*(-Me%OutPut%CenterV(i, j, k) + Me%OutPut%CenterV(i, j+1, k) * &
                    Me%External_Var%WaterPoints3D (i,j+1,k))/ &
                    Me%External_Var%DZX(i, j)                


                    !du/dy
                    Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                    0.5*(Me%OutPut%CenterU(i, j, k) - Me%OutPut%CenterU(i-1, j, k) * &
                    Me%External_Var%WaterPoints3D (i-1,j,k))/ &
                    Me%External_Var%DZY(i-1, j)                    
                    
                    Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                    0.5*(-Me%OutPut%CenterU(i, j, k) + Me%OutPut%CenterU(i+1, j, k) * &
                    Me%External_Var%WaterPoints3D (i+1,j,k))/ &
                    Me%External_Var%DZY(i, j)                

                enddo            
            endif        
        enddo        
        enddo        
        
        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ModifyMatrixesOutput")

    end subroutine ModifyMatrixesOutput

    !--------------------------------------------------------------------------


    subroutine CenterVelocity( CenterU, CenterV, VectorType)

        !Arguments-------------------------------------------------------------
         
        real,    dimension(:, :, :), pointer    :: CenterU, CenterV
        integer                                 :: VectorType

        !Local-----------------------------------------------------------------
        real,    dimension(:, :, :), pointer    :: FaceVelocityU, FaceVelocityV
        real(8), dimension(:, :, :), pointer    :: FaceUDouble, FaceVDouble
        real                                    :: VelU, VelV, AngleX, AngleY
        integer                                 :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                 :: i, j, k
        logical                                 :: Simple, Double
        integer                                 :: CHUNK
                
        !Bounds
        ILB = Me%Size%ILB 
        IUB = Me%Size%IUB 

        JLB = Me%Size%JLB 
        JUB = Me%Size%JUB 

        KLB = Me%Size%KLB 
        KUB = Me%Size%KUB 
        
        AngleX = 0.
        AngleY = 0.

        Simple = .false.
        Double = .true.
        
        !Checks for the type of velocity to interpolate
        if (VectorType == CurrentVelocity) then

            FaceVelocityU => Me%Velocity%Horizontal%U%New
            FaceVelocityV => Me%Velocity%Horizontal%V%New

            Simple = .true.

        elseif (VectorType == BaroclinicVelocity) then

            FaceVelocityU => Me%VelBaroclinic%U%New
            FaceVelocityV => Me%VelBaroclinic%V%New

            Simple = .true.

        elseif (VectorType == ResidualVelocity) then

            FaceVelocityU => Me%Residual%Velocity_U
            FaceVelocityV => Me%Residual%Velocity_V

            Simple = .true.

        elseif (VectorType == ResidualFlux) then

            FaceUDouble => Me%Residual%WaterFlux_X
            FaceVDouble => Me%Residual%WaterFlux_Y


            Double = .true.

        elseif (VectorType == AltimGeostrophicVelocity) then

            FaceVelocityU => Me%Geostroph%U
            FaceVelocityV => Me%Geostroph%V
            
            Simple = .true.

        elseif (VectorType == BaroclinicForce) then

            FaceVelocityU => Me%Forces%Rox3X
            FaceVelocityV => Me%Forces%Rox3Y

            Simple = .true.

        else

            stop 'CenterVelocity - ModuleHydrodynamic - ERR00'

        endif
            
        CHUNK = CHUNK_J(JLB, JUB)
        
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "CenterVelocity")
        endif
        
        !$OMP PARALLEL PRIVATE(i,j,k,AngleX,AngleY,VelU,VelV)

        !Interpolates CenterVelocities
        if (Me%External_Var%Distortion .and. Simple)then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB
            
                if (Me%External_Var%WaterPoints3D(i, j, k) == 1) then

                    AngleX = Me%External_Var%RotationX(i, j) 
                    AngleY = Me%External_Var%RotationY(i, j) 

                    VelU = (FaceVelocityU(i, j, k)  +   FaceVelocityU(i, j+1, k)) / 2.

                    VelV = (FaceVelocityV(i, j, k)  +   FaceVelocityV(i+1, j, k)) / 2.
                else

                    VelU = 0.
                    VelV = 0.

                endif

                CenterU(i, j, k) = VelU * cos(AngleX) + VelV * cos(AngleY)
                CenterV(i, j, k) = VelU * sin(AngleX) + VelV * sin(AngleY)

            enddo
            enddo
            !$OMP END DO
            enddo
            

        elseif(Me%External_Var%Distortion .and. Double)then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB


                if (Me%External_Var%WaterPoints3D(i, j, k) == 1) then

                    AngleX = Me%External_Var%RotationX(i, j) 
                    AngleY = Me%External_Var%RotationY(i, j) 

                    VelU = (FaceUDouble(i, j, k)  +  FaceUDouble(i, j+1, k)) / 2.

                    VelV = (FaceVDouble(i, j, k)  +  FaceVDouble(i+1, j, k)) / 2.
                              
                else

                    VelU = 0.
                    VelV = 0.

                endif

                CenterU(i, j, k) = VelU * cos(AngleX) + VelV * cos(AngleY)
                CenterV(i, j, k) = VelU * sin(AngleX) + VelV * sin(AngleY)

            enddo
            enddo
            !$OMP END DO
            enddo


        elseif((.not. Me%External_Var%Distortion) .and. Simple)then
            
            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB
            
                if (Me%External_Var%WaterPoints3D(i, j, k) == 1) then

                    AngleX = 0.
                    AngleY = Pi/2.

                    AngleX = AngleX + Me%External_Var%GridRotation
                    AngleY = AngleY + Me%External_Var%GridRotation
                    
                    VelU = (FaceVelocityU(i, j, k)  +   FaceVelocityU(i, j+1, k)) / 2.

                    VelV = (FaceVelocityV(i, j, k)  +   FaceVelocityV(i+1, j, k)) / 2.
                
                else

                    VelU = 0.
                    VelV = 0.

                endif
                
                CenterU(i, j, k) = VelU * cos(AngleX) + VelV * cos(AngleY)
                CenterV(i, j, k) = VelU * sin(AngleX) + VelV * sin(AngleY)

            enddo
            enddo
            !$OMP END DO
            enddo

        elseif((.not. Me%External_Var%Distortion) .and. Double)then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB
            
                if (Me%External_Var%WaterPoints3D(i, j, k) == 1) then

                    AngleX = 0.
                    AngleY = Pi/2.


                    AngleX = AngleX + Me%External_Var%GridRotation
                    AngleY = AngleY + Me%External_Var%GridRotation

                    VelU = (FaceUDouble(i, j, k)  +  FaceUDouble(i, j+1, k)) / 2.

                    VelV = (FaceVDouble(i, j, k)  +  FaceVDouble(i+1, j, k)) / 2.
                              
                else

                    VelU = 0.
                    VelV = 0.

                endif

                CenterU(i, j, k) = VelU * cos(AngleX) + VelV * cos(AngleY)
                CenterV(i, j, k) = VelU * sin(AngleX) + VelV * sin(AngleY)

            enddo
            enddo
            !$OMP END DO
            enddo

        endif

        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "CenterVelocity")
        endif

        !Nullifies FaceVelocityU, FaceVelocityV
        nullify(FaceVelocityU, FaceVelocityV)
        nullify(FaceUDouble,   FaceVDouble)

    end subroutine CenterVelocity



    subroutine OutPut_TimeSeries

        !Arguments-------------------------------------------------------------
        

        !External--------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real                                    :: DepthLevel
        integer                                 :: STAT_CALL, TimeSerieNumber, dn, id, jd, kd
        logical                                 :: DepthON, IgnoreOK


        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "OutPut_TimeSeries")

        !Corrects if necessary the cell of the time serie based in the time serie depth
        call GetNumberOfTimeSeries(Me%ObjTimeSerie, TimeSerieNumber, STAT  = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR10'  

        do dn = 1, TimeSerieNumber

            call GetTimeSerieLocation(Me%ObjTimeSerie, dn,                              &  
                                      LocalizationI = id,                               &
                                      LocalizationJ = jd,                               &
                                      DepthLevel    = DepthLevel,                       &
                                      DepthON       = DepthON,                          & 
                                      STAT          = STAT_CALL)
            if (DepthON) then

                if (Id < 0 .or. Jd < 0) then
                
                    call TryIgnoreTimeSerie(Me%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR20'

                    if (IgnoreOK) then
                        cycle
                    else
                        stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR30'
                    endif

                endif
                kd = GetLayer4Level(Me%ObjGeometry, id, jd, DepthLevel, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR40'

                call CorrectsCellsTimeSerie(Me%ObjTimeSerie, dn,  k = kd, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR50'

                if (Me%External_Var%WaterPoints3D(Id, JD, kd) /= WaterPoint .and. Me%FirstIteration) then
                    
                    write(*,*) 'Time serie station I=',Id, 'J=',Jd,'K=',Kd,'is located in land' 
                    write(*,*) 'Construct_Sub_Modules - ModuleHydrodynamic - WRN100'

                endif
            endif

        enddo

        !West-East Velocity
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data3D = Me%OutPut%CenterU,                                 &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR60'

        !South-North Velocity
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data3D = Me%OutPut%CenterV,                                 &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR70'


        !Vertical Velocity
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data3D = Me%OutPut%CenterW,                                 &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR80'

        !Horizontal Velocity intensity
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data3D = Me%OutPut%ModulusH,                                &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR90'


        !Horizontal Velocity Direction
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data3D = Me%OutPut%DirectionH,                              &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR100'


        !Elevation
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data2D = Me%WaterLevel%New,                                 &
                            factor = Me%OutPut%WaterLevelUnits,                         &    
                            STAT   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR110'


       !Open Points
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data3D_Int = Me%External_Var%OpenPoints3D,                  &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR120'

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "OutPut_TimeSeries")

   
    end subroutine OutPut_TimeSeries

    !--------------------------------------------------------------------------

    subroutine OutPut_Profile

        !Local-----------------------------------------------------------------
        integer                                 :: STAT_CALL
        
        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "OutPut_Profile")

        call WriteProfile(Me%ObjProfile,                                        &
                          Me%OutPut%CenterU,                                    &
                          SZZ    = Me%External_Var%SZZ,                         &
                          STAT   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Profile - ModuleHydrodynamic - ERR01'
            
        call WriteProfile(Me%ObjProfile,                                        &
                          Me%OutPut%CenterV,                                    &
                          SZZ    = Me%External_Var%SZZ,                         &
                          STAT   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Profile - ModuleHydrodynamic - ERR02'

        call WriteProfile(Me%ObjProfile,                                        &
                          Me%OutPut%CenterW,                                    &
                          SZZ    = Me%External_Var%SZZ,                         &
                          STAT   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Profile - ModuleHydrodynamic - ERR03'


        call WriteProfile(Me%ObjProfile,                                        &
                          Me%OutPut%ModulusH,                                   &
                          SZZ    = Me%External_Var%SZZ,                         &
                          STAT   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Profile - ModuleHydrodynamic - ERR04'


        call WriteProfile(Me%ObjProfile,                                        &
                          Me%OutPut%DirectionH,                                 &
                          SZZ    = Me%External_Var%SZZ,                         &
                          STAT   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Profile - ModuleHydrodynamic - ERR05'

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "OutPut_Profile")

    
    end subroutine OutPut_Profile

    !--------------------------------------------------------------------------------------


    Real Function TangentialVelInterpolation(Velocity_VU_New, ComputeFaces3D_VU, &
                                             DXX_YY, di, dj, I, J, K)

        !Parameters variables
        real,    dimension(:,:,:), pointer  :: Velocity_VU_New
        real,    dimension(:,:  ), pointer  :: DXX_YY
        integer, dimension(:,:,:), pointer  :: ComputeFaces3D_VU
        integer                             :: di, dj, I, J, K

        !Local Variables
        real         :: Face1, Face2, Face3, Face4, Face12,  &
                        Face34, VUvar1, VUvar2, VUAverage
        integer      :: I1, I2, I3, J1, J2, J3


            I1    = I+dj-di
            J1    = J-dj+di
            I2    = I+dj
            J2    = J+di
            I3    = I-di
            J3    = J-dj



            !This aux variables are needed to the velocity_UV_New interpolation 
            !be valid near the open boundary faces and near land faces 

            Face1      = ComputeFaces3D_VU(I1, J1, K)

            Face2      = ComputeFaces3D_VU(I2, J2, K)

            Face3      = ComputeFaces3D_VU(I3, J3, K)

            Face4      = ComputeFaces3D_VU(I , J , K)

            ! Average velocity in the North or East face 
            ! if Face1 = 0 => VUvar1 = Velocity_VU_New(I2, J2, K)
            ! Face1 = 0 (cell face where de Velocity_VU is not compute)

            Face12 = Covered

            if (Face1 == Covered .and. Face2 == Covered) then 

                VUvar1 = (Velocity_VU_New(I1, J1, K) * DXX_YY(I2, J2) + &
                          Velocity_VU_New(I2, J2, K) * DXX_YY(I1, J1))/ &
                         (DXX_YY(I1, J1) +  DXX_YY(I2, J2))

            else if (Face1 == Covered) then

                VUvar1 = Velocity_VU_New(I1, J1, K)

            else if (Face2 == Covered) then

                VUvar1 = Velocity_VU_New(I2, J2, K)

            else 
            
                VUvar1 = 0.
            
                Face12 = Not_Covered

            endif

            ! Average velocity in the South or West face 
            ! if Face3 = 0 => VUvar2 = Velocity_VU_New(I4, J4, K)
            ! Face3 = 0 (cell face where de Velocity_VU is not compute)

            Face34 = Covered

            if (Face3 == Covered .and. Face4 == Covered) then 


                VUvar2 = (Velocity_VU_New(I3, J3, K) * DXX_YY(I, J)   + &
                          Velocity_VU_New(I,   J, K) * DXX_YY(I3, J3))/ &
                         (DXX_YY(I3, J3) +  DXX_YY(I, J))

            else if (Face3 == Covered) then

                VUvar2 = Velocity_VU_New(I3, J3, K)

            else if (Face4 == Covered) then

                VUvar2 = Velocity_VU_New(I , J , K)

            else 
            
                VUvar2 = 0. 

                Face34 = Not_Covered

            endif


            ! Velocity V in the U point or Velocity U in the V point
            if (Face12 == Covered .and. Face34 == Covered) then

                VUAverage  = (VUvar1 + VUvar2)/2.

            else if (Face12 == Covered) then

                VUAverage  = VUvar1

            else if (Face34 == Covered) then

                VUAverage  = VUvar2

            else 

                VUAverage  = 0.
                
            endif                        

            TangentialVelInterpolation = VUAverage

    End Function TangentialVelInterpolation

#ifdef OVERLAP

    subroutine GetHydroOverlap(HydrodynamicID, Overlap, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        logical                                     :: Overlap
        integer, optional                           :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 
        
cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            Overlap = Me%ComputeOptions%Overlap

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT))                                                    &
            STAT = STAT_

    end subroutine GetHydroOverlap

    !--------------------------------------------------------------------------

    subroutine SetModelOverlapHydro(HydrodynamicID, OverlapHydrodynamicID, OverlapCells, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: OverlapHydrodynamicID
        integer, dimension(:,:),pointer             :: OverlapCells
        integer, optional                           :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_, readyOverlap_
        type(T_Hydrodynamic),    pointer            :: ObjOverlapHydrodynamic
        integer                                     :: n, nOverlapCells, i, j, io, jo, k
        real                                        :: AuxWaterLevel, AuxU, AuxV

        !------------------------------------------------------------------------


        call Ready          (HydrodynamicID, ready_)

        call ReadyFather    (OverlapHydrodynamicID, ObjOverlapHydrodynamic, readyOverlap_)

cd1 :   if (ready_ .EQ. IDLE_ERR_ .and. readyOverlap_ .EQ. IDLE_ERR_) then

            nOverlapCells = size(OverlapCells, dim=1)

            do n = 1, nOverlapCells

                i   = OverlapCells(n, 1)
                j   = OverlapCells(n, 2)
                k   = 1
                io  = OverlapCells(n, 3)
                jo  = OverlapCells(n, 4)

                AuxWaterLevel                                    = Me%WaterLevel%New(i,j)

                !Me%Velocity%Horizontal%U%New(i,j,k)             = ObjOverlapHydrodynamic%Velocity%Horizontal%U%New(io,jo,k)
                Me%Velocity%Horizontal%V%New(i,j,k)              = ObjOverlapHydrodynamic%Velocity%Horizontal%V%New(io,jo,k)

                ObjOverlapHydrodynamic%WaterLevel%New(io,jo  )   = AuxWaterLevel
            enddo


            STAT_ = SUCCESS_
        else cd1
         
            STAT_ = ready_


        end if cd1

        if(present(STAT)) STAT = STAT_

    end subroutine SetModelOverlapHydro


#endif OVERLAP



    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCT 

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



    subroutine KillHydrodynamic(HydrodynamicID, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(INOUT) :: HydrodynamicID
        integer, optional, intent(OUT)   :: STAT    


        !Local-----------------------------------------------------------------

        integer :: STAT_, nUsers
        integer :: STAT_CALL
        integer :: ready_    

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)
        
cd1 :   if (ready_ /= OFF_ERR_) then

            nUsers = DeassociateInstance(mHYDRODYNAMIC_,  Me%InstanceID)

cd2:        if (nUsers == 0) then

                !Time Properties - Actualises CurrentTime
                call GetComputeCurrentTime(Me%ObjTime, Me%CurrentTime, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) &
                    stop 'KillHydrodynamic; ModuleHydrodynamic. ERR01.'

                !Write final HDF output if necessary
cd3:            if (Me%OutPut%hdf5ON) then

                    call ReadLock_External_Modules

                    if (.not. Me%OutPut%Run_End) then 
                        !Output in HDF
                        Me%OutPut%Run_End = .true.
                        call Write_HDF5_Format
                    endif

                    call ReadUnLock_External_Modules

                endif cd3

                if (Me%OutPut%HDF5_Surface_ON) then

                    call KillHDF5 (Me%ObjSurfaceHDF5, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR00'

                endif

                if (Me%OutPut%ProfileON) then

                    call ReadLock_External_Modules

                    call OutPut_Profile

                    call ReadUnLock_External_Modules

                endif

                if (Me%ComputeOptions%Evolution == Solve_Equations_) then

                    call Write_Final_Hydrodynamic_File 

                endif

                call Deassociate_External_Modules 

                call Kill_Sub_Modules 

                if (Me%ComputeOptions%Evolution == ImposedSolution_) then

                    if(Me%WaterLevel%ID%SolutionFromFile)then
                        call KillFillMatrix(Me%WaterLevel%ID%ObjFillMatrix, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR10'
                    end if
    
                    if(Me%Velocity%Horizontal%U%ID%SolutionFromFile)then
                        call KillFillMatrix(Me%Velocity%Horizontal%U%ID%ObjFillMatrix, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR10'
                    end if

                    if(Me%Velocity%Horizontal%V%ID%SolutionFromFile)then
                        call KillFillMatrix(Me%Velocity%Horizontal%V%ID%ObjFillMatrix, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR20'
                    end if


                endif

#ifdef _ENABLE_CUDA                
                !Kills ModuleCuda
                call KillCuda (Me%ObjCuda, STAT = STAT_CALL)
                ! No need to give error yet, Module still has users
#endif _ENABLE_CUDA                
                
                call DeallocateVariables                 
               
                call DeallocateInstance()

                HydrodynamicID = 0
                STAT_          = SUCCESS_

            end if cd2

        else 
            
            STAT_ = UNKNOWN_

        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine KillHydrodynamic


    !--------------------------------------------------------------------------
    ! The model writes the final hydrodynamic properties in a binary file

    subroutine Write_Final_Hydrodynamic_File

        !Arguments-------------------------------------------------------------

         

        !External--------------------------------------------------------------

        integer :: STAT_CALL

        !Local-----------------------------------------------------------------


        real               :: Year_File, Month_File, Day_File, &
                              Hour_File, Minute_File, Second_File

        integer            :: IUB, JUB, KUB, ILB, JLB, KLB
        integer            :: FinalFile, i, j, k
        character (Len = Pathlength)          :: filename

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB 
        IUB = Me%Size%IUB

        JLB = Me%Size%JLB 
        JUB = Me%Size%JUB 

        KLB = Me%Size%KLB 
        KUB = Me%Size%KUB 


        call UnitsManager(FinalFile, FileOpen, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError (FATAL_, INTERNAL_,'Write_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR10.')

        !Checks if it's at the end of the run 
        !or !if it's supposed to overwrite the final HDF file
        if (Me%Output%Run_End .or. Me%Output%RestartOverwrite) then

            filename = trim(Me%Files%FinalHydrodynamic)

        else

            filename =  ChangeSuffix(Me%Files%FinalHydrodynamic,                         &
                            "_"//trim(TimeToString(Me%CurrentTime))//".fin")

        endif

        open(Unit = FinalFile, File = trim(filename),           &
             Form = 'UNFORMATTED', status = 'UNKNOWN', IOSTAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError (FATAL_, INTERNAL_,'Write_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR20.')

        !Time Properties - Actualizes CurrentTime
        call GetComputeCurrentTime(Me%ObjTime, Me%CurrentTime, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError (FATAL_, INTERNAL_,'Write_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR30.')



        !Start writting the final hydrodynamic conditions file

        call ExtractDate(Me%CurrentTime, Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File)

        write(FinalFile) Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File

        !Write the discretization Method used
        write(FinalFile) Me%ComputeOptions%Num_Discretization


        write(FinalFile) Me%ComputeOptions%Residual

        !Write the last direction computed implicit by the model
        write(FinalFile) Me%Direction%XY 


        !Water level
        write(FinalFile) ((Me%WaterLevel%New(i, j),                         &
                           i = ILB, IUB), j = JLB, JUB)


        !Horizontal velocity Old
        write(FinalFile) (((Me%Velocity%Horizontal%U%Old(i, j, k),          &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


        write(FinalFile) (((Me%Velocity%Horizontal%V%Old(i, j, k),          &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


        !Horizontal velocity New
        write(FinalFile) (((Me%Velocity%Horizontal%U%New(i, j, k),          &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        write(FinalFile) (((Me%Velocity%Horizontal%V%New(i, j, k),          &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        !Water fluxes
        write(FinalFile) (((Me%WaterFluxes%X(i, j, k),                      &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        write(FinalFile) (((Me%WaterFluxes%Y(i, j, k) ,                     &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                            
        write(FinalFile) (((Me%WaterFluxes%Z(i, j, k),                      &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
       
cd1:    if (Me%ComputeOptions%Residual) then

                   
            write(FinalFile) Me%Residual%ResidualTime

            !Average water level 
            write(FinalFile) ((Me%Residual%WaterLevel(i, j),                &
                               i = ILB, IUB), j = JLB, JUB)

            !Residual horizontal velocities
            write(FinalFile) (((Me%Residual%Velocity_U(i, j, k),            &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            write(FinalFile) (((Me%Residual%Velocity_V(i, j, k),            &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !Residual vertical velocity  
            write(FinalFile) (((Me%Residual%Vertical_Velocity(i, j, k),     &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !Residual Water specific fluxes 
            write(FinalFile) (((Me%Residual%WaterFlux_X(i, j, k),           &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            write(FinalFile) (((Me%Residual%WaterFlux_Y(i, j, k) ,          &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
  
                              
        endif cd1

        call WriteGeometry(Me%ObjGeometry, FinalFile, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError (FATAL_, INTERNAL_,'Write_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR40.')

cd2:    if (Me%ComputeOptions%Residual) then 

            !Residual layer thickness 
            write(FinalFile) (((Me%Residual%DWZ(i, j, k),                   &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        endif cd2

        write(FinalFile) Me%ComputeOptions%BaroclinicRadia

cd4:    if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then


            !Horizontal baroclinic velocity Old
            write(FinalFile) (((Me%VelBaroclinic%U%Old(i, j, k),            &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


            write(FinalFile) (((Me%VelBaroclinic%V%Old(i, j, k),            &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !Horizontal baroclinic velocity New
            write(FinalFile) (((Me%VelBaroclinic%U%New(i, j, k),            &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            write(FinalFile) (((Me%VelBaroclinic%V%New(i, j, k),            &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !vertical baroclinic velocity 
            write(FinalFile) (((Me%VelBaroclinic%W_New(i, j, k),            &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            write(FinalFile) (((Me%VelBaroclinic%W_Old(i, j, k),            &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        endif cd4


        if (Me%NonHydrostatic%ON) then

            write(FinalFile) (((Me%Velocity%Vertical%CartesianOld(i, j, k), &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
        endif

        !Submodel
        if (Me%SubModel%ON) then

            write(FinalFile, IOSTAT = STAT_CALL)                                        &  
                (((Me%SubModel%qX(i, j, k),                                             &
                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            if (STAT_CALL /= SUCCESS_) then
                call SetError (FATAL_, INTERNAL_,'Write_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR50.')
            endif

            write(FinalFile, IOSTAT = STAT_CALL)                                        &  
                (((Me%SubModel%qY(i, j, k),                                             &
                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            if (STAT_CALL /= SUCCESS_) then
                call SetError (FATAL_, INTERNAL_,'Write_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR60.')
            endif

        endif        


        call UnitsManager(FinalFile, FileClose, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                        &
            call SetError (FATAL_, INTERNAL_,'Write_Final_Hydrodynamic_File; ModuleHydrodynamic. ERR70.')


    end subroutine Write_Final_Hydrodynamic_File

    !End--------------------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input :                                                             !
    ! OutPut:                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Deassociate_External_Modules

        !Arguments-------------------------------------------------------------

        !Local---------------------------------------------------------
        integer                       :: nUsers

        nUsers = DeassociateInstance (mTIME_,           Me%ObjTime)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR01'

        nUsers = DeassociateInstance (mGRIDDATA_,       Me%ObjGridData)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR02'

        nUsers = DeassociateInstance (mHORIZONTALGRID_,  Me%ObjHorizontalGrid)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR03'
        
        nUsers = DeassociateInstance (mHORIZONTALMAP_,  Me%ObjHorizontalMap)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR04'
        
        nUsers = DeassociateInstance (mGEOMETRY_,       Me%ObjGeometry)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR05'

        nUsers = DeassociateInstance (mMAP_,            Me%ObjMap)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR06'

        nUsers = DeassociateInstance (mTURBULENCE_,     Me%ObjTurbulence)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR07'
#ifndef _WAVES_
        if(Me%ObjWaves /= 0)then
            nUsers = DeassociateInstance (mWAVES_,  Me%ObjWaves)
            if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR08'
        end if
#endif

        
!        nUsers = DeassociateInstance (mBOTTOM_,         Me%ObjBottom)
!        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR08'
        
!        nUsers = DeassociateInstance (mSURFACE_,        Me%ObjSurface)
!        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR09'

    End Subroutine Deassociate_External_Modules

    !End---------------------------------------------------------


    !If needed the sub-modules responsible for the:
    !   - Turbulence
    !   - OpenBoundary
    !   - Discharges
    !   - Surface conditions
    !   - Bottom Conditions
    !will be construct in this subroutine

    subroutine Kill_Sub_Modules 


        !Arguments------------------------------------------------------------

        !Local----------------------------------------------------------------
        integer :: STAT_CALL, nUsers, dis

        !Begin----------------------------------------------------------------

        
        if (Me%ComputeOptions%WaterDischarges) then

            nUsers = GetUsersNumber(mDISCHARGES_, Me%ObjDischarges)
            if (nUsers == 1) then
            
                call Kill_Discharges(Me%ObjDischarges, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                               &
                    stop 'Subroutine Kill_Sub_Modules; Module ModuleHydrodynamic. ERR01.'  
                    
       
                if (Me%OutPut%TimeSerieDischON) then
                    do dis = 1, Me%OutPut%DischargesNumber
                        
                        call KillTimeSerie(TimeSerieID         = Me%OutPut%TimeSerieDischID(dis), &
                                             STAT              = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'Kill_Sub_Modules - Hydrodynamic - ERR40'
                        
                    enddo                    
                    
                    deallocate(Me%OutPut%TimeSerieDischProp)
                    deallocate(Me%OutPut%TimeSerieDischID)                    
                    
                endif                    

            else if (nUsers > 1) then

                nUsers = DeassociateInstance (mDISCHARGES_, Me%ObjDischarges)
                if (nUsers == 0) stop 'Kill_Sub_Modules - ModuleHydrodynamic - ERR02'
               
            else
            
                stop 'Subroutine Kill_Sub_Modules; Module ModuleHydrodynamic. ERR03.'  

            endif

        endif


        !Kill the assimilation object
        if (Me%ComputeOptions%Relaxation .or. Me%ComputeOptions%AltimetryAssimilation%Yes)  then

            nUsers = GetUsersNumber(mASSIMILATION_, Me%ObjAssimilation)
            if (nUsers == 1) then
            
                call KillAssimilation(Me%ObjAssimilation, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                               &
                    stop 'Subroutine Kill_Sub_Modules; Module ModuleHydrodynamic. ERR04.'  

            else if (nUsers > 1) then

                nUsers = DeassociateInstance (mASSIMILATION_, Me%ObjAssimilation)
                if (nUsers == 0) stop 'Kill_Sub_Modules - ModuleHydrodynamic - ERR05'
               
            else
            
                stop 'Subroutine Kill_Sub_Modules; Module ModuleHydrodynamic. ERR06.'  

            endif


        endif

        call KillOpenBoundary(Me%ObjOpenBoundary, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine Kill_Sub_Modules; Module ModuleHydrodynamic. ERR07.'  


        if (Me%ComputeOptions%Evolution == Read_File_) then
            call KillHydrodynamicFile(Me%ObjHydrodynamicFileIn, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine Kill_Sub_Modules; Module ModuleHydrodynamic. ERR08.'  
        endif

        if (Me%ComputeOptions%Recording) then
            call KillHydrodynamicFile(Me%ObjHydrodynamicFileOut, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                            &
                stop 'Subroutine Kill_Sub_Modules; Module ModuleHydrodynamic. ERR09.'  
        endif

        !Kill boxes
cd1:    if (Me%State%BOXFLUXES) then

            call KillBoxDif(Me%ObjBoxDif, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine Kill_Sub_Modules; Module ModuleHydrodynamic. ERR10.'  

        endif cd1


        !Disposes the rest of the energy buffer
        if (Me%ComputeOptions%Energy) call KillEnergy

        !Deallocates the variables necessary to compute 
        !the tide potential
        if (Me%TidePotential%Compute) call KillTidePotential 

        if (Me%SubModel%ON) call KillSubModel 

        if (Me%Generic4D%ON) call KillTimeSerie(Me%Generic4D%ObjTimeSerie, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine Kill_Sub_Modules; Module ModuleHydrodynamic. ERR11.'  


    end subroutine Kill_Sub_Modules   

    !End----------------------------------------------------------------------

    subroutine KillEnergy

        !Arguments------------------------------------------------------------
         

        !Local----------------------------------------------------------------
        integer                         :: STAT_CALL

        !Disposes the rest of the buffer
        call WriteEnergyDataFile

        call UnitsManager(Me%Energy%FileID, FileClose, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR01' 

        !Deallocates buffer
        deallocate(Me%Energy%YearBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR02' 

        deallocate(Me%Energy%MonthBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR03' 

        deallocate(Me%Energy%DayBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR04' 

        deallocate(Me%Energy%HourBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR05' 

        deallocate(Me%Energy%MinuteBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR06' 

        deallocate(Me%Energy%SecondBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR07' 

        deallocate(Me%Energy%KineticBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR08' 

        deallocate(Me%Energy%PotentialBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR09' 
        
        deallocate(Me%Energy%VorticityBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR09a' 

        deallocate(Me%Energy%MassBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR10' 

        deallocate(Me%Energy%VolumeBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR11' 

        deallocate(Me%Energy%OpenVolumeBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR11a' 

        deallocate(Me%Energy%WaterLevelBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR12' 

        deallocate(Me%Energy%BarotropicKEBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR13' 

        deallocate(Me%Energy%RelativeKEBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR14' 

        deallocate(Me%Energy%RelativePEBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR15' 

        deallocate(Me%Energy%BaroclinicKEBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR16' 

        deallocate(Me%Energy%VelMaxBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR17' 

        deallocate(Me%Energy%VelMaxBaroclinicBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR18' 

        deallocate(Me%Energy%CenterU, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR19' 

        deallocate(Me%Energy%CenterV, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR20' 

        deallocate(Me%Energy%CenterW, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR21' 
        
        deallocate(Me%Energy%BarotropicU, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR22' 

        deallocate(Me%Energy%BarotropicV, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR23' 

    end subroutine KillEnergy

    !--------------------------------------------------------------------------

    Subroutine KillTidePotential

        !Arguments-------------------------------------------------------------

        

        !Local-----------------------------------------------------------------
        integer   :: STATUS
        


        deallocate (Me%TidePotential%Frequency, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                              &
            call SetError (FATAL_, OUT_OF_MEM_, "KillTidePotential - Hydrodynamic - ERR01")

        deallocate (Me%TidePotential%Amplitude, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                              &
            call SetError (FATAL_, OUT_OF_MEM_, "KillTidePotential - Hydrodynamic - ERR02")

        deallocate (Me%TidePotential%Arguments        , STAT = STATUS)
        if (STATUS /= SUCCESS_)                                              &
            call SetError (FATAL_, OUT_OF_MEM_, "KillTidePotential - Hydrodynamic - ERR03")

        deallocate (Me%TidePotential%Beta            , STAT = STATUS)
        if (STATUS /= SUCCESS_)                                              &
            call SetError (FATAL_, OUT_OF_MEM_, "KillTidePotential - Hydrodynamic - ERR04")

        deallocate (Me%TidePotential%m               , STAT = STATUS)
        if (STATUS /= SUCCESS_)                                              &
            call SetError (FATAL_, OUT_OF_MEM_, "KillTidePotential - Hydrodynamic - ERR05")

        deallocate (Me%TidePotential%L               , STAT = STATUS)
        if (STATUS /= SUCCESS_)                                              &
            call SetError (FATAL_, OUT_OF_MEM_, "KillTidePotential - Hydrodynamic - ERR06")


    end subroutine KillTidePotential


    !-----------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine KillHydroStatistics

        !Arguments-------------------------------------------------------------

        

        !Local-----------------------------------------------------------------
        integer   :: STATUS, i


        if (Me%Statistics%ON) then


            do i = 1, Me%Statistics%Nprop
            
                call KillStatistic (Me%Statistics%ID(i), STAT = STATUS)
                if (STATUS /= SUCCESS_)                                                  &
                    call SetError (FATAL_, OUT_OF_MEM_, "KillHydroStatistics - Hydrodynamic - ERR10")

            enddo
        
            deallocate(Me%Statistics%PropList, Me%Statistics%ID)

        endif

        if (Me%Statistics2D%ON) then


            do i = 1, Me%Statistics2D%Nprop
        
                call KillStatistic (Me%Statistics2D%ID(i), STAT = STATUS)
                if (STATUS /= SUCCESS_)                                                  &
                    call SetError (FATAL_, OUT_OF_MEM_, "KillHydroStatistics - Hydrodynamic - ERR20")
                    
            enddo                    

            deallocate(Me%Statistics2D%PropList, Me%Statistics2D%ID)

        endif

    end subroutine KillHydroStatistics

    !-----------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine KillSubModel

        !Arguments-------------------------------------------------------------

        

        !Local-----------------------------------------------------------------
        integer   :: STATUS

        

        deallocate (Me%SubModel%Z, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR01")

        nullify(Me%SubModel%Z)

        deallocate (Me%SubModel%U_New, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR02")

        nullify(Me%SubModel%U_New)

        deallocate (Me%SubModel%V_New, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR03")

        nullify(Me%SubModel%V_New)

        nullify(Me%SubModel%UV_New)


        deallocate (Me%SubModel%DUZ_New, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR04")

        nullify(Me%SubModel%DUZ_New)

        deallocate (Me%SubModel%DVZ_New, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR05")

        nullify(Me%SubModel%DVZ_New)



        deallocate (Me%SubModel%qX, STAT = STATUS)

        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR06")

        nullify(Me%SubModel%qX)

        deallocate (Me%SubModel%qY, STAT = STATUS)

        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR07")

        nullify(Me%SubModel%qY )

        nullify(Me%SubModel%qXY)

        nullify(Me%SubModel%qYX)


        deallocate (Me%SubModel%DUZ_Old, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR08")

        nullify(Me%SubModel%DUZ_Old)

        deallocate (Me%SubModel%DVZ_Old, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR09")

        nullify(Me%SubModel%DVZ_Old)

        nullify(Me%SubModel%DUVZ_Old)

        deallocate (Me%SubModel%U_Old, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR10")

        nullify(Me%SubModel%U_Old)

        deallocate (Me%SubModel%V_Old, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR11")

        nullify(Me%SubModel%V_Old)

        nullify(Me%SubModel%UV_Old)

cd1:    if (Me%SubModel%InterpolTime) then

            deallocate (Me%SubModel%Z_Previous, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR12")

            nullify(Me%SubModel%Z_Previous)

            deallocate (Me%SubModel%Z_Next, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR13")

            nullify(Me%SubModel%Z_Next)

            deallocate (Me%SubModel%U_Previous, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR14")

            nullify(Me%SubModel%U_Previous)

            deallocate (Me%SubModel%U_Next, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR15")

            nullify(Me%SubModel%U_Next)


            deallocate (Me%SubModel%V_Previous, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR16")

            nullify(Me%SubModel%V_Previous)

            deallocate (Me%SubModel%V_Next, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR17")

            nullify(Me%SubModel%V_Next)


            deallocate (Me%SubModel%DUZ_Previous, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR18")

            nullify(Me%SubModel%DUZ_Previous)

            deallocate (Me%SubModel%DUZ_Next, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR19")

            nullify(Me%SubModel%DUZ_Next)


            deallocate (Me%SubModel%DVZ_Previous, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR20")

            nullify(Me%SubModel%DVZ_Previous)

            deallocate (Me%SubModel%DVZ_Next, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR21")

            nullify(Me%SubModel%DVZ_Next)

        endif cd1

        if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.                            &
            (Me%SubModel%VertComunic == Father3DSon2D)) then
              
            deallocate (Me%SubModel%Aux_qX, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR22")

            nullify(Me%SubModel%Aux_qX)

            deallocate (Me%SubModel%Aux_qY, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR23")

            nullify(Me%SubModel%Aux_qY)

            deallocate (Me%SubModel%Aux_DUZ, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR24")

            nullify(Me%SubModel%Aux_DUZ)

            deallocate (Me%SubModel%Aux_DVZ, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR25")

            nullify(Me%SubModel%Aux_DVZ)

            deallocate (Me%SubModel%Aux_U, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR26")

            nullify(Me%SubModel%Aux_U)

            deallocate (Me%SubModel%Aux_V, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR27")

            nullify(Me%SubModel%Aux_V)
           
        endif

cd2:    if (Me%SubModel%DeadZone) then

            deallocate (Me%SubModel%DeadZonePoint, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR28")

        endif cd2



    End Subroutine KillSubModel

    !--------------------------------------------------------------------------

    Subroutine DeallocateVariables

        !Arguments-------------------------------------------------------------
        
        !griflet
        type(T_Coef_Baroc), pointer :: LocalBaroc
        type(T_VECGW), pointer      :: VECGW
        integer                     :: p

        !Local-----------------------------------------------------------------

        integer :: STAT_CALL

        !Begin------------------------------------------------------------------

        !Water level variables allocation
        deallocate (Me%WaterLevel%New, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR01.' 

        nullify (Me%WaterLevel%New) 



        deallocate (Me%WaterLevel%Old, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR02.' 

        nullify (Me%WaterLevel%Old) 
             
        deallocate (Me%WaterLevel%VolumeCreated, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR02a.' 

        nullify (Me%WaterLevel%VolumeCreated) 

        deallocate (Me%WaterLevel%Maxi, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR02b.' 

        nullify (Me%WaterLevel%Maxi) 

        deallocate (Me%WaterLevel%Mini, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR02c.' 

        nullify (Me%WaterLevel%Mini) 

#ifdef _USE_PAGELOCKED
        ! FreePageLocked will also nullify the pointers and arrays
        call FreePageLocked(Me%ObjCuda, Me%Velocity%Horizontal%U%NewPtr, Me%Velocity%Horizontal%U%New)
        call FreePageLocked(Me%ObjCuda, Me%Velocity%Horizontal%U%OldPtr, Me%Velocity%Horizontal%U%Old)
        call FreePageLocked(Me%ObjCuda, Me%Velocity%Horizontal%V%NewPtr, Me%Velocity%Horizontal%U%New)
        call FreePageLocked(Me%ObjCuda, Me%Velocity%Horizontal%V%OldPtr, Me%Velocity%Horizontal%U%Old)
#else
        !Horizontal velocity
        deallocate (Me%Velocity%Horizontal%U%New, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR04.' 

        nullify (Me%Velocity%Horizontal%U%New) 



        deallocate (Me%Velocity%Horizontal%U%Old, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR05.' 

        nullify (Me%Velocity%Horizontal%U%Old)            



        deallocate (Me%Velocity%Horizontal%V%New, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR07.' 

        nullify (Me%Velocity%Horizontal%V%New) 


             
        deallocate (Me%Velocity%Horizontal%V%Old, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR08.' 

        nullify (Me%Velocity%Horizontal%V%Old) 
#endif _USE_PAGELOCKED
             
        !Auxiliar horizontal velocity pointers
        nullify (Me%Velocity%Horizontal%UV%New) 
        nullify (Me%Velocity%Horizontal%UV%Old) 

        nullify (Me%Velocity%Horizontal%VU%New) 
        nullify (Me%Velocity%Horizontal%VU%Old) 


        ! guillaume
        if (Me%Geostroph%ON) then
            deallocate (Me%Geostroph%U                      ) 
            deallocate (Me%Geostroph%V                      ) 
            deallocate (Me%Geostroph%AuxDesCentre           ) 
            deallocate (Me%Geostroph%PressGrad              )             
            deallocate (Me%Geostroph%U_barotropic           ) 
            deallocate (Me%Geostroph%V_barotropic           ) 
            nullify    (Me%Geostroph%U                      )     
            nullify    (Me%Geostroph%V                      )
            nullify    (Me%Geostroph%UV                     )     
            nullify    (Me%Geostroph%VU                     )
            nullify    (Me%Geostroph%AuxDesCentre           )
            nullify    (Me%Geostroph%PressGrad              )      
            nullify    (Me%Geostroph%U_barotropic           )     
            nullify    (Me%Geostroph%V_barotropic           )
        endif

        !Vertical Velocity
#ifdef _USE_PAGELOCKED
        ! FreePageLocked will also nullify the pointers and arrays
        call FreePageLocked(Me%ObjCuda, Me%Velocity%Vertical%CartesianPtr, Me%Velocity%Vertical%Cartesian)
#else
        deallocate (Me%Velocity%Vertical%Cartesian, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11.' 

        nullify (Me%Velocity%Vertical%Cartesian) 
#endif _USE_PAGELOCKED        
        
        deallocate (Me%Velocity%Vertical%Across, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR10.' 
        
        nullify (Me%Velocity%Vertical%Across)         

        if (Me%NonHydrostatic%ON) then

            deallocate (Me%Velocity%Vertical%CartesianOld, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11a.' 

            nullify (Me%Velocity%Vertical%CartesianOld) 

            deallocate (Me%NonHydrostatic%PressureCorrect, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11b.' 

            nullify (Me%NonHydrostatic%PressureCorrect) 

            deallocate (Me%NonHydrostatic%PrevisionalQ, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11b.' 

            nullify (Me%NonHydrostatic%PrevisionalQ) 

            deallocate (Me%NonHydrostatic%CCoef, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11b.' 

            nullify (Me%NonHydrostatic%CCoef) 

            deallocate (Me%NonHydrostatic%GCoef, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11b.' 

            nullify (Me%NonHydrostatic%GCoef) 

        endif

        if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then

            deallocate (Me%VelBaroclinic%W_New, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11a.' 

            nullify (Me%VelBaroclinic%W_New) 

            deallocate (Me%VelBaroclinic%W_Old, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11b.' 

            nullify (Me%VelBaroclinic%W_Old) 

            deallocate (Me%VelBaroclinic%U%New, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11c.' 

            nullify(Me%VelBaroclinic%U%New)

            deallocate (Me%VelBaroclinic%U%Old, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11d.' 

            nullify(Me%VelBaroclinic%U%Old)



            deallocate (Me%VelBaroclinic%V%New, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11e.' 

            nullify(Me%VelBaroclinic%V%New)

            deallocate (Me%VelBaroclinic%V%Old, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11f.' 

            nullify(Me%VelBaroclinic%V%Old)

            deallocate (Me%VelBaroclinic%U2D, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11g.' 
      
            nullify(Me%VelBaroclinic%U2D)


            deallocate (Me%VelBaroclinic%V2D, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR11h.' 
      
            nullify(Me%VelBaroclinic%V2D)


            !Auxiliar horizontal baroclinic velocity pointers
            nullify (Me%VelBaroclinic%UV%New) 
            nullify (Me%VelBaroclinic%UV%Old) 

            nullify (Me%VelBaroclinic%VU%New) 
            nullify (Me%VelBaroclinic%VU%Old) 

            nullify (Me%VelBaroclinic%UV2D) 

        endif
                      


        !Water fluxes        
        deallocate (Me%WaterFluxes%X, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DellocateVariables; Module ModuleHydrodynamic. ERR13.' 

        nullify (Me%WaterFluxes%X) 
             
        deallocate (Me%WaterFluxes%Y, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR14.' 
             
        nullify (Me%WaterFluxes%Y) 


        deallocate (Me%WaterFluxes%Z, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR15.' 

        nullify (Me%WaterFluxes%Z) 

        deallocate (Me%WaterFluxes%Discharges, STAT = STAT_CALL) 

        if (STAT_CALL /= SUCCESS_)                                                   &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR15a.' 

        nullify (Me%WaterFluxes%Discharges) 
        
        !Auxiliar Water Fluxes
        nullify (Me%WaterFluxes%XY) 
        nullify (Me%WaterFluxes%YX) 
        
        if (Me%ComputeOptions%MomentumDischarge) then
            deallocate (Me%WaterFluxes%DischargesVelU)
            deallocate (Me%WaterFluxes%DischargesVelV)            
            nullify    (Me%WaterFluxes%DischargesVelU)
            nullify    (Me%WaterFluxes%DischargesVelV)
            nullify    (Me%WaterFluxes%DischargesVelUV)            
        endif
        

        !If compute Residual properties then must allocate residual variables

cd1:    if (Me%ComputeOptions%Residual) then 


            Me%Residual%ResidualTime = FillValueReal

            
            !Can be interesting to compute the average water level
            deallocate (Me%Residual%WaterLevel, STAT = STAT_CALL)        
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR03.'  

            nullify (Me%Residual%WaterLevel) 


            deallocate (Me%Residual%Velocity_U, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR06.'  

            nullify (Me%Residual%Velocity_U)



            deallocate (Me%Residual%Velocity_V, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR09.'  

            nullify (Me%Residual%Velocity_V) 


            deallocate (Me%Residual%Vertical_Velocity, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR12.'  

            nullify (Me%Residual%Vertical_Velocity)


            deallocate (Me%Residual%WaterFlux_X, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR13a.' 

            nullify (Me%Residual%WaterFlux_X) 


             
            deallocate (Me%Residual%WaterFlux_Y, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR14a.' 
          
            nullify (Me%Residual%WaterFlux_Y) 

            deallocate (Me%Residual%DWZ, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR13b.' 

            nullify (Me%Residual%DWZ) 

            
        endif cd1


        !Forces 
        deallocate (Me%Forces%Rox3X, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR16.' 
        
        nullify (Me%Forces%Rox3X) 

        deallocate (Me%Forces%Rox3Y, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR16a.' 

        nullify (Me%Forces%Rox3Y) 
                
             
        deallocate (Me%Forces%Horizontal_Transport, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR17.' 

        nullify (Me%Forces%Horizontal_Transport) 
             
        deallocate (Me%Forces%Inertial_Aceleration, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR18.' 

        nullify (Me%Forces%Inertial_Aceleration) 


        deallocate (Me%Forces%TidePotentialLevel,   STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR18a.' 

        nullify (Me%Forces%TidePotentialLevel) 


        if(Me%ComputeOptions%AltimetryAssimilation%Yes) then 
    
            deallocate (Me%Forces%Altim_Relax_Aceleration,   STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                  &
               stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR18b.' 
    
            nullify (Me%Forces%Altim_Relax_Aceleration) 
    
        endif

        if (Me%Relaxation%Force) then
            deallocate (Me%Forces%Relax_Aceleration, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR18d.' 

            nullify (Me%Forces%Relax_Aceleration) 

        endif


        if (Me%Relaxation%Geometry) then
            deallocate (Me%Relaxation%DecayTimeGeo, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR18e.' 

            nullify (Me%Relaxation%DecayTimeGeo) 

        endif


             
        !Coefficients
        deallocate (Me%Coef%D2%D, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR20.' 

        nullify (Me%Coef%D2%D) 
                    


        deallocate (Me%Coef%D2%E, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR21.' 

        nullify (Me%Coef%D2%E) 
                     
        deallocate (Me%Coef%D2%EAux, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR21a.' 

        nullify (Me%Coef%D2%EAux) 
                     

        deallocate (Me%Coef%D2%F, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR22.' 

        nullify (Me%Coef%D2%F) 


             
        deallocate (Me%Coef%D2%Ti, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR23.'  

        nullify (Me%Coef%D2%Ti) 

             
        deallocate (Me%Coef%D2%TiAux, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR23d.'  

        nullify (Me%Coef%D2%TiAux) 


cd2:    if (Me%ComputeOptions%BarotropicRadia == FlatherWindWave_ .or.      &
            Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            deallocate (Me%Coef%D2%Rad, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR23a.'  

            nullify(Me%Coef%D2%Rad)


            deallocate (Me%Coef%D2%TiRad, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR23b.'  

            nullify(Me%Coef%D2%TiRad)

        endif cd2

#ifdef _USE_PAGELOCKED
        ! FreePageLocked will also nullify the pointers and arrays
        call FreePageLocked(Me%ObjCuda, Me%Coef%D3%DPtr, Me%Coef%D3%D)
        call FreePageLocked(Me%ObjCuda, Me%Coef%D3%EPtr, Me%Coef%D3%E)
        call FreePageLocked(Me%ObjCuda, Me%Coef%D3%FPtr, Me%Coef%D3%F)
        call FreePageLocked(Me%ObjCuda, Me%Coef%D3%TiPtr, Me%Coef%D3%Ti)
#else
        deallocate (Me%Coef%D3%D, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR24.'  
        
        deallocate (Me%Coef%D3%E, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR25.' 
        
        deallocate (Me%Coef%D3%F, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR26.' 
        
        deallocate (Me%Coef%D3%Ti, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR27.'  
        
        nullify (Me%Coef%D3%D) 
        nullify (Me%Coef%D3%E) 
        nullify (Me%Coef%D3%F) 
        nullify (Me%Coef%D3%Ti)
#endif _USE_PAGELOCKED

        !External Variables

        !Bottom boundary: this variable in the future must migrate to the module ModuleBottom
        deallocate (Me%External_Var%ChezyZ, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR28.'  

        nullify (Me%External_Var%ChezyZ)

        deallocate (Me%External_Var%ChezyVelUV, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR28.'  

        nullify (Me%External_Var%ChezyVelUV)



        !OutPut Time variables

cd3:    if (Me%OutPut%hdf5ON) then
        

            Deallocate (Me%OutPut%OutTime, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'Sub. DeallocateVariables - ModuleHydrodynamic - ERR33'

            nullify (Me%OutPut%OutTime)
            

        endif cd3


        if(Me%OutPut%ProfileON)then

            call KillProfile(Me%ObjProfile, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                stop 'DeallocateVariables - ModuleHydrodynamic - ERR340'

        end if

        !Kills the TimeSerie
        if (Me%ObjTimeSerie /= 0) then
            call KillTimeSerie(Me%ObjTimeSerie, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                stop 'DeallocateVariables - ModuleHydrodynamic - ERR34'
        endif

                
cd4:    if (Me%ComputeOptions%Baroclinic) then 

            !griflet            
            do p=1,Me%MaxThreads
            
                LocalBaroc => Me%Coef%Baroc(p)
                
                deallocate (LocalBaroc%Kleft,       STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &            
                    stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR35.'  
                nullify (LocalBaroc%Kleft)
        
                deallocate (LocalBaroc%Kright,      STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &            
                    stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR36'
                nullify (LocalBaroc%Kright)

                deallocate (LocalBaroc%Depth_integ, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &            
                    stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR37'
                nullify (LocalBaroc%Depth_integ)

                deallocate (LocalBaroc%Hcenter,     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &            
                    stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR38'
                nullify (LocalBaroc%Hcenter)
               
                deallocate (LocalBaroc%Hleft,       STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &            
                    stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR39'
                nullify (LocalBaroc%Hleft)        
                 
                deallocate (LocalBaroc%Hright,      STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &            
                    stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR40'        
                nullify (LocalBaroc%Hright)            
              
                deallocate (LocalBaroc%HroLeft,     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &            
                    stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR41'
                nullify (LocalBaroc%HroLeft)
        
                deallocate (LocalBaroc%HroRight,    STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &            
                    stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR42'
                nullify (LocalBaroc%HroRight)
            
                deallocate (LocalBaroc%DensRight,    STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &            
                    stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR420'
                nullify (LocalBaroc%DensRight)
    
                deallocate (LocalBaroc%DensLeft,    STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &            
                    stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR430'
                nullify (LocalBaroc%DensLeft)

            enddo
            
        endif cd4

        !griflet
        do p = 1, Me%MaxThreads
            VECGW => Me%THOMAS2D%VEC(p)
            deallocate(VECGW%G)
            deallocate(VECGW%W)
        enddo        
        deallocate(Me%THOMAS2D%VEC)
        deallocate(Me%THOMAS2D%COEF2)
        deallocate(Me%THOMAS2D)

        do p = 1, Me%MaxThreads
            VECGW => Me%THOMAS%VEC(p)
            deallocate(VECGW%G)
            deallocate(VECGW%W)
        enddo        
        deallocate(Me%THOMAS%VEC)
        deallocate(Me%THOMAS%COEF3)
        deallocate(Me%THOMAS)
        
        deallocate (Me%VECG_3D,    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &            
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR43'
        nullify (Me%VECG_3D)

        
        deallocate (Me%VECW_3D,    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &            
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR44'
        nullify (Me%VECW_3D)

        
        deallocate (Me%VECG_2D,    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &            
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR45'
        nullify (Me%VECG_2D)

        
        deallocate (Me%VECW_2D,    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &            
            stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR46'
        nullify (Me%VECW_2D)

        if (Me%ComputeOptions%BarotropicRadia == BlumbergKantha_)  then

            deallocate (Me%ComputeOptions%Tlag, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &            
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR47'
            nullify (Me%ComputeOptions%Tlag)

        endif

        if (Me%ComputeOptions%BiHarmonic) then

            deallocate (Me%ComputeOptions%BiHarmonicUX_VY,    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &            
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR48'
            
            deallocate (Me%ComputeOptions%BiHarmonicUY_VX,    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &            
                stop 'Subroutine DeallocateVariables; Module ModuleHydrodynamic. ERR49'

        endif

ic1:    if (Me%CyclicBoundary%ON) then

            deallocate (Me%Coef%D1%a,   STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR52.' 

            deallocate (Me%Coef%D1%b,   STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR53.' 

            deallocate (Me%Coef%D1%bb,  STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR54.' 

            deallocate (Me%Coef%D1%c,   STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR55.' 

            deallocate (Me%Coef%D1%r,   STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR56.' 

            deallocate (Me%Coef%D1%u,   STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR57.' 

            deallocate (Me%Coef%D1%x,   STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR58.' 

            deallocate (Me%Coef%D1%z,   STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR59.' 

            deallocate (Me%Coef%D1%gam, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR60.' 

        endif ic1

        if(Me%ComputeOptions%Obstacle)then
            
            deallocate (Me%Drag%Coef, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR70.' 

            if(Me%Drag%ID%SolutionFromFile)then
                call KillFillMatrix(Me%Drag%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR80.' 
            endif


            deallocate (Me%Forces%ObstacleDrag_Aceleration, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR110.' 


        end if
        
        if(Me%ComputeOptions%Scraper)then
            
            deallocate (Me%Forces%Scraper_Aceleration, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR120.' 
            
            deallocate (Me%Scraper%Position, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR125.' 
            
            if (Me%Scraper%UOn) deallocate(Me%Scraper%VelU)            
            
            if (Me%Scraper%VOn) deallocate(Me%Scraper%VelV)
            
            if(Me%Scraper%ID_U%SolutionFromFile)then
                call KillFillMatrix(Me%Scraper%ID_U%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR130.' 
            endif
            
            
            if(Me%Scraper%ID_V%SolutionFromFile)then
                call KillFillMatrix(Me%Scraper%ID_V%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR140.' 
            endif

!            if(Me%Scraper%ID_W%SolutionFromFile)then
!                call KillFillMatrix(Me%Scraper%ID_W%ObjFillMatrix, STAT = STAT_CALL)
!                if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR150.' 
!            endif


        end if        

        if (Me%OutPut%TimeSerieON .or. Me%OutPut%hdf5ON .or. Me%OutPut%ProfileON) &
            call KillMatrixesOutput
            

        if (Me%ComputeOptions%InvertBaromSomeBound)                                     &
            deallocate(Me%ComputeOptions%InvertBarometerCells)            


        deallocate(Me%Aux3DFlux)
        
        if (Me%ThinWalls%ON) then
            call KillThinWalls
        endif        
       !----------------------------------------------------------------------

    end subroutine DeallocateVariables   

    !--------------------------------------------------------------------------
    
    !--------------------------------------------------------------------------

    subroutine KillThinWalls

        !Local-----------------------------------------------------------------
        integer                                 :: STAT_CALL

        !----------------------------------------------------------------------
        
        if (Me%ThinWalls%UOn) then
            
            deallocate(Me%ThinWalls%FaceU_I)
            deallocate(Me%ThinWalls%FaceU_J)
            deallocate(Me%ThinWalls%FaceU_K)
            
        endif

        if (Me%ThinWalls%VOn) then
            
            deallocate(Me%ThinWalls%FaceV_I)
            deallocate(Me%ThinWalls%FaceV_J)
            deallocate(Me%ThinWalls%FaceV_K)
           
        endif

        if (Me%ThinWalls%WOn) then
        
            deallocate(Me%ThinWalls%FaceW_I)
            deallocate(Me%ThinWalls%FaceW_J)
            deallocate(Me%ThinWalls%FaceW_K)
            
        endif

        if (Me%ThinWalls%VariableInTime) then
            deallocate(Me%Forces%ThinWalls_Dissipation)
            call KillTimeSerie(TimeSerieID         = Me%ThinWalls%ObjTimeSerie,         &
                                 STAT              = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'KillThinWalls - Hydrodynamic - ERR10'

        endif   

    end subroutine KillThinWalls

    !--------------------------------------------------------------------------    

    subroutine KillMatrixesOutput

        !Arguments-------------------------------------------------------------
        

        !Local-----------------------------------------------------------------
        integer                             :: STAT_CALL

        !----------------------------------------------------------------------


        !Horizontal Velocity
        deallocate(Me%OutPut%CenterU   ,                                                &
                   Me%OutPut%CenterV   ,                                                &
                   Me%OutPut%ModulusH  ,                                                &
                   Me%OutPut%DirectionH,                                                &
                   Me%OutPut%CenterW,                                                   &
                   Me%OutPut%CenterUaux,                                                &
                   Me%OutPut%CenterVaux,                                                &
                   Me%OutPut%ModulusUVaux,                                              &
                   Me%OutPut%CenterWaux,                                                &
                   Me%OutPut%Aux2D,                                                     &
                   Me%OutPut%WaterLevelMax,                                                     &
                   Me%OutPut%WaterLevelMin,                                                     &
                   STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'KillMatrixesOutput - ModuleHydrodynamic - ERR10'

        nullify  (Me%OutPut%CenterU     )
        nullify  (Me%OutPut%CenterV     )
        nullify  (Me%OutPut%ModulusH    )
        nullify  (Me%OutPut%DirectionH  )
        nullify  (Me%OutPut%CenterW     )
       
        nullify  (Me%OutPut%CenterUaux  ) 
        nullify  (Me%OutPut%CenterVaux  ) 
        nullify  (Me%OutPut%ModulusUVaux)
        nullify  (Me%OutPut%CenterWaux  ) 
        nullify  (Me%OutPut%Aux2D       ) 
        nullify  (Me%OutPut%WaterLevelMax       ) 
        nullify  (Me%OutPut%WaterLevelMin       ) 
    
    end subroutine KillMatrixesOutput

    !--------------------------------------------------------------------------


    subroutine DeallocateInstance ()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Hydrodynamic), pointer           :: AuxHydrodynamic
        type (T_Hydrodynamic), pointer           :: PreviousHydrodynamic

        !Updates pointers
        if (Me%InstanceID == FirstHydrodynamic%InstanceID) then
            FirstHydrodynamic => FirstHydrodynamic%Next
        else
            PreviousHydrodynamic => FirstHydrodynamic
            AuxHydrodynamic      => FirstHydrodynamic%Next
            do while (AuxHydrodynamic%InstanceID /= Me%InstanceID)
                PreviousHydrodynamic => AuxHydrodynamic
                AuxHydrodynamic      => AuxHydrodynamic%Next
            enddo

            !Now update linked list
            PreviousHydrodynamic%Next => AuxHydrodynamic%Next


        endif

        !Deallocates instance
        deallocate (Me)
        nullify    (Me) 

            
    end subroutine DeallocateInstance

#ifdef _USE_SEQASSIMILATION
    !--------------------------------------------------------------------------

    subroutine NullifyHydroStatePointer(HydrodynamicID, STAT)

        !Arguments-------------------------------------------------------------

        integer,               intent(IN ) :: HydrodynamicID
        integer, optional,     intent(OUT) :: STAT

        !External--------------------------------------------------------------

        integer :: ready_   

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_) 

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            nullify(Me%AuxPointer%WaterLevelNew)

            nullify(Me%AuxPointer%VelocityUNew)

            nullify(Me%AuxPointer%VelocityVNew)

            nullify(Me%AuxPointer%VelocityUOld)

            nullify(Me%AuxPointer%VelocityVOld)

            nullify(Me%AuxPointer%VelVerticalCartesian)

            nullify(Me%AuxPointer%VelVerticalAcross)

            nullify(Me%AuxPointer%WaterFluxX)

            nullify(Me%AuxPointer%WaterFluxY)

            nullify(Me%AuxPointer%WaterFluxZ)

            if (Me%SubModel%ON) then
                nullify(Me%AuxPointer%SubModelqX)

                nullify(Me%AuxPointer%SubModelqY)
            endif

            nullify(Me%AuxPointer%ChezyVelUV)

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine NullifyHydroStatePointer

#endif _USE_SEQASSIMILATION


    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEME

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    subroutine Ready (HydrodynamicID, ready_) 

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: ready_

        !----------------------------------------------------------------------

        nullify (Me)

cd1:    if (HydrodynamicID > 0) then
            Me => FirstHydrodynamic
            do while (associated (Me))
                if (Me%InstanceID == HydrodynamicID) exit
                Me => Me%Next
            enddo

            if (.not. associated(Me))                                                    &
                stop 'ModuleHydrodynamic - Ready - ERR01'

            ready_ = VerifyReadLock (mHYDRODYNAMIC_, Me%InstanceID)
        else
            ready_ = OFF_ERR_
        end if cd1

        !----------------------------------------------------------------------

    end subroutine Ready

    !--------------------------------------------------------------------------


    subroutine ReadyFather (HydrodynamicID, HydroFather, ready_) 

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        type (T_Hydrodynamic), pointer              :: HydroFather
        integer                                     :: ready_

        !----------------------------------------------------------------------

        nullify (HydroFather)

cd1:    if (HydrodynamicID > 0) then
            HydroFather => FirstHydrodynamic
            do while (associated (HydroFather))
                if (HydroFather%InstanceID == HydrodynamicID) exit
                HydroFather => HydroFather%Next
            enddo

            if (.not. associated(HydroFather))                                                    &
                stop 'ModuleHydrodynamic - Ready - ERR01'

            ready_ = VerifyReadLock (mHYDRODYNAMIC_, HydroFather%InstanceID)

        else
            ready_ = OFF_ERR_
        end if cd1


        !----------------------------------------------------------------------

    end subroutine ReadyFather




    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !         Manuel Ruiz Villarreal 2000: Vertical viscosities are located at faces of control volume  !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ReadLock_ModuleTurbulence 


        !Arguments-------------------------------------------------------------------
        


        !Local----------------------------------------------------------------------
        integer                          :: STAT_CALL 

        !Module - ModuleTurbulence
        !Turbulence Properties
        call GetHorizontalViscosity(Me%ObjTurbulence,                       &
                                    Me%External_Var%Visc_H_Center,          &
                                    Me%External_Var%Visc_H_Corner,          &
                                    STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadLock_ModuleTurbulence; module ModuleHydrodynamic. ERR01.'



!Manuel
        call GetVerticalViscosity(Me%ObjTurbulence,                         &
                                  VerticalViscosity =                              &
                                  Me%External_Var%Vertical_Viscosity,       &
                                  STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadLock_ModuleTurbulence; module ModuleHydrodynamic. ERR02.'



    End Subroutine ReadLock_ModuleTurbulence

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    Subroutine ReadUnLock_ModuleTurbulence


        !Arguments-------------------------------------------------------------

        


        !Local-----------------------------------------------------------------

        integer        :: STAT_CALL 

        !----------------------------------------------------------------------

        !Module - ModuleTurbulence
        !Turbulence Properties
        !Horizontal Turbulent Viscosity in the cell Center
        call UnGetTurbulence(Me%ObjTurbulence,                   &
                             Me%External_Var%Visc_H_Center, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleTurbulence; module ModuleHydrodynamic. ERR01.'



        !Horizontal Turbulent Viscosity in the cell corner
        call UnGetTurbulence(Me%ObjTurbulence,                   &
                             Me%External_Var%Visc_H_Corner, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleTurbulence; module ModuleHydrodynamic. ERR02.'



        !Vertical Turbulent Viscosity
        call UnGetTurbulence(Me%ObjTurbulence,                   &
                             Me%External_Var%Vertical_Viscosity, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleTurbulence; module ModuleHydrodynamic. ERR03.'

        !----------------------------------------------------------------------

    End Subroutine ReadUnLock_ModuleTurbulence

    !--------------------------------------------------------------------------

#ifndef _WAVES_
    Subroutine ReadLock_ModuleWaves 

        !Local------------------------------------------------------------------
        integer                          :: STAT_CALL 

        !Begin------------------------------------------------------------------
        call SetGeneric4DValues(Me%ObjWaves, Me%Generic4D%CurrentValue, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleWaves; module ModuleHydrodynamic. ERR10.'


        call GetWavesStress    (Me%ObjWaves,                                            &
                                Me%External_Var%TauWavesU,                              &
                                Me%External_Var%TauWavesV,                              &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleWaves; module ModuleHydrodynamic. ERR20.'


    End Subroutine ReadLock_ModuleWaves


    !--------------------------------------------------------------------------

    real function TimeSerieValue(ObjTimeSerie, Now, TimeSerieColumn)    
        !Arguments--------------------------------------------------------------
        integer                                         :: ObjTimeSerie, TimeSerieColumn
        type (T_Time)                                   :: Now
        !Local------------------------------------------------------------------
        integer                                         :: STAT_CALL
        type (T_Time)                                   :: Time1, Time2
        real                                            :: Value1, Value2
        logical                                         :: TimeCycle

        !Begin------------------------------------------------------------------



        !Gets Value for current Time
        call GetTimeSerieValue (ObjTimeSerie, Now, TimeSerieColumn,                     &
                                Time1, Value1, Time2, Value2, TimeCycle,                &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'TimeSerieValue - ModuleHydrodynamic - ERR10'
     
        if (TimeCycle) then
            TimeSerieValue = Value1

        else

            !Interpolates Value for current instant
            call InterpolateValueInTime(Now, Time1, Value1, Time2, Value2, TimeSerieValue)

        endif

    end function TimeSerieValue

    !--------------------------------------------------------------------------

    Subroutine ReadUnLock_ModuleWaves

        !Local-----------------------------------------------------------------

        integer        :: STAT_CALL 

        !----------------------------------------------------------------------

        call UnGetWaves(Me%ObjWaves,                                                     &
                             Me%External_Var%TauWavesU, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadUnLock_ModuleWaves; module ModuleHydrodynamic. ERR01.'

        call UnGetWaves(Me%ObjWaves,                                                     &
                             Me%External_Var%TauWavesV, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadUnLock_ModuleWaves; module ModuleHydrodynamic. ERR02.'

        !----------------------------------------------------------------------

    End Subroutine ReadUnLock_ModuleWaves

    !--------------------------------------------------------------------------

#endif

    !--------------------------------------------------------------------------

    Subroutine ReadLock_ModuleHorizontalGrid


        !Arguments-------------------------------------------------------------

        


        !Local----------------------------------------------------------------------
        integer                          :: STAT_CALL 

       
        !Module - ModuleHorizontalGrid
        !Horizontal Grid properties
         call GetHorizontalGrid(Me%ObjHorizontalGrid,                                   &
                                DXX  = Me%External_Var%DXX,                             &
                                DYY  = Me%External_Var%DYY,                             &
                                DZX  = Me%External_Var%DZX,                             &
                                DZY  = Me%External_Var%DZY,                             &
                                DUX  = Me%External_Var%DUX,                             &
                                DVY  = Me%External_Var%DVY,                             &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR01.'



        call GetCoriolisFrequency(Me%ObjHorizontalGrid,                                 &
                                  Me%External_Var%Coriolis_Freq,                        &
                                  STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR02.'

        call GetCheckDistortion (Me%ObjHorizontalGrid,                                  &
                                 Me%External_Var%Distortion,                            &
                                 STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR03.'

        if (Me%External_Var%Distortion) then

            call GetGridRotation(Me%ObjHorizontalGrid,                                  &
                                 Me%External_Var%RotationX,                             &
                                 Me%External_Var%RotationY,                             &
                                 STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine ReadLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR04.'

        else

            call GetGridAngle(Me%ObjHorizontalGrid,                                     &
                              Me%External_Var%GridRotation,                             &
                              STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine ReadLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR40.'

            !Convert from degrees in to radians 
            Me%External_Var%GridRotation = Me%External_Var%GridRotation * Pi / 180.
            

        endif


    End Subroutine ReadLock_ModuleHorizontalGrid

    !End----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input :                                                                              !
    ! OutPut:                                                                              !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ReadUnLock_ModuleHorizontalGrid 


        !Arguments-------------------------------------------------------------

        


        !Local-----------------------------------------------------------------
        integer        :: STAT_CALL 
        
        !Module - ModuleHorizontalGrid
        !Horizontal Grid properties

        !DXX
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%DXX, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR01.'

        
        !DYY
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%DYY, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR02.'


        !DZX
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%DZX, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR03.'


        !DZY
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%DZY, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR04.'


        !DUX
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%DUX, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR05.'


        !DVY
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%DVY, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR06.'

         
        !Coriolis frequency
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%Coriolis_Freq, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR07.'

        if (Me%External_Var%Distortion) then

            call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                     Me%External_Var%RotationX, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                            &
                stop 'Subroutine ReadUnLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR08.'

         
            call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                     Me%External_Var%RotationY, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                            &
                stop 'Subroutine ReadUnLock_ModuleHorizontalGrid; module ModuleHydrodynamic. ERR09.'

        endif


        !---------------------------------------------------------------------

    End Subroutine ReadUnLock_ModuleHorizontalGrid

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    Subroutine ReadLock_ModuleHorizontalMap 


        !Arguments-------------------------------------------------------------------
        


        !Local----------------------------------------------------------------------
        integer                          :: STAT_CALL 



        !Module - ModuleHorizontalMap
        !Horizontal Mapping Properties
        call GetBoundaryFaces(Me%ObjHorizontalMap,                          &
                              Me%External_Var%BoundaryFacesU,               &
                              Me%External_Var%BoundaryFacesV,               &
                              STAT = STAT_CALL)      

        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadLock_ModuleHorizontalMap; module ModuleHydrodynamic. ERR**.'


        call GetBoundaries(Me%ObjHorizontalMap,                             &
                           Me%External_Var%BoundaryPoints,                  &
                              STAT = STAT_CALL)      

        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadLock_ModuleHorizontalMap; module ModuleHydrodynamic. ERR**.'

        !Gets WaterPoints2D
        call GetWaterPoints2D(Me%ObjHorizontalMap, &
                              Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadLock_ModuleHorizontalMap; module ModuleHydrodynamic. ERR**.'


    End Subroutine ReadLock_ModuleHorizontalMap

    !End----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input :                                                                              !
    ! OutPut:                                                                              !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ReadUnLock_ModuleHorizontalMap 


        !Arguments-------------------------------------------------------------------
        


        !Local----------------------------------------------------------------------
        integer        :: STAT_CALL 

  
        !Module - ModuleHorizontalMap
        !Horizontal Mapping Properties

        !Boundary faces along the X direction
        call UnGetHorizontalMap(Me%ObjHorizontalMap, Me%External_Var%BoundaryFacesU,  &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine ReadUnLock_ModuleHorizontalMap; module ModuleHydrodynamic. ERR**.'


        !Boundary faces along the Y direction
        call UnGetHorizontalMap(Me%ObjHorizontalMap, Me%External_Var%BoundaryFacesV,  &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine ReadUnLock_ModuleHorizontalMap; module ModuleHydrodynamic. ERR**.'

       !Boundary points
        call UnGetHorizontalMap(Me%ObjHorizontalMap, Me%External_Var%BoundaryPoints,  &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine ReadUnLock_ModuleHorizontalMap; module ModuleHydrodynamic. ERR**.'

        !UnGets WaterPoints2D
        call UnGetHorizontalMap(Me%ObjHorizontalMap, &
                                Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
        
        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine ReadUnLock_ModuleHorizontalMap; module ModuleHydrodynamic. ERR**.'



    End Subroutine ReadUnLock_ModuleHorizontalMap

    !End----------------------------------------------------------------------



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ReadLock_ModuleGeometry 


        !Arguments-------------------------------------------------------------------
        


        !Local----------------------------------------------------------------------
        integer                          :: STAT_CALL 

        !Module - ModuleGeometry
        !3D Geometry properties

        call GetGeometryKFloor(Me%ObjGeometry,               &
                               Z = Me%External_Var%KFloor_Z, &
                               U = Me%External_Var%KFloor_U, &
                               V = Me%External_Var%KFloor_V, &
                               STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'Subroutine ReadLock_ModuleGeometry; module ModuleHydrodynamic. ERR**.'



        call GetGeometryVolumes(Me%ObjGeometry,                            &
                                VolumeZ = Me%External_Var%Volume_Z_New,    &
                                VolumeU = Me%External_Var%Volume_U,        &
                                VolumeV = Me%External_Var%Volume_V,        &
                                VolumeW = Me%External_Var%Volume_W,        &
                                VolumeZOld = Me%External_Var%Volume_Z_Old, &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'Subroutine ReadLock_ModuleGeometry; module ModuleHydrodynamic. ERR**.'



        call GetGeometryAreas(Me%ObjGeometry,                 &
                              AreaU = Me%External_Var%Area_U, &
                              AreaV = Me%External_Var%Area_V, &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'Subroutine ReadLock_ModuleGeometry; module ModuleHydrodynamic. ERR**.'



        call GetGeometryDistances(Me%ObjGeometry,             &
                                  DWZ = Me%External_Var%DWZ,  &
                                  SZZ = Me%External_Var%SZZ,  &
                                  DUZ = Me%External_Var%DUZ,  &
                                  DVZ = Me%External_Var%DVZ,  &
                                  DZZ = Me%External_Var%DZZ,  &
                                  STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'Subroutine ReadLock_ModuleGeometry; module ModuleHydrodynamic. ERR**.'



        call GetGeometryWaterColumn(Me%ObjGeometry,                             &
                                    WaterColumn = Me%External_Var%WaterColumn,  &
                                    WaterColumnU= Me%External_Var%WaterColumnU, &
                                    WaterColumnV= Me%External_Var%WaterColumnV, &
                                    STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'Subroutine ReadLock_ModuleGeometry; module ModuleHydrodynamic. ERR**.'



    End Subroutine ReadLock_ModuleGeometry

    !End----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input :                                                                              !
    ! OutPut:                                                                              !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ReadUnLock_ModuleGeometry 


        !Arguments-------------------------------------------------------------
        


        !Local-----------------------------------------------------------------
        integer        :: STAT_CALL 

        !Module - ModuleGeometry
        !3D Geometry properties


        !First non land layer of the Z cell (water level compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%KFloor_Z, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR01.'


        !First non land layer of the U cell (velocity U compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%KFloor_U, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR02.'


        !First non land layer of the V cell (velocity V compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%KFloor_V, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR03.'



        !New volume of the Z cell (water level compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Volume_Z_New, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR04.'



        !Old volume of the Z cell (water level compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Volume_Z_Old, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR05.'


        !New volume of the U cell (Velocity U compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Volume_U, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR06.'


        !New volume of the V cell (Velocity V compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Volume_V, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR07.'

        !New volume of the V cell (Velocity W compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Volume_W, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR07a.'

        !New Area of the U cell (Velocity U compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Area_U, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR08.'


        !New Area of the V cell (Velocity V compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Area_V, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR09.'


        !Tickness of the Z cell 
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%DWZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR10.'

        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%DZZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR10a.'


        !Top face position
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%SZZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR11.'


        !Tickness of the total water column in the Z cell center
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%WaterColumn, STAT = STAT_CALL)
       if (STAT_CALL /= SUCCESS_)                                             &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR12.'

        !Tickness of the total water column in the U cell center
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%WaterColumnU, STAT = STAT_CALL)
       if (STAT_CALL /= SUCCESS_)                                             &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR13.'


        !Tickness of the total water column in the V cell center
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%WaterColumnV, STAT = STAT_CALL)
       if (STAT_CALL /= SUCCESS_)                                             &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR14.'

        !Tickness of the U cell center
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%DUZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR15.'


        !Tickness of the V cell center
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%DVZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry; module ModuleHydrodynamic. ERR16.'


    End Subroutine ReadUnLock_ModuleGeometry 

    !End----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine ReadLock_ModuleMap 


        !Arguments-------------------------------------------------------------------
        


        !Local----------------------------------------------------------------------
        integer                          :: STAT_CALL 



        !Module - ModuleMap
        !3D Mapping Properties

        call GetComputeFaces3D(Me%ObjMap,                        &
                               ComputeFacesU3D =                              &
                               Me%External_Var%ComputeFaces3D_U, &
                               ComputeFacesV3D =                              &
                               Me%External_Var%ComputeFaces3D_V, &
                               ComputeFacesW3D =                              &
                               Me%External_Var%ComputeFaces3D_W, &
                               STAT= STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadLock_ModuleMap; module ModuleHydrodynamic. ERR**.'


!        call GetUnCoveredFaces3D(Me%ObjMap,                        &
!                               UnCoveredFacesU3D =                              &
!                               Me%External_Var%UnCoveredFaces3D_U, &
!                               UnCoveredFacesV3D =                              &
!                               Me%External_Var%UnCoveredFaces3D_V, &
!                               STAT= STAT_CALL)

!        if (STAT_CALL /= SUCCESS_)                                          &
!            stop 'Subroutine ReadLock_ModuleMap; module ModuleHydrodynamic. ERR**.'


        call GetLandBoundaryFaces3D(Me%ObjMap,                     &
                               LandBoundaryFaces3DU =                           &
                               Me%External_Var%LandBoundaryFacesU, &
                               LandBoundaryFaces3DV =                           &
                               Me%External_Var%LandBoundaryFacesV, &
                               STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'Subroutine ReadLock_ModuleMap; module ModuleHydrodynamic. ERR**.'


        call GetWaterPoints3D(Me%ObjMap,                     &
                              Me%External_Var%WaterPoints3D, &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) &
            Stop 'Sub. ReadLock_ModuleMap - ModuleHydrodynamic - ERR**.'

        call GetOpenPoints3D(Me%ObjMap,                      &
                             Me%External_Var%OpenPoints3D,   &
                             STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) &
            Stop 'Sub. ReadLock_ModuleMap - ModuleHydrodynamic - ERR**.'


        call GetImposedTangentialFaces(Me%ObjMap,                           &
                              Me%External_Var%ImposedTangentialFacesU,      &
                              Me%External_Var%ImposedTangentialFacesV,      &
                              STAT = STAT_CALL)      

        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadLock_ModuleMap; module ModuleHydrodynamic. ERR**.'


        call GetImposedNormalFaces(Me%ObjMap,                               &
                              Me%External_Var%ImposedNormalFacesU,          &
                              Me%External_Var%ImposedNormalFacesV,          &
                              STAT = STAT_CALL)      

        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadLock_ModuleMap; module ModuleHydrodynamic. ERR**.'




    End Subroutine ReadLock_ModuleMap

    !End----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input :                                                                              !
    ! OutPut:                                                                              !
    ! Author: Paulo Chambel (99/6)                                                         !

    Subroutine ReadUnLock_ModuleMap 


        !Arguments-------------------------------------------------------------
        


        !Local-----------------------------------------------------------------
        integer        :: STAT_CALL 

  

        !Module - ModuleMap
        !3D Mapping Properties

        !3D Boundary land faces along the X direction
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%LandBoundaryFacesU, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR01.'


        !3D Boundary land faces along the Y direction
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%LandBoundaryFacesV, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR02.'


        !3D water points
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR03.'


        !3D Compute faces along the X direction
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%ComputeFaces3D_U, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR04.'


        !3D Compute faces along the Y direction
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%ComputeFaces3D_V, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR05.'

        !3D Compute faces along the Z direction  !flavio
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%ComputeFaces3D_W, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR05a.'
        
        !3D UnCovered faces along the X direction
!        call UnGetMap(Me%ObjMap,                                 &
!                      Me%External_Var%UnCoveredFaces3D_U, STAT = STAT_CALL)
!        if (STAT_CALL /= SUCCESS_)                                            &
!            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR06.'


        !3D UnCovered faces along the Y direction
!        call UnGetMap(Me%ObjMap,                                 &
!                      Me%External_Var%UnCoveredFaces3D_V, STAT = STAT_CALL)
!        if (STAT_CALL /= SUCCESS_)                                            &
!            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR07.'

        !3D OpenPoints
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%OpenPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR07.'



        !Imposed Tangential faces along the X direction
        call UnGetMap(Me%ObjMap, Me%External_Var%ImposedTangentialFacesU,  &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR**.'


        !Imposed Tangential  faces along the Y direction
        call UnGetMap(Me%ObjMap, Me%External_Var%ImposedTangentialFacesV,  &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR**.'


        !Imposed Normal faces along the X direction
        call UnGetMap(Me%ObjMap, Me%External_Var%ImposedNormalFacesU,  &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR**.'


        !Imposed Normal  faces along the Y direction
        call UnGetMap(Me%ObjMap, Me%External_Var%ImposedNormalFacesV,  &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine ReadUnLock_ModuleMap; module ModuleHydrodynamic. ERR**.'

 
        !----------------------------------------------------------------------

    End Subroutine ReadUnLock_ModuleMap

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine ReadLock_ModuleAssimilation


        !Local----------------------------------------------------------------------
        integer                          :: STAT_CALL 

cd1:    if(Me%ComputeOptions%AltimetryAssimilation%Yes) then
       
            !Fetch the analyzed sigma density field
            call GetAltimSigmaDensAnalyzed( Me%ObjAssimilation,                         &
                                            Me%External_Var%AltimSigmaDensAnalyzed,     &
                                            STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadLock_ModuleAssimilation - ModuleHydrodynamic - ERR01'

            !Fetch the analyzed Water Level field
            call GetAssimilationField(Me%ObjAssimilation,                               &
                                     ID      = AltimLevelAnalyzed_,                     &
                                     Field2D = Me%External_Var%AltimWaterLevelAnalyzed, &
                                     STAT    = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadLock_ModuleAssimilation - ModuleHydrodynamic - ERR02'

            !Fetch the DecayTime
            call GetAltimetryDecayTime(Me%ObjAssimilation,                              &               
                                       Me%External_Var%AltimDecayTime,                  &
                                       STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadLock_ModuleAssimilation - ModuleHydrodynamic - ERR03'

            !Here we fetch the altimetry DT and initialize the nextcompute time            
            call GetAssimilationAltimetryDT(Me%ObjAssimilation,                         &
                                    Me%ComputeOptions%AltimetryAssimilation%DT_Compute, &
                                    STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadLock_ModuleAssimilation - ModuleHydrodynamic - ERR04'

        endif cd1

    End Subroutine ReadLock_ModuleAssimilation

    !End----------------------------------------------------------------------


    Subroutine ReadUnLock_ModuleAssimilation

        
        !Local-----------------------------------------------------------------
        integer        :: STAT_CALL 
               
cd1:    if(Me%ComputeOptions%AltimetryAssimilation%Yes) then


            !Unfetch the analyzed Water Level field
            call UnGetAssimilation( Me%ObjAssimilation,                                 &
                                    Me%External_Var%AltimWaterLevelAnalyzed,            &
                                    STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadUnLock_ModuleAssimilation - ModuleHydrodynamic - ERR01' 

            !Unfetch the analyzed Sigma Density field
            call UnGetAssimilation( Me%ObjAssimilation,                                 &
                                    Me%External_Var%AltimSigmaDensAnalyzed,             &
                                    STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadUnLock_ModuleAssimilation - ModuleHydrodynamic - ERR02' 


        endif cd1

        !---------------------------------------------------------------------

    End Subroutine ReadUnLock_ModuleAssimilation

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine ReadLock_External_Modules

        !Arguments-------------------------------------------------------------

         

        !----------------------------------------------------------------------

            call ReadLock_ModuleHorizontalGrid 

            call ReadLock_ModuleHorizontalMap  

            call ReadLock_ModuleGeometry       

            call ReadLock_ModuleMap
            
            call ReadLock_ModuleAssimilation            

        !----------------------------------------------------------------------

    End Subroutine ReadLock_External_Modules

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine ReadUnLock_External_Modules

        !Arguments-------------------------------------------------------------

         

        !----------------------------------------------------------------------

            call ReadUnLock_ModuleHorizontalGrid 

            call ReadUnLock_ModuleHorizontalMap 

            call ReadUnLock_ModuleGeometry 

            call ReadUnLock_ModuleMap 

            call ReadUnLock_ModuleAssimilation            


        !----------------------------------------------------------------------

    End Subroutine ReadUnLock_External_Modules

    !--------------------------------------------------------------------------
#ifdef _USE_MPI

    subroutine SendHydrodynamicMPI (HydrodynamicID, Destination, Window, InitialField, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: Destination
        type (T_Size2D)                             :: Window
        logical                                     :: InitialField
        integer, optional, intent (OUT)             :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_ 
        integer                                     :: STAT_, STAT_CALL
        real                                        :: DT
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        real, dimension(6)                          :: AuxTime
        real,    dimension(:,:,:), pointer          :: DUZFather, DVZFather
        integer, dimension(:,:,:), pointer          :: Open3DFather     
        integer, dimension(:,:,:), pointer          :: WetFaces_UFather    
        integer, dimension(:,:,:), pointer          :: WetFaces_VFather
        integer, dimension(:,:,:), pointer          :: Faces3D_UFather    
        integer, dimension(:,:,:), pointer          :: Faces3D_VFather
        integer                                     :: iSize
        integer, save                               :: Precision

        !Begin-----------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            !Window to send
            ILB = Window%ILB
            IUB = Window%IUB
            JLB = Window%JLB
            JUB = Window%JUB
            KLB = Me%WorkSize%KLB
            KUB = Me%WorkSize%KUB

            if (InitialField) then

                !Gets Compute time step
                call GetComputeTimeStep(Me%ObjTime, DT, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR01'

                !Sends Continous Compute
                call MPI_Send (Me%ComputeOptions%Continuous, 1, MPI_LOGICAL, Destination, &
                               1000, MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR02'
            
                !Sends KLB
                call MPI_Send (Me%WorkSize%KLB, 1, MPI_INTEGER, Destination, 1001,       &
                               MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR03'

                !Sends KUB
                call MPI_Send (Me%WorkSize%KUB, 1, MPI_INTEGER, Destination, 1002,       &
                               MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR04'

                Precision = MPIKind(DT)

                !Sends DT
                call MPI_Send (DT, 1, Precision, Destination, 1003, MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR05'

            endif
            
            !Sends last iteration
            call ExtractDate (Me%LastIteration, AuxTime(1), AuxTime(2), AuxTime(3),      &
                              AuxTime(4), AuxTime(5), AuxTime(6))
            
            !Assuming that all other variables have the same kind
            Precision = MPIKind(Me%Velocity%Horizontal%U%New)

            call MPI_Send (AuxTime, 6, Precision, Destination, 1004, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR06'
            
            !Gets OpenPoints
            call GetOpenPoints3D      (Me%ObjMap, Open3DFather, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR07'
            
            !Gets ComputeFaces
            call GetComputeFaces3D    (Me%ObjMap, ComputeFacesU3D = Faces3D_UFather,     &
                                       ComputeFacesV3D = Faces3D_VFather,                &
                                       STAT= STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR08'

            !Gets WetFaces
            call GetWetFaces          (Me%ObjMap, WetFaceU = WetFaces_UFather,           &
                                       WetFaceV = WetFaces_VFather,                      &
                                       STAT= STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR09'

            !Gets DUZ, DVZ
            call GetGeometryDistances (Me%ObjGeometry, DUZ =  DUZFather,                 &
                                       DVZ =  DVZFather, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR10'

            !UFather
            iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
            
            call MPI_Send (Me%Velocity%Horizontal%U%New(ILB:IUB, JLB:JUB+1, KLB:KUB),    &
                           iSize, Precision, Destination, 1005, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR11'

            !VFather
            iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Me%Velocity%Horizontal%V%New(ILB:IUB+1, JLB:JUB, KLB:KUB),    &
                           iSize, Precision, Destination, 1006, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR12'
            
            !FluxXFather
            iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Me%WaterFluxes%X(ILB:IUB, JLB:JUB+1, KLB:KUB),                &
                           iSize, MPI_DOUBLE_PRECISION, Destination, 1007, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR13'

            !FluxYFather
            iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Me%WaterFluxes%Y(ILB:IUB+1, JLB:JUB, KLB:KUB),                &
                           iSize, MPI_DOUBLE_PRECISION, Destination, 1008, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR14'


            !ZFather
            iSize = (IUB-ILB+1) * (JUB-JLB+1)
            call MPI_Send (Me%WaterLevel%New(ILB:IUB, JLB:JUB),                          &
                           iSize, Precision, Destination, 1009, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR15'



            !Open3DFather
            iSize = (IUB-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Open3DFather(ILB:IUB, JLB:JUB, KLB:KUB),                      &
                           iSize, MPI_INTEGER, Destination, 1010, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR16'


            !Faces3D_UFather
            iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Faces3D_UFather(ILB:IUB, JLB:JUB+1, KLB:KUB),                 &
                           iSize, MPI_INTEGER, Destination, 1011, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR17'


            !Faces3D_VFather
            iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Faces3D_VFather(ILB:IUB+1, JLB:JUB, KLB:KUB),                 &
                           iSize, MPI_INTEGER, Destination, 1012, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR18'


            !WetFaces_UFather
            iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
            call MPI_Send (WetFaces_UFather(ILB:IUB, JLB:JUB+1, KLB:KUB),                &
                           iSize, MPI_INTEGER, Destination, 1011, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR19'


            !WetFaces_VFather
            iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (WetFaces_VFather(ILB:IUB+1, JLB:JUB, KLB:KUB),                &
                           iSize, MPI_INTEGER, Destination, 1012, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR20'


            !DUZFather
            iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
            call MPI_Send (DUZFather(ILB:IUB, JLB:JUB+1, KLB:KUB),                       &
                           iSize, Precision , Destination, 1013, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR21'

            !DVZFather
            iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (DVZFather(ILB:IUB+1, JLB:JUB, KLB:KUB),                       &
                           iSize, Precision, Destination, 1014, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR22'

            !Ungets information
            call UnGetMap       (Me%ObjMap,      Open3DFather,    STAT = STAT_CALL)
            call UnGetMap       (Me%ObjMap,      Faces3D_UFather, STAT = STAT_CALL)
            call UnGetMap       (Me%ObjMap,      Faces3D_VFather, STAT = STAT_CALL)
            call UnGetMap       (Me%ObjMap,      WetFaces_UFather, STAT = STAT_CALL)
            call UnGetMap       (Me%ObjMap,      WetFaces_VFather, STAT = STAT_CALL)

            !Ungets information
            call UnGetGeometry  (Me%ObjGeometry, DUZFather,  STAT = STAT_CALL)
            call UnGetGeometry  (Me%ObjGeometry, DVZFather,  STAT = STAT_CALL)


            STAT_ = SUCCESS_
            
        else              
         
            STAT_ = ready_

        end if cd1


        if (present(STAT)) STAT = STAT_

    end subroutine SendHydrodynamicMPI

    !--------------------------------------------------------------------------

    subroutine RecvHydrodynamicMPI (HydrodynamicID, Source, Window, InitialField,        &
                                    FatherGridID, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: Source
        type (T_Size2D)                             :: Window
        logical                                     :: InitialField
        integer                                     :: FatherGridID
        integer, optional, intent (OUT)             :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_ 
        integer                                     :: STAT_, STAT_CALL
        logical                                     :: FatherContinous
        real                                        :: DT
        integer, save                               :: KLB, KUB
        integer                                     :: ILB, IUB, JLB, JUB
        type (T_Size2D), save                       :: WorkSize, Size
        integer                                     :: status(MPI_STATUS_SIZE)
        real, dimension(6)                          :: AuxTime
        type (T_Time)                               :: LastIteration
        real,    dimension(:,:,:), pointer, save    :: UFather, VFather, DUZFather, DVZFather
        real(8), dimension(:,:,:), pointer, save    :: FluxXFather, FluxYFather
        real,    dimension(:,:  ), pointer, save    :: ZFather
        integer, dimension(:,:,:), pointer, save    :: Open3DFather     
        integer, dimension(:,:,:), pointer, save    :: WetFaces_UFather    
        integer, dimension(:,:,:), pointer, save    :: WetFaces_VFather
        integer, dimension(:,:,:), pointer, save    :: Faces3D_UFather    
        integer, dimension(:,:,:), pointer, save    :: Faces3D_VFather
        integer                                     :: iSize
        integer, save                               :: Precision

        !Begin-----------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            call GetHorizontalGridSize (FatherGridID, Size = Size,                       &
                                        WorkSize = WorkSize, STAT = STAT_CALL)


            !Window Size
            ILB = Window%ILB
            IUB = Window%IUB
            JLB = Window%JLB
            JUB = Window%JUB

            if (InitialField) then

                !Recieves Continous Compute
                call MPI_Recv (FatherContinous, 1, MPI_LOGICAL, Source, 1000, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR01'

                !Recieves KLB
                call MPI_Recv (KLB, 1, MPI_INTEGER, Source, 1001,  MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR02'

                !Recieves KUB
                call MPI_Recv (KUB, 1, MPI_INTEGER, Source, 1002,  MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR03'


                Precision = MPIKind(DT)

                !Recieves DT
                call MPI_Recv (DT, 1, Precision, Source, 1003,  MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR04'

                call TestSubModelOptionsConsistence (FatherContinous)

                !Ang: new implementation
                Me%SubModel%FatherKLB = KLB
                Me%SubModel%FatherKUB = KUB

                call ConstructTimeInterpolation     (DT)

                !Allocates receiving buffer
                allocate (UFather        (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (VFather        (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (DUZFather      (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (DVZFather      (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (FluxXFather    (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (FluxYFather    (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (ZFather        (Size%ILB:Size%IUB, Size%JLB:Size%JUB             ))
                allocate (Open3DFather   (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (WetFaces_UFather(Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (WetFaces_VFather(Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (Faces3D_UFather(Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (Faces3D_VFather(Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))


                UFather             = 0.0
                VFather             = 0.0
                DUZFather           = null_real
                DVZFather           = null_real
                FluxXFather         = 0.0
                FluxYFather         = 0.0
                ZFather             = null_real
                Open3DFather        = 0
                WetFaces_UFather    = 0
                WetFaces_VFather    = 0
                Faces3D_UFather     = 0
                Faces3D_VFather     = 0

            endif
            
            call SetMatrixValue(Me%SubModel%DUZ_Old, Me%Size, Me%SubModel%DUZ_New)
            call SetMatrixValue(Me%SubModel%DVZ_Old, Me%Size, Me%SubModel%DVZ_New)

            !Receives LastIteration
            call MPI_Recv (AuxTime, 6, Precision, Source, 1004, MPI_COMM_WORLD, status, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR05'

            call SetDate  (LastIteration, AuxTime(1), AuxTime(2), AuxTime(3), AuxTime(4), AuxTime(5), AuxTime(6))

            if (LastIteration > Me%SubModel%NextTime .or. InitialField) then

                !UFather
                iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (UFather(ILB:IUB, JLB:JUB+1, KLB:KUB), iSize, Precision,   &
                               Source, 1005, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR06'

                !VFather
                iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (VFather(ILB:IUB+1, JLB:JUB, KLB:KUB), iSize, Precision,   &
                               Source, 1006, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR07'
            

                !FluxXFather
                iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (FluxXFather(ILB:IUB, JLB:JUB+1, KLB:KUB), iSize, MPI_DOUBLE_PRECISION,&
                               Source, 1007, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR08'


                !FluxYFather
                iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (FluxYFather(ILB:IUB+1, JLB:JUB, KLB:KUB), iSize, MPI_DOUBLE_PRECISION,&
                               Source, 1008, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR09'


                !ZFather
                iSize = (IUB-ILB+1) * (JUB-JLB+1)
                call MPI_Recv (ZFather(ILB:IUB, JLB:JUB), iSize, Precision,              &
                               Source, 1009, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR10'


                !Open3DFather
                iSize = (IUB-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (Open3DFather(ILB:IUB, JLB:JUB, KLB:KUB), iSize, MPI_INTEGER, &
                               Source, 1010, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR11'


                !Faces3D_UFather
                iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (Faces3D_UFather(ILB:IUB, JLB:JUB+1, KLB:KUB), iSize, MPI_INTEGER,&
                               Source, 1011, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR12'


                !Faces3D_VFather
                iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (Faces3D_VFather(ILB:IUB+1, JLB:JUB, KLB:KUB), iSize, MPI_INTEGER,&
                               Source, 1012, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR13'


                !WetFaces_UFather
                iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (WetFaces_UFather(ILB:IUB, JLB:JUB+1, KLB:KUB), iSize, MPI_INTEGER,&
                               Source, 1011, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR14'


                !WetFaces_VFather
                iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (WetFaces_VFather(ILB:IUB+1, JLB:JUB, KLB:KUB), iSize, MPI_INTEGER,&
                               Source, 1012, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR15'


                !DUZFather
                iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (DUZFather(ILB:IUB, JLB:JUB+1, KLB:KUB), iSize, Precision, &
                               Source, 1013, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR16'

                !DVZFather
                iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (DVZFather(ILB:IUB+1, JLB:JUB, KLB:KUB), iSize, Precision, &
                               Source, 1014, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR17'


                call ReadNextOrInitialField (UFather, VFather, DUZFather, DVZFather,     &
                                       FluxXFather, FluxYFather, ZFather, Open3DFather,  &
                                       Faces3D_UFather, Faces3D_VFather,                 &
                                       WetFaces_UFather, WetFaces_VFather, InitialField, &
                                       FatherGridID)

                if (.not. InitialField) then
                    Me%SubModel%PreviousTime = Me%SubModel%NextTime
                    Me%SubModel%NextTime     = LastIteration 
                endif

            endif

            if      (Me%SubModel%VertComunic == FatherSonEqualDim) then
                
                call ActualizeSubModelValues    (InitialField)

            else if (Me%SubModel%VertComunic == Father2DSon3D) then

                call ActualizeSon3DWithFather2D (InitialField)

            else if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.                   &
                      (Me%SubModel%VertComunic == Father3DSon2D)) then

                !Ang: new implementation
                call ActualizeSon3DWithFather3D (InitialField)

            endif

!            if (Me%SubModel%DeadZone .and. InitialField  .and. .not. Me%ComputeOptions%Continuous)  then
            if (InitialField  .and. .not. Me%ComputeOptions%Continuous)  then
                call Initial_Geometry(Me%WaterLevel%New)
            endif

            STAT_ = SUCCESS_

        else              
         
            STAT_ = ready_

        end if cd1


        if (present(STAT)) STAT = STAT_

    end subroutine RecvHydrodynamicMPI

    !--------------------------------------------------------------------------

    subroutine UpdateHydroMPI (HydrodynamicID, InitialField, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        logical                                     :: InitialField
        integer, optional, intent (OUT)             :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_ 
        integer                                     :: STAT_

        !Begin-----------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            call SetMatrixValue(Me%SubModel%DUZ_Old, Me%Size, Me%SubModel%DUZ_New)
            call SetMatrixValue(Me%SubModel%DVZ_Old, Me%Size, Me%SubModel%DVZ_New)

            if      (Me%SubModel%VertComunic == FatherSonEqualDim) then
                
                call ActualizeSubModelValues    (InitialField)

            else if (Me%SubModel%VertComunic == Father2DSon3D) then

                call ActualizeSon3DWithFather2D (InitialField)

            else if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.           &
                      (Me%SubModel%VertComunic == Father3DSon2D)) then

                !Ang: new implementation
                call ActualizeSon3DWithFather3D (InitialField)

            endif

            STAT_ = SUCCESS_

        else              
         
            STAT_ = ready_

        end if cd1


        if (present(STAT)) STAT = STAT_


    end subroutine UpdateHydroMPI


#endif _USE_MPI

#ifdef _OPENMI_

        !--------------------------------------------------------------------------
    
    !DEC$ IFDEFINED (VF66)
    !dec$ attributes dllexport::GetWaterLevelAtPoint
    !DEC$ ELSE
    !dec$ attributes dllexport,alias:"_GETWATERLEVELATPOINT"::GetWaterLevelAtPoint
    !DEC$ ENDIF
    real(8) function GetWaterLevelAtPoint(HydrodynamicID, i, j)
    
        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: i, j
        
        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: ready_         

        call Ready(HydrodynamicID, ready_)    
        
        if ((ready_ .EQ. IDLE_ERR_) .OR. (ready_ .EQ. READ_LOCK_ERR_)) then
            GetWaterLevelAtPoint = Me%WaterLevel%New(i, j)
        else 
            GetWaterLevelAtPoint = - 99.0
        end if
           
        return

    end function GetWaterLevelAtPoint
    
    !------------------------------------------------------------------------------------

    !DEC$ IFDEFINED (VF66)
    !dec$ attributes dllexport::GetWaterLevel1D
    !DEC$ ELSE
    !dec$ attributes dllexport,alias:"_GETWATERLEVEL1D"::GetWaterLevel1D
    !DEC$ ENDIF
    logical function GetWaterLevel1D(HydrodynamicID, nComputePoints, waterlevels1D)
    
        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: nComputePoints
        real(8), dimension(nComputePoints)          :: waterlevels1D
        
        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: ready_         
        integer                                     :: i, j, idx

        call Ready(HydrodynamicID, ready_)    
        
        if ((ready_ .EQ. IDLE_ERR_) .OR. (ready_ .EQ. READ_LOCK_ERR_)) then
        
            !Gets WaterPoints2D
            call GetWaterPoints2D(Me%ObjHorizontalMap, Me%External_Var%WaterPoints2D,    &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'GetWaterLevel1D - ModuleHydrodynamic - ERR01'

            idx = 1
            do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            do i = Me%WorkSize%ILB, Me%WorkSize%IUB
                if (Me%External_Var%WaterPoints2D(i, j) == WaterPoint) then
                    waterlevels1D(idx) = Me%WaterLevel%New(i, j)
                    idx = idx + 1 
                endif
            enddo
            enddo

            !UnGets WaterPoints2D
            call UnGetHorizontalMap(Me%ObjHorizontalMap, Me%External_Var%WaterPoints2D, &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'GetWaterLevel1D - ModuleHydrodynamic - ERR02'

       
            GetWaterLevel1D = .true.
        else 
            GetWaterLevel1D = .false.
        end if
           
        return
    
    
    end function GetWaterLevel1D
    
#endif

End Module ModuleHydrodynamic    

!----------------------------------------------------------------------------------------------------------
!MOHID Water Modelling System.
!Copyright (C) 1985, 1998, 2002, 2005. Instituto Superior Técnico, Technical University of Lisbon. 
!----------------------------------------------------------------------------------------------------------

